commit 7a321ce808ef9cec1f45cce92befcc9e170d3aa9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Aug 27 10:22:09 2020 +0200

    version: bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
index 1645944..8512c21 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1,3 +1,3 @@
 #ifndef WIREGUARD_TOOLS_VERSION
-#define WIREGUARD_TOOLS_VERSION "1.0.20200820"
+#define WIREGUARD_TOOLS_VERSION "1.0.20200827"
 #endif

commit 91fbeb4a926b8a75274d012a3994ef337dca51d9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Aug 27 10:17:42 2020 +0200

    Revert "wg-quick: wait on process substitutions"
    
    This reverts commit 26683f6c9ad18d9914b23312c221f27fd5ecab51, which
    means the old problem comes back. That's an issue. But waiting on
    process substitutions is not available with commonly used bash versions:
    
      # wg-quick up demo
      [#] ip link add demo type wireguard
      [#] wg setconf demo /dev/fd/63
      /usr/bin/wg-quick: line 251: wait: pid 2955 is not a child of this shell
      [#] ip link delete dev demo
    
    This means we have to wait a few years before fixing this issue. IOW,
    bash limitation; can't fix.
    
    Reported-by: Theodore Mozzo <theodore.mozzo@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 26c6cd3..cde1b54 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -92,7 +92,7 @@ detect_launchd() {
 			LAUNCHED_BY_LAUNCHD=1
 			break
 		fi
-	done < <(launchctl procinfo $$ 2>/dev/null); wait $!
+	done < <(launchctl procinfo $$ 2>/dev/null)
 }
 
 read_bool() {
@@ -132,14 +132,14 @@ del_routes() {
 	local todelete=( ) destination gateway netif
 	while read -r destination _ _ _ _ netif _; do
 		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet); wait $!
+	done < <(netstat -nr -f inet)
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet "$destination" >/dev/null || true
 	done
 	todelete=( )
 	while read -r destination gateway _ netif; do
 		[[ $netif == "$REAL_INTERFACE" || ( $netif == lo* && $gateway == "$REAL_INTERFACE" ) ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet6); wait $!
+	done < <(netstat -nr -f inet6)
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet6 "$destination" >/dev/null || true
 	done
@@ -181,7 +181,7 @@ set_mtu() {
 			defaultif="$netif"
 			break
 		fi
-	done < <(netstat -nr -f inet); wait $!
+	done < <(netstat -nr -f inet)
 	[[ -n $defaultif && $(ifconfig "$defaultif") =~ mtu\ ([0-9]+) ]] && mtu="${BASH_REMATCH[1]}"
 	[[ $mtu -gt 0 ]] || mtu=1500
 	mtu=$(( mtu - 80 ))
@@ -197,14 +197,14 @@ collect_gateways() {
 		[[ $destination == default ]] || continue
 		GATEWAY4="$gateway"
 		break
-	done < <(netstat -nr -f inet); wait $!
+	done < <(netstat -nr -f inet)
 
 	GATEWAY6=""
 	while read -r destination gateway _; do
 		[[ $destination == default ]] || continue
 		GATEWAY6="$gateway"
 		break
-	done < <(netstat -nr -f inet6); wait $!
+	done < <(netstat -nr -f inet6)
 }
 
 collect_endpoints() {
@@ -212,7 +212,7 @@ collect_endpoints() {
 	while read -r _ endpoint; do
 		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
 		ENDPOINTS+=( "${BASH_REMATCH[1]}" )
-	done < <(wg show "$REAL_INTERFACE" endpoints); wait $!
+	done < <(wg show "$REAL_INTERFACE" endpoints)
 }
 
 declare -A SERVICE_DNS
@@ -230,7 +230,7 @@ collect_new_service_dns() {
 		get_response="$(cmd networksetup -getsearchdomains "$service")"
 		[[ $get_response == *" "* ]] && get_response="Empty"
 		[[ -n $get_response ]] && SERVICE_DNS_SEARCH["$service"]="$get_response"
-	done; } < <(networksetup -listallnetworkservices); wait $!
+	done; } < <(networksetup -listallnetworkservices)
 
 	for service in "${!SERVICE_DNS[@]}"; do
 		if ! [[ -n ${found_services["$service"]} ]]; then
@@ -304,7 +304,7 @@ set_dns() {
 			else
 				cmd networksetup -setsearchdomains "$service" "${DNS_SEARCH[@]}"
 			fi
-		); wait $!
+		)
 	done
 }
 
@@ -316,7 +316,7 @@ del_dns() {
 		done < <(
 			cmd networksetup -setdnsservers "$service" ${SERVICE_DNS["$service"]} || true
 			cmd networksetup -setsearchdomains "$service" ${SERVICE_DNS_SEARCH["$service"]} || true
-		); wait $!
+		)
 	done
 }
 
@@ -339,7 +339,7 @@ monitor_daemon() {
 			set_dns
 			sleep 2 && kill -ALRM $pid 2>/dev/null &
 		fi
-	done < <(route -n monitor); wait $!) &
+	done < <(route -n monitor)) &
 	[[ -n $LAUNCHED_BY_LAUNCHD ]] || disown
 }
 
@@ -367,7 +367,7 @@ add_route() {
 }
 
 set_config() {
-	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG"); wait $!
+	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG")
 }
 
 save_config() {
@@ -375,7 +375,7 @@ save_config() {
 	new_config=$'[Interface]\n'
 	while read -r address; do
 		[[ $address =~ inet6?\ ([^ ]+) ]] && new_config+="Address = ${BASH_REMATCH[1]}"$'\n'
-	done < <(ifconfig "$REAL_INTERFACE"); wait $!
+	done < <(ifconfig "$REAL_INTERFACE")
 	# TODO: actually determine current DNS for interface
 	for address in "${DNS[@]}"; do
 		new_config+="DNS = $address"$'\n'
@@ -458,7 +458,7 @@ cmd_up() {
 	done
 	set_mtu
 	up_if
-	for i in $({ while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips); wait $!; } | sort -nr -k 2 -t /); do
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
 		add_route "$i"
 	done
 	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index bcd394c..e1ee67f 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -121,14 +121,14 @@ del_routes() {
 	local todelete=( ) destination gateway netif
 	while read -r destination _ _ _ _ netif _; do
 		[[ $netif == "$INTERFACE" ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet); wait $!
+	done < <(netstat -nr -f inet)
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet "$destination" || true
 	done
 	todelete=( )
 	while read -r destination gateway _ netif; do
 		[[ $netif == "$INTERFACE" || ( $netif == lo* && $gateway == "$INTERFACE" ) ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet6); wait $!
+	done < <(netstat -nr -f inet6)
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet6 "$destination" || true
 	done
@@ -191,9 +191,9 @@ set_mtu() {
 		[[ ${BASH_REMATCH[1]} == *:* ]] && family=inet6
 		output="$(route -n get "-$family" "${BASH_REMATCH[1]}" || true)"
 		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
-	done < <(wg show "$INTERFACE" endpoints); wait $!
+	done < <(wg show "$INTERFACE" endpoints)
 	if [[ $mtu -eq 0 ]]; then
-		read -r output < <(route -n get default) || true
+		read -r output < <(route -n get default || true) || true
 		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
 	fi
 	[[ $mtu -gt 0 ]] || mtu=1500
@@ -209,14 +209,14 @@ collect_gateways() {
 		[[ $destination == default ]] || continue
 		GATEWAY4="$gateway"
 		break
-	done < <(netstat -nr -f inet); wait $!
+	done < <(netstat -nr -f inet)
 
 	GATEWAY6=""
 	while read -r destination gateway _; do
 		[[ $destination == default ]] || continue
 		GATEWAY6="$gateway"
 		break
-	done < <(netstat -nr -f inet6); wait $!
+	done < <(netstat -nr -f inet6)
 }
 
 collect_endpoints() {
@@ -224,7 +224,7 @@ collect_endpoints() {
 	while read -r _ endpoint; do
 		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
 		ENDPOINTS+=( "${BASH_REMATCH[1]}" )
-	done < <(wg show "$INTERFACE" endpoints); wait $!
+	done < <(wg show "$INTERFACE" endpoints)
 }
 
 set_endpoint_direct_route() {
@@ -294,7 +294,7 @@ monitor_daemon() {
 		if_exists || break
 		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
 		# TODO: set the mtu as well, but only if up
-	done < <(route -n monitor); wait $!) & disown
+	done < <(route -n monitor)) & disown
 }
 
 HAVE_SET_DNS=0
@@ -335,7 +335,7 @@ add_route() {
 }
 
 set_config() {
-	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG"); wait $!
+	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG")
 }
 
 save_config() {
@@ -343,13 +343,13 @@ save_config() {
 	new_config=$'[Interface]\n'
 	{ read -r _; while read -r _ _ _ address _; do
 		new_config+="Address = $address"$'\n'
-	done } < <(netstat -I "$INTERFACE" -n -W -f inet); wait $!
+	done } < <(netstat -I "$INTERFACE" -n -W -f inet)
 	{ read -r _; while read -r _ _ _ address _; do
 		new_config+="Address = $address"$'\n'
-	done } < <(netstat -I "$INTERFACE" -n -W -f inet6); wait $!
+	done } < <(netstat -I "$INTERFACE" -n -W -f inet6)
 	while read -r address; do
 		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
-	done < <(resolvconf -l "$INTERFACE" 2>/dev/null); wait $!
+	done < <(resolvconf -l "$INTERFACE" 2>/dev/null)
 	[[ -n $MTU ]] && new_config+="MTU = $MTU"$'\n'
 	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
@@ -427,7 +427,7 @@ cmd_up() {
 	set_mtu
 	up_if
 	set_dns
-	for i in $({ while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips); wait $!; } | sort -nr -k 2 -t /); do
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
 		add_route "$i"
 	done
 	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 8bda740..e4d4c4f 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -132,9 +132,9 @@ set_mtu_up() {
 		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
 		output="$(ip route get "${BASH_REMATCH[1]}" || true)"
 		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
-	done < <(wg show "$INTERFACE" endpoints); wait $!
+	done < <(wg show "$INTERFACE" endpoints)
 	if [[ $mtu -eq 0 ]]; then
-		read -r output < <(ip route show default) || true
+		read -r output < <(ip route show default || true) || true
 		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
 	fi
 	[[ $mtu -gt 0 ]] || mtu=1500
@@ -191,8 +191,8 @@ remove_firewall() {
 		local table nftcmd
 		while read -r table; do
 			[[ $table == *" wg-quick-$INTERFACE" ]] && printf -v nftcmd '%sdelete %s\n' "$nftcmd" "$table"
-		done < <(nft list tables 2>/dev/null) || true
-		[[ -z $nftcmd ]] || cmd nft -f <(echo -n "$nftcmd"); wait $!
+		done < <(nft list tables 2>/dev/null)
+		[[ -z $nftcmd ]] || cmd nft -f <(echo -n "$nftcmd")
 	fi
 	if type -p iptables >/dev/null; then
 		local line iptables found restore
@@ -202,7 +202,7 @@ remove_firewall() {
 				[[ $line == "*"* || $line == COMMIT || $line == "-A "*"-m comment --comment \"wg-quick(8) rule for $INTERFACE\""* ]] || continue
 				[[ $line == "-A"* ]] && found=1
 				printf -v restore '%s%s\n' "$restore" "${line/#-A/-D}"
-			done < <($iptables-save 2>/dev/null) || true
+			done < <($iptables-save 2>/dev/null)
 			[[ $found -ne 1 ]] || echo -n "$restore" | cmd $iptables-restore -n
 		done
 	fi
@@ -233,22 +233,22 @@ add_default() {
 		[[ $line =~ .*inet6?\ ([0-9a-f:.]+)/[0-9]+.* ]] || continue
 		printf -v restore '%s-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${BASH_REMATCH[1]}" "$marker"
 		printf -v nftcmd '%sadd rule %s %s preraw iifname != "%s" %s daddr %s fib saddr type != local drop\n' "$nftcmd" "$pf" "$nftable" "$INTERFACE" "$pf" "${BASH_REMATCH[1]}"
-	done < <(ip -o $proto addr show dev "$INTERFACE"); wait $!
+	done < <(ip -o $proto addr show dev "$INTERFACE" 2>/dev/null)
 	printf -v restore '%sCOMMIT\n*mangle\n-I POSTROUTING -m mark --mark %d -p udp -j CONNMARK --save-mark %s\n-I PREROUTING -p udp -j CONNMARK --restore-mark %s\nCOMMIT\n' "$restore" $table "$marker" "$marker"
 	printf -v nftcmd '%sadd rule %s %s postmangle meta l4proto udp mark %d ct mark set mark \n' "$nftcmd" "$pf" "$nftable" $table
 	printf -v nftcmd '%sadd rule %s %s premangle meta l4proto udp meta mark set ct mark \n' "$nftcmd" "$pf" "$nftable"
 	[[ $proto == -4 ]] && cmd sysctl -q net.ipv4.conf.all.src_valid_mark=1
 	if type -p nft >/dev/null; then
-		cmd nft -f <(echo -n "$nftcmd"); wait $!
+		cmd nft -f <(echo -n "$nftcmd")
 	else
-		echo -n "$restore" | cmd $iptables-restore -n; wait $!
+		echo -n "$restore" | cmd $iptables-restore -n
 	fi
 	HAVE_SET_FIREWALL=1
 	return 0
 }
 
 set_config() {
-	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG"); wait $!
+	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG")
 }
 
 save_config() {
@@ -260,7 +260,7 @@ save_config() {
 	done
 	while read -r address; do
 		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
-	done < <(resolvconf -l "$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null || cat "/etc/resolvconf/run/interface/$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null) || true
+	done < <(resolvconf -l "$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null || cat "/etc/resolvconf/run/interface/$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null)
 	[[ -n $MTU && $(ip link show dev "$INTERFACE") =~ mtu\ ([0-9]+) ]] && new_config+="MTU = ${BASH_REMATCH[1]}"$'\n'
 	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
@@ -335,7 +335,7 @@ cmd_up() {
 	done
 	set_mtu_up
 	set_dns
-	for i in $({ while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips); wait $!; } | sort -nr -k 2 -t /); do
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
 		add_route "$i"
 	done
 	execute_hooks "${POST_UP[@]}"
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index f45027c..ffd1834 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -131,14 +131,14 @@ del_routes() {
 	[[ -n $REAL_INTERFACE ]] || return 0
 	while read -r destination _ _ _ _ netif _; do
 		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet); wait $!
+	done < <(netstat -nr -f inet)
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet "$destination" || true
 	done
 	todelete=( )
 	while read -r destination gateway _ netif; do
 		[[ $netif == "$REAL_INTERFACE" || ( $netif == lo* && $gateway == "$REAL_INTERFACE" ) ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet6); wait $!
+	done < <(netstat -nr -f inet6)
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet6 "$destination" || true
 	done
@@ -189,9 +189,9 @@ set_mtu() {
 		[[ ${BASH_REMATCH[1]} == *:* ]] && family=inet6
 		output="$(route -n get "-$family" "${BASH_REMATCH[1]}" || true)"
 		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
-	done < <(wg show "$REAL_INTERFACE" endpoints); wait $!
+	done < <(wg show "$REAL_INTERFACE" endpoints)
 	if [[ $mtu -eq 0 ]]; then
-		read -r output < <(route -n get default) || true
+		read -r output < <(route -n get default || true) || true
 		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
 	fi
 	[[ $mtu -gt 0 ]] || mtu=1500
@@ -207,14 +207,14 @@ collect_gateways() {
 		[[ $destination == default ]] || continue
 		GATEWAY4="$gateway"
 		break
-	done < <(netstat -nr -f inet); wait $!
+	done < <(netstat -nr -f inet)
 
 	GATEWAY6=""
 	while read -r destination gateway _; do
 		[[ $destination == default ]] || continue
 		GATEWAY6="$gateway"
 		break
-	done < <(netstat -nr -f inet6); wait $!
+	done < <(netstat -nr -f inet6)
 }
 
 collect_endpoints() {
@@ -222,7 +222,7 @@ collect_endpoints() {
 	while read -r _ endpoint; do
 		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
 		ENDPOINTS+=( "${BASH_REMATCH[1]}" )
-	done < <(wg show "$REAL_INTERFACE" endpoints); wait $!
+	done < <(wg show "$REAL_INTERFACE" endpoints)
 }
 
 set_endpoint_direct_route() {
@@ -290,7 +290,7 @@ monitor_daemon() {
 		ifconfig "$REAL_INTERFACE" >/dev/null 2>&1 || break
 		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
 		# TODO: set the mtu as well, but only if up
-	done < <(route -n monitor); wait $!) & disown
+	done < <(route -n monitor)) & disown
 }
 
 set_dns() {
@@ -339,7 +339,7 @@ add_route() {
 }
 
 set_config() {
-	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG"); wait $!
+	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG")
 }
 
 save_config() {
@@ -347,7 +347,7 @@ save_config() {
 	new_config=$'[Interface]\n'
 	{ read -r _; while read -r _ _ network address _; do
 		[[ $network == *Link* ]] || new_config+="Address = $address"$'\n'
-	done } < <(netstat -I "$REAL_INTERFACE" -n -v); wait $!
+	done } < <(netstat -I "$REAL_INTERFACE" -n -v)
 	# TODO: actually determine current DNS for interface
 	for address in "${DNS[@]}"; do
 		new_config+="DNS = $address"$'\n'
@@ -428,7 +428,7 @@ cmd_up() {
 	set_mtu
 	up_if
 	set_dns
-	for i in $({ while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips); wait $!; } | sort -nr -k 2 -t /); do
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
 		add_route "$i"
 	done
 	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route

commit 9a0d65e2afbd6e418c883e0de8555b4fac29f1d5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Aug 25 21:54:22 2020 +0200

    wg-quick: android: use iproute2 to bring up interface instead of ndc
    
    Android 11's ndc regresses even more, but it turns out that netd doesn't
    need to track up/down state via direct invocation, so just set the
    interface up by way of normal iproute2.
    
    Reported-by: Harsh Shandilya <me@msfjarvis.dev>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 49ae1e3..2ad107e 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -726,7 +726,7 @@ static void up_if(unsigned int *netid, const char *iface, uint16_t listen_port)
 		cmd("iptables -I INPUT 1 -p udp --dport %u -j ACCEPT -m comment --comment \"wireguard rule %s\"", listen_port, iface);
 		cmd("ip6tables -I INPUT 1 -p udp --dport %u -j %s -m comment --comment \"wireguard rule %s\"", listen_port, should_block_ipv6(iface) ? "DROP" : "ACCEPT", iface);
 	}
-	cndc("interface setcfg %s up", iface);
+	cmd("ip link set up dev %s", iface);
 	cndc("network create %u vpn 1 1", *netid);
 	cndc("network interface add %u %s", *netid, iface);
 }

commit fbca033c69d7073033e05507293e5101d29b43ef
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Aug 20 12:06:22 2020 +0200

    version: bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
index 31cfae2..1645944 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1,3 +1,3 @@
 #ifndef WIREGUARD_TOOLS_VERSION
-#define WIREGUARD_TOOLS_VERSION "1.0.20200513"
+#define WIREGUARD_TOOLS_VERSION "1.0.20200820"
 #endif

commit 26683f6c9ad18d9914b23312c221f27fd5ecab51
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Aug 3 10:18:40 2020 +0200

    wg-quick: wait on process substitutions
    
    Bash does not propagate error values, which is a bummer, but process
    substitutions are a useful feature. Introduce a new idiom to deal with
    this: either "; wait $!" after the line to propagate the error, or "||
    true" to indicate explicitly that we don't care about the error.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index cde1b54..26c6cd3 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -92,7 +92,7 @@ detect_launchd() {
 			LAUNCHED_BY_LAUNCHD=1
 			break
 		fi
-	done < <(launchctl procinfo $$ 2>/dev/null)
+	done < <(launchctl procinfo $$ 2>/dev/null); wait $!
 }
 
 read_bool() {
@@ -132,14 +132,14 @@ del_routes() {
 	local todelete=( ) destination gateway netif
 	while read -r destination _ _ _ _ netif _; do
 		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet)
+	done < <(netstat -nr -f inet); wait $!
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet "$destination" >/dev/null || true
 	done
 	todelete=( )
 	while read -r destination gateway _ netif; do
 		[[ $netif == "$REAL_INTERFACE" || ( $netif == lo* && $gateway == "$REAL_INTERFACE" ) ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet6)
+	done < <(netstat -nr -f inet6); wait $!
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet6 "$destination" >/dev/null || true
 	done
@@ -181,7 +181,7 @@ set_mtu() {
 			defaultif="$netif"
 			break
 		fi
-	done < <(netstat -nr -f inet)
+	done < <(netstat -nr -f inet); wait $!
 	[[ -n $defaultif && $(ifconfig "$defaultif") =~ mtu\ ([0-9]+) ]] && mtu="${BASH_REMATCH[1]}"
 	[[ $mtu -gt 0 ]] || mtu=1500
 	mtu=$(( mtu - 80 ))
@@ -197,14 +197,14 @@ collect_gateways() {
 		[[ $destination == default ]] || continue
 		GATEWAY4="$gateway"
 		break
-	done < <(netstat -nr -f inet)
+	done < <(netstat -nr -f inet); wait $!
 
 	GATEWAY6=""
 	while read -r destination gateway _; do
 		[[ $destination == default ]] || continue
 		GATEWAY6="$gateway"
 		break
-	done < <(netstat -nr -f inet6)
+	done < <(netstat -nr -f inet6); wait $!
 }
 
 collect_endpoints() {
@@ -212,7 +212,7 @@ collect_endpoints() {
 	while read -r _ endpoint; do
 		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
 		ENDPOINTS+=( "${BASH_REMATCH[1]}" )
-	done < <(wg show "$REAL_INTERFACE" endpoints)
+	done < <(wg show "$REAL_INTERFACE" endpoints); wait $!
 }
 
 declare -A SERVICE_DNS
@@ -230,7 +230,7 @@ collect_new_service_dns() {
 		get_response="$(cmd networksetup -getsearchdomains "$service")"
 		[[ $get_response == *" "* ]] && get_response="Empty"
 		[[ -n $get_response ]] && SERVICE_DNS_SEARCH["$service"]="$get_response"
-	done; } < <(networksetup -listallnetworkservices)
+	done; } < <(networksetup -listallnetworkservices); wait $!
 
 	for service in "${!SERVICE_DNS[@]}"; do
 		if ! [[ -n ${found_services["$service"]} ]]; then
@@ -304,7 +304,7 @@ set_dns() {
 			else
 				cmd networksetup -setsearchdomains "$service" "${DNS_SEARCH[@]}"
 			fi
-		)
+		); wait $!
 	done
 }
 
@@ -316,7 +316,7 @@ del_dns() {
 		done < <(
 			cmd networksetup -setdnsservers "$service" ${SERVICE_DNS["$service"]} || true
 			cmd networksetup -setsearchdomains "$service" ${SERVICE_DNS_SEARCH["$service"]} || true
-		)
+		); wait $!
 	done
 }
 
@@ -339,7 +339,7 @@ monitor_daemon() {
 			set_dns
 			sleep 2 && kill -ALRM $pid 2>/dev/null &
 		fi
-	done < <(route -n monitor)) &
+	done < <(route -n monitor); wait $!) &
 	[[ -n $LAUNCHED_BY_LAUNCHD ]] || disown
 }
 
@@ -367,7 +367,7 @@ add_route() {
 }
 
 set_config() {
-	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG")
+	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG"); wait $!
 }
 
 save_config() {
@@ -375,7 +375,7 @@ save_config() {
 	new_config=$'[Interface]\n'
 	while read -r address; do
 		[[ $address =~ inet6?\ ([^ ]+) ]] && new_config+="Address = ${BASH_REMATCH[1]}"$'\n'
-	done < <(ifconfig "$REAL_INTERFACE")
+	done < <(ifconfig "$REAL_INTERFACE"); wait $!
 	# TODO: actually determine current DNS for interface
 	for address in "${DNS[@]}"; do
 		new_config+="DNS = $address"$'\n'
@@ -458,7 +458,7 @@ cmd_up() {
 	done
 	set_mtu
 	up_if
-	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
+	for i in $({ while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips); wait $!; } | sort -nr -k 2 -t /); do
 		add_route "$i"
 	done
 	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index e1ee67f..bcd394c 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -121,14 +121,14 @@ del_routes() {
 	local todelete=( ) destination gateway netif
 	while read -r destination _ _ _ _ netif _; do
 		[[ $netif == "$INTERFACE" ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet)
+	done < <(netstat -nr -f inet); wait $!
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet "$destination" || true
 	done
 	todelete=( )
 	while read -r destination gateway _ netif; do
 		[[ $netif == "$INTERFACE" || ( $netif == lo* && $gateway == "$INTERFACE" ) ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet6)
+	done < <(netstat -nr -f inet6); wait $!
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet6 "$destination" || true
 	done
@@ -191,9 +191,9 @@ set_mtu() {
 		[[ ${BASH_REMATCH[1]} == *:* ]] && family=inet6
 		output="$(route -n get "-$family" "${BASH_REMATCH[1]}" || true)"
 		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
-	done < <(wg show "$INTERFACE" endpoints)
+	done < <(wg show "$INTERFACE" endpoints); wait $!
 	if [[ $mtu -eq 0 ]]; then
-		read -r output < <(route -n get default || true) || true
+		read -r output < <(route -n get default) || true
 		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
 	fi
 	[[ $mtu -gt 0 ]] || mtu=1500
@@ -209,14 +209,14 @@ collect_gateways() {
 		[[ $destination == default ]] || continue
 		GATEWAY4="$gateway"
 		break
-	done < <(netstat -nr -f inet)
+	done < <(netstat -nr -f inet); wait $!
 
 	GATEWAY6=""
 	while read -r destination gateway _; do
 		[[ $destination == default ]] || continue
 		GATEWAY6="$gateway"
 		break
-	done < <(netstat -nr -f inet6)
+	done < <(netstat -nr -f inet6); wait $!
 }
 
 collect_endpoints() {
@@ -224,7 +224,7 @@ collect_endpoints() {
 	while read -r _ endpoint; do
 		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
 		ENDPOINTS+=( "${BASH_REMATCH[1]}" )
-	done < <(wg show "$INTERFACE" endpoints)
+	done < <(wg show "$INTERFACE" endpoints); wait $!
 }
 
 set_endpoint_direct_route() {
@@ -294,7 +294,7 @@ monitor_daemon() {
 		if_exists || break
 		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
 		# TODO: set the mtu as well, but only if up
-	done < <(route -n monitor)) & disown
+	done < <(route -n monitor); wait $!) & disown
 }
 
 HAVE_SET_DNS=0
@@ -335,7 +335,7 @@ add_route() {
 }
 
 set_config() {
-	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG")
+	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG"); wait $!
 }
 
 save_config() {
@@ -343,13 +343,13 @@ save_config() {
 	new_config=$'[Interface]\n'
 	{ read -r _; while read -r _ _ _ address _; do
 		new_config+="Address = $address"$'\n'
-	done } < <(netstat -I "$INTERFACE" -n -W -f inet)
+	done } < <(netstat -I "$INTERFACE" -n -W -f inet); wait $!
 	{ read -r _; while read -r _ _ _ address _; do
 		new_config+="Address = $address"$'\n'
-	done } < <(netstat -I "$INTERFACE" -n -W -f inet6)
+	done } < <(netstat -I "$INTERFACE" -n -W -f inet6); wait $!
 	while read -r address; do
 		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
-	done < <(resolvconf -l "$INTERFACE" 2>/dev/null)
+	done < <(resolvconf -l "$INTERFACE" 2>/dev/null); wait $!
 	[[ -n $MTU ]] && new_config+="MTU = $MTU"$'\n'
 	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
@@ -427,7 +427,7 @@ cmd_up() {
 	set_mtu
 	up_if
 	set_dns
-	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
+	for i in $({ while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips); wait $!; } | sort -nr -k 2 -t /); do
 		add_route "$i"
 	done
 	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index e4d4c4f..8bda740 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -132,9 +132,9 @@ set_mtu_up() {
 		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
 		output="$(ip route get "${BASH_REMATCH[1]}" || true)"
 		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
-	done < <(wg show "$INTERFACE" endpoints)
+	done < <(wg show "$INTERFACE" endpoints); wait $!
 	if [[ $mtu -eq 0 ]]; then
-		read -r output < <(ip route show default || true) || true
+		read -r output < <(ip route show default) || true
 		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
 	fi
 	[[ $mtu -gt 0 ]] || mtu=1500
@@ -191,8 +191,8 @@ remove_firewall() {
 		local table nftcmd
 		while read -r table; do
 			[[ $table == *" wg-quick-$INTERFACE" ]] && printf -v nftcmd '%sdelete %s\n' "$nftcmd" "$table"
-		done < <(nft list tables 2>/dev/null)
-		[[ -z $nftcmd ]] || cmd nft -f <(echo -n "$nftcmd")
+		done < <(nft list tables 2>/dev/null) || true
+		[[ -z $nftcmd ]] || cmd nft -f <(echo -n "$nftcmd"); wait $!
 	fi
 	if type -p iptables >/dev/null; then
 		local line iptables found restore
@@ -202,7 +202,7 @@ remove_firewall() {
 				[[ $line == "*"* || $line == COMMIT || $line == "-A "*"-m comment --comment \"wg-quick(8) rule for $INTERFACE\""* ]] || continue
 				[[ $line == "-A"* ]] && found=1
 				printf -v restore '%s%s\n' "$restore" "${line/#-A/-D}"
-			done < <($iptables-save 2>/dev/null)
+			done < <($iptables-save 2>/dev/null) || true
 			[[ $found -ne 1 ]] || echo -n "$restore" | cmd $iptables-restore -n
 		done
 	fi
@@ -233,22 +233,22 @@ add_default() {
 		[[ $line =~ .*inet6?\ ([0-9a-f:.]+)/[0-9]+.* ]] || continue
 		printf -v restore '%s-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${BASH_REMATCH[1]}" "$marker"
 		printf -v nftcmd '%sadd rule %s %s preraw iifname != "%s" %s daddr %s fib saddr type != local drop\n' "$nftcmd" "$pf" "$nftable" "$INTERFACE" "$pf" "${BASH_REMATCH[1]}"
-	done < <(ip -o $proto addr show dev "$INTERFACE" 2>/dev/null)
+	done < <(ip -o $proto addr show dev "$INTERFACE"); wait $!
 	printf -v restore '%sCOMMIT\n*mangle\n-I POSTROUTING -m mark --mark %d -p udp -j CONNMARK --save-mark %s\n-I PREROUTING -p udp -j CONNMARK --restore-mark %s\nCOMMIT\n' "$restore" $table "$marker" "$marker"
 	printf -v nftcmd '%sadd rule %s %s postmangle meta l4proto udp mark %d ct mark set mark \n' "$nftcmd" "$pf" "$nftable" $table
 	printf -v nftcmd '%sadd rule %s %s premangle meta l4proto udp meta mark set ct mark \n' "$nftcmd" "$pf" "$nftable"
 	[[ $proto == -4 ]] && cmd sysctl -q net.ipv4.conf.all.src_valid_mark=1
 	if type -p nft >/dev/null; then
-		cmd nft -f <(echo -n "$nftcmd")
+		cmd nft -f <(echo -n "$nftcmd"); wait $!
 	else
-		echo -n "$restore" | cmd $iptables-restore -n
+		echo -n "$restore" | cmd $iptables-restore -n; wait $!
 	fi
 	HAVE_SET_FIREWALL=1
 	return 0
 }
 
 set_config() {
-	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG")
+	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG"); wait $!
 }
 
 save_config() {
@@ -260,7 +260,7 @@ save_config() {
 	done
 	while read -r address; do
 		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
-	done < <(resolvconf -l "$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null || cat "/etc/resolvconf/run/interface/$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null)
+	done < <(resolvconf -l "$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null || cat "/etc/resolvconf/run/interface/$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null) || true
 	[[ -n $MTU && $(ip link show dev "$INTERFACE") =~ mtu\ ([0-9]+) ]] && new_config+="MTU = ${BASH_REMATCH[1]}"$'\n'
 	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
@@ -335,7 +335,7 @@ cmd_up() {
 	done
 	set_mtu_up
 	set_dns
-	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
+	for i in $({ while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips); wait $!; } | sort -nr -k 2 -t /); do
 		add_route "$i"
 	done
 	execute_hooks "${POST_UP[@]}"
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index ffd1834..f45027c 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -131,14 +131,14 @@ del_routes() {
 	[[ -n $REAL_INTERFACE ]] || return 0
 	while read -r destination _ _ _ _ netif _; do
 		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet)
+	done < <(netstat -nr -f inet); wait $!
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet "$destination" || true
 	done
 	todelete=( )
 	while read -r destination gateway _ netif; do
 		[[ $netif == "$REAL_INTERFACE" || ( $netif == lo* && $gateway == "$REAL_INTERFACE" ) ]] && todelete+=( "$destination" )
-	done < <(netstat -nr -f inet6)
+	done < <(netstat -nr -f inet6); wait $!
 	for destination in "${todelete[@]}"; do
 		cmd route -q -n delete -inet6 "$destination" || true
 	done
@@ -189,9 +189,9 @@ set_mtu() {
 		[[ ${BASH_REMATCH[1]} == *:* ]] && family=inet6
 		output="$(route -n get "-$family" "${BASH_REMATCH[1]}" || true)"
 		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
-	done < <(wg show "$REAL_INTERFACE" endpoints)
+	done < <(wg show "$REAL_INTERFACE" endpoints); wait $!
 	if [[ $mtu -eq 0 ]]; then
-		read -r output < <(route -n get default || true) || true
+		read -r output < <(route -n get default) || true
 		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
 	fi
 	[[ $mtu -gt 0 ]] || mtu=1500
@@ -207,14 +207,14 @@ collect_gateways() {
 		[[ $destination == default ]] || continue
 		GATEWAY4="$gateway"
 		break
-	done < <(netstat -nr -f inet)
+	done < <(netstat -nr -f inet); wait $!
 
 	GATEWAY6=""
 	while read -r destination gateway _; do
 		[[ $destination == default ]] || continue
 		GATEWAY6="$gateway"
 		break
-	done < <(netstat -nr -f inet6)
+	done < <(netstat -nr -f inet6); wait $!
 }
 
 collect_endpoints() {
@@ -222,7 +222,7 @@ collect_endpoints() {
 	while read -r _ endpoint; do
 		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
 		ENDPOINTS+=( "${BASH_REMATCH[1]}" )
-	done < <(wg show "$REAL_INTERFACE" endpoints)
+	done < <(wg show "$REAL_INTERFACE" endpoints); wait $!
 }
 
 set_endpoint_direct_route() {
@@ -290,7 +290,7 @@ monitor_daemon() {
 		ifconfig "$REAL_INTERFACE" >/dev/null 2>&1 || break
 		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
 		# TODO: set the mtu as well, but only if up
-	done < <(route -n monitor)) & disown
+	done < <(route -n monitor); wait $!) & disown
 }
 
 set_dns() {
@@ -339,7 +339,7 @@ add_route() {
 }
 
 set_config() {
-	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG")
+	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG"); wait $!
 }
 
 save_config() {
@@ -347,7 +347,7 @@ save_config() {
 	new_config=$'[Interface]\n'
 	{ read -r _; while read -r _ _ network address _; do
 		[[ $network == *Link* ]] || new_config+="Address = $address"$'\n'
-	done } < <(netstat -I "$REAL_INTERFACE" -n -v)
+	done } < <(netstat -I "$REAL_INTERFACE" -n -v); wait $!
 	# TODO: actually determine current DNS for interface
 	for address in "${DNS[@]}"; do
 		new_config+="DNS = $address"$'\n'
@@ -428,7 +428,7 @@ cmd_up() {
 	set_mtu
 	up_if
 	set_dns
-	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
+	for i in $({ while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips); wait $!; } | sort -nr -k 2 -t /); do
 		add_route "$i"
 	done
 	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route

commit 13fac76a71f25631d7415ba457bdab267d0950d4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Aug 4 14:49:21 2020 +0200

    ctype: use non-locale-specific ctype.h
    
    We also make these constant time, even though we're never distinguishing
    between bits of a secret using them. From that perspective, though, this
    is markedly better than the locale-specific table lookups in glibc, even
    though base64 characters span two cache lines and valid private keys
    must hit both.
    
    Co-authored-by: Samuel Neves <sneves@dei.uc.pt>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Samuel Neves <sneves@dei.uc.pt>

diff --git a/src/config.c b/src/config.c
index b8394a5..e0b4b7c 100644
--- a/src/config.c
+++ b/src/config.c
@@ -5,7 +5,6 @@
 
 #include <arpa/inet.h>
 #include <limits.h>
-#include <ctype.h>
 #include <netdb.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -19,6 +18,7 @@
 #include "containers.h"
 #include "ipc.h"
 #include "encoding.h"
+#include "ctype.h"
 
 #define COMMENT_CHAR '#'
 
@@ -86,7 +86,7 @@ static inline bool parse_fwmark(uint32_t *fwmark, uint32_t *flags, const char *v
 		return true;
 	}
 
-	if (!isdigit(value[0]))
+	if (!char_is_digit(value[0]))
 		goto err;
 
 	if (strlen(value) > 2 && value[0] == '0' && value[1] == 'x')
@@ -141,7 +141,7 @@ static bool parse_keyfile(uint8_t key[static WG_KEY_LEN], const char *path)
 	dst[WG_KEY_LEN_BASE64 - 1] = '\0';
 
 	while ((c = getc(f)) != EOF) {
-		if (!isspace(c)) {
+		if (!char_is_space(c)) {
 			fprintf(stderr, "Found trailing character in key file: `%c'\n", c);
 			goto out;
 		}
@@ -290,7 +290,7 @@ static inline bool parse_persistent_keepalive(uint16_t *interval, uint32_t *flag
 		return true;
 	}
 
-	if (!isdigit(value[0]))
+	if (!char_is_digit(value[0]))
 		goto err;
 
 	ret = strtoul(value, &end, 10);
@@ -375,7 +375,7 @@ static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **la
 		}
 
 		if (mask) {
-			if (!isdigit(mask[0]))
+			if (!char_is_digit(mask[0]))
 				goto err;
 			cidr = strtoul(mask, &end, 10);
 			if (*end || (cidr > 32 && new_allowedip->family == AF_INET) || (cidr > 128 && new_allowedip->family == AF_INET6))
@@ -501,7 +501,7 @@ bool config_read_line(struct config_ctx *ctx, const char *input)
 	}
 
 	for (size_t i = 0; i < len; ++i) {
-		if (!isspace(input[i]))
+		if (!char_is_space(input[i]))
 			line[cleaned_len++] = input[i];
 	}
 	if (!cleaned_len)
@@ -555,7 +555,7 @@ static char *strip_spaces(const char *in)
 		return NULL;
 	}
 	for (i = 0, l = 0; i < t; ++i) {
-		if (!isspace(in[i]))
+		if (!char_is_space(in[i]))
 			out[l++] = in[i];
 	}
 	return out;
diff --git a/src/ctype.h b/src/ctype.h
new file mode 100644
index 0000000..98b2283
--- /dev/null
+++ b/src/ctype.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * Specialized constant-time ctype.h reimplementations that aren't locale-specific.
+ */
+
+#ifndef CTYPE_H
+#define CTYPE_H
+
+#include <stdbool.h>
+
+static inline bool char_is_space(int c)
+{
+	unsigned char d = c - 9;
+	return (0x80001FU >> (d & 31)) & (1U >> (d >> 5));
+}
+
+static inline bool char_is_digit(int c)
+{
+	return (unsigned int)(('0' - 1 - c) & (c - ('9' + 1))) >> (sizeof(c) * 8 - 1);
+}
+
+static inline bool char_is_alpha(int c)
+{
+	return (unsigned int)(('a' - 1 - (c | 32)) & ((c | 32) - ('z' + 1))) >> (sizeof(c) * 8 - 1);
+}
+
+#endif
diff --git a/src/ipc-uapi.h b/src/ipc-uapi.h
index 3b1fff3..f464be7 100644
--- a/src/ipc-uapi.h
+++ b/src/ipc-uapi.h
@@ -4,7 +4,6 @@
  */
 
 #include <arpa/inet.h>
-#include <ctype.h>
 #include <errno.h>
 #include <net/if.h>
 #include <netdb.h>
@@ -17,6 +16,7 @@
 #include "containers.h"
 #include "curve25519.h"
 #include "encoding.h"
+#include "ctype.h"
 
 #ifdef _WIN32
 #include "ipc-uapi-windows.h"
@@ -102,7 +102,7 @@ static int userspace_set_device(struct wgdevice *dev)
 #define NUM(max) ({ \
 	unsigned long long num; \
 	char *end; \
-	if (!isdigit(value[0])) \
+	if (!char_is_digit(value[0])) \
 		break; \
 	num = strtoull(value, &end, 10); \
 	if (*end || num > max) \
@@ -223,7 +223,7 @@ static int userspace_get_device(struct wgdevice **out, const char *iface)
 			struct wgallowedip *new_allowedip;
 			char *end, *mask = value, *ip = strsep(&mask, "/");
 
-			if (!mask || !isdigit(mask[0]))
+			if (!mask || !char_is_digit(mask[0]))
 				break;
 			new_allowedip = calloc(1, sizeof(*new_allowedip));
 			if (!new_allowedip) {
diff --git a/src/pubkey.c b/src/pubkey.c
index a78fe11..b4478dc 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -5,11 +5,11 @@
 
 #include <errno.h>
 #include <stdio.h>
-#include <ctype.h>
 
 #include "curve25519.h"
 #include "encoding.h"
 #include "subcommands.h"
+#include "ctype.h"
 
 int pubkey_main(int argc, char *argv[])
 {
@@ -31,7 +31,7 @@ int pubkey_main(int argc, char *argv[])
 
 	for (;;) {
 		trailing_char = getc(stdin);
-		if (!trailing_char || isspace(trailing_char))
+		if (!trailing_char || char_is_space(trailing_char))
 			continue;
 		if (trailing_char == EOF)
 			break;
diff --git a/src/terminal.c b/src/terminal.c
index bea27ba..7c293cd 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -3,7 +3,6 @@
  * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
-#include <ctype.h>
 #include <stdarg.h>
 #include <stddef.h>
 #include <stdio.h>
@@ -11,6 +10,7 @@
 #include <string.h>
 #include <stdbool.h>
 #include <unistd.h>
+#include "ctype.h"
 
 static bool color_mode(void)
 {
@@ -46,7 +46,7 @@ static void filter_ansi(const char *fmt, va_list args)
 			if (str[i] == '\x1b' && str[i + 1] == '[') {
 				str[i] = str[i + 1] = '\0';
 				for (j = i + 2; j < len; ++j) {
-					if (isalpha(str[j]))
+					if (char_is_alpha(str[j]))
 						break;
 					str[j] = '\0';
 				}

commit cf2bf0952498059c6a8987bb54b58987748af7e2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Aug 4 14:04:52 2020 +0200

    pubkey: isblank is a subset of isspace
    
    Therefore, there's no need to test both.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/pubkey.c b/src/pubkey.c
index 19235fc..a78fe11 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -31,7 +31,7 @@ int pubkey_main(int argc, char *argv[])
 
 	for (;;) {
 		trailing_char = getc(stdin);
-		if (!trailing_char || isspace(trailing_char) || isblank(trailing_char))
+		if (!trailing_char || isspace(trailing_char))
 			continue;
 		if (trailing_char == EOF)
 			break;

commit b4a8a18797335de6d3d416e14a2ad769219426db
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jul 28 10:57:54 2020 +0200

    man: wg-quick: use syncconf instead of addconf for strip example
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg-quick.8 b/src/man/wg-quick.8
index c693a89..b84eb64 100644
--- a/src/man/wg-quick.8
+++ b/src/man/wg-quick.8
@@ -254,9 +254,7 @@ This will load the configuration file `/etc/wireguard/wgnet0.conf'.
 The \fIstrip\fP command is useful for reloading configuration files without disrupting active
 sessions:
 
-\fB    # wg addconf wgnet0 <(wg-quick strip wgnet0)\fP
-
-(Note that the above command will add and update peers but will not remove peers.)
+\fB    # wg syncconf wgnet0 <(wg-quick strip wgnet0)\fP
 
 .SH SEE ALSO
 .BR wg (8),

commit a66219fa107e1bf0a03ebbbc405879c1f0a826c5
Author: Domonkos P. Tomcsanyi <domi@tomcsanyi.net>
Date:   Fri Jul 24 16:21:52 2020 +0200

    systemd: add reload target to systemd unit
    
    Users can now run `systemctl reload wg-quick@wgnet0`, as described in
    the wg-quick(8) man page. Note that this won't adjust Address=, DNS=, or
    the various other non-wg(8) fields.
    
    Signed-off-by: Domonkos P. Tomcsanyi <domi@tomcsanyi.net>
    [zx2c4: use exec for bash commands to reduce excess forks, and rewrite
            commit message]
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/systemd/wg-quick@.service b/src/systemd/wg-quick@.service
index a9cbb58..dbdab44 100644
--- a/src/systemd/wg-quick@.service
+++ b/src/systemd/wg-quick@.service
@@ -15,6 +15,7 @@ Type=oneshot
 RemainAfterExit=yes
 ExecStart=/usr/bin/wg-quick up %i
 ExecStop=/usr/bin/wg-quick down %i
+ExecReload=/bin/bash -c 'exec /usr/bin/wg syncconf %i <(exec /usr/bin/wg-quick strip %i)'
 Environment=WG_ENDPOINT_RESOLUTION_RETRIES=infinity
 
 [Install]

commit eb4665ecf082033d986c64453e2becce19bc7af7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 25 18:05:14 2020 -0600

    wincompat: fold random into genkey
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/genkey.c b/src/genkey.c
index d1bb643..ef7770b 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -28,7 +28,7 @@
 #include "encoding.h"
 #include "subcommands.h"
 
-#ifndef WINCOMPAT
+#ifndef _WIN32
 static inline bool __attribute__((__warn_unused_result__)) get_random_bytes(uint8_t *out, size_t len)
 {
 	ssize_t ret = 0;
@@ -65,7 +65,11 @@ static inline bool __attribute__((__warn_unused_result__)) get_random_bytes(uint
 	return i == len;
 }
 #else
-#include "wincompat/getrandom.c"
+#include <ntsecapi.h>
+static inline bool __attribute__((__warn_unused_result__)) get_random_bytes(uint8_t *out, size_t len)
+{
+        return RtlGenRandom(out, len);
+}
 #endif
 
 int genkey_main(int argc, char *argv[])
diff --git a/src/wincompat/compat.h b/src/wincompat/compat.h
index 5decc66..643c11d 100644
--- a/src/wincompat/compat.h
+++ b/src/wincompat/compat.h
@@ -18,8 +18,6 @@
 #undef min
 #undef max
 
-#define WINCOMPAT
-
 #define IFNAMSIZ 64
 #define EAI_SYSTEM -99
 
diff --git a/src/wincompat/getrandom.c b/src/wincompat/getrandom.c
deleted file mode 100644
index b064b04..0000000
--- a/src/wincompat/getrandom.c
+++ /dev/null
@@ -1,12 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-
-#include <stdbool.h>
-#include <ntsecapi.h>
-
-static inline bool __attribute__((__warn_unused_result__)) get_random_bytes(uint8_t *out, size_t len)
-{
-	return RtlGenRandom(out, len);
-}
diff --git a/src/wincompat/include/sys/ioctl.h b/src/wincompat/include/sys/ioctl.h
deleted file mode 100644
index e69de29..0000000
diff --git a/src/wincompat/include/sys/un.h b/src/wincompat/include/sys/un.h
deleted file mode 100644
index e69de29..0000000

commit 197995d50c398db0565d77b577c2a34c6e4f7466
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 25 17:13:20 2020 -0600

    ipc: split into separate files per-platform
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc-linux.h b/src/ipc-linux.h
new file mode 100644
index 0000000..5883ffe
--- /dev/null
+++ b/src/ipc-linux.h
@@ -0,0 +1,519 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <time.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <linux/genetlink.h>
+#include <linux/if_link.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <linux/wireguard.h>
+#include <netinet/in.h>
+#include "containers.h"
+#include "encoding.h"
+#include "netlink.h"
+
+#define IPC_SUPPORTS_KERNEL_INTERFACE
+
+#define SOCKET_BUFFER_SIZE (mnl_ideal_socket_buffer_size())
+
+struct interface {
+	const char *name;
+	bool is_wireguard;
+};
+
+static int parse_linkinfo(const struct nlattr *attr, void *data)
+{
+	struct interface *interface = data;
+
+	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp(WG_GENL_NAME, mnl_attr_get_str(attr)))
+		interface->is_wireguard = true;
+	return MNL_CB_OK;
+}
+
+static int parse_infomsg(const struct nlattr *attr, void *data)
+{
+	struct interface *interface = data;
+
+	if (mnl_attr_get_type(attr) == IFLA_LINKINFO)
+		return mnl_attr_parse_nested(attr, parse_linkinfo, data);
+	else if (mnl_attr_get_type(attr) == IFLA_IFNAME)
+		interface->name = mnl_attr_get_str(attr);
+	return MNL_CB_OK;
+}
+
+static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
+{
+	struct string_list *list = data;
+	struct interface interface = { 0 };
+	int ret;
+
+	ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, &interface);
+	if (ret != MNL_CB_OK)
+		return ret;
+	if (interface.name && interface.is_wireguard)
+		ret = string_list_add(list, interface.name);
+	if (ret < 0)
+		return ret;
+	if (nlh->nlmsg_type != NLMSG_DONE)
+		return MNL_CB_OK + 1;
+	return MNL_CB_OK;
+}
+
+static int kernel_get_wireguard_interfaces(struct string_list *list)
+{
+	struct mnl_socket *nl = NULL;
+	char *rtnl_buffer = NULL;
+	size_t message_len;
+	unsigned int portid, seq;
+	ssize_t len;
+	int ret = 0;
+	struct nlmsghdr *nlh;
+	struct ifinfomsg *ifm;
+
+	ret = -ENOMEM;
+	rtnl_buffer = calloc(SOCKET_BUFFER_SIZE, 1);
+	if (!rtnl_buffer)
+		goto cleanup;
+
+	nl = mnl_socket_open(NETLINK_ROUTE);
+	if (!nl) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	seq = time(NULL);
+	portid = mnl_socket_get_portid(nl);
+	nlh = mnl_nlmsg_put_header(rtnl_buffer);
+	nlh->nlmsg_type = RTM_GETLINK;
+	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP;
+	nlh->nlmsg_seq = seq;
+	ifm = mnl_nlmsg_put_extra_header(nlh, sizeof(*ifm));
+	ifm->ifi_family = AF_UNSPEC;
+	message_len = nlh->nlmsg_len;
+
+	if (mnl_socket_sendto(nl, rtnl_buffer, message_len) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+another:
+	if ((len = mnl_socket_recvfrom(nl, rtnl_buffer, SOCKET_BUFFER_SIZE)) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, list)) < 0) {
+		/* Netlink returns NLM_F_DUMP_INTR if the set of all tunnels changed
+		 * during the dump. That's unfortunate, but is pretty common on busy
+		 * systems that are adding and removing tunnels all the time. Rather
+		 * than retrying, potentially indefinitely, we just work with the
+		 * partial results. */
+		if (errno != EINTR) {
+			ret = -errno;
+			goto cleanup;
+		}
+	}
+	if (len == MNL_CB_OK + 1)
+		goto another;
+	ret = 0;
+
+cleanup:
+	free(rtnl_buffer);
+	if (nl)
+		mnl_socket_close(nl);
+	return ret;
+}
+
+static int kernel_set_device(struct wgdevice *dev)
+{
+	int ret = 0;
+	struct wgpeer *peer = NULL;
+	struct wgallowedip *allowedip = NULL;
+	struct nlattr *peers_nest, *peer_nest, *allowedips_nest, *allowedip_nest;
+	struct nlmsghdr *nlh;
+	struct mnlg_socket *nlg;
+
+	nlg = mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
+	if (!nlg)
+		return -errno;
+
+again:
+	nlh = mnlg_msg_prepare(nlg, WG_CMD_SET_DEVICE, NLM_F_REQUEST | NLM_F_ACK);
+	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, dev->name);
+
+	if (!peer) {
+		uint32_t flags = 0;
+
+		if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY)
+			mnl_attr_put(nlh, WGDEVICE_A_PRIVATE_KEY, sizeof(dev->private_key), dev->private_key);
+		if (dev->flags & WGDEVICE_HAS_LISTEN_PORT)
+			mnl_attr_put_u16(nlh, WGDEVICE_A_LISTEN_PORT, dev->listen_port);
+		if (dev->flags & WGDEVICE_HAS_FWMARK)
+			mnl_attr_put_u32(nlh, WGDEVICE_A_FWMARK, dev->fwmark);
+		if (dev->flags & WGDEVICE_REPLACE_PEERS)
+			flags |= WGDEVICE_F_REPLACE_PEERS;
+		if (flags)
+			mnl_attr_put_u32(nlh, WGDEVICE_A_FLAGS, flags);
+	}
+	if (!dev->first_peer)
+		goto send;
+	peers_nest = peer_nest = allowedips_nest = allowedip_nest = NULL;
+	peers_nest = mnl_attr_nest_start(nlh, WGDEVICE_A_PEERS);
+	for (peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
+		uint32_t flags = 0;
+
+		peer_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, 0);
+		if (!peer_nest)
+			goto toobig_peers;
+		if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PUBLIC_KEY, sizeof(peer->public_key), peer->public_key))
+			goto toobig_peers;
+		if (peer->flags & WGPEER_REMOVE_ME)
+			flags |= WGPEER_F_REMOVE_ME;
+		if (!allowedip) {
+			if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
+				flags |= WGPEER_F_REPLACE_ALLOWEDIPS;
+			if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
+				if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PRESHARED_KEY, sizeof(peer->preshared_key), peer->preshared_key))
+					goto toobig_peers;
+			}
+			if (peer->endpoint.addr.sa_family == AF_INET) {
+				if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr4), &peer->endpoint.addr4))
+					goto toobig_peers;
+			} else if (peer->endpoint.addr.sa_family == AF_INET6) {
+				if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr6), &peer->endpoint.addr6))
+					goto toobig_peers;
+			}
+			if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL) {
+				if (!mnl_attr_put_u16_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL, peer->persistent_keepalive_interval))
+					goto toobig_peers;
+			}
+		}
+		if (flags) {
+			if (!mnl_attr_put_u32_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_FLAGS, flags))
+				goto toobig_peers;
+		}
+		if (peer->first_allowedip) {
+			if (!allowedip)
+				allowedip = peer->first_allowedip;
+			allowedips_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ALLOWEDIPS);
+			if (!allowedips_nest)
+				goto toobig_allowedips;
+			for (; allowedip; allowedip = allowedip->next_allowedip) {
+				allowedip_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, 0);
+				if (!allowedip_nest)
+					goto toobig_allowedips;
+				if (!mnl_attr_put_u16_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_FAMILY, allowedip->family))
+					goto toobig_allowedips;
+				if (allowedip->family == AF_INET) {
+					if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip4), &allowedip->ip4))
+						goto toobig_allowedips;
+				} else if (allowedip->family == AF_INET6) {
+					if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip6), &allowedip->ip6))
+						goto toobig_allowedips;
+				}
+				if (!mnl_attr_put_u8_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_CIDR_MASK, allowedip->cidr))
+					goto toobig_allowedips;
+				mnl_attr_nest_end(nlh, allowedip_nest);
+				allowedip_nest = NULL;
+			}
+			mnl_attr_nest_end(nlh, allowedips_nest);
+			allowedips_nest = NULL;
+		}
+
+		mnl_attr_nest_end(nlh, peer_nest);
+		peer_nest = NULL;
+	}
+	mnl_attr_nest_end(nlh, peers_nest);
+	peers_nest = NULL;
+	goto send;
+toobig_allowedips:
+	if (allowedip_nest)
+		mnl_attr_nest_cancel(nlh, allowedip_nest);
+	if (allowedips_nest)
+		mnl_attr_nest_end(nlh, allowedips_nest);
+	mnl_attr_nest_end(nlh, peer_nest);
+	mnl_attr_nest_end(nlh, peers_nest);
+	goto send;
+toobig_peers:
+	if (peer_nest)
+		mnl_attr_nest_cancel(nlh, peer_nest);
+	mnl_attr_nest_end(nlh, peers_nest);
+	goto send;
+send:
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		ret = -errno;
+		goto out;
+	}
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, NULL, NULL) < 0) {
+		ret = errno ? -errno : -EINVAL;
+		goto out;
+	}
+	if (peer)
+		goto again;
+
+out:
+	mnlg_socket_close(nlg);
+	errno = -ret;
+	return ret;
+}
+
+static int parse_allowedip(const struct nlattr *attr, void *data)
+{
+	struct wgallowedip *allowedip = data;
+
+	switch (mnl_attr_get_type(attr)) {
+	case WGALLOWEDIP_A_UNSPEC:
+		break;
+	case WGALLOWEDIP_A_FAMILY:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
+			allowedip->family = mnl_attr_get_u16(attr);
+		break;
+	case WGALLOWEDIP_A_IPADDR:
+		if (mnl_attr_get_payload_len(attr) == sizeof(allowedip->ip4))
+			memcpy(&allowedip->ip4, mnl_attr_get_payload(attr), sizeof(allowedip->ip4));
+		else if (mnl_attr_get_payload_len(attr) == sizeof(allowedip->ip6))
+			memcpy(&allowedip->ip6, mnl_attr_get_payload(attr), sizeof(allowedip->ip6));
+		break;
+	case WGALLOWEDIP_A_CIDR_MASK:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U8))
+			allowedip->cidr = mnl_attr_get_u8(attr);
+		break;
+	}
+
+	return MNL_CB_OK;
+}
+
+static int parse_allowedips(const struct nlattr *attr, void *data)
+{
+	struct wgpeer *peer = data;
+	struct wgallowedip *new_allowedip = calloc(1, sizeof(*new_allowedip));
+	int ret;
+
+	if (!new_allowedip) {
+		perror("calloc");
+		return MNL_CB_ERROR;
+	}
+	if (!peer->first_allowedip)
+		peer->first_allowedip = peer->last_allowedip = new_allowedip;
+	else {
+		peer->last_allowedip->next_allowedip = new_allowedip;
+		peer->last_allowedip = new_allowedip;
+	}
+	ret = mnl_attr_parse_nested(attr, parse_allowedip, new_allowedip);
+	if (!ret)
+		return ret;
+	if (!((new_allowedip->family == AF_INET && new_allowedip->cidr <= 32) || (new_allowedip->family == AF_INET6 && new_allowedip->cidr <= 128)))
+		return MNL_CB_ERROR;
+	return MNL_CB_OK;
+}
+
+static int parse_peer(const struct nlattr *attr, void *data)
+{
+	struct wgpeer *peer = data;
+
+	switch (mnl_attr_get_type(attr)) {
+	case WGPEER_A_UNSPEC:
+		break;
+	case WGPEER_A_PUBLIC_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->public_key)) {
+			memcpy(peer->public_key, mnl_attr_get_payload(attr), sizeof(peer->public_key));
+			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
+		}
+		break;
+	case WGPEER_A_PRESHARED_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->preshared_key)) {
+			memcpy(peer->preshared_key, mnl_attr_get_payload(attr), sizeof(peer->preshared_key));
+			if (!key_is_zero(peer->preshared_key))
+				peer->flags |= WGPEER_HAS_PRESHARED_KEY;
+		}
+		break;
+	case WGPEER_A_ENDPOINT: {
+		struct sockaddr *addr;
+
+		if (mnl_attr_get_payload_len(attr) < sizeof(*addr))
+			break;
+		addr = mnl_attr_get_payload(attr);
+		if (addr->sa_family == AF_INET && mnl_attr_get_payload_len(attr) == sizeof(peer->endpoint.addr4))
+			memcpy(&peer->endpoint.addr4, addr, sizeof(peer->endpoint.addr4));
+		else if (addr->sa_family == AF_INET6 && mnl_attr_get_payload_len(attr) == sizeof(peer->endpoint.addr6))
+			memcpy(&peer->endpoint.addr6, addr, sizeof(peer->endpoint.addr6));
+		break;
+	}
+	case WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
+			peer->persistent_keepalive_interval = mnl_attr_get_u16(attr);
+		break;
+	case WGPEER_A_LAST_HANDSHAKE_TIME:
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->last_handshake_time))
+			memcpy(&peer->last_handshake_time, mnl_attr_get_payload(attr), sizeof(peer->last_handshake_time));
+		break;
+	case WGPEER_A_RX_BYTES:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
+			peer->rx_bytes = mnl_attr_get_u64(attr);
+		break;
+	case WGPEER_A_TX_BYTES:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
+			peer->tx_bytes = mnl_attr_get_u64(attr);
+		break;
+	case WGPEER_A_ALLOWEDIPS:
+		return mnl_attr_parse_nested(attr, parse_allowedips, peer);
+	}
+
+	return MNL_CB_OK;
+}
+
+static int parse_peers(const struct nlattr *attr, void *data)
+{
+	struct wgdevice *device = data;
+	struct wgpeer *new_peer = calloc(1, sizeof(*new_peer));
+	int ret;
+
+	if (!new_peer) {
+		perror("calloc");
+		return MNL_CB_ERROR;
+	}
+	if (!device->first_peer)
+		device->first_peer = device->last_peer = new_peer;
+	else {
+		device->last_peer->next_peer = new_peer;
+		device->last_peer = new_peer;
+	}
+	ret = mnl_attr_parse_nested(attr, parse_peer, new_peer);
+	if (!ret)
+		return ret;
+	if (!(new_peer->flags & WGPEER_HAS_PUBLIC_KEY))
+		return MNL_CB_ERROR;
+	return MNL_CB_OK;
+}
+
+static int parse_device(const struct nlattr *attr, void *data)
+{
+	struct wgdevice *device = data;
+
+	switch (mnl_attr_get_type(attr)) {
+	case WGDEVICE_A_UNSPEC:
+		break;
+	case WGDEVICE_A_IFINDEX:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
+			device->ifindex = mnl_attr_get_u32(attr);
+		break;
+	case WGDEVICE_A_IFNAME:
+		if (!mnl_attr_validate(attr, MNL_TYPE_STRING)) {
+			strncpy(device->name, mnl_attr_get_str(attr), sizeof(device->name) - 1);
+			device->name[sizeof(device->name) - 1] = '\0';
+		}
+		break;
+	case WGDEVICE_A_PRIVATE_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(device->private_key)) {
+			memcpy(device->private_key, mnl_attr_get_payload(attr), sizeof(device->private_key));
+			device->flags |= WGDEVICE_HAS_PRIVATE_KEY;
+		}
+		break;
+	case WGDEVICE_A_PUBLIC_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(device->public_key)) {
+			memcpy(device->public_key, mnl_attr_get_payload(attr), sizeof(device->public_key));
+			device->flags |= WGDEVICE_HAS_PUBLIC_KEY;
+		}
+		break;
+	case WGDEVICE_A_LISTEN_PORT:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
+			device->listen_port = mnl_attr_get_u16(attr);
+		break;
+	case WGDEVICE_A_FWMARK:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
+			device->fwmark = mnl_attr_get_u32(attr);
+		break;
+	case WGDEVICE_A_PEERS:
+		return mnl_attr_parse_nested(attr, parse_peers, device);
+	}
+
+	return MNL_CB_OK;
+}
+
+static int read_device_cb(const struct nlmsghdr *nlh, void *data)
+{
+	return mnl_attr_parse(nlh, sizeof(struct genlmsghdr), parse_device, data);
+}
+
+static void coalesce_peers(struct wgdevice *device)
+{
+	struct wgpeer *old_next_peer, *peer = device->first_peer;
+
+	while (peer && peer->next_peer) {
+		if (memcmp(peer->public_key, peer->next_peer->public_key, sizeof(peer->public_key))) {
+			peer = peer->next_peer;
+			continue;
+		}
+		if (!peer->first_allowedip) {
+			peer->first_allowedip = peer->next_peer->first_allowedip;
+			peer->last_allowedip = peer->next_peer->last_allowedip;
+		} else {
+			peer->last_allowedip->next_allowedip = peer->next_peer->first_allowedip;
+			peer->last_allowedip = peer->next_peer->last_allowedip;
+		}
+		old_next_peer = peer->next_peer;
+		peer->next_peer = old_next_peer->next_peer;
+		free(old_next_peer);
+	}
+}
+
+static int kernel_get_device(struct wgdevice **device, const char *iface)
+{
+	int ret;
+	struct nlmsghdr *nlh;
+	struct mnlg_socket *nlg;
+
+try_again:
+	ret = 0;
+	*device = calloc(1, sizeof(**device));
+	if (!*device)
+		return -errno;
+
+	nlg = mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
+	if (!nlg) {
+		free_wgdevice(*device);
+		*device = NULL;
+		return -errno;
+	}
+
+	nlh = mnlg_msg_prepare(nlg, WG_CMD_GET_DEVICE, NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP);
+	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, iface);
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		ret = -errno;
+		goto out;
+	}
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, read_device_cb, *device) < 0) {
+		ret = errno ? -errno : -EINVAL;
+		goto out;
+	}
+	coalesce_peers(*device);
+
+out:
+	if (nlg)
+		mnlg_socket_close(nlg);
+	if (ret) {
+		free_wgdevice(*device);
+		if (ret == -EINTR)
+			goto try_again;
+		*device = NULL;
+	}
+	errno = -ret;
+	return ret;
+}
diff --git a/src/ipc-openbsd.h b/src/ipc-openbsd.h
new file mode 100644
index 0000000..30554b1
--- /dev/null
+++ b/src/ipc-openbsd.h
@@ -0,0 +1,281 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <errno.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/types.h>
+#include <net/if.h>
+#include <net/if_wg.h>
+#include <netinet/in.h>
+#include "containers.h"
+
+#define IPC_SUPPORTS_KERNEL_INTERFACE
+
+static int get_dgram_socket(void)
+{
+	static int sock = -1;
+	if (sock < 0)
+		sock = socket(AF_INET, SOCK_DGRAM, 0);
+	return sock;
+}
+
+static int kernel_get_wireguard_interfaces(struct string_list *list)
+{
+	struct ifgroupreq ifgr = { .ifgr_name = "wg" };
+	struct ifg_req *ifg;
+	int s = get_dgram_socket(), ret = 0;
+
+	if (s < 0)
+		return -errno;
+
+	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) < 0)
+		return errno == ENOENT ? 0 : -errno;
+
+	ifgr.ifgr_groups = calloc(1, ifgr.ifgr_len);
+	if (!ifgr.ifgr_groups)
+		return -errno;
+	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) < 0) {
+		ret = -errno;
+		goto out;
+	}
+
+	for (ifg = ifgr.ifgr_groups; ifg && ifgr.ifgr_len > 0; ++ifg) {
+		if ((ret = string_list_add(list, ifg->ifgrq_member)) < 0)
+			goto out;
+		ifgr.ifgr_len -= sizeof(struct ifg_req);
+	}
+
+out:
+	free(ifgr.ifgr_groups);
+	return ret;
+}
+
+static int kernel_get_device(struct wgdevice **device, const char *iface)
+{
+	struct wg_data_io wgdata = { .wgd_size = 0 };
+	struct wg_interface_io *wg_iface;
+	struct wg_peer_io *wg_peer;
+	struct wg_aip_io *wg_aip;
+	struct wgdevice *dev;
+	struct wgpeer *peer;
+	struct wgallowedip *aip;
+	int s = get_dgram_socket(), ret;
+
+	if (s < 0)
+		return -errno;
+
+	*device = NULL;
+	strlcpy(wgdata.wgd_name, iface, sizeof(wgdata.wgd_name));
+	for (size_t last_size = wgdata.wgd_size;; last_size = wgdata.wgd_size) {
+		if (ioctl(s, SIOCGWG, (caddr_t)&wgdata) < 0)
+			goto out;
+		if (last_size >= wgdata.wgd_size)
+			break;
+		wgdata.wgd_interface = realloc(wgdata.wgd_interface, wgdata.wgd_size);
+		if (!wgdata.wgd_interface)
+			goto out;
+	}
+
+	wg_iface = wgdata.wgd_interface;
+	dev = calloc(1, sizeof(*dev));
+	if (!dev)
+		goto out;
+	strlcpy(dev->name, iface, sizeof(dev->name));
+
+	if (wg_iface->i_flags & WG_INTERFACE_HAS_RTABLE) {
+		dev->fwmark = wg_iface->i_rtable;
+		dev->flags |= WGDEVICE_HAS_FWMARK;
+	}
+
+	if (wg_iface->i_flags & WG_INTERFACE_HAS_PORT) {
+		dev->listen_port = wg_iface->i_port;
+		dev->flags |= WGDEVICE_HAS_LISTEN_PORT;
+	}
+
+	if (wg_iface->i_flags & WG_INTERFACE_HAS_PUBLIC) {
+		memcpy(dev->public_key, wg_iface->i_public, sizeof(dev->public_key));
+		dev->flags |= WGDEVICE_HAS_PUBLIC_KEY;
+	}
+
+	if (wg_iface->i_flags & WG_INTERFACE_HAS_PRIVATE) {
+		memcpy(dev->private_key, wg_iface->i_private, sizeof(dev->private_key));
+		dev->flags |= WGDEVICE_HAS_PRIVATE_KEY;
+	}
+
+	wg_peer = &wg_iface->i_peers[0];
+	for (size_t i = 0; i < wg_iface->i_peers_count; ++i) {
+		peer = calloc(1, sizeof(*peer));
+		if (!peer)
+			goto out;
+
+		if (dev->first_peer == NULL)
+			dev->first_peer = peer;
+		else
+			dev->last_peer->next_peer = peer;
+		dev->last_peer = peer;
+
+		if (wg_peer->p_flags & WG_PEER_HAS_PUBLIC) {
+			memcpy(peer->public_key, wg_peer->p_public, sizeof(peer->public_key));
+			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
+		}
+
+		if (wg_peer->p_flags & WG_PEER_HAS_PSK) {
+			memcpy(peer->preshared_key, wg_peer->p_psk, sizeof(peer->preshared_key));
+			peer->flags |= WGPEER_HAS_PRESHARED_KEY;
+		}
+
+		if (wg_peer->p_flags & WG_PEER_HAS_PKA) {
+			peer->persistent_keepalive_interval = wg_peer->p_pka;
+			peer->flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
+		}
+
+		if (wg_peer->p_flags & WG_PEER_HAS_ENDPOINT && wg_peer->p_sa.sa_len <= sizeof(peer->endpoint.addr))
+			memcpy(&peer->endpoint.addr, &wg_peer->p_sa, wg_peer->p_sa.sa_len);
+
+		peer->rx_bytes = wg_peer->p_rxbytes;
+		peer->tx_bytes = wg_peer->p_txbytes;
+
+		peer->last_handshake_time.tv_sec = wg_peer->p_last_handshake.tv_sec;
+		peer->last_handshake_time.tv_nsec = wg_peer->p_last_handshake.tv_nsec;
+
+		wg_aip = &wg_peer->p_aips[0];
+		for (size_t j = 0; j < wg_peer->p_aips_count; ++j) {
+			aip = calloc(1, sizeof(*aip));
+			if (!aip)
+				goto out;
+
+			if (peer->first_allowedip == NULL)
+				peer->first_allowedip = aip;
+			else
+				peer->last_allowedip->next_allowedip = aip;
+			peer->last_allowedip = aip;
+
+			aip->family = wg_aip->a_af;
+			if (wg_aip->a_af == AF_INET) {
+				memcpy(&aip->ip4, &wg_aip->a_ipv4, sizeof(aip->ip4));
+				aip->cidr = wg_aip->a_cidr;
+			} else if (wg_aip->a_af == AF_INET6) {
+				memcpy(&aip->ip6, &wg_aip->a_ipv6, sizeof(aip->ip6));
+				aip->cidr = wg_aip->a_cidr;
+			}
+			++wg_aip;
+		}
+		wg_peer = (struct wg_peer_io *)wg_aip;
+	}
+	*device = dev;
+	errno = 0;
+out:
+	ret = -errno;
+	free(wgdata.wgd_interface);
+	return ret;
+}
+
+static int kernel_set_device(struct wgdevice *dev)
+{
+	struct wg_data_io wgdata = { .wgd_size = sizeof(struct wg_interface_io) };
+	struct wg_interface_io *wg_iface;
+	struct wg_peer_io *wg_peer;
+	struct wg_aip_io *wg_aip;
+	struct wgpeer *peer;
+	struct wgallowedip *aip;
+	int s = get_dgram_socket(), ret;
+	size_t peer_count, aip_count;
+
+	if (s < 0)
+		return -errno;
+
+	for_each_wgpeer(dev, peer) {
+		wgdata.wgd_size += sizeof(struct wg_peer_io);
+		for_each_wgallowedip(peer, aip)
+			wgdata.wgd_size += sizeof(struct wg_aip_io);
+	}
+	wg_iface = wgdata.wgd_interface = calloc(1, wgdata.wgd_size);
+	if (!wgdata.wgd_interface)
+		return -errno;
+	strlcpy(wgdata.wgd_name, dev->name, sizeof(wgdata.wgd_name));
+
+	if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY) {
+		memcpy(wg_iface->i_private, dev->private_key, sizeof(wg_iface->i_private));
+		wg_iface->i_flags |= WG_INTERFACE_HAS_PRIVATE;
+	}
+
+	if (dev->flags & WGDEVICE_HAS_LISTEN_PORT) {
+		wg_iface->i_port = dev->listen_port;
+		wg_iface->i_flags |= WG_INTERFACE_HAS_PORT;
+	}
+
+	if (dev->flags & WGDEVICE_HAS_FWMARK) {
+		wg_iface->i_rtable = dev->fwmark;
+		wg_iface->i_flags |= WG_INTERFACE_HAS_RTABLE;
+	}
+
+	if (dev->flags & WGDEVICE_REPLACE_PEERS)
+		wg_iface->i_flags |= WG_INTERFACE_REPLACE_PEERS;
+
+	peer_count = 0;
+	wg_peer = &wg_iface->i_peers[0];
+	for_each_wgpeer(dev, peer) {
+		wg_peer->p_flags = WG_PEER_HAS_PUBLIC;
+		memcpy(wg_peer->p_public, peer->public_key, sizeof(wg_peer->p_public));
+
+		if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
+			memcpy(wg_peer->p_psk, peer->preshared_key, sizeof(wg_peer->p_psk));
+			wg_peer->p_flags |= WG_PEER_HAS_PSK;
+		}
+
+		if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL) {
+			wg_peer->p_pka = peer->persistent_keepalive_interval;
+			wg_peer->p_flags |= WG_PEER_HAS_PKA;
+		}
+
+		if ((peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6) &&
+		    peer->endpoint.addr.sa_len <= sizeof(wg_peer->p_endpoint)) {
+			memcpy(&wg_peer->p_endpoint, &peer->endpoint.addr, peer->endpoint.addr.sa_len);
+			wg_peer->p_flags |= WG_PEER_HAS_ENDPOINT;
+		}
+
+		if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
+			wg_peer->p_flags |= WG_PEER_REPLACE_AIPS;
+
+		if (peer->flags & WGPEER_REMOVE_ME)
+			wg_peer->p_flags |= WG_PEER_REMOVE;
+
+		aip_count = 0;
+		wg_aip = &wg_peer->p_aips[0];
+		for_each_wgallowedip(peer, aip) {
+			wg_aip->a_af = aip->family;
+			wg_aip->a_cidr = aip->cidr;
+
+			if (aip->family == AF_INET) {
+				memcpy(&wg_aip->a_ipv4, &aip->ip4, sizeof(wg_aip->a_ipv4));
+			} else if (aip->family == AF_INET6) {
+				memcpy(&wg_aip->a_ipv6, &aip->ip6, sizeof(wg_aip->a_ipv6));
+			} else {
+				continue;
+			}
+			++aip_count;
+			++wg_aip;
+		}
+		wg_peer->p_aips_count = aip_count;
+		++peer_count;
+		wg_peer = (struct wg_peer_io *)wg_aip;
+	}
+	wg_iface->i_peers_count = peer_count;
+
+	if (ioctl(s, SIOCSWG, (caddr_t)&wgdata) < 0)
+		goto out;
+	errno = 0;
+
+out:
+	ret = -errno;
+	free(wgdata.wgd_interface);
+	return ret;
+}
diff --git a/src/ipc-uapi-unix.h b/src/ipc-uapi-unix.h
new file mode 100644
index 0000000..aaf60ca
--- /dev/null
+++ b/src/ipc-uapi-unix.h
@@ -0,0 +1,119 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+
+#define SOCK_PATH RUNSTATEDIR "/wireguard/"
+#define SOCK_SUFFIX ".sock"
+
+static FILE *userspace_interface_file(const char *iface)
+{
+	struct stat sbuf;
+	struct sockaddr_un addr = { .sun_family = AF_UNIX };
+	int fd = -1, ret;
+	FILE *f = NULL;
+
+	errno = EINVAL;
+	if (strchr(iface, '/'))
+		goto out;
+	ret = snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, iface);
+	if (ret < 0)
+		goto out;
+	ret = stat(addr.sun_path, &sbuf);
+	if (ret < 0)
+		goto out;
+	errno = EBADF;
+	if (!S_ISSOCK(sbuf.st_mode))
+		goto out;
+
+	ret = fd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (ret < 0)
+		goto out;
+
+	ret = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
+	if (ret < 0) {
+		if (errno == ECONNREFUSED) /* If the process is gone, we try to clean up the socket. */
+			unlink(addr.sun_path);
+		goto out;
+	}
+	f = fdopen(fd, "r+");
+	if (f)
+		errno = 0;
+out:
+	ret = -errno;
+	if (ret) {
+		if (fd >= 0)
+			close(fd);
+		errno = -ret;
+		return NULL;
+	}
+	return f;
+}
+
+static bool userspace_has_wireguard_interface(const char *iface)
+{
+	struct stat sbuf;
+	struct sockaddr_un addr = { .sun_family = AF_UNIX };
+	int fd, ret;
+
+	if (strchr(iface, '/'))
+		return false;
+	if (snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, iface) < 0)
+		return false;
+	if (stat(addr.sun_path, &sbuf) < 0)
+		return false;
+	if (!S_ISSOCK(sbuf.st_mode))
+		return false;
+	ret = fd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (ret < 0)
+		return false;
+	ret = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
+	if (ret < 0 && errno == ECONNREFUSED) { /* If the process is gone, we try to clean up the socket. */
+		close(fd);
+		unlink(addr.sun_path);
+		return false;
+	}
+	close(fd);
+	return true;
+}
+
+static int userspace_get_wireguard_interfaces(struct string_list *list)
+{
+	DIR *dir;
+	struct dirent *ent;
+	size_t len;
+	char *end;
+	int ret = 0;
+
+	dir = opendir(SOCK_PATH);
+	if (!dir)
+		return errno == ENOENT ? 0 : -errno;
+	while ((ent = readdir(dir))) {
+		len = strlen(ent->d_name);
+		if (len <= strlen(SOCK_SUFFIX))
+			continue;
+		end = &ent->d_name[len - strlen(SOCK_SUFFIX)];
+		if (strncmp(end, SOCK_SUFFIX, strlen(SOCK_SUFFIX)))
+			continue;
+		*end = '\0';
+		if (!userspace_has_wireguard_interface(ent->d_name))
+			continue;
+		ret = string_list_add(list, ent->d_name);
+		if (ret < 0)
+			goto out;
+	}
+out:
+	closedir(dir);
+	return ret;
+}
diff --git a/src/wincompat/ipc.c b/src/ipc-uapi-windows.h
similarity index 100%
rename from src/wincompat/ipc.c
rename to src/ipc-uapi-windows.h
diff --git a/src/ipc-uapi.h b/src/ipc-uapi.h
new file mode 100644
index 0000000..3b1fff3
--- /dev/null
+++ b/src/ipc-uapi.h
@@ -0,0 +1,272 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <arpa/inet.h>
+#include <ctype.h>
+#include <errno.h>
+#include <net/if.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include "containers.h"
+#include "curve25519.h"
+#include "encoding.h"
+
+#ifdef _WIN32
+#include "ipc-uapi-windows.h"
+#else
+#include "ipc-uapi-unix.h"
+#endif
+
+static int userspace_set_device(struct wgdevice *dev)
+{
+	char hex[WG_KEY_LEN_HEX], ip[INET6_ADDRSTRLEN], host[4096 + 1], service[512 + 1];
+	struct wgpeer *peer;
+	struct wgallowedip *allowedip;
+	FILE *f;
+	int ret;
+	socklen_t addr_len;
+
+	f = userspace_interface_file(dev->name);
+	if (!f)
+		return -errno;
+	fprintf(f, "set=1\n");
+
+	if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY) {
+		key_to_hex(hex, dev->private_key);
+		fprintf(f, "private_key=%s\n", hex);
+	}
+	if (dev->flags & WGDEVICE_HAS_LISTEN_PORT)
+		fprintf(f, "listen_port=%u\n", dev->listen_port);
+	if (dev->flags & WGDEVICE_HAS_FWMARK)
+		fprintf(f, "fwmark=%u\n", dev->fwmark);
+	if (dev->flags & WGDEVICE_REPLACE_PEERS)
+		fprintf(f, "replace_peers=true\n");
+
+	for_each_wgpeer(dev, peer) {
+		key_to_hex(hex, peer->public_key);
+		fprintf(f, "public_key=%s\n", hex);
+		if (peer->flags & WGPEER_REMOVE_ME) {
+			fprintf(f, "remove=true\n");
+			continue;
+		}
+		if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
+			key_to_hex(hex, peer->preshared_key);
+			fprintf(f, "preshared_key=%s\n", hex);
+		}
+		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6) {
+			addr_len = 0;
+			if (peer->endpoint.addr.sa_family == AF_INET)
+				addr_len = sizeof(struct sockaddr_in);
+			else if (peer->endpoint.addr.sa_family == AF_INET6)
+				addr_len = sizeof(struct sockaddr_in6);
+			if (!getnameinfo(&peer->endpoint.addr, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST)) {
+				if (peer->endpoint.addr.sa_family == AF_INET6 && strchr(host, ':'))
+					fprintf(f, "endpoint=[%s]:%s\n", host, service);
+				else
+					fprintf(f, "endpoint=%s:%s\n", host, service);
+			}
+		}
+		if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL)
+			fprintf(f, "persistent_keepalive_interval=%u\n", peer->persistent_keepalive_interval);
+		if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
+			fprintf(f, "replace_allowed_ips=true\n");
+		for_each_wgallowedip(peer, allowedip) {
+			if (allowedip->family == AF_INET) {
+				if (!inet_ntop(AF_INET, &allowedip->ip4, ip, INET6_ADDRSTRLEN))
+					continue;
+			} else if (allowedip->family == AF_INET6) {
+				if (!inet_ntop(AF_INET6, &allowedip->ip6, ip, INET6_ADDRSTRLEN))
+					continue;
+			} else
+				continue;
+			fprintf(f, "allowed_ip=%s/%d\n", ip, allowedip->cidr);
+		}
+	}
+	fprintf(f, "\n");
+	fflush(f);
+
+	if (fscanf(f, "errno=%d\n\n", &ret) != 1)
+		ret = errno ? -errno : -EPROTO;
+	fclose(f);
+	errno = -ret;
+	return ret;
+}
+
+#define NUM(max) ({ \
+	unsigned long long num; \
+	char *end; \
+	if (!isdigit(value[0])) \
+		break; \
+	num = strtoull(value, &end, 10); \
+	if (*end || num > max) \
+		break; \
+	num; \
+})
+
+static int userspace_get_device(struct wgdevice **out, const char *iface)
+{
+	struct wgdevice *dev;
+	struct wgpeer *peer = NULL;
+	struct wgallowedip *allowedip = NULL;
+	size_t line_buffer_len = 0, line_len;
+	char *key = NULL, *value;
+	FILE *f;
+	int ret = -EPROTO;
+
+	*out = dev = calloc(1, sizeof(*dev));
+	if (!dev)
+		return -errno;
+
+	f = userspace_interface_file(iface);
+	if (!f) {
+		ret = -errno;
+		free(dev);
+		*out = NULL;
+		return ret;
+	}
+
+	fprintf(f, "get=1\n\n");
+	fflush(f);
+
+	strncpy(dev->name, iface, IFNAMSIZ - 1);
+	dev->name[IFNAMSIZ - 1] = '\0';
+
+	while (getline(&key, &line_buffer_len, f) > 0) {
+		line_len = strlen(key);
+		if (line_len == 1 && key[0] == '\n')
+			goto err;
+		value = strchr(key, '=');
+		if (!value || line_len == 0 || key[line_len - 1] != '\n')
+			break;
+		*value++ = key[--line_len] = '\0';
+
+		if (!peer && !strcmp(key, "private_key")) {
+			if (!key_from_hex(dev->private_key, value))
+				break;
+			curve25519_generate_public(dev->public_key, dev->private_key);
+			dev->flags |= WGDEVICE_HAS_PRIVATE_KEY | WGDEVICE_HAS_PUBLIC_KEY;
+		} else if (!peer && !strcmp(key, "listen_port")) {
+			dev->listen_port = NUM(0xffffU);
+			dev->flags |= WGDEVICE_HAS_LISTEN_PORT;
+		} else if (!peer && !strcmp(key, "fwmark")) {
+			dev->fwmark = NUM(0xffffffffU);
+			dev->flags |= WGDEVICE_HAS_FWMARK;
+		} else if (!strcmp(key, "public_key")) {
+			struct wgpeer *new_peer = calloc(1, sizeof(*new_peer));
+
+			if (!new_peer) {
+				ret = -ENOMEM;
+				goto err;
+			}
+			allowedip = NULL;
+			if (peer)
+				peer->next_peer = new_peer;
+			else
+				dev->first_peer = new_peer;
+			peer = new_peer;
+			if (!key_from_hex(peer->public_key, value))
+				break;
+			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
+		} else if (peer && !strcmp(key, "preshared_key")) {
+			if (!key_from_hex(peer->preshared_key, value))
+				break;
+			if (!key_is_zero(peer->preshared_key))
+				peer->flags |= WGPEER_HAS_PRESHARED_KEY;
+		} else if (peer && !strcmp(key, "endpoint")) {
+			char *begin, *end;
+			struct addrinfo *resolved;
+			struct addrinfo hints = {
+				.ai_family = AF_UNSPEC,
+				.ai_socktype = SOCK_DGRAM,
+				.ai_protocol = IPPROTO_UDP
+			};
+			if (!strlen(value))
+				break;
+			if (value[0] == '[') {
+				begin = &value[1];
+				end = strchr(value, ']');
+				if (!end)
+					break;
+				*end++ = '\0';
+				if (*end++ != ':' || !*end)
+					break;
+			} else {
+				begin = value;
+				end = strrchr(value, ':');
+				if (!end || !*(end + 1))
+					break;
+				*end++ = '\0';
+			}
+			if (getaddrinfo(begin, end, &hints, &resolved) != 0) {
+				ret = ENETUNREACH;
+				goto err;
+			}
+			if ((resolved->ai_family == AF_INET && resolved->ai_addrlen == sizeof(struct sockaddr_in)) ||
+			    (resolved->ai_family == AF_INET6 && resolved->ai_addrlen == sizeof(struct sockaddr_in6)))
+				memcpy(&peer->endpoint.addr, resolved->ai_addr, resolved->ai_addrlen);
+			else  {
+				freeaddrinfo(resolved);
+				break;
+			}
+			freeaddrinfo(resolved);
+		} else if (peer && !strcmp(key, "persistent_keepalive_interval")) {
+			peer->persistent_keepalive_interval = NUM(0xffffU);
+			peer->flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
+		} else if (peer && !strcmp(key, "allowed_ip")) {
+			struct wgallowedip *new_allowedip;
+			char *end, *mask = value, *ip = strsep(&mask, "/");
+
+			if (!mask || !isdigit(mask[0]))
+				break;
+			new_allowedip = calloc(1, sizeof(*new_allowedip));
+			if (!new_allowedip) {
+				ret = -ENOMEM;
+				goto err;
+			}
+			if (allowedip)
+				allowedip->next_allowedip = new_allowedip;
+			else
+				peer->first_allowedip = new_allowedip;
+			allowedip = new_allowedip;
+			allowedip->family = AF_UNSPEC;
+			if (strchr(ip, ':')) {
+				if (inet_pton(AF_INET6, ip, &allowedip->ip6) == 1)
+					allowedip->family = AF_INET6;
+			} else {
+				if (inet_pton(AF_INET, ip, &allowedip->ip4) == 1)
+					allowedip->family = AF_INET;
+			}
+			allowedip->cidr = strtoul(mask, &end, 10);
+			if (*end || allowedip->family == AF_UNSPEC || (allowedip->family == AF_INET6 && allowedip->cidr > 128) || (allowedip->family == AF_INET && allowedip->cidr > 32))
+				break;
+		} else if (peer && !strcmp(key, "last_handshake_time_sec"))
+			peer->last_handshake_time.tv_sec = NUM(0x7fffffffffffffffULL);
+		else if (peer && !strcmp(key, "last_handshake_time_nsec"))
+			peer->last_handshake_time.tv_nsec = NUM(0x7fffffffffffffffULL);
+		else if (peer && !strcmp(key, "rx_bytes"))
+			peer->rx_bytes = NUM(0xffffffffffffffffULL);
+		else if (peer && !strcmp(key, "tx_bytes"))
+			peer->tx_bytes = NUM(0xffffffffffffffffULL);
+		else if (!strcmp(key, "errno"))
+			ret = -NUM(0x7fffffffU);
+	}
+	ret = -EPROTO;
+err:
+	free(key);
+	if (ret) {
+		free_wgdevice(dev);
+		*out = NULL;
+	}
+	fclose(f);
+	errno = -ret;
+	return ret;
+
+}
+#undef NUM
diff --git a/src/ipc.c b/src/ipc.c
index 75a95b3..b4928e3 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -3,50 +3,10 @@
  * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
-#ifdef __linux__
-#include <linux/if_link.h>
-#include <linux/rtnetlink.h>
-#include <linux/wireguard.h>
-#include "netlink.h"
-#endif
-#ifdef __OpenBSD__
-#include <net/if_wg.h>
-#endif
-#include <netinet/in.h>
-#include <sys/socket.h>
-#include <net/if.h>
-#include <errno.h>
-#include <stdbool.h>
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
-#include <ctype.h>
-#include <unistd.h>
-#include <time.h>
-#include <dirent.h>
-#include <signal.h>
-#include <netdb.h>
-#include <limits.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/un.h>
-#include <arpa/inet.h>
-
-#include "ipc.h"
+#include <stdlib.h>
+#include <errno.h>
 #include "containers.h"
-#include "encoding.h"
-#include "curve25519.h"
-
-#define SOCK_PATH RUNSTATEDIR "/wireguard/"
-#define SOCK_SUFFIX ".sock"
-#ifdef __linux__
-#define SOCKET_BUFFER_SIZE (mnl_ideal_socket_buffer_size())
-#else
-#define SOCKET_BUFFER_SIZE 8192
-#endif
 
 struct string_list {
 	char *buffer;
@@ -79,1113 +39,11 @@ static int string_list_add(struct string_list *list, const char *str)
 	return 0;
 }
 
-#ifndef WINCOMPAT
-static FILE *userspace_interface_file(const char *iface)
-{
-	struct stat sbuf;
-	struct sockaddr_un addr = { .sun_family = AF_UNIX };
-	int fd = -1, ret;
-	FILE *f = NULL;
-
-	errno = EINVAL;
-	if (strchr(iface, '/'))
-		goto out;
-	ret = snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, iface);
-	if (ret < 0)
-		goto out;
-	ret = stat(addr.sun_path, &sbuf);
-	if (ret < 0)
-		goto out;
-	errno = EBADF;
-	if (!S_ISSOCK(sbuf.st_mode))
-		goto out;
-
-	ret = fd = socket(AF_UNIX, SOCK_STREAM, 0);
-	if (ret < 0)
-		goto out;
-
-	ret = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
-	if (ret < 0) {
-		if (errno == ECONNREFUSED) /* If the process is gone, we try to clean up the socket. */
-			unlink(addr.sun_path);
-		goto out;
-	}
-	f = fdopen(fd, "r+");
-	if (f)
-		errno = 0;
-out:
-	ret = -errno;
-	if (ret) {
-		if (fd >= 0)
-			close(fd);
-		errno = -ret;
-		return NULL;
-	}
-	return f;
-}
-
-static bool userspace_has_wireguard_interface(const char *iface)
-{
-	struct stat sbuf;
-	struct sockaddr_un addr = { .sun_family = AF_UNIX };
-	int fd, ret;
-
-	if (strchr(iface, '/'))
-		return false;
-	if (snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, iface) < 0)
-		return false;
-	if (stat(addr.sun_path, &sbuf) < 0)
-		return false;
-	if (!S_ISSOCK(sbuf.st_mode))
-		return false;
-	ret = fd = socket(AF_UNIX, SOCK_STREAM, 0);
-	if (ret < 0)
-		return false;
-	ret = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
-	if (ret < 0 && errno == ECONNREFUSED) { /* If the process is gone, we try to clean up the socket. */
-		close(fd);
-		unlink(addr.sun_path);
-		return false;
-	}
-	close(fd);
-	return true;
-}
-
-static int userspace_get_wireguard_interfaces(struct string_list *list)
-{
-	DIR *dir;
-	struct dirent *ent;
-	size_t len;
-	char *end;
-	int ret = 0;
-
-	dir = opendir(SOCK_PATH);
-	if (!dir)
-		return errno == ENOENT ? 0 : -errno;
-	while ((ent = readdir(dir))) {
-		len = strlen(ent->d_name);
-		if (len <= strlen(SOCK_SUFFIX))
-			continue;
-		end = &ent->d_name[len - strlen(SOCK_SUFFIX)];
-		if (strncmp(end, SOCK_SUFFIX, strlen(SOCK_SUFFIX)))
-			continue;
-		*end = '\0';
-		if (!userspace_has_wireguard_interface(ent->d_name))
-			continue;
-		ret = string_list_add(list, ent->d_name);
-		if (ret < 0)
-			goto out;
-	}
-out:
-	closedir(dir);
-	return ret;
-}
-#else
-#include "wincompat/ipc.c"
-#endif
-
-static int userspace_set_device(struct wgdevice *dev)
-{
-	char hex[WG_KEY_LEN_HEX], ip[INET6_ADDRSTRLEN], host[4096 + 1], service[512 + 1];
-	struct wgpeer *peer;
-	struct wgallowedip *allowedip;
-	FILE *f;
-	int ret;
-	socklen_t addr_len;
-
-	f = userspace_interface_file(dev->name);
-	if (!f)
-		return -errno;
-	fprintf(f, "set=1\n");
-
-	if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY) {
-		key_to_hex(hex, dev->private_key);
-		fprintf(f, "private_key=%s\n", hex);
-	}
-	if (dev->flags & WGDEVICE_HAS_LISTEN_PORT)
-		fprintf(f, "listen_port=%u\n", dev->listen_port);
-	if (dev->flags & WGDEVICE_HAS_FWMARK)
-		fprintf(f, "fwmark=%u\n", dev->fwmark);
-	if (dev->flags & WGDEVICE_REPLACE_PEERS)
-		fprintf(f, "replace_peers=true\n");
-
-	for_each_wgpeer(dev, peer) {
-		key_to_hex(hex, peer->public_key);
-		fprintf(f, "public_key=%s\n", hex);
-		if (peer->flags & WGPEER_REMOVE_ME) {
-			fprintf(f, "remove=true\n");
-			continue;
-		}
-		if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
-			key_to_hex(hex, peer->preshared_key);
-			fprintf(f, "preshared_key=%s\n", hex);
-		}
-		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6) {
-			addr_len = 0;
-			if (peer->endpoint.addr.sa_family == AF_INET)
-				addr_len = sizeof(struct sockaddr_in);
-			else if (peer->endpoint.addr.sa_family == AF_INET6)
-				addr_len = sizeof(struct sockaddr_in6);
-			if (!getnameinfo(&peer->endpoint.addr, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST)) {
-				if (peer->endpoint.addr.sa_family == AF_INET6 && strchr(host, ':'))
-					fprintf(f, "endpoint=[%s]:%s\n", host, service);
-				else
-					fprintf(f, "endpoint=%s:%s\n", host, service);
-			}
-		}
-		if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL)
-			fprintf(f, "persistent_keepalive_interval=%u\n", peer->persistent_keepalive_interval);
-		if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
-			fprintf(f, "replace_allowed_ips=true\n");
-		for_each_wgallowedip(peer, allowedip) {
-			if (allowedip->family == AF_INET) {
-				if (!inet_ntop(AF_INET, &allowedip->ip4, ip, INET6_ADDRSTRLEN))
-					continue;
-			} else if (allowedip->family == AF_INET6) {
-				if (!inet_ntop(AF_INET6, &allowedip->ip6, ip, INET6_ADDRSTRLEN))
-					continue;
-			} else
-				continue;
-			fprintf(f, "allowed_ip=%s/%d\n", ip, allowedip->cidr);
-		}
-	}
-	fprintf(f, "\n");
-	fflush(f);
-
-	if (fscanf(f, "errno=%d\n\n", &ret) != 1)
-		ret = errno ? -errno : -EPROTO;
-	fclose(f);
-	errno = -ret;
-	return ret;
-}
-
-#define NUM(max) ({ \
-	unsigned long long num; \
-	char *end; \
-	if (!isdigit(value[0])) \
-		break; \
-	num = strtoull(value, &end, 10); \
-	if (*end || num > max) \
-		break; \
-	num; \
-})
-
-static int userspace_get_device(struct wgdevice **out, const char *iface)
-{
-	struct wgdevice *dev;
-	struct wgpeer *peer = NULL;
-	struct wgallowedip *allowedip = NULL;
-	size_t line_buffer_len = 0, line_len;
-	char *key = NULL, *value;
-	FILE *f;
-	int ret = -EPROTO;
-
-	*out = dev = calloc(1, sizeof(*dev));
-	if (!dev)
-		return -errno;
-
-	f = userspace_interface_file(iface);
-	if (!f) {
-		ret = -errno;
-		free(dev);
-		*out = NULL;
-		return ret;
-	}
-
-	fprintf(f, "get=1\n\n");
-	fflush(f);
-
-	strncpy(dev->name, iface, IFNAMSIZ - 1);
-	dev->name[IFNAMSIZ - 1] = '\0';
-
-	while (getline(&key, &line_buffer_len, f) > 0) {
-		line_len = strlen(key);
-		if (line_len == 1 && key[0] == '\n')
-			goto err;
-		value = strchr(key, '=');
-		if (!value || line_len == 0 || key[line_len - 1] != '\n')
-			break;
-		*value++ = key[--line_len] = '\0';
-
-		if (!peer && !strcmp(key, "private_key")) {
-			if (!key_from_hex(dev->private_key, value))
-				break;
-			curve25519_generate_public(dev->public_key, dev->private_key);
-			dev->flags |= WGDEVICE_HAS_PRIVATE_KEY | WGDEVICE_HAS_PUBLIC_KEY;
-		} else if (!peer && !strcmp(key, "listen_port")) {
-			dev->listen_port = NUM(0xffffU);
-			dev->flags |= WGDEVICE_HAS_LISTEN_PORT;
-		} else if (!peer && !strcmp(key, "fwmark")) {
-			dev->fwmark = NUM(0xffffffffU);
-			dev->flags |= WGDEVICE_HAS_FWMARK;
-		} else if (!strcmp(key, "public_key")) {
-			struct wgpeer *new_peer = calloc(1, sizeof(*new_peer));
-
-			if (!new_peer) {
-				ret = -ENOMEM;
-				goto err;
-			}
-			allowedip = NULL;
-			if (peer)
-				peer->next_peer = new_peer;
-			else
-				dev->first_peer = new_peer;
-			peer = new_peer;
-			if (!key_from_hex(peer->public_key, value))
-				break;
-			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
-		} else if (peer && !strcmp(key, "preshared_key")) {
-			if (!key_from_hex(peer->preshared_key, value))
-				break;
-			if (!key_is_zero(peer->preshared_key))
-				peer->flags |= WGPEER_HAS_PRESHARED_KEY;
-		} else if (peer && !strcmp(key, "endpoint")) {
-			char *begin, *end;
-			struct addrinfo *resolved;
-			struct addrinfo hints = {
-				.ai_family = AF_UNSPEC,
-				.ai_socktype = SOCK_DGRAM,
-				.ai_protocol = IPPROTO_UDP
-			};
-			if (!strlen(value))
-				break;
-			if (value[0] == '[') {
-				begin = &value[1];
-				end = strchr(value, ']');
-				if (!end)
-					break;
-				*end++ = '\0';
-				if (*end++ != ':' || !*end)
-					break;
-			} else {
-				begin = value;
-				end = strrchr(value, ':');
-				if (!end || !*(end + 1))
-					break;
-				*end++ = '\0';
-			}
-			if (getaddrinfo(begin, end, &hints, &resolved) != 0) {
-				ret = ENETUNREACH;
-				goto err;
-			}
-			if ((resolved->ai_family == AF_INET && resolved->ai_addrlen == sizeof(struct sockaddr_in)) ||
-			    (resolved->ai_family == AF_INET6 && resolved->ai_addrlen == sizeof(struct sockaddr_in6)))
-				memcpy(&peer->endpoint.addr, resolved->ai_addr, resolved->ai_addrlen);
-			else  {
-				freeaddrinfo(resolved);
-				break;
-			}
-			freeaddrinfo(resolved);
-		} else if (peer && !strcmp(key, "persistent_keepalive_interval")) {
-			peer->persistent_keepalive_interval = NUM(0xffffU);
-			peer->flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
-		} else if (peer && !strcmp(key, "allowed_ip")) {
-			struct wgallowedip *new_allowedip;
-			char *end, *mask = value, *ip = strsep(&mask, "/");
-
-			if (!mask || !isdigit(mask[0]))
-				break;
-			new_allowedip = calloc(1, sizeof(*new_allowedip));
-			if (!new_allowedip) {
-				ret = -ENOMEM;
-				goto err;
-			}
-			if (allowedip)
-				allowedip->next_allowedip = new_allowedip;
-			else
-				peer->first_allowedip = new_allowedip;
-			allowedip = new_allowedip;
-			allowedip->family = AF_UNSPEC;
-			if (strchr(ip, ':')) {
-				if (inet_pton(AF_INET6, ip, &allowedip->ip6) == 1)
-					allowedip->family = AF_INET6;
-			} else {
-				if (inet_pton(AF_INET, ip, &allowedip->ip4) == 1)
-					allowedip->family = AF_INET;
-			}
-			allowedip->cidr = strtoul(mask, &end, 10);
-			if (*end || allowedip->family == AF_UNSPEC || (allowedip->family == AF_INET6 && allowedip->cidr > 128) || (allowedip->family == AF_INET && allowedip->cidr > 32))
-				break;
-		} else if (peer && !strcmp(key, "last_handshake_time_sec"))
-			peer->last_handshake_time.tv_sec = NUM(0x7fffffffffffffffULL);
-		else if (peer && !strcmp(key, "last_handshake_time_nsec"))
-			peer->last_handshake_time.tv_nsec = NUM(0x7fffffffffffffffULL);
-		else if (peer && !strcmp(key, "rx_bytes"))
-			peer->rx_bytes = NUM(0xffffffffffffffffULL);
-		else if (peer && !strcmp(key, "tx_bytes"))
-			peer->tx_bytes = NUM(0xffffffffffffffffULL);
-		else if (!strcmp(key, "errno"))
-			ret = -NUM(0x7fffffffU);
-	}
-	ret = -EPROTO;
-err:
-	free(key);
-	if (ret) {
-		free_wgdevice(dev);
-		*out = NULL;
-	}
-	fclose(f);
-	errno = -ret;
-	return ret;
-
-}
-#undef NUM
-
-#ifdef __linux__
-
-struct interface {
-	const char *name;
-	bool is_wireguard;
-};
-
-static int parse_linkinfo(const struct nlattr *attr, void *data)
-{
-	struct interface *interface = data;
-
-	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp(WG_GENL_NAME, mnl_attr_get_str(attr)))
-		interface->is_wireguard = true;
-	return MNL_CB_OK;
-}
-
-static int parse_infomsg(const struct nlattr *attr, void *data)
-{
-	struct interface *interface = data;
-
-	if (mnl_attr_get_type(attr) == IFLA_LINKINFO)
-		return mnl_attr_parse_nested(attr, parse_linkinfo, data);
-	else if (mnl_attr_get_type(attr) == IFLA_IFNAME)
-		interface->name = mnl_attr_get_str(attr);
-	return MNL_CB_OK;
-}
-
-static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
-{
-	struct string_list *list = data;
-	struct interface interface = { 0 };
-	int ret;
-
-	ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, &interface);
-	if (ret != MNL_CB_OK)
-		return ret;
-	if (interface.name && interface.is_wireguard)
-		ret = string_list_add(list, interface.name);
-	if (ret < 0)
-		return ret;
-	if (nlh->nlmsg_type != NLMSG_DONE)
-		return MNL_CB_OK + 1;
-	return MNL_CB_OK;
-}
-
-static int kernel_get_wireguard_interfaces(struct string_list *list)
-{
-	struct mnl_socket *nl = NULL;
-	char *rtnl_buffer = NULL;
-	size_t message_len;
-	unsigned int portid, seq;
-	ssize_t len;
-	int ret = 0;
-	struct nlmsghdr *nlh;
-	struct ifinfomsg *ifm;
-
-	ret = -ENOMEM;
-	rtnl_buffer = calloc(SOCKET_BUFFER_SIZE, 1);
-	if (!rtnl_buffer)
-		goto cleanup;
-
-	nl = mnl_socket_open(NETLINK_ROUTE);
-	if (!nl) {
-		ret = -errno;
-		goto cleanup;
-	}
-
-	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
-		ret = -errno;
-		goto cleanup;
-	}
-
-	seq = time(NULL);
-	portid = mnl_socket_get_portid(nl);
-	nlh = mnl_nlmsg_put_header(rtnl_buffer);
-	nlh->nlmsg_type = RTM_GETLINK;
-	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP;
-	nlh->nlmsg_seq = seq;
-	ifm = mnl_nlmsg_put_extra_header(nlh, sizeof(*ifm));
-	ifm->ifi_family = AF_UNSPEC;
-	message_len = nlh->nlmsg_len;
-
-	if (mnl_socket_sendto(nl, rtnl_buffer, message_len) < 0) {
-		ret = -errno;
-		goto cleanup;
-	}
-
-another:
-	if ((len = mnl_socket_recvfrom(nl, rtnl_buffer, SOCKET_BUFFER_SIZE)) < 0) {
-		ret = -errno;
-		goto cleanup;
-	}
-	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, list)) < 0) {
-		/* Netlink returns NLM_F_DUMP_INTR if the set of all tunnels changed
-		 * during the dump. That's unfortunate, but is pretty common on busy
-		 * systems that are adding and removing tunnels all the time. Rather
-		 * than retrying, potentially indefinitely, we just work with the
-		 * partial results. */
-		if (errno != EINTR) {
-			ret = -errno;
-			goto cleanup;
-		}
-	}
-	if (len == MNL_CB_OK + 1)
-		goto another;
-	ret = 0;
-
-cleanup:
-	free(rtnl_buffer);
-	if (nl)
-		mnl_socket_close(nl);
-	return ret;
-}
-
-static int kernel_set_device(struct wgdevice *dev)
-{
-	int ret = 0;
-	struct wgpeer *peer = NULL;
-	struct wgallowedip *allowedip = NULL;
-	struct nlattr *peers_nest, *peer_nest, *allowedips_nest, *allowedip_nest;
-	struct nlmsghdr *nlh;
-	struct mnlg_socket *nlg;
-
-	nlg = mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
-	if (!nlg)
-		return -errno;
-
-again:
-	nlh = mnlg_msg_prepare(nlg, WG_CMD_SET_DEVICE, NLM_F_REQUEST | NLM_F_ACK);
-	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, dev->name);
-
-	if (!peer) {
-		uint32_t flags = 0;
-
-		if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY)
-			mnl_attr_put(nlh, WGDEVICE_A_PRIVATE_KEY, sizeof(dev->private_key), dev->private_key);
-		if (dev->flags & WGDEVICE_HAS_LISTEN_PORT)
-			mnl_attr_put_u16(nlh, WGDEVICE_A_LISTEN_PORT, dev->listen_port);
-		if (dev->flags & WGDEVICE_HAS_FWMARK)
-			mnl_attr_put_u32(nlh, WGDEVICE_A_FWMARK, dev->fwmark);
-		if (dev->flags & WGDEVICE_REPLACE_PEERS)
-			flags |= WGDEVICE_F_REPLACE_PEERS;
-		if (flags)
-			mnl_attr_put_u32(nlh, WGDEVICE_A_FLAGS, flags);
-	}
-	if (!dev->first_peer)
-		goto send;
-	peers_nest = peer_nest = allowedips_nest = allowedip_nest = NULL;
-	peers_nest = mnl_attr_nest_start(nlh, WGDEVICE_A_PEERS);
-	for (peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
-		uint32_t flags = 0;
-
-		peer_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, 0);
-		if (!peer_nest)
-			goto toobig_peers;
-		if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PUBLIC_KEY, sizeof(peer->public_key), peer->public_key))
-			goto toobig_peers;
-		if (peer->flags & WGPEER_REMOVE_ME)
-			flags |= WGPEER_F_REMOVE_ME;
-		if (!allowedip) {
-			if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
-				flags |= WGPEER_F_REPLACE_ALLOWEDIPS;
-			if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
-				if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PRESHARED_KEY, sizeof(peer->preshared_key), peer->preshared_key))
-					goto toobig_peers;
-			}
-			if (peer->endpoint.addr.sa_family == AF_INET) {
-				if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr4), &peer->endpoint.addr4))
-					goto toobig_peers;
-			} else if (peer->endpoint.addr.sa_family == AF_INET6) {
-				if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr6), &peer->endpoint.addr6))
-					goto toobig_peers;
-			}
-			if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL) {
-				if (!mnl_attr_put_u16_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL, peer->persistent_keepalive_interval))
-					goto toobig_peers;
-			}
-		}
-		if (flags) {
-			if (!mnl_attr_put_u32_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_FLAGS, flags))
-				goto toobig_peers;
-		}
-		if (peer->first_allowedip) {
-			if (!allowedip)
-				allowedip = peer->first_allowedip;
-			allowedips_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ALLOWEDIPS);
-			if (!allowedips_nest)
-				goto toobig_allowedips;
-			for (; allowedip; allowedip = allowedip->next_allowedip) {
-				allowedip_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, 0);
-				if (!allowedip_nest)
-					goto toobig_allowedips;
-				if (!mnl_attr_put_u16_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_FAMILY, allowedip->family))
-					goto toobig_allowedips;
-				if (allowedip->family == AF_INET) {
-					if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip4), &allowedip->ip4))
-						goto toobig_allowedips;
-				} else if (allowedip->family == AF_INET6) {
-					if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip6), &allowedip->ip6))
-						goto toobig_allowedips;
-				}
-				if (!mnl_attr_put_u8_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_CIDR_MASK, allowedip->cidr))
-					goto toobig_allowedips;
-				mnl_attr_nest_end(nlh, allowedip_nest);
-				allowedip_nest = NULL;
-			}
-			mnl_attr_nest_end(nlh, allowedips_nest);
-			allowedips_nest = NULL;
-		}
-
-		mnl_attr_nest_end(nlh, peer_nest);
-		peer_nest = NULL;
-	}
-	mnl_attr_nest_end(nlh, peers_nest);
-	peers_nest = NULL;
-	goto send;
-toobig_allowedips:
-	if (allowedip_nest)
-		mnl_attr_nest_cancel(nlh, allowedip_nest);
-	if (allowedips_nest)
-		mnl_attr_nest_end(nlh, allowedips_nest);
-	mnl_attr_nest_end(nlh, peer_nest);
-	mnl_attr_nest_end(nlh, peers_nest);
-	goto send;
-toobig_peers:
-	if (peer_nest)
-		mnl_attr_nest_cancel(nlh, peer_nest);
-	mnl_attr_nest_end(nlh, peers_nest);
-	goto send;
-send:
-	if (mnlg_socket_send(nlg, nlh) < 0) {
-		ret = -errno;
-		goto out;
-	}
-	errno = 0;
-	if (mnlg_socket_recv_run(nlg, NULL, NULL) < 0) {
-		ret = errno ? -errno : -EINVAL;
-		goto out;
-	}
-	if (peer)
-		goto again;
-
-out:
-	mnlg_socket_close(nlg);
-	errno = -ret;
-	return ret;
-}
-
-static int parse_allowedip(const struct nlattr *attr, void *data)
-{
-	struct wgallowedip *allowedip = data;
-
-	switch (mnl_attr_get_type(attr)) {
-	case WGALLOWEDIP_A_UNSPEC:
-		break;
-	case WGALLOWEDIP_A_FAMILY:
-		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
-			allowedip->family = mnl_attr_get_u16(attr);
-		break;
-	case WGALLOWEDIP_A_IPADDR:
-		if (mnl_attr_get_payload_len(attr) == sizeof(allowedip->ip4))
-			memcpy(&allowedip->ip4, mnl_attr_get_payload(attr), sizeof(allowedip->ip4));
-		else if (mnl_attr_get_payload_len(attr) == sizeof(allowedip->ip6))
-			memcpy(&allowedip->ip6, mnl_attr_get_payload(attr), sizeof(allowedip->ip6));
-		break;
-	case WGALLOWEDIP_A_CIDR_MASK:
-		if (!mnl_attr_validate(attr, MNL_TYPE_U8))
-			allowedip->cidr = mnl_attr_get_u8(attr);
-		break;
-	}
-
-	return MNL_CB_OK;
-}
-
-static int parse_allowedips(const struct nlattr *attr, void *data)
-{
-	struct wgpeer *peer = data;
-	struct wgallowedip *new_allowedip = calloc(1, sizeof(*new_allowedip));
-	int ret;
-
-	if (!new_allowedip) {
-		perror("calloc");
-		return MNL_CB_ERROR;
-	}
-	if (!peer->first_allowedip)
-		peer->first_allowedip = peer->last_allowedip = new_allowedip;
-	else {
-		peer->last_allowedip->next_allowedip = new_allowedip;
-		peer->last_allowedip = new_allowedip;
-	}
-	ret = mnl_attr_parse_nested(attr, parse_allowedip, new_allowedip);
-	if (!ret)
-		return ret;
-	if (!((new_allowedip->family == AF_INET && new_allowedip->cidr <= 32) || (new_allowedip->family == AF_INET6 && new_allowedip->cidr <= 128)))
-		return MNL_CB_ERROR;
-	return MNL_CB_OK;
-}
-
-static int parse_peer(const struct nlattr *attr, void *data)
-{
-	struct wgpeer *peer = data;
-
-	switch (mnl_attr_get_type(attr)) {
-	case WGPEER_A_UNSPEC:
-		break;
-	case WGPEER_A_PUBLIC_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(peer->public_key)) {
-			memcpy(peer->public_key, mnl_attr_get_payload(attr), sizeof(peer->public_key));
-			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
-		}
-		break;
-	case WGPEER_A_PRESHARED_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(peer->preshared_key)) {
-			memcpy(peer->preshared_key, mnl_attr_get_payload(attr), sizeof(peer->preshared_key));
-			if (!key_is_zero(peer->preshared_key))
-				peer->flags |= WGPEER_HAS_PRESHARED_KEY;
-		}
-		break;
-	case WGPEER_A_ENDPOINT: {
-		struct sockaddr *addr;
-
-		if (mnl_attr_get_payload_len(attr) < sizeof(*addr))
-			break;
-		addr = mnl_attr_get_payload(attr);
-		if (addr->sa_family == AF_INET && mnl_attr_get_payload_len(attr) == sizeof(peer->endpoint.addr4))
-			memcpy(&peer->endpoint.addr4, addr, sizeof(peer->endpoint.addr4));
-		else if (addr->sa_family == AF_INET6 && mnl_attr_get_payload_len(attr) == sizeof(peer->endpoint.addr6))
-			memcpy(&peer->endpoint.addr6, addr, sizeof(peer->endpoint.addr6));
-		break;
-	}
-	case WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL:
-		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
-			peer->persistent_keepalive_interval = mnl_attr_get_u16(attr);
-		break;
-	case WGPEER_A_LAST_HANDSHAKE_TIME:
-		if (mnl_attr_get_payload_len(attr) == sizeof(peer->last_handshake_time))
-			memcpy(&peer->last_handshake_time, mnl_attr_get_payload(attr), sizeof(peer->last_handshake_time));
-		break;
-	case WGPEER_A_RX_BYTES:
-		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
-			peer->rx_bytes = mnl_attr_get_u64(attr);
-		break;
-	case WGPEER_A_TX_BYTES:
-		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
-			peer->tx_bytes = mnl_attr_get_u64(attr);
-		break;
-	case WGPEER_A_ALLOWEDIPS:
-		return mnl_attr_parse_nested(attr, parse_allowedips, peer);
-	}
-
-	return MNL_CB_OK;
-}
-
-static int parse_peers(const struct nlattr *attr, void *data)
-{
-	struct wgdevice *device = data;
-	struct wgpeer *new_peer = calloc(1, sizeof(*new_peer));
-	int ret;
-
-	if (!new_peer) {
-		perror("calloc");
-		return MNL_CB_ERROR;
-	}
-	if (!device->first_peer)
-		device->first_peer = device->last_peer = new_peer;
-	else {
-		device->last_peer->next_peer = new_peer;
-		device->last_peer = new_peer;
-	}
-	ret = mnl_attr_parse_nested(attr, parse_peer, new_peer);
-	if (!ret)
-		return ret;
-	if (!(new_peer->flags & WGPEER_HAS_PUBLIC_KEY))
-		return MNL_CB_ERROR;
-	return MNL_CB_OK;
-}
-
-static int parse_device(const struct nlattr *attr, void *data)
-{
-	struct wgdevice *device = data;
-
-	switch (mnl_attr_get_type(attr)) {
-	case WGDEVICE_A_UNSPEC:
-		break;
-	case WGDEVICE_A_IFINDEX:
-		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
-			device->ifindex = mnl_attr_get_u32(attr);
-		break;
-	case WGDEVICE_A_IFNAME:
-		if (!mnl_attr_validate(attr, MNL_TYPE_STRING)) {
-			strncpy(device->name, mnl_attr_get_str(attr), sizeof(device->name) - 1);
-			device->name[sizeof(device->name) - 1] = '\0';
-		}
-		break;
-	case WGDEVICE_A_PRIVATE_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(device->private_key)) {
-			memcpy(device->private_key, mnl_attr_get_payload(attr), sizeof(device->private_key));
-			device->flags |= WGDEVICE_HAS_PRIVATE_KEY;
-		}
-		break;
-	case WGDEVICE_A_PUBLIC_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(device->public_key)) {
-			memcpy(device->public_key, mnl_attr_get_payload(attr), sizeof(device->public_key));
-			device->flags |= WGDEVICE_HAS_PUBLIC_KEY;
-		}
-		break;
-	case WGDEVICE_A_LISTEN_PORT:
-		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
-			device->listen_port = mnl_attr_get_u16(attr);
-		break;
-	case WGDEVICE_A_FWMARK:
-		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
-			device->fwmark = mnl_attr_get_u32(attr);
-		break;
-	case WGDEVICE_A_PEERS:
-		return mnl_attr_parse_nested(attr, parse_peers, device);
-	}
-
-	return MNL_CB_OK;
-}
-
-static int read_device_cb(const struct nlmsghdr *nlh, void *data)
-{
-	return mnl_attr_parse(nlh, sizeof(struct genlmsghdr), parse_device, data);
-}
-
-static void coalesce_peers(struct wgdevice *device)
-{
-	struct wgpeer *old_next_peer, *peer = device->first_peer;
-
-	while (peer && peer->next_peer) {
-		if (memcmp(peer->public_key, peer->next_peer->public_key, sizeof(peer->public_key))) {
-			peer = peer->next_peer;
-			continue;
-		}
-		if (!peer->first_allowedip) {
-			peer->first_allowedip = peer->next_peer->first_allowedip;
-			peer->last_allowedip = peer->next_peer->last_allowedip;
-		} else {
-			peer->last_allowedip->next_allowedip = peer->next_peer->first_allowedip;
-			peer->last_allowedip = peer->next_peer->last_allowedip;
-		}
-		old_next_peer = peer->next_peer;
-		peer->next_peer = old_next_peer->next_peer;
-		free(old_next_peer);
-	}
-}
-
-static int kernel_get_device(struct wgdevice **device, const char *iface)
-{
-	int ret;
-	struct nlmsghdr *nlh;
-	struct mnlg_socket *nlg;
-
-try_again:
-	ret = 0;
-	*device = calloc(1, sizeof(**device));
-	if (!*device)
-		return -errno;
-
-	nlg = mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
-	if (!nlg) {
-		free_wgdevice(*device);
-		*device = NULL;
-		return -errno;
-	}
-
-	nlh = mnlg_msg_prepare(nlg, WG_CMD_GET_DEVICE, NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP);
-	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, iface);
-	if (mnlg_socket_send(nlg, nlh) < 0) {
-		ret = -errno;
-		goto out;
-	}
-	errno = 0;
-	if (mnlg_socket_recv_run(nlg, read_device_cb, *device) < 0) {
-		ret = errno ? -errno : -EINVAL;
-		goto out;
-	}
-	coalesce_peers(*device);
-
-out:
-	if (nlg)
-		mnlg_socket_close(nlg);
-	if (ret) {
-		free_wgdevice(*device);
-		if (ret == -EINTR)
-			goto try_again;
-		*device = NULL;
-	}
-	errno = -ret;
-	return ret;
-}
-#endif
-
-#ifdef __OpenBSD__
-static int get_dgram_socket(void)
-{
-	static int sock = -1;
-	if (sock < 0)
-		sock = socket(AF_INET, SOCK_DGRAM, 0);
-	return sock;
-}
-
-static int kernel_get_wireguard_interfaces(struct string_list *list)
-{
-	struct ifgroupreq ifgr = { .ifgr_name = "wg" };
-	struct ifg_req *ifg;
-	int s = get_dgram_socket(), ret = 0;
-
-	if (s < 0)
-		return -errno;
-
-	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) < 0)
-		return errno == ENOENT ? 0 : -errno;
-
-	ifgr.ifgr_groups = calloc(1, ifgr.ifgr_len);
-	if (!ifgr.ifgr_groups)
-		return -errno;
-	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) < 0) {
-		ret = -errno;
-		goto out;
-	}
-
-	for (ifg = ifgr.ifgr_groups; ifg && ifgr.ifgr_len > 0; ++ifg) {
-		if ((ret = string_list_add(list, ifg->ifgrq_member)) < 0)
-			goto out;
-		ifgr.ifgr_len -= sizeof(struct ifg_req);
-	}
-
-out:
-	free(ifgr.ifgr_groups);
-	return ret;
-}
-
-static int kernel_get_device(struct wgdevice **device, const char *iface)
-{
-	struct wg_data_io wgdata = { .wgd_size = 0 };
-	struct wg_interface_io *wg_iface;
-	struct wg_peer_io *wg_peer;
-	struct wg_aip_io *wg_aip;
-	struct wgdevice *dev;
-	struct wgpeer *peer;
-	struct wgallowedip *aip;
-	int s = get_dgram_socket(), ret;
-
-	if (s < 0)
-		return -errno;
-
-	*device = NULL;
-	strlcpy(wgdata.wgd_name, iface, sizeof(wgdata.wgd_name));
-	for (size_t last_size = wgdata.wgd_size;; last_size = wgdata.wgd_size) {
-		if (ioctl(s, SIOCGWG, (caddr_t)&wgdata) < 0)
-			goto out;
-		if (last_size >= wgdata.wgd_size)
-			break;
-		wgdata.wgd_interface = realloc(wgdata.wgd_interface, wgdata.wgd_size);
-		if (!wgdata.wgd_interface)
-			goto out;
-	}
-
-	wg_iface = wgdata.wgd_interface;
-	dev = calloc(1, sizeof(*dev));
-	if (!dev)
-		goto out;
-	strlcpy(dev->name, iface, sizeof(dev->name));
-
-	if (wg_iface->i_flags & WG_INTERFACE_HAS_RTABLE) {
-		dev->fwmark = wg_iface->i_rtable;
-		dev->flags |= WGDEVICE_HAS_FWMARK;
-	}
-
-	if (wg_iface->i_flags & WG_INTERFACE_HAS_PORT) {
-		dev->listen_port = wg_iface->i_port;
-		dev->flags |= WGDEVICE_HAS_LISTEN_PORT;
-	}
-
-	if (wg_iface->i_flags & WG_INTERFACE_HAS_PUBLIC) {
-		memcpy(dev->public_key, wg_iface->i_public, sizeof(dev->public_key));
-		dev->flags |= WGDEVICE_HAS_PUBLIC_KEY;
-	}
-
-	if (wg_iface->i_flags & WG_INTERFACE_HAS_PRIVATE) {
-		memcpy(dev->private_key, wg_iface->i_private, sizeof(dev->private_key));
-		dev->flags |= WGDEVICE_HAS_PRIVATE_KEY;
-	}
-
-	wg_peer = &wg_iface->i_peers[0];
-	for (size_t i = 0; i < wg_iface->i_peers_count; ++i) {
-		peer = calloc(1, sizeof(*peer));
-		if (!peer)
-			goto out;
-
-		if (dev->first_peer == NULL)
-			dev->first_peer = peer;
-		else
-			dev->last_peer->next_peer = peer;
-		dev->last_peer = peer;
-
-		if (wg_peer->p_flags & WG_PEER_HAS_PUBLIC) {
-			memcpy(peer->public_key, wg_peer->p_public, sizeof(peer->public_key));
-			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
-		}
-
-		if (wg_peer->p_flags & WG_PEER_HAS_PSK) {
-			memcpy(peer->preshared_key, wg_peer->p_psk, sizeof(peer->preshared_key));
-			peer->flags |= WGPEER_HAS_PRESHARED_KEY;
-		}
-
-		if (wg_peer->p_flags & WG_PEER_HAS_PKA) {
-			peer->persistent_keepalive_interval = wg_peer->p_pka;
-			peer->flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
-		}
-
-		if (wg_peer->p_flags & WG_PEER_HAS_ENDPOINT && wg_peer->p_sa.sa_len <= sizeof(peer->endpoint.addr))
-			memcpy(&peer->endpoint.addr, &wg_peer->p_sa, wg_peer->p_sa.sa_len);
-
-		peer->rx_bytes = wg_peer->p_rxbytes;
-		peer->tx_bytes = wg_peer->p_txbytes;
-
-		peer->last_handshake_time.tv_sec = wg_peer->p_last_handshake.tv_sec;
-		peer->last_handshake_time.tv_nsec = wg_peer->p_last_handshake.tv_nsec;
-
-		wg_aip = &wg_peer->p_aips[0];
-		for (size_t j = 0; j < wg_peer->p_aips_count; ++j) {
-			aip = calloc(1, sizeof(*aip));
-			if (!aip)
-				goto out;
-
-			if (peer->first_allowedip == NULL)
-				peer->first_allowedip = aip;
-			else
-				peer->last_allowedip->next_allowedip = aip;
-			peer->last_allowedip = aip;
-
-			aip->family = wg_aip->a_af;
-			if (wg_aip->a_af == AF_INET) {
-				memcpy(&aip->ip4, &wg_aip->a_ipv4, sizeof(aip->ip4));
-				aip->cidr = wg_aip->a_cidr;
-			} else if (wg_aip->a_af == AF_INET6) {
-				memcpy(&aip->ip6, &wg_aip->a_ipv6, sizeof(aip->ip6));
-				aip->cidr = wg_aip->a_cidr;
-			}
-			++wg_aip;
-		}
-		wg_peer = (struct wg_peer_io *)wg_aip;
-	}
-	*device = dev;
-	errno = 0;
-out:
-	ret = -errno;
-	free(wgdata.wgd_interface);
-	return ret;
-}
-
-static int kernel_set_device(struct wgdevice *dev)
-{
-	struct wg_data_io wgdata = { .wgd_size = sizeof(struct wg_interface_io) };
-	struct wg_interface_io *wg_iface;
-	struct wg_peer_io *wg_peer;
-	struct wg_aip_io *wg_aip;
-	struct wgpeer *peer;
-	struct wgallowedip *aip;
-	int s = get_dgram_socket(), ret;
-	size_t peer_count, aip_count;
-
-	if (s < 0)
-		return -errno;
-
-	for_each_wgpeer(dev, peer) {
-		wgdata.wgd_size += sizeof(struct wg_peer_io);
-		for_each_wgallowedip(peer, aip)
-			wgdata.wgd_size += sizeof(struct wg_aip_io);
-	}
-	wg_iface = wgdata.wgd_interface = calloc(1, wgdata.wgd_size);
-	if (!wgdata.wgd_interface)
-		return -errno;
-	strlcpy(wgdata.wgd_name, dev->name, sizeof(wgdata.wgd_name));
-
-	if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY) {
-		memcpy(wg_iface->i_private, dev->private_key, sizeof(wg_iface->i_private));
-		wg_iface->i_flags |= WG_INTERFACE_HAS_PRIVATE;
-	}
-
-	if (dev->flags & WGDEVICE_HAS_LISTEN_PORT) {
-		wg_iface->i_port = dev->listen_port;
-		wg_iface->i_flags |= WG_INTERFACE_HAS_PORT;
-	}
-
-	if (dev->flags & WGDEVICE_HAS_FWMARK) {
-		wg_iface->i_rtable = dev->fwmark;
-		wg_iface->i_flags |= WG_INTERFACE_HAS_RTABLE;
-	}
-
-	if (dev->flags & WGDEVICE_REPLACE_PEERS)
-		wg_iface->i_flags |= WG_INTERFACE_REPLACE_PEERS;
-
-	peer_count = 0;
-	wg_peer = &wg_iface->i_peers[0];
-	for_each_wgpeer(dev, peer) {
-		wg_peer->p_flags = WG_PEER_HAS_PUBLIC;
-		memcpy(wg_peer->p_public, peer->public_key, sizeof(wg_peer->p_public));
-
-		if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
-			memcpy(wg_peer->p_psk, peer->preshared_key, sizeof(wg_peer->p_psk));
-			wg_peer->p_flags |= WG_PEER_HAS_PSK;
-		}
-
-		if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL) {
-			wg_peer->p_pka = peer->persistent_keepalive_interval;
-			wg_peer->p_flags |= WG_PEER_HAS_PKA;
-		}
-
-		if ((peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6) &&
-		    peer->endpoint.addr.sa_len <= sizeof(wg_peer->p_endpoint)) {
-			memcpy(&wg_peer->p_endpoint, &peer->endpoint.addr, peer->endpoint.addr.sa_len);
-			wg_peer->p_flags |= WG_PEER_HAS_ENDPOINT;
-		}
-
-		if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
-			wg_peer->p_flags |= WG_PEER_REPLACE_AIPS;
-
-		if (peer->flags & WGPEER_REMOVE_ME)
-			wg_peer->p_flags |= WG_PEER_REMOVE;
-
-		aip_count = 0;
-		wg_aip = &wg_peer->p_aips[0];
-		for_each_wgallowedip(peer, aip) {
-			wg_aip->a_af = aip->family;
-			wg_aip->a_cidr = aip->cidr;
-
-			if (aip->family == AF_INET) {
-				memcpy(&wg_aip->a_ipv4, &aip->ip4, sizeof(wg_aip->a_ipv4));
-			} else if (aip->family == AF_INET6) {
-				memcpy(&wg_aip->a_ipv6, &aip->ip6, sizeof(wg_aip->a_ipv6));
-			} else {
-				continue;
-			}
-			++aip_count;
-			++wg_aip;
-		}
-		wg_peer->p_aips_count = aip_count;
-		++peer_count;
-		wg_peer = (struct wg_peer_io *)wg_aip;
-	}
-	wg_iface->i_peers_count = peer_count;
-
-	if (ioctl(s, SIOCSWG, (caddr_t)&wgdata) < 0)
-		goto out;
-	errno = 0;
-
-out:
-	ret = -errno;
-	free(wgdata.wgd_interface);
-	return ret;
-}
+#include "ipc-uapi.h"
+#if defined(__linux__)
+#include "ipc-linux.h"
+#elif defined(__OpenBSD__)
+#include "ipc-openbsd.h"
 #endif
 
 /* first\0second\0third\0forth\0last\0\0 */
@@ -1194,7 +52,7 @@ char *ipc_list_devices(void)
 	struct string_list list = { 0 };
 	int ret;
 
-#if defined(__linux__) || defined(__OpenBSD__)
+#ifdef IPC_SUPPORTS_KERNEL_INTERFACE
 	ret = kernel_get_wireguard_interfaces(&list);
 	if (ret < 0)
 		goto cleanup;
@@ -1214,7 +72,7 @@ cleanup:
 
 int ipc_get_device(struct wgdevice **dev, const char *iface)
 {
-#if defined(__linux__) || defined(__OpenBSD__)
+#ifdef IPC_SUPPORTS_KERNEL_INTERFACE
 	if (userspace_has_wireguard_interface(iface))
 		return userspace_get_device(dev, iface);
 	return kernel_get_device(dev, iface);
@@ -1225,7 +83,7 @@ int ipc_get_device(struct wgdevice **dev, const char *iface)
 
 int ipc_set_device(struct wgdevice *dev)
 {
-#if defined(__linux__) || defined(__OpenBSD__)
+#ifdef IPC_SUPPORTS_KERNEL_INTERFACE
 	if (userspace_has_wireguard_interface(dev->name))
 		return userspace_set_device(dev);
 	return kernel_set_device(dev);

commit c45d422a93d57f6fdec429640ff7f96b396beed4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 13 18:29:41 2020 -0600

    version: bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
index 47e4143..31cfae2 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1,3 +1,3 @@
 #ifndef WIREGUARD_TOOLS_VERSION
-#define WIREGUARD_TOOLS_VERSION "1.0.20200510"
+#define WIREGUARD_TOOLS_VERSION "1.0.20200513"
 #endif

commit 56cb39fb225e284c21d3a33efeb84eff1fd94798
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 13 00:37:46 2020 -0600

    ipc: openbsd: switch to array ioctl interface
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index e68970e..75a95b3 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -986,12 +986,12 @@ static int kernel_get_device(struct wgdevice **device, const char *iface)
 			goto out;
 		if (last_size >= wgdata.wgd_size)
 			break;
-		wgdata.wgd_mem = realloc(wgdata.wgd_mem, wgdata.wgd_size);
-		if (!wgdata.wgd_mem)
+		wgdata.wgd_interface = realloc(wgdata.wgd_interface, wgdata.wgd_size);
+		if (!wgdata.wgd_interface)
 			goto out;
 	}
 
-	wg_iface = wgdata.wgd_mem;
+	wg_iface = wgdata.wgd_interface;
 	dev = calloc(1, sizeof(*dev));
 	if (!dev)
 		goto out;
@@ -1017,7 +1017,8 @@ static int kernel_get_device(struct wgdevice **device, const char *iface)
 		dev->flags |= WGDEVICE_HAS_PRIVATE_KEY;
 	}
 
-	for (wg_peer = wg_iface->i_peers; wg_peer; wg_peer = wg_peer->p_next) {
+	wg_peer = &wg_iface->i_peers[0];
+	for (size_t i = 0; i < wg_iface->i_peers_count; ++i) {
 		peer = calloc(1, sizeof(*peer));
 		if (!peer)
 			goto out;
@@ -1052,7 +1053,8 @@ static int kernel_get_device(struct wgdevice **device, const char *iface)
 		peer->last_handshake_time.tv_sec = wg_peer->p_last_handshake.tv_sec;
 		peer->last_handshake_time.tv_nsec = wg_peer->p_last_handshake.tv_nsec;
 
-		for (wg_aip = wg_peer->p_aips; wg_aip; wg_aip = wg_aip->a_next) {
+		wg_aip = &wg_peer->p_aips[0];
+		for (size_t j = 0; j < wg_peer->p_aips_count; ++j) {
 			aip = calloc(1, sizeof(*aip));
 			if (!aip)
 				goto out;
@@ -1071,55 +1073,63 @@ static int kernel_get_device(struct wgdevice **device, const char *iface)
 				memcpy(&aip->ip6, &wg_aip->a_ipv6, sizeof(aip->ip6));
 				aip->cidr = wg_aip->a_cidr;
 			}
+			++wg_aip;
 		}
+		wg_peer = (struct wg_peer_io *)wg_aip;
 	}
 	*device = dev;
 	errno = 0;
 out:
 	ret = -errno;
-	free(wgdata.wgd_mem);
+	free(wgdata.wgd_interface);
 	return ret;
 }
 
 static int kernel_set_device(struct wgdevice *dev)
 {
-	struct wg_data_io wgdata = { .wgd_size = 0 };
-	struct wg_interface_io wg_iface = { 0 };
-	struct wg_peer_io *wg_peer, *wg_peer_next;
-	struct wg_aip_io *wg_aip, *wg_aip_next;
+	struct wg_data_io wgdata = { .wgd_size = sizeof(struct wg_interface_io) };
+	struct wg_interface_io *wg_iface;
+	struct wg_peer_io *wg_peer;
+	struct wg_aip_io *wg_aip;
 	struct wgpeer *peer;
 	struct wgallowedip *aip;
 	int s = get_dgram_socket(), ret;
+	size_t peer_count, aip_count;
 
 	if (s < 0)
 		return -errno;
 
+	for_each_wgpeer(dev, peer) {
+		wgdata.wgd_size += sizeof(struct wg_peer_io);
+		for_each_wgallowedip(peer, aip)
+			wgdata.wgd_size += sizeof(struct wg_aip_io);
+	}
+	wg_iface = wgdata.wgd_interface = calloc(1, wgdata.wgd_size);
+	if (!wgdata.wgd_interface)
+		return -errno;
 	strlcpy(wgdata.wgd_name, dev->name, sizeof(wgdata.wgd_name));
-	wgdata.wgd_mem = &wg_iface;
 
 	if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY) {
-		memcpy(wg_iface.i_private, dev->private_key, sizeof(wg_iface.i_private));
-		wg_iface.i_flags |= WG_INTERFACE_HAS_PRIVATE;
+		memcpy(wg_iface->i_private, dev->private_key, sizeof(wg_iface->i_private));
+		wg_iface->i_flags |= WG_INTERFACE_HAS_PRIVATE;
 	}
 
 	if (dev->flags & WGDEVICE_HAS_LISTEN_PORT) {
-		wg_iface.i_port = dev->listen_port;
-		wg_iface.i_flags |= WG_INTERFACE_HAS_PORT;
+		wg_iface->i_port = dev->listen_port;
+		wg_iface->i_flags |= WG_INTERFACE_HAS_PORT;
 	}
 
 	if (dev->flags & WGDEVICE_HAS_FWMARK) {
-		wg_iface.i_rtable = dev->fwmark;
-		wg_iface.i_flags |= WG_INTERFACE_HAS_RTABLE;
+		wg_iface->i_rtable = dev->fwmark;
+		wg_iface->i_flags |= WG_INTERFACE_HAS_RTABLE;
 	}
 
 	if (dev->flags & WGDEVICE_REPLACE_PEERS)
-		wg_iface.i_flags |= WG_INTERFACE_REPLACE_PEERS;
+		wg_iface->i_flags |= WG_INTERFACE_REPLACE_PEERS;
 
+	peer_count = 0;
+	wg_peer = &wg_iface->i_peers[0];
 	for_each_wgpeer(dev, peer) {
-		wg_peer = calloc(1, sizeof(*wg_peer));
-		if (!wg_peer)
-			goto out;
-
 		wg_peer->p_flags = WG_PEER_HAS_PUBLIC;
 		memcpy(wg_peer->p_public, peer->public_key, sizeof(wg_peer->p_public));
 
@@ -1145,14 +1155,9 @@ static int kernel_set_device(struct wgdevice *dev)
 		if (peer->flags & WGPEER_REMOVE_ME)
 			wg_peer->p_flags |= WG_PEER_REMOVE;
 
-		wg_peer->p_next = wg_iface.i_peers;
-		wg_iface.i_peers = wg_peer;
-
+		aip_count = 0;
+		wg_aip = &wg_peer->p_aips[0];
 		for_each_wgallowedip(peer, aip) {
-			wg_aip = calloc(1, sizeof(*wg_aip));
-			if (!wg_aip)
-				goto out;
-
 			wg_aip->a_af = aip->family;
 			wg_aip->a_cidr = aip->cidr;
 
@@ -1161,14 +1166,16 @@ static int kernel_set_device(struct wgdevice *dev)
 			} else if (aip->family == AF_INET6) {
 				memcpy(&wg_aip->a_ipv6, &aip->ip6, sizeof(wg_aip->a_ipv6));
 			} else {
-				free(wg_aip);
 				continue;
 			}
-
-			wg_aip->a_next = wg_peer->p_aips;
-			wg_peer->p_aips = wg_aip;
+			++aip_count;
+			++wg_aip;
 		}
+		wg_peer->p_aips_count = aip_count;
+		++peer_count;
+		wg_peer = (struct wg_peer_io *)wg_aip;
 	}
+	wg_iface->i_peers_count = peer_count;
 
 	if (ioctl(s, SIOCSWG, (caddr_t)&wgdata) < 0)
 		goto out;
@@ -1176,14 +1183,7 @@ static int kernel_set_device(struct wgdevice *dev)
 
 out:
 	ret = -errno;
-	for (wg_peer = wg_iface.i_peers; wg_peer; wg_peer = wg_peer_next) {
-		for (wg_aip = wg_peer->p_aips; wg_aip; wg_aip = wg_aip_next) {
-			wg_aip_next = wg_aip->a_next;
-			free(wg_aip);
-		}
-		wg_peer_next = wg_peer->p_next;
-		free(wg_peer);
-	}
+	free(wgdata.wgd_interface);
 	return ret;
 }
 #endif
diff --git a/src/uapi/openbsd/net/if_wg.h b/src/uapi/openbsd/net/if_wg.h
index 5b958f9..bd33a88 100644
--- a/src/uapi/openbsd/net/if_wg.h
+++ b/src/uapi/openbsd/net/if_wg.h
@@ -25,26 +25,16 @@
 #define SIOCSWG _IOWR('i', 210, struct wg_data_io)
 #define SIOCGWG _IOWR('i', 211, struct wg_data_io)
 
-struct wg_data_io {
-	char	 wgd_name[IFNAMSIZ];
-	size_t	 wgd_size;	/* size of the mem below */
-	void	*wgd_mem;	/* wg_interface_io{1},(wg_peer_io,wg_aip_io*)* */
-};
-
-#define WG_INTERFACE_HAS_PUBLIC		(1 << 0)
-#define WG_INTERFACE_HAS_PRIVATE	(1 << 1)
-#define WG_INTERFACE_HAS_PORT		(1 << 2)
-#define WG_INTERFACE_HAS_RTABLE		(1 << 3)
-#define WG_INTERFACE_REPLACE_PEERS	(1 << 4)
-
-struct wg_interface_io {
-	uint8_t			 i_flags;
-	struct wg_peer_io	*i_peers;
+#define a_ipv4	a_addr.addr_ipv4
+#define a_ipv6	a_addr.addr_ipv6
 
-	in_port_t		 i_port;
-	int			 i_rtable;
-	uint8_t			 i_public[WG_KEY_LEN];
-	uint8_t			 i_private[WG_KEY_LEN];
+struct wg_aip_io {
+	sa_family_t	 a_af;
+	int		 a_cidr;
+	union wg_aip_addr {
+		struct in_addr		addr_ipv4;
+		struct in6_addr		addr_ipv6;
+	}		 a_addr;
 };
 
 #define WG_PEER_HAS_PUBLIC		(1 << 0)
@@ -60,42 +50,43 @@ struct wg_interface_io {
 #define p_sin6		p_endpoint.sa_sin6
 
 struct wg_peer_io {
-	int			 p_flags;
-	struct wg_peer_io	*p_next;
-	struct wg_aip_io	*p_aips;
-
-	int			 p_protocol_version;
-	uint8_t			 p_public[WG_KEY_LEN];
-	uint8_t			 p_psk[WG_KEY_LEN];
-	uint16_t		 p_pka;
+	int			p_flags;
+	int			p_protocol_version;
+	uint8_t			p_public[WG_KEY_LEN];
+	uint8_t			p_psk[WG_KEY_LEN];
+	uint16_t		p_pka;
 	union wg_peer_endpoint {
 		struct sockaddr		sa_sa;
 		struct sockaddr_in	sa_sin;
 		struct sockaddr_in6	sa_sin6;
-	}			 p_endpoint;
-
-	uint64_t		 p_txbytes;
-	uint64_t		 p_rxbytes;
-	struct timespec		 p_last_handshake; /* nanotime */
+	}			p_endpoint;
+	uint64_t		p_txbytes;
+	uint64_t		p_rxbytes;
+	struct timespec		p_last_handshake; /* nanotime */
+	size_t			p_aips_count;
+	struct wg_aip_io	p_aips[];
 };
 
-#define a_af	a_data.d_af
-#define a_cidr	a_data.d_cidr
-#define a_addr	a_data.d_addr
-#define a_ipv4	a_addr.addr_ipv4
-#define a_ipv6	a_addr.addr_ipv6
+#define WG_INTERFACE_HAS_PUBLIC		(1 << 0)
+#define WG_INTERFACE_HAS_PRIVATE	(1 << 1)
+#define WG_INTERFACE_HAS_PORT		(1 << 2)
+#define WG_INTERFACE_HAS_RTABLE		(1 << 3)
+#define WG_INTERFACE_REPLACE_PEERS	(1 << 4)
 
-struct wg_aip_io {
-	struct wg_aip_io	*a_next;
-
-	struct wg_aip_data {
-		sa_family_t		 d_af;
-		int			 d_cidr;
-		union wg_aip_addr {
-			struct in_addr		addr_ipv4;
-			struct in6_addr		addr_ipv6;
-		}			 d_addr;
-	}			 a_data;
+struct wg_interface_io {
+	uint8_t			i_flags;
+	in_port_t		i_port;
+	int			i_rtable;
+	uint8_t			i_public[WG_KEY_LEN];
+	uint8_t			i_private[WG_KEY_LEN];
+	size_t			i_peers_count;
+	struct wg_peer_io	i_peers[];
+};
+
+struct wg_data_io {
+	char	 		 wgd_name[IFNAMSIZ];
+	size_t			 wgd_size;	/* total size of the memory pointed to by wgd_interface */
+	struct wg_interface_io	*wgd_interface;
 };
 
 #endif /* __IF_WG_H__ */

commit 0cfde946b1ffc35fff57501f3d9eb675a2dd2dba
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 11 21:31:05 2020 -0600

    Makefile: remember to install all systemd units
    
    Reported-by: Unit 193 <unit193@unit193.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index d3d56cc..157153e 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -90,7 +90,7 @@ install: wg
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_BASHCOMPLETION)" = "yes" ] || exit 0; \
 	install -v -m 0644 completion/wg-quick.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg-quick"
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_SYSTEMDUNITS)" = "yes" ] || exit 0; \
-	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -v -m 0644 systemd/wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
+	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -v -m 0644 systemd/* "$(DESTDIR)$(SYSTEMDUNITDIR)/"
 
 check: clean
 	scan-build --html-title=wireguard-tools -maxloop 100 --view --keep-going $(MAKE) wg

commit 8137c14dc63ee371108237ead4f15e06ffc97f5e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun May 10 22:20:44 2020 -0600

    version: bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
index ea2fd63..47e4143 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1,3 +1,3 @@
 #ifndef WIREGUARD_TOOLS_VERSION
-#define WIREGUARD_TOOLS_VERSION "1.0.20200319"
+#define WIREGUARD_TOOLS_VERSION "1.0.20200510"
 #endif

commit 10b4e7677f984894e92e7de73d734d40ac0af7bb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun May 10 00:58:31 2020 -0600

    wg-quick: cleanup openbsd support
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 1150be5..e4d4c4f 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -90,7 +90,7 @@ add_if() {
 	if ! cmd ip link add "$INTERFACE" type wireguard; then
 		ret=$?
 		[[ -e /sys/module/wireguard ]] || ! command -v "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" >/dev/null && exit $ret
-		echo "[!] Missing WireGuard kernel module. Falling back to slow userspace implementation."
+		echo "[!] Missing WireGuard kernel module. Falling back to slow userspace implementation." >&2
 		cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" "$INTERFACE"
 	fi
 }
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index 3b90df2..ffd1834 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -8,6 +8,7 @@ set -e -o pipefail
 shopt -s extglob
 export LC_ALL=C
 
+exec 3>&2
 SELF="$(readlink -f "${BASH_SOURCE[0]}")"
 export PATH="${SELF%/*}:$PATH"
 
@@ -28,7 +29,7 @@ PROGRAM="${0##*/}"
 ARGS=( "$@" )
 
 cmd() {
-	echo "[#] $*" >&2
+	echo "[#] $*" >&3
 	"$@"
 }
 
@@ -91,34 +92,38 @@ get_real_interface() {
 	wg show interfaces >/dev/null
 	[[ -f "/var/run/wireguard/$INTERFACE.name" ]] || return 1
 	interface="$(< "/var/run/wireguard/$INTERFACE.name")"
-	[[ -n $interface && -S "/var/run/wireguard/$interface.sock" ]] || return 1
-	diff=$(( $(stat -f %m "/var/run/wireguard/$interface.sock" 2>/dev/null || echo 200) - $(stat -f %m "/var/run/wireguard/$INTERFACE.name" 2>/dev/null || echo 100) ))
-	[[ $diff -ge 2 || $diff -le -2 ]] && return 1
+	if [[ $interface != wg* ]]; then
+		[[ -n $interface && -S "/var/run/wireguard/$interface.sock" ]] || return 1
+		diff=$(( $(stat -f %m "/var/run/wireguard/$interface.sock" 2>/dev/null || echo 200) - $(stat -f %m "/var/run/wireguard/$INTERFACE.name" 2>/dev/null || echo 100) ))
+		[[ $diff -ge 2 || $diff -le -2 ]] && return 1
+		echo "[+] Tun interface for $INTERFACE is $interface" >&2
+	else
+		[[ " $(wg show interfaces) " == *" $interface "* ]] || return 1
+	fi
 	REAL_INTERFACE="$interface"
-	echo "[+] Interface for $INTERFACE is $REAL_INTERFACE" >&2
 	return 0
 }
 
 add_if() {
-	local index
-	echo "find wg" | config -e /bsd 2>/dev/null | grep "wg count 1" >/dev/null
-	if [[ $? == 0 ]]; then
-		REAL_INTERFACE=""
-		index=0
-		while [[ $REAL_INTERFACE == "" ]]; do
-			ifconfig wg$index create
-			if [[ $? == 0 ]]; then
-				$REAL_INTERFACE="wg$index"
-			fi
-			index=$((index+1))
-		done
-		echo "[+] Interface for $INTERFACE is $REAL_INTERFACE" >&2
-	else
-		export WG_TUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
-		mkdir -p "/var/run/wireguard/"
-		cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" tun
-		get_real_interface
-	fi
+	local index=0 ret
+	while true; do
+		if ret="$(cmd ifconfig wg$index create 2>&1)"; then
+			mkdir -p "/var/run/wireguard/"
+			echo wg$index > /var/run/wireguard/$INTERFACE.name
+			get_real_interface
+			return 0
+		fi
+		if [[ $ret != *"ifconfig: SIOCIFCREATE: File exists"* ]]; then
+			echo "[!] Missing WireGuard kernel support ($ret). Falling back to slow userspace implementation." >&3
+			break
+		fi
+		echo "[+] wg$index in use, trying next"
+		((++index))
+	done
+	export WG_TUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
+	mkdir -p "/var/run/wireguard/"
+	cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" tun
+	get_real_interface
 }
 
 del_routes() {
@@ -148,7 +153,11 @@ del_routes() {
 
 del_if() {
 	unset_dns
-	[[ -z $REAL_INTERFACE ]] || cmd rm -f "/var/run/wireguard/$REAL_INTERFACE.sock"
+	if [[ -n $REAL_INTERFACE && $REAL_INTERFACE != wg* ]]; then
+		cmd rm -f "/var/run/wireguard/$REAL_INTERFACE.sock"
+	else
+		cmd ifconfig $REAL_INTERFACE destroy
+	fi
 	cmd rm -f "/var/run/wireguard/$INTERFACE.name"
 }
 

commit 9eda95d084d72ef7412e1af359242d6839215c48
Author: Matt Dunwoodie <ncon@noconroy.net>
Date:   Sun May 10 02:06:14 2020 -0600

    wg-quick: add support for openbsd kernel implementation
    
    Signed-off-by: Matt Dunwoodie <ncon@noconroy.net>

diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index 9584902..3b90df2 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -100,10 +100,25 @@ get_real_interface() {
 }
 
 add_if() {
-	export WG_TUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
-	mkdir -p "/var/run/wireguard/"
-	cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" tun
-	get_real_interface
+	local index
+	echo "find wg" | config -e /bsd 2>/dev/null | grep "wg count 1" >/dev/null
+	if [[ $? == 0 ]]; then
+		REAL_INTERFACE=""
+		index=0
+		while [[ $REAL_INTERFACE == "" ]]; do
+			ifconfig wg$index create
+			if [[ $? == 0 ]]; then
+				$REAL_INTERFACE="wg$index"
+			fi
+			index=$((index+1))
+		done
+		echo "[+] Interface for $INTERFACE is $REAL_INTERFACE" >&2
+	else
+		export WG_TUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
+		mkdir -p "/var/run/wireguard/"
+		cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" tun
+		get_real_interface
+	fi
 }
 
 del_routes() {

commit d4a32c97fd0953acfe18ce4eb3bdea8b33af1d23
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun May 10 00:24:46 2020 -0600

    ipc: cleanup openbsd support
    
    We also add a wg_if.h in the fallback include path.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 341a90e..d3d56cc 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -38,7 +38,9 @@ endif
 PLATFORM ?= $(shell uname -s | tr '[:upper:]' '[:lower:]')
 
 CFLAGS ?= -O3
-CFLAGS += -idirafter uapi
+ifneq ($(wildcard uapi/$(PLATFORM)/.),)
+CFLAGS += -idirafter uapi/$(PLATFORM)
+endif
 CFLAGS += -std=gnu99 -D_GNU_SOURCE
 CFLAGS += -Wall -Wextra
 CFLAGS += -MMD -MP
diff --git a/src/containers.h b/src/containers.h
index 2ffc230..fb5434f 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -12,7 +12,15 @@
 #include <sys/socket.h>
 #include <net/if.h>
 #include <netinet/in.h>
+#if defined(__linux__)
 #include <linux/wireguard.h>
+#elif defined(__OpenBSD__)
+#include <net/if_wg.h>
+#endif
+
+#ifndef WG_KEY_LEN
+#define WG_KEY_LEN 32
+#endif
 
 /* Cross platform __kernel_timespec */
 struct timespec64 {
diff --git a/src/ipc.c b/src/ipc.c
index 954f239..e68970e 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -862,7 +862,7 @@ static void coalesce_peers(struct wgdevice *device)
 	struct wgpeer *old_next_peer, *peer = device->first_peer;
 
 	while (peer && peer->next_peer) {
-		if (memcmp(peer->public_key, peer->next_peer->public_key, WG_KEY_LEN)) {
+		if (memcmp(peer->public_key, peer->next_peer->public_key, sizeof(peer->public_key))) {
 			peer = peer->next_peer;
 			continue;
 		}
@@ -926,42 +926,38 @@ out:
 #endif
 
 #ifdef __OpenBSD__
-int s = -1;
-
-void
-getsock()
+static int get_dgram_socket(void)
 {
-	if (s < 0)
-		s = socket(AF_INET, SOCK_DGRAM, 0);
+	static int sock = -1;
+	if (sock < 0)
+		sock = socket(AF_INET, SOCK_DGRAM, 0);
+	return sock;
 }
 
 static int kernel_get_wireguard_interfaces(struct string_list *list)
 {
-	struct ifgroupreq ifgr;
+	struct ifgroupreq ifgr = { .ifgr_name = "wg" };
 	struct ifg_req *ifg;
-	size_t len = 0;
-	int ret = 0;
-
-	getsock();
+	int s = get_dgram_socket(), ret = 0;
 
-	bzero(&ifgr, sizeof(ifgr));
-	strlcpy(ifgr.ifgr_name, "wg", sizeof(ifgr.ifgr_name));
+	if (s < 0)
+		return -errno;
 
-	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1)
-		return errno;
+	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) < 0)
+		return errno == ENOENT ? 0 : -errno;
 
-	len = ifgr.ifgr_len;
-	if ((ifgr.ifgr_groups = calloc(1, len)) == NULL)
-		return errno;
-	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1) {
-		ret = errno;
+	ifgr.ifgr_groups = calloc(1, ifgr.ifgr_len);
+	if (!ifgr.ifgr_groups)
+		return -errno;
+	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) < 0) {
+		ret = -errno;
 		goto out;
 	}
 
-	for (ifg = ifgr.ifgr_groups; ifg && len > 0; ifg++) {
+	for (ifg = ifgr.ifgr_groups; ifg && ifgr.ifgr_len > 0; ++ifg) {
 		if ((ret = string_list_add(list, ifg->ifgrq_member)) < 0)
 			goto out;
-		len -= sizeof(struct ifg_req);
+		ifgr.ifgr_len -= sizeof(struct ifg_req);
 	}
 
 out:
@@ -971,40 +967,34 @@ out:
 
 static int kernel_get_device(struct wgdevice **device, const char *iface)
 {
-	struct wg_data_io wgdata;
+	struct wg_data_io wgdata = { .wgd_size = 0 };
 	struct wg_interface_io *wg_iface;
 	struct wg_peer_io *wg_peer;
 	struct wg_aip_io *wg_aip;
-
 	struct wgdevice *dev;
 	struct wgpeer *peer;
 	struct wgallowedip *aip;
+	int s = get_dgram_socket(), ret;
 
-	size_t size;
-
-	getsock();
+	if (s < 0)
+		return -errno;
 
 	*device = NULL;
-
 	strlcpy(wgdata.wgd_name, iface, sizeof(wgdata.wgd_name));
-	wgdata.wgd_size = size = 0;
-	wgdata.wgd_mem = NULL;
-
-	if (ioctl(s, SIOCGWG, (caddr_t)&wgdata) == -1 &&
-	    (errno == ENOTTY || errno == EPERM))
-		return -errno;
-
-	while (size < wgdata.wgd_size) {
-		size = wgdata.wgd_size;
-		wgdata.wgd_mem = realloc(wgdata.wgd_mem, size);
-		if (ioctl(s, SIOCGWG, (caddr_t)&wgdata) == -1)
-			return -errno;
+	for (size_t last_size = wgdata.wgd_size;; last_size = wgdata.wgd_size) {
+		if (ioctl(s, SIOCGWG, (caddr_t)&wgdata) < 0)
+			goto out;
+		if (last_size >= wgdata.wgd_size)
+			break;
+		wgdata.wgd_mem = realloc(wgdata.wgd_mem, wgdata.wgd_size);
+		if (!wgdata.wgd_mem)
+			goto out;
 	}
 
 	wg_iface = wgdata.wgd_mem;
-
-	if ((dev = calloc(1, sizeof(*dev))) == NULL)
-		return -errno;
+	dev = calloc(1, sizeof(*dev));
+	if (!dev)
+		goto out;
 	strlcpy(dev->name, iface, sizeof(dev->name));
 
 	if (wg_iface->i_flags & WG_INTERFACE_HAS_RTABLE) {
@@ -1013,23 +1003,24 @@ static int kernel_get_device(struct wgdevice **device, const char *iface)
 	}
 
 	if (wg_iface->i_flags & WG_INTERFACE_HAS_PORT) {
-		dev->listen_port = ntohs(wg_iface->i_port);
+		dev->listen_port = wg_iface->i_port;
 		dev->flags |= WGDEVICE_HAS_LISTEN_PORT;
 	}
 
 	if (wg_iface->i_flags & WG_INTERFACE_HAS_PUBLIC) {
-		memcpy(dev->public_key, wg_iface->i_public, WG_KEY_SIZE);
+		memcpy(dev->public_key, wg_iface->i_public, sizeof(dev->public_key));
 		dev->flags |= WGDEVICE_HAS_PUBLIC_KEY;
 	}
 
 	if (wg_iface->i_flags & WG_INTERFACE_HAS_PRIVATE) {
-		memcpy(dev->private_key, wg_iface->i_private, WG_KEY_SIZE);
+		memcpy(dev->private_key, wg_iface->i_private, sizeof(dev->private_key));
 		dev->flags |= WGDEVICE_HAS_PRIVATE_KEY;
 	}
 
-	for (wg_peer = wg_iface->i_peers; wg_peer != NULL; wg_peer = wg_peer->p_next) {
-		if ((peer = calloc(1, sizeof(*peer))) == NULL)
-			return -errno;
+	for (wg_peer = wg_iface->i_peers; wg_peer; wg_peer = wg_peer->p_next) {
+		peer = calloc(1, sizeof(*peer));
+		if (!peer)
+			goto out;
 
 		if (dev->first_peer == NULL)
 			dev->first_peer = peer;
@@ -1038,12 +1029,12 @@ static int kernel_get_device(struct wgdevice **device, const char *iface)
 		dev->last_peer = peer;
 
 		if (wg_peer->p_flags & WG_PEER_HAS_PUBLIC) {
-			memcpy(peer->public_key, wg_peer->p_public, WG_KEY_SIZE);
+			memcpy(peer->public_key, wg_peer->p_public, sizeof(peer->public_key));
 			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
 		}
 
 		if (wg_peer->p_flags & WG_PEER_HAS_PSK) {
-			memcpy(peer->preshared_key, wg_peer->p_psk, WG_KEY_SIZE);
+			memcpy(peer->preshared_key, wg_peer->p_psk, sizeof(peer->preshared_key));
 			peer->flags |= WGPEER_HAS_PRESHARED_KEY;
 		}
 
@@ -1052,9 +1043,8 @@ static int kernel_get_device(struct wgdevice **device, const char *iface)
 			peer->flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
 		}
 
-		if (wg_peer->p_flags & WG_PEER_HAS_SOCKADDR)
-			memcpy(&peer->endpoint.addr, &wg_peer->p_sa,
-			    wg_peer->p_sa.sa_len);
+		if (wg_peer->p_flags & WG_PEER_HAS_ENDPOINT && wg_peer->p_sa.sa_len <= sizeof(peer->endpoint.addr))
+			memcpy(&peer->endpoint.addr, &wg_peer->p_sa, wg_peer->p_sa.sa_len);
 
 		peer->rx_bytes = wg_peer->p_rxbytes;
 		peer->tx_bytes = wg_peer->p_txbytes;
@@ -1062,9 +1052,10 @@ static int kernel_get_device(struct wgdevice **device, const char *iface)
 		peer->last_handshake_time.tv_sec = wg_peer->p_last_handshake.tv_sec;
 		peer->last_handshake_time.tv_nsec = wg_peer->p_last_handshake.tv_nsec;
 
-		for (wg_aip = wg_peer->p_aips; wg_aip != NULL; wg_aip = wg_aip->a_next) {
-			if ((aip = calloc(1, sizeof(*aip))) == NULL)
-				return -errno;
+		for (wg_aip = wg_peer->p_aips; wg_aip; wg_aip = wg_aip->a_next) {
+			aip = calloc(1, sizeof(*aip));
+			if (!aip)
+				goto out;
 
 			if (peer->first_allowedip == NULL)
 				peer->first_allowedip = aip;
@@ -1075,43 +1066,44 @@ static int kernel_get_device(struct wgdevice **device, const char *iface)
 			aip->family = wg_aip->a_af;
 			if (wg_aip->a_af == AF_INET) {
 				memcpy(&aip->ip4, &wg_aip->a_ipv4, sizeof(aip->ip4));
-				aip->cidr = wg_aip->a_mask;
+				aip->cidr = wg_aip->a_cidr;
 			} else if (wg_aip->a_af == AF_INET6) {
 				memcpy(&aip->ip6, &wg_aip->a_ipv6, sizeof(aip->ip6));
-				aip->cidr = wg_aip->a_mask;
+				aip->cidr = wg_aip->a_cidr;
 			}
 		}
 	}
-
 	*device = dev;
+	errno = 0;
+out:
+	ret = -errno;
 	free(wgdata.wgd_mem);
-	return 0;
+	return ret;
 }
 
 static int kernel_set_device(struct wgdevice *dev)
 {
-	struct wg_data_io wgdata;
-	struct wg_interface_io wg_iface;
-	struct wg_peer_io *wg_peer;
-	struct wg_aip_io *wg_aip;
-
+	struct wg_data_io wgdata = { .wgd_size = 0 };
+	struct wg_interface_io wg_iface = { 0 };
+	struct wg_peer_io *wg_peer, *wg_peer_next;
+	struct wg_aip_io *wg_aip, *wg_aip_next;
 	struct wgpeer *peer;
 	struct wgallowedip *aip;
+	int s = get_dgram_socket(), ret;
 
-	getsock();
+	if (s < 0)
+		return -errno;
 
 	strlcpy(wgdata.wgd_name, dev->name, sizeof(wgdata.wgd_name));
 	wgdata.wgd_mem = &wg_iface;
 
-	bzero(&wg_iface, sizeof(wg_iface));
-
 	if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY) {
-		memcpy(wg_iface.i_private, dev->private_key, WG_KEY_SIZE);
+		memcpy(wg_iface.i_private, dev->private_key, sizeof(wg_iface.i_private));
 		wg_iface.i_flags |= WG_INTERFACE_HAS_PRIVATE;
 	}
 
 	if (dev->flags & WGDEVICE_HAS_LISTEN_PORT) {
-		wg_iface.i_port = htons(dev->listen_port);
+		wg_iface.i_port = dev->listen_port;
 		wg_iface.i_flags |= WG_INTERFACE_HAS_PORT;
 	}
 
@@ -1124,14 +1116,15 @@ static int kernel_set_device(struct wgdevice *dev)
 		wg_iface.i_flags |= WG_INTERFACE_REPLACE_PEERS;
 
 	for_each_wgpeer(dev, peer) {
-		if ((wg_peer = calloc(1, sizeof(*wg_peer))) == NULL)
-			return -errno;
+		wg_peer = calloc(1, sizeof(*wg_peer));
+		if (!wg_peer)
+			goto out;
 
 		wg_peer->p_flags = WG_PEER_HAS_PUBLIC;
-		memcpy(wg_peer->p_public, peer->public_key, WG_KEY_SIZE);
+		memcpy(wg_peer->p_public, peer->public_key, sizeof(wg_peer->p_public));
 
 		if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
-			memcpy(wg_peer->p_psk, peer->preshared_key, WG_KEY_SIZE);
+			memcpy(wg_peer->p_psk, peer->preshared_key, sizeof(wg_peer->p_psk));
 			wg_peer->p_flags |= WG_PEER_HAS_PSK;
 		}
 
@@ -1140,10 +1133,10 @@ static int kernel_set_device(struct wgdevice *dev)
 			wg_peer->p_flags |= WG_PEER_HAS_PKA;
 		}
 
-		if (peer->endpoint.addr.sa_family == AF_INET ||
-		    peer->endpoint.addr.sa_family == AF_INET6) {
-			memcpy(&wg_peer->p_sa, &peer->endpoint.addr, peer->endpoint.addr.sa_len);
-			wg_peer->p_flags |= WG_PEER_HAS_SOCKADDR;
+		if ((peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6) &&
+		    peer->endpoint.addr.sa_len <= sizeof(wg_peer->p_endpoint)) {
+			memcpy(&wg_peer->p_endpoint, &peer->endpoint.addr, peer->endpoint.addr.sa_len);
+			wg_peer->p_flags |= WG_PEER_HAS_ENDPOINT;
 		}
 
 		if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
@@ -1156,30 +1149,44 @@ static int kernel_set_device(struct wgdevice *dev)
 		wg_iface.i_peers = wg_peer;
 
 		for_each_wgallowedip(peer, aip) {
-			if ((wg_aip = calloc(1, sizeof(*wg_aip))) == NULL)
-				return -errno;
+			wg_aip = calloc(1, sizeof(*wg_aip));
+			if (!wg_aip)
+				goto out;
 
 			wg_aip->a_af = aip->family;
-			wg_aip->a_mask = aip->cidr;
+			wg_aip->a_cidr = aip->cidr;
 
-			if (aip->family == AF_INET)
-				memcpy(&wg_aip->a_ipv4, &aip->ip4, sizeof(aip->ip4));
-			else if (aip->family == AF_INET6)
-				memcpy(&wg_aip->a_ipv6, &aip->ip6, sizeof(aip->ip6));
-			else
-				return -1;
+			if (aip->family == AF_INET) {
+				memcpy(&wg_aip->a_ipv4, &aip->ip4, sizeof(wg_aip->a_ipv4));
+			} else if (aip->family == AF_INET6) {
+				memcpy(&wg_aip->a_ipv6, &aip->ip6, sizeof(wg_aip->a_ipv6));
+			} else {
+				free(wg_aip);
+				continue;
+			}
 
 			wg_aip->a_next = wg_peer->p_aips;
 			wg_peer->p_aips = wg_aip;
 		}
 	}
 
-	if (ioctl(s, SIOCSWG, (caddr_t)&wgdata) == -1)
-		return -errno;
+	if (ioctl(s, SIOCSWG, (caddr_t)&wgdata) < 0)
+		goto out;
+	errno = 0;
 
-	return 0;
+out:
+	ret = -errno;
+	for (wg_peer = wg_iface.i_peers; wg_peer; wg_peer = wg_peer_next) {
+		for (wg_aip = wg_peer->p_aips; wg_aip; wg_aip = wg_aip_next) {
+			wg_aip_next = wg_aip->a_next;
+			free(wg_aip);
+		}
+		wg_peer_next = wg_peer->p_next;
+		free(wg_peer);
+	}
+	return ret;
 }
-#endif /* OpenBSD */
+#endif
 
 /* first\0second\0third\0forth\0last\0\0 */
 char *ipc_list_devices(void)
diff --git a/src/uapi/linux/wireguard.h b/src/uapi/linux/linux/wireguard.h
similarity index 100%
rename from src/uapi/linux/wireguard.h
rename to src/uapi/linux/linux/wireguard.h
diff --git a/src/uapi/openbsd/net/if_wg.h b/src/uapi/openbsd/net/if_wg.h
new file mode 100644
index 0000000..5b958f9
--- /dev/null
+++ b/src/uapi/openbsd/net/if_wg.h
@@ -0,0 +1,101 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (c) 2020 Matt Dunwoodie <ncon@noconroy.net>
+ */
+
+#ifndef __IF_WG_H__
+#define __IF_WG_H__
+
+#include <sys/limits.h>
+#include <sys/errno.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+
+
+/*
+ * This is the public interface to the WireGuard network interface.
+ *
+ * It is designed to be used by tools such as ifconfig(8) and wg(8).
+ */
+
+#define WG_KEY_LEN 32
+
+#define SIOCSWG _IOWR('i', 210, struct wg_data_io)
+#define SIOCGWG _IOWR('i', 211, struct wg_data_io)
+
+struct wg_data_io {
+	char	 wgd_name[IFNAMSIZ];
+	size_t	 wgd_size;	/* size of the mem below */
+	void	*wgd_mem;	/* wg_interface_io{1},(wg_peer_io,wg_aip_io*)* */
+};
+
+#define WG_INTERFACE_HAS_PUBLIC		(1 << 0)
+#define WG_INTERFACE_HAS_PRIVATE	(1 << 1)
+#define WG_INTERFACE_HAS_PORT		(1 << 2)
+#define WG_INTERFACE_HAS_RTABLE		(1 << 3)
+#define WG_INTERFACE_REPLACE_PEERS	(1 << 4)
+
+struct wg_interface_io {
+	uint8_t			 i_flags;
+	struct wg_peer_io	*i_peers;
+
+	in_port_t		 i_port;
+	int			 i_rtable;
+	uint8_t			 i_public[WG_KEY_LEN];
+	uint8_t			 i_private[WG_KEY_LEN];
+};
+
+#define WG_PEER_HAS_PUBLIC		(1 << 0)
+#define WG_PEER_HAS_PSK			(1 << 1)
+#define WG_PEER_HAS_PKA			(1 << 2)
+#define WG_PEER_HAS_ENDPOINT		(1 << 3)
+#define WG_PEER_REPLACE_AIPS		(1 << 4)
+#define WG_PEER_REMOVE			(1 << 5)
+#define WG_PEER_UPDATE			(1 << 6)
+
+#define p_sa		p_endpoint.sa_sa
+#define p_sin		p_endpoint.sa_sin
+#define p_sin6		p_endpoint.sa_sin6
+
+struct wg_peer_io {
+	int			 p_flags;
+	struct wg_peer_io	*p_next;
+	struct wg_aip_io	*p_aips;
+
+	int			 p_protocol_version;
+	uint8_t			 p_public[WG_KEY_LEN];
+	uint8_t			 p_psk[WG_KEY_LEN];
+	uint16_t		 p_pka;
+	union wg_peer_endpoint {
+		struct sockaddr		sa_sa;
+		struct sockaddr_in	sa_sin;
+		struct sockaddr_in6	sa_sin6;
+	}			 p_endpoint;
+
+	uint64_t		 p_txbytes;
+	uint64_t		 p_rxbytes;
+	struct timespec		 p_last_handshake; /* nanotime */
+};
+
+#define a_af	a_data.d_af
+#define a_cidr	a_data.d_cidr
+#define a_addr	a_data.d_addr
+#define a_ipv4	a_addr.addr_ipv4
+#define a_ipv6	a_addr.addr_ipv6
+
+struct wg_aip_io {
+	struct wg_aip_io	*a_next;
+
+	struct wg_aip_data {
+		sa_family_t		 d_af;
+		int			 d_cidr;
+		union wg_aip_addr {
+			struct in_addr		addr_ipv4;
+			struct in6_addr		addr_ipv6;
+		}			 d_addr;
+	}			 a_data;
+};
+
+#endif /* __IF_WG_H__ */

commit 5c66f6ecd19037845ea3587ef1cc03928f3fa76b
Author: Matt Dunwoodie <ncon@noconroy.net>
Date:   Sun Dec 29 12:48:38 2019 +1100

    ipc: add support for openbsd kernel implementation
    
    Signed-off-by: Matt Dunwoodie <ncon@noconroy.net>

diff --git a/src/ipc.c b/src/ipc.c
index 8c59ef1..954f239 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -9,6 +9,9 @@
 #include <linux/wireguard.h>
 #include "netlink.h"
 #endif
+#ifdef __OpenBSD__
+#include <net/if_wg.h>
+#endif
 #include <netinet/in.h>
 #include <sys/socket.h>
 #include <net/if.h>
@@ -922,13 +925,269 @@ out:
 }
 #endif
 
+#ifdef __OpenBSD__
+int s = -1;
+
+void
+getsock()
+{
+	if (s < 0)
+		s = socket(AF_INET, SOCK_DGRAM, 0);
+}
+
+static int kernel_get_wireguard_interfaces(struct string_list *list)
+{
+	struct ifgroupreq ifgr;
+	struct ifg_req *ifg;
+	size_t len = 0;
+	int ret = 0;
+
+	getsock();
+
+	bzero(&ifgr, sizeof(ifgr));
+	strlcpy(ifgr.ifgr_name, "wg", sizeof(ifgr.ifgr_name));
+
+	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1)
+		return errno;
+
+	len = ifgr.ifgr_len;
+	if ((ifgr.ifgr_groups = calloc(1, len)) == NULL)
+		return errno;
+	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1) {
+		ret = errno;
+		goto out;
+	}
+
+	for (ifg = ifgr.ifgr_groups; ifg && len > 0; ifg++) {
+		if ((ret = string_list_add(list, ifg->ifgrq_member)) < 0)
+			goto out;
+		len -= sizeof(struct ifg_req);
+	}
+
+out:
+	free(ifgr.ifgr_groups);
+	return ret;
+}
+
+static int kernel_get_device(struct wgdevice **device, const char *iface)
+{
+	struct wg_data_io wgdata;
+	struct wg_interface_io *wg_iface;
+	struct wg_peer_io *wg_peer;
+	struct wg_aip_io *wg_aip;
+
+	struct wgdevice *dev;
+	struct wgpeer *peer;
+	struct wgallowedip *aip;
+
+	size_t size;
+
+	getsock();
+
+	*device = NULL;
+
+	strlcpy(wgdata.wgd_name, iface, sizeof(wgdata.wgd_name));
+	wgdata.wgd_size = size = 0;
+	wgdata.wgd_mem = NULL;
+
+	if (ioctl(s, SIOCGWG, (caddr_t)&wgdata) == -1 &&
+	    (errno == ENOTTY || errno == EPERM))
+		return -errno;
+
+	while (size < wgdata.wgd_size) {
+		size = wgdata.wgd_size;
+		wgdata.wgd_mem = realloc(wgdata.wgd_mem, size);
+		if (ioctl(s, SIOCGWG, (caddr_t)&wgdata) == -1)
+			return -errno;
+	}
+
+	wg_iface = wgdata.wgd_mem;
+
+	if ((dev = calloc(1, sizeof(*dev))) == NULL)
+		return -errno;
+	strlcpy(dev->name, iface, sizeof(dev->name));
+
+	if (wg_iface->i_flags & WG_INTERFACE_HAS_RTABLE) {
+		dev->fwmark = wg_iface->i_rtable;
+		dev->flags |= WGDEVICE_HAS_FWMARK;
+	}
+
+	if (wg_iface->i_flags & WG_INTERFACE_HAS_PORT) {
+		dev->listen_port = ntohs(wg_iface->i_port);
+		dev->flags |= WGDEVICE_HAS_LISTEN_PORT;
+	}
+
+	if (wg_iface->i_flags & WG_INTERFACE_HAS_PUBLIC) {
+		memcpy(dev->public_key, wg_iface->i_public, WG_KEY_SIZE);
+		dev->flags |= WGDEVICE_HAS_PUBLIC_KEY;
+	}
+
+	if (wg_iface->i_flags & WG_INTERFACE_HAS_PRIVATE) {
+		memcpy(dev->private_key, wg_iface->i_private, WG_KEY_SIZE);
+		dev->flags |= WGDEVICE_HAS_PRIVATE_KEY;
+	}
+
+	for (wg_peer = wg_iface->i_peers; wg_peer != NULL; wg_peer = wg_peer->p_next) {
+		if ((peer = calloc(1, sizeof(*peer))) == NULL)
+			return -errno;
+
+		if (dev->first_peer == NULL)
+			dev->first_peer = peer;
+		else
+			dev->last_peer->next_peer = peer;
+		dev->last_peer = peer;
+
+		if (wg_peer->p_flags & WG_PEER_HAS_PUBLIC) {
+			memcpy(peer->public_key, wg_peer->p_public, WG_KEY_SIZE);
+			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
+		}
+
+		if (wg_peer->p_flags & WG_PEER_HAS_PSK) {
+			memcpy(peer->preshared_key, wg_peer->p_psk, WG_KEY_SIZE);
+			peer->flags |= WGPEER_HAS_PRESHARED_KEY;
+		}
+
+		if (wg_peer->p_flags & WG_PEER_HAS_PKA) {
+			peer->persistent_keepalive_interval = wg_peer->p_pka;
+			peer->flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
+		}
+
+		if (wg_peer->p_flags & WG_PEER_HAS_SOCKADDR)
+			memcpy(&peer->endpoint.addr, &wg_peer->p_sa,
+			    wg_peer->p_sa.sa_len);
+
+		peer->rx_bytes = wg_peer->p_rxbytes;
+		peer->tx_bytes = wg_peer->p_txbytes;
+
+		peer->last_handshake_time.tv_sec = wg_peer->p_last_handshake.tv_sec;
+		peer->last_handshake_time.tv_nsec = wg_peer->p_last_handshake.tv_nsec;
+
+		for (wg_aip = wg_peer->p_aips; wg_aip != NULL; wg_aip = wg_aip->a_next) {
+			if ((aip = calloc(1, sizeof(*aip))) == NULL)
+				return -errno;
+
+			if (peer->first_allowedip == NULL)
+				peer->first_allowedip = aip;
+			else
+				peer->last_allowedip->next_allowedip = aip;
+			peer->last_allowedip = aip;
+
+			aip->family = wg_aip->a_af;
+			if (wg_aip->a_af == AF_INET) {
+				memcpy(&aip->ip4, &wg_aip->a_ipv4, sizeof(aip->ip4));
+				aip->cidr = wg_aip->a_mask;
+			} else if (wg_aip->a_af == AF_INET6) {
+				memcpy(&aip->ip6, &wg_aip->a_ipv6, sizeof(aip->ip6));
+				aip->cidr = wg_aip->a_mask;
+			}
+		}
+	}
+
+	*device = dev;
+	free(wgdata.wgd_mem);
+	return 0;
+}
+
+static int kernel_set_device(struct wgdevice *dev)
+{
+	struct wg_data_io wgdata;
+	struct wg_interface_io wg_iface;
+	struct wg_peer_io *wg_peer;
+	struct wg_aip_io *wg_aip;
+
+	struct wgpeer *peer;
+	struct wgallowedip *aip;
+
+	getsock();
+
+	strlcpy(wgdata.wgd_name, dev->name, sizeof(wgdata.wgd_name));
+	wgdata.wgd_mem = &wg_iface;
+
+	bzero(&wg_iface, sizeof(wg_iface));
+
+	if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY) {
+		memcpy(wg_iface.i_private, dev->private_key, WG_KEY_SIZE);
+		wg_iface.i_flags |= WG_INTERFACE_HAS_PRIVATE;
+	}
+
+	if (dev->flags & WGDEVICE_HAS_LISTEN_PORT) {
+		wg_iface.i_port = htons(dev->listen_port);
+		wg_iface.i_flags |= WG_INTERFACE_HAS_PORT;
+	}
+
+	if (dev->flags & WGDEVICE_HAS_FWMARK) {
+		wg_iface.i_rtable = dev->fwmark;
+		wg_iface.i_flags |= WG_INTERFACE_HAS_RTABLE;
+	}
+
+	if (dev->flags & WGDEVICE_REPLACE_PEERS)
+		wg_iface.i_flags |= WG_INTERFACE_REPLACE_PEERS;
+
+	for_each_wgpeer(dev, peer) {
+		if ((wg_peer = calloc(1, sizeof(*wg_peer))) == NULL)
+			return -errno;
+
+		wg_peer->p_flags = WG_PEER_HAS_PUBLIC;
+		memcpy(wg_peer->p_public, peer->public_key, WG_KEY_SIZE);
+
+		if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
+			memcpy(wg_peer->p_psk, peer->preshared_key, WG_KEY_SIZE);
+			wg_peer->p_flags |= WG_PEER_HAS_PSK;
+		}
+
+		if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL) {
+			wg_peer->p_pka = peer->persistent_keepalive_interval;
+			wg_peer->p_flags |= WG_PEER_HAS_PKA;
+		}
+
+		if (peer->endpoint.addr.sa_family == AF_INET ||
+		    peer->endpoint.addr.sa_family == AF_INET6) {
+			memcpy(&wg_peer->p_sa, &peer->endpoint.addr, peer->endpoint.addr.sa_len);
+			wg_peer->p_flags |= WG_PEER_HAS_SOCKADDR;
+		}
+
+		if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
+			wg_peer->p_flags |= WG_PEER_REPLACE_AIPS;
+
+		if (peer->flags & WGPEER_REMOVE_ME)
+			wg_peer->p_flags |= WG_PEER_REMOVE;
+
+		wg_peer->p_next = wg_iface.i_peers;
+		wg_iface.i_peers = wg_peer;
+
+		for_each_wgallowedip(peer, aip) {
+			if ((wg_aip = calloc(1, sizeof(*wg_aip))) == NULL)
+				return -errno;
+
+			wg_aip->a_af = aip->family;
+			wg_aip->a_mask = aip->cidr;
+
+			if (aip->family == AF_INET)
+				memcpy(&wg_aip->a_ipv4, &aip->ip4, sizeof(aip->ip4));
+			else if (aip->family == AF_INET6)
+				memcpy(&wg_aip->a_ipv6, &aip->ip6, sizeof(aip->ip6));
+			else
+				return -1;
+
+			wg_aip->a_next = wg_peer->p_aips;
+			wg_peer->p_aips = wg_aip;
+		}
+	}
+
+	if (ioctl(s, SIOCSWG, (caddr_t)&wgdata) == -1)
+		return -errno;
+
+	return 0;
+}
+#endif /* OpenBSD */
+
 /* first\0second\0third\0forth\0last\0\0 */
 char *ipc_list_devices(void)
 {
 	struct string_list list = { 0 };
 	int ret;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(__OpenBSD__)
 	ret = kernel_get_wireguard_interfaces(&list);
 	if (ret < 0)
 		goto cleanup;
@@ -948,7 +1207,7 @@ cleanup:
 
 int ipc_get_device(struct wgdevice **dev, const char *iface)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(__OpenBSD__)
 	if (userspace_has_wireguard_interface(iface))
 		return userspace_get_device(dev, iface);
 	return kernel_get_device(dev, iface);
@@ -959,7 +1218,7 @@ int ipc_get_device(struct wgdevice **dev, const char *iface)
 
 int ipc_set_device(struct wgdevice *dev)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(__OpenBSD__)
 	if (userspace_has_wireguard_interface(dev->name))
 		return userspace_set_device(dev);
 	return kernel_set_device(dev);

commit b60e30e19607555f8a640e72391a77bcac254e28
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat May 9 23:20:03 2020 -0600

    ipc: remove extra space
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index b9d2532..8c59ef1 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -62,7 +62,7 @@ static int string_list_add(struct string_list *list, const char *str)
 		char *new_buffer;
 		size_t new_cap = list->cap * 2;
 
-		if (new_cap <  list->len +len + 1)
+		if (new_cap < list->len + len + 1)
 			new_cap = list->len + len + 1;
 		new_buffer = realloc(list->buffer, new_cap);
 		if (!new_buffer)

commit 7f236c79570642d466c5acab890b26c3a07f4f7a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 8 23:15:50 2020 -0600

    wg-quick: support dns search domains
    
    If DNS= has an IP in it, treat it as a DNS server. If DNS= has a non-IP
    in it, treat it as a DNS search domain.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/dns-hatchet/hatchet.bash b/contrib/dns-hatchet/hatchet.bash
index 5857cc1..bc4d090 100644
--- a/contrib/dns-hatchet/hatchet.bash
+++ b/contrib/dns-hatchet/hatchet.bash
@@ -2,7 +2,9 @@ set_dns() {
 	[[ ${#DNS[@]} -gt 0 ]] || return 0
 
 	if [[ $(resolvconf --version 2>/dev/null) == openresolv\ * ]]; then
-		printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "$INTERFACE" -m 0 -x
+		{ printf 'nameserver %s\n' "${DNS[@]}"
+		  [[ ${#DNS_SEARCH[@]} -eq 0 ]] || printf 'search %s\n' "${DNS_SEARCH[*]}"
+		} | cmd resolvconf -a "$INTERFACE" -m 0 -x
 	else
 		echo "[#] mount \`${DNS[*]}' /etc/resolv.conf" >&2
 		[[ -e /etc/resolv.conf ]] || touch /etc/resolv.conf
@@ -15,6 +17,7 @@ set_dns() {
 
 		_EOF
 		printf 'nameserver %s\n' "${DNS[@]}"
+		[[ ${#DNS_SEARCH[@]} -eq 0 ]] || printf 'search %s\n' "${DNS_SEARCH[*]}"
 		} | unshare -m --propagation shared bash -c "$(cat <<-_EOF
 			set -e
 			context="\$(stat -c %C /etc/resolv.conf 2>/dev/null)" || unset context
diff --git a/contrib/highlighter/highlighter.c b/contrib/highlighter/highlighter.c
index e0d4e04..d89feda 100644
--- a/contrib/highlighter/highlighter.c
+++ b/contrib/highlighter/highlighter.c
@@ -337,11 +337,6 @@ static bool is_valid_network(string_span_t s)
 	return is_valid_ipv4(s) || is_valid_ipv6(s);
 }
 
-static bool is_valid_dns(string_span_t s)
-{
-	return is_valid_ipv4(s) || is_valid_ipv6(s);
-}
-
 enum field {
 	InterfaceSection,
 	PrivateKey,
@@ -451,7 +446,12 @@ static void highlight_multivalue_value(struct highlight_span_array *ret, const s
 {
 	switch (section) {
 	case DNS:
-		append_highlight_span(ret, parent.s, s, is_valid_dns(s) ? HighlightIP : HighlightError);
+		if (is_valid_ipv4(s) || is_valid_ipv6(s))
+			append_highlight_span(ret, parent.s, s, HighlightIP);
+		else if (is_valid_hostname(s))
+			append_highlight_span(ret, parent.s, s, HighlightHost);
+		else
+			append_highlight_span(ret, parent.s, s, HighlightError);
 		break;
 	case Address:
 	case AllowedIPs: {
diff --git a/src/man/wg-quick.8 b/src/man/wg-quick.8
index eca3b48..c693a89 100644
--- a/src/man/wg-quick.8
+++ b/src/man/wg-quick.8
@@ -76,7 +76,8 @@ Address \(em a comma-separated list of IP (v4 or v6) addresses (optionally with
 to be assigned to the interface. May be specified multiple times.
 .IP \(bu
 DNS \(em a comma-separated list of IP (v4 or v6) addresses to be set as the interface's
-DNS servers. May be specified multiple times. Upon bringing the interface up, this runs
+DNS servers, or non-IP hostnames to be set as the interface's DNS search domains. May be
+specified multiple times. Upon bringing the interface up, this runs
 `resolvconf -a tun.\fIINTERFACE\fP -m 0 -x` and upon bringing it down, this runs
 `resolvconf -d tun.\fIINTERFACE\fP`. If these particular invocations of
 .BR resolvconf (8)
diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 540925a..49ae1e3 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -837,37 +837,49 @@ static void set_dnses(unsigned int netid, const char *dnses)
 	if (len > (1<<16))
 		return;
 	_cleanup_free_ char *mutable = xstrdup(dnses);
-	_cleanup_free_ char *shell_arglist = xmalloc(len * 4 + 1);
-	_cleanup_free_ char *function_arglist = xmalloc(len * 4 + 1);
+	_cleanup_free_ char *dns_shell_arglist = xmalloc(len * 4 + 1);
+	_cleanup_free_ char *dns_search_shell_arglist = xmalloc(len * 4 + 1);
+	_cleanup_free_ char *dns_function_arglist = xmalloc(len * 4 + 1);
+	_cleanup_free_ char *dns_search_function_arglist = xmalloc(len * 4 + 1);
 	_cleanup_free_ char *arg = xmalloc(len + 4);
 	_cleanup_free_ char **dns_list = NULL;
+	_cleanup_free_ char **dns_search_list = NULL;
 	_cleanup_binder_ AIBinder *handle = NULL;
-	size_t dns_list_size = 0;
+	_cleanup_regfree_ regex_t regex_ipnothost = { 0 };
+	size_t dns_list_size = 0, dns_search_list_size = 0;
+	bool is_ip;
 
 	if (!len)
 		return;
+
+	xregcomp(&regex_ipnothost, "^[a-zA-Z0-9_=+.-]{1,15}$", REG_EXTENDED | REG_NOSUB);
 	for (char *dns = strtok(mutable, ", \t\n"); dns; dns = strtok(NULL, ", \t\n")) {
 		if (strchr(dns, '\'') || strchr(dns, '\\'))
 			continue;
-		++dns_list_size;
+		++*(!regexec(&regex_ipnothost, dns, 0, NULL, 0) ? &dns_list_size : &dns_search_list_size);
 	}
 	if (!dns_list_size)
 		return;
 	dns_list = xcalloc(dns_list_size + 1, sizeof(*dns_list));
+	dns_search_list = xcalloc(dns_search_list_size + 1, sizeof(*dns_search_list));
 	free(mutable);
 	mutable = xstrdup(dnses);
 
-	shell_arglist[0] = '\0';
-	function_arglist[0] = '\0';
+	dns_shell_arglist[0] = '\0';
+	dns_search_shell_arglist[0] = '\0';
+	dns_function_arglist[0] = '\0';
+	dns_search_function_arglist[0] = '\0';
 	dns_list_size = 0;
+	dns_search_list_size = 0;
 	for (char *dns = strtok(mutable, ", \t\n"); dns; dns = strtok(NULL, ", \t\n")) {
 		if (strchr(dns, '\'') || strchr(dns, '\\'))
 			continue;
+		is_ip = !regexec(&regex_ipnothost, dns, 0, NULL, 0);
 		snprintf(arg, len + 3, "'%s' ", dns);
-		strncat(shell_arglist, arg, len * 4 - 1);
-		snprintf(arg, len + 2, function_arglist[0] == '\0' ? "%s" : ", %s", dns);
-		strncat(function_arglist, arg, len * 4 - 1);
-		dns_list[dns_list_size++] = dns;
+		strncat(is_ip ? dns_shell_arglist : dns_search_shell_arglist, arg, len * 4 - 1);
+		snprintf(arg, len + 2, (is_ip ? dns_function_arglist[0] : dns_search_function_arglist[0]) == '\0' ? "%s" : ", %s", dns);
+		strncat(is_ip ? dns_function_arglist : dns_search_function_arglist, arg, len * 4 - 1);
+		*(is_ip ? &dns_list[dns_list_size++] : &dns_search_list[dns_search_list_size++]) = dns;
 	}
 
 	if ((handle = dnsresolver_get_handle())) {
@@ -889,15 +901,16 @@ static void set_dnses(unsigned int netid, const char *dnses)
 			.base_timeout_msec = DNSRESOLVER_BASE_TIMEOUT,
 			.retry_count = DNSRESOLVER_RETRY_COUNT,
 			.servers = dns_list,
-			.domains = (char *[]){NULL},
+			.domains = dns_search_list,
 			.tls_name = "",
 			.tls_servers = (char *[]){NULL},
 			.tls_fingerprints = (char *[]){NULL}
 		};
 
-		printf("[#] <binder>::dnsResolver->setResolverConfiguration(%u, [%s], [], %d, %d, %d, %d, %d, %d, [], [])\n",
-		       netid, function_arglist, DNSRESOLVER_SAMPLE_VALIDITY, DNSRESOLVER_SUCCESS_THRESHOLD,
-		       DNSRESOLVER_MIN_SAMPLES, DNSRESOLVER_MAX_SAMPLES, DNSRESOLVER_BASE_TIMEOUT, DNSRESOLVER_RETRY_COUNT);
+		printf("[#] <binder>::dnsResolver->setResolverConfiguration(%u, [%s], [%s], %d, %d, %d, %d, %d, %d, [], [])\n",
+		       netid, dns_function_arglist, dns_search_function_arglist, DNSRESOLVER_SAMPLE_VALIDITY,
+		       DNSRESOLVER_SUCCESS_THRESHOLD, DNSRESOLVER_MIN_SAMPLES, DNSRESOLVER_MAX_SAMPLES,
+		       DNSRESOLVER_BASE_TIMEOUT, DNSRESOLVER_RETRY_COUNT);
 		status = dnsresolver_set_resolver_configuration(handle, &params);
 
 		if (status != 0) {
@@ -905,7 +918,7 @@ static void set_dnses(unsigned int netid, const char *dnses)
 			exit(ENONET);
 		}
 	} else
-		cndc("resolver setnetdns %u '' %s", netid, shell_arglist);
+		cndc("resolver setnetdns %u '%s' %s", netid, dns_search_shell_arglist, dns_shell_arglist);
 }
 
 static void add_addr(const char *iface, const char *addr)
diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index d9d07cf..cde1b54 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -18,6 +18,7 @@ INTERFACE=""
 ADDRESSES=( )
 MTU=""
 DNS=( )
+DNS_SEARCH=( )
 TABLE=""
 PRE_UP=( )
 POST_UP=( )
@@ -43,7 +44,7 @@ die() {
 CONFIG_SEARCH_PATHS=( /etc/wireguard /usr/local/etc/wireguard )
 
 parse_options() {
-	local interface_section=0 line key value stripped path
+	local interface_section=0 line key value stripped path v
 	CONFIG_FILE="$1"
 	if [[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]]; then
 		for path in "${CONFIG_SEARCH_PATHS[@]}"; do
@@ -67,7 +68,9 @@ parse_options() {
 			case "$key" in
 			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
 			MTU) MTU="$value"; continue ;;
-			DNS) DNS+=( ${value//,/ } ); continue ;;
+			DNS) for v in ${value//,/ }; do
+				[[ $v =~ (^[0-9.]+$)|(^.*:.*$) ]] && DNS+=( $v ) || DNS_SEARCH+=( $v )
+			done; continue ;;
 			Table) TABLE="$value"; continue ;;
 			PreUp) PRE_UP+=( "$value" ); continue ;;
 			PreDown) PRE_DOWN+=( "$value" ); continue ;;
@@ -213,6 +216,7 @@ collect_endpoints() {
 }
 
 declare -A SERVICE_DNS
+declare -A SERVICE_DNS_SEARCH
 collect_new_service_dns() {
 	local service get_response
 	local -A found_services
@@ -223,10 +227,16 @@ collect_new_service_dns() {
 		get_response="$(cmd networksetup -getdnsservers "$service")"
 		[[ $get_response == *" "* ]] && get_response="Empty"
 		[[ -n $get_response ]] && SERVICE_DNS["$service"]="$get_response"
+		get_response="$(cmd networksetup -getsearchdomains "$service")"
+		[[ $get_response == *" "* ]] && get_response="Empty"
+		[[ -n $get_response ]] && SERVICE_DNS_SEARCH["$service"]="$get_response"
 	done; } < <(networksetup -listallnetworkservices)
 
 	for service in "${!SERVICE_DNS[@]}"; do
-		[[ -n ${found_services["$service"]} ]] || unset SERVICE_DNS["$service"]
+		if ! [[ -n ${found_services["$service"]} ]]; then
+			unset SERVICE_DNS["$service"]
+			unset SERVICE_DNS_SEARCH["$service"]
+		fi
 	done
 }
 
@@ -287,7 +297,14 @@ set_dns() {
 	for service in "${!SERVICE_DNS[@]}"; do
 		while read -r response; do
 			[[ $response == *Error* ]] && echo "$response" >&2
-		done < <(cmd networksetup -setdnsservers "$service" "${DNS[@]}")
+		done < <(
+			cmd networksetup -setdnsservers "$service" "${DNS[@]}"
+			if [[ ${#DNS_SEARCH[@]} -eq 0 ]]; then
+				cmd networksetup -setsearchdomains "$service" Empty
+			else
+				cmd networksetup -setsearchdomains "$service" "${DNS_SEARCH[@]}"
+			fi
+		)
 	done
 }
 
@@ -296,7 +313,10 @@ del_dns() {
 	for service in "${!SERVICE_DNS[@]}"; do
 		while read -r response; do
 			[[ $response == *Error* ]] && echo "$response" >&2
-		done < <(cmd networksetup -setdnsservers "$service" ${SERVICE_DNS["$service"]} || true)
+		done < <(
+			cmd networksetup -setdnsservers "$service" ${SERVICE_DNS["$service"]} || true
+			cmd networksetup -setsearchdomains "$service" ${SERVICE_DNS_SEARCH["$service"]} || true
+		)
 	done
 }
 
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index c390dcc..e1ee67f 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -16,6 +16,7 @@ INTERFACE=""
 ADDRESSES=( )
 MTU=""
 DNS=( )
+DNS_SEARCH=( )
 TABLE=""
 PRE_UP=( )
 POST_UP=( )
@@ -60,7 +61,7 @@ clean_temp() {
 }
 
 parse_options() {
-	local interface_section=0 line key value stripped path
+	local interface_section=0 line key value stripped path v
 	CONFIG_FILE="$1"
 	if [[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]]; then
 		for path in "${CONFIG_SEARCH_PATHS[@]}"; do
@@ -84,7 +85,9 @@ parse_options() {
 			case "$key" in
 			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
 			MTU) MTU="$value"; continue ;;
-			DNS) DNS+=( ${value//,/ } ); continue ;;
+			DNS) for v in ${value//,/ }; do
+				[[ $v =~ (^[0-9.]+$)|(^.*:.*$) ]] && DNS+=( $v ) || DNS_SEARCH+=( $v )
+			done; continue ;;
 			Table) TABLE="$value"; continue ;;
 			PreUp) PRE_UP+=( "$value" ); continue ;;
 			PreDown) PRE_DOWN+=( "$value" ); continue ;;
@@ -297,7 +300,9 @@ monitor_daemon() {
 HAVE_SET_DNS=0
 set_dns() {
 	[[ ${#DNS[@]} -gt 0 ]] || return 0
-	printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "$INTERFACE" -x
+	{ printf 'nameserver %s\n' "${DNS[@]}"
+	  [[ ${#DNS_SEARCH[@]} -eq 0 ]] || printf 'search %s\n' "${DNS_SEARCH[*]}"
+	} | cmd resolvconf -a "$INTERFACE" -x
 	HAVE_SET_DNS=1
 }
 
diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 7c2c002..1150be5 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -16,6 +16,7 @@ INTERFACE=""
 ADDRESSES=( )
 MTU=""
 DNS=( )
+DNS_SEARCH=( )
 TABLE=""
 PRE_UP=( )
 POST_UP=( )
@@ -37,7 +38,7 @@ die() {
 }
 
 parse_options() {
-	local interface_section=0 line key value stripped
+	local interface_section=0 line key value stripped v
 	CONFIG_FILE="$1"
 	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
@@ -56,7 +57,9 @@ parse_options() {
 			case "$key" in
 			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
 			MTU) MTU="$value"; continue ;;
-			DNS) DNS+=( ${value//,/ } ); continue ;;
+			DNS) for v in ${value//,/ }; do
+				[[ $v =~ (^[0-9.]+$)|(^.*:.*$) ]] && DNS+=( $v ) || DNS_SEARCH+=( $v )
+			done; continue ;;
 			Table) TABLE="$value"; continue ;;
 			PreUp) PRE_UP+=( "$value" ); continue ;;
 			PreDown) PRE_DOWN+=( "$value" ); continue ;;
@@ -150,7 +153,9 @@ resolvconf_iface_prefix() {
 HAVE_SET_DNS=0
 set_dns() {
 	[[ ${#DNS[@]} -gt 0 ]] || return 0
-	printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "$(resolvconf_iface_prefix)$INTERFACE" -m 0 -x
+	{ printf 'nameserver %s\n' "${DNS[@]}"
+	  [[ ${#DNS_SEARCH[@]} -eq 0 ]] || printf 'search %s\n' "${DNS_SEARCH[*]}"
+	} | cmd resolvconf -a "$(resolvconf_iface_prefix)$INTERFACE" -m 0 -x
 	HAVE_SET_DNS=1
 }
 
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index 8d458d1..9584902 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -16,6 +16,7 @@ INTERFACE=""
 ADDRESSES=( )
 MTU=""
 DNS=( )
+DNS_SEARCH=( )
 TABLE=""
 PRE_UP=( )
 POST_UP=( )
@@ -56,7 +57,9 @@ parse_options() {
 			case "$key" in
 			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
 			MTU) MTU="$value"; continue ;;
-			DNS) DNS+=( ${value//,/ } ); continue ;;
+			DNS) for v in ${value//,/ }; do
+				[[ $v =~ (^[0-9.]+$)|(^.*:.*$) ]] && DNS+=( $v ) || DNS_SEARCH+=( $v )
+			done; continue ;;
 			Table) TABLE="$value"; continue ;;
 			PreUp) PRE_UP+=( "$value" ); continue ;;
 			PreDown) PRE_DOWN+=( "$value" ); continue ;;
@@ -270,7 +273,9 @@ set_dns() {
 	[[ ${#DNS[@]} -gt 0 ]] || return 0
 	# TODO: this is a horrible way of doing it. Has OpenBSD no resolvconf?
 	cmd cp /etc/resolv.conf "/etc/resolv.conf.wg-quick-backup.$INTERFACE"
-	cmd printf 'nameserver %s\n' "${DNS[@]}" > /etc/resolv.conf
+	{ cmd printf 'nameserver %s\n' "${DNS[@]}"
+	  [[ ${#DNS_SEARCH[@]} -eq 0 ]] || cmd printf 'search %s\n' "${DNS_SEARCH[*]}"
+	} > /etc/resolv.conf
 }
 
 unset_dns() {

commit 238ca4059136f5cd8a2f7defbf1772a9eafe8625
Author: Martin Hauke <mardnh@gmx.de>
Date:   Fri May 1 23:55:55 2020 +0200

    systemd: add wg-quick.target
    
    Add file wg-quick.target, which allows starting and stopping all
    wg-quick@.service instances at once.
    
    Signed-off-by: Martin Hauke <mardnh@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/systemd/wg-quick.target b/src/systemd/wg-quick.target
new file mode 100644
index 0000000..c209890
--- /dev/null
+++ b/src/systemd/wg-quick.target
@@ -0,0 +1,2 @@
+[Unit]
+Description=WireGuard Tunnels via wg-quick(8)
diff --git a/src/systemd/wg-quick@.service b/src/systemd/wg-quick@.service
index 7c5f9d1..a9cbb58 100644
--- a/src/systemd/wg-quick@.service
+++ b/src/systemd/wg-quick@.service
@@ -2,6 +2,7 @@
 Description=WireGuard via wg-quick(8) for %I
 After=network-online.target nss-lookup.target
 Wants=network-online.target nss-lookup.target
+PartOf=wg-quick.target
 Documentation=man:wg-quick(8)
 Documentation=man:wg(8)
 Documentation=https://www.wireguard.com/

commit 891fb523a23a33a8e3832319877159753bfd057a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Apr 20 22:52:35 2020 -0600

    terminal: specialize color_mode to stdout only
    
    By specializing this to stdout, we can cache the isatty result.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/terminal.c b/src/terminal.c
index ba88597..bea27ba 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -12,7 +12,7 @@
 #include <stdbool.h>
 #include <unistd.h>
 
-static bool color_mode(FILE *file)
+static bool color_mode(void)
 {
 	static int mode = -1;
 	const char *var;
@@ -25,17 +25,17 @@ static bool color_mode(FILE *file)
 	else if (var && !strcmp(var, "never"))
 		mode = false;
 	else
-		return isatty(fileno(file));
+		mode = isatty(fileno(stdout));
 	return mode;
 }
 
-static void filter_ansi(FILE *file, const char *fmt, va_list args)
+static void filter_ansi(const char *fmt, va_list args)
 {
 	char *str = NULL;
 	size_t len, i, j;
 
-	if (color_mode(file)) {
-		vfprintf(file, fmt, args);
+	if (color_mode()) {
+		vfprintf(stdout, fmt, args);
 		return;
 	}
 
@@ -55,7 +55,7 @@ static void filter_ansi(FILE *file, const char *fmt, va_list args)
 		}
 	}
 	for (i = 0; i < len; i = j) {
-		fputs(&str[i], file);
+		fputs(&str[i], stdout);
 		for (j = i + strlen(&str[i]); j < len; ++j) {
 			if (str[j] != '\0')
 				break;
@@ -70,15 +70,6 @@ void terminal_printf(const char *fmt, ...)
 	va_list args;
 
 	va_start(args, fmt);
-	filter_ansi(stdout, fmt, args);
-	va_end(args);
-}
-
-void terminal_fprintf(FILE *file, const char *fmt, ...)
-{
-	va_list args;
-
-	va_start(args, fmt);
-	filter_ansi(file, fmt, args);
+	filter_ansi(fmt, args);
 	va_end(args);
 }
diff --git a/src/terminal.h b/src/terminal.h
index e8cb570..58697fa 100644
--- a/src/terminal.h
+++ b/src/terminal.h
@@ -47,6 +47,5 @@
 #define TERMINAL_CLEAR_ALL	"\x1b[2J"
 
 void terminal_printf(const char *fmt, ...) __attribute__((format(printf, 1, 2)));
-void terminal_fprintf(FILE *file, const char *fmt, ...) __attribute__((format(printf, 2, 3)));
 
 #endif

commit 3377409bb334e8d371f254586210e3884b7e7c75
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Apr 8 23:51:16 2020 -0600

    git: add gitattributes so tarball doesn't have gitignore files
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..5966153
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,2 @@
+.gitattributes export-ignore
+.gitignore export-ignore

commit e189f9942d54b6900f7140c1f4a41312cb6889eb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 5 19:38:11 2020 -0600

    wg-quick: android: support application whitelist
    
    Prior we only supported a blacklist, but actually a whitelist is an
    easier algorithm because that's internally how netd considers it, so we
    don't need to find range spans. This commit adds an IncludedApplications
    key.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 54ea81c..540925a 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -782,31 +782,49 @@ static uid_t *get_uid_list(const char *selected_applications)
 	return uid_list;
 }
 
-static void set_users(unsigned int netid, const char *excluded_applications)
+static void set_users(unsigned int netid, const char *excluded_applications, const char *included_applications)
 {
-	_cleanup_free_ uid_t *excluded_uids = get_uid_list(excluded_applications);
+	_cleanup_free_ uid_t *uids = NULL;
 	unsigned int args_per_command = 0;
 	_cleanup_free_ char *ranges = NULL;
 	char range[22];
 	uid_t start;
 
-	for (start = 0; *excluded_uids; start = *excluded_uids + 1, ++excluded_uids) {
-		if (start > *excluded_uids - 1)
-			continue;
-		else if (start == *excluded_uids - 1)
-			snprintf(range, sizeof(range), "%u", start);
-		else
-			snprintf(range, sizeof(range), "%u-%u", start, *excluded_uids - 1);
-		ranges = concat_and_free(ranges, " ", range);
-		if (++args_per_command % 18 == 0) {
-			cndc("network users add %u %s", netid, ranges);
-			free(ranges);
-			ranges = NULL;
-		}
+	if (excluded_applications && included_applications) {
+		fprintf(stderr, "Error: only one of ExcludedApplications and IncludedApplications may be specified, but not both\n");
+		exit(EEXIST);
 	}
-	if (start < 99999) {
-		snprintf(range, sizeof(range), "%u-99999", start);
-		ranges = concat_and_free(ranges, " ", range);
+
+	if (excluded_applications || !included_applications) {
+		uids = get_uid_list(excluded_applications);
+		for (start = 0; *uids; start = *uids + 1, ++uids) {
+			if (start > *uids - 1)
+				continue;
+			else if (start == *uids - 1)
+				snprintf(range, sizeof(range), "%u", start);
+			else
+				snprintf(range, sizeof(range), "%u-%u", start, *uids - 1);
+			ranges = concat_and_free(ranges, " ", range);
+			if (++args_per_command % 18 == 0) {
+				cndc("network users add %u %s", netid, ranges);
+				free(ranges);
+				ranges = NULL;
+			}
+		}
+		if (start < 99999) {
+			snprintf(range, sizeof(range), "%u-99999", start);
+			ranges = concat_and_free(ranges, " ", range);
+		}
+	} else {
+		for (uids = get_uid_list(included_applications); *uids; ++uids) {
+			snprintf(range, sizeof(range), "%u", *uids);
+			ranges = concat_and_free(ranges, " ", range);
+			if (++args_per_command % 18 == 0) {
+				cndc("network users add %u %s", netid, ranges);
+				free(ranges);
+				ranges = NULL;
+			}
+		}
 	}
 
 	if (ranges)
@@ -1063,7 +1081,8 @@ static void cmd_usage(const char *program)
 		"    IP addresses (with an optional CIDR mask) to be set for the interface.\n"
 		"  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.\n"
 		"  - DNS: an optional DNS server to use while the device is up.\n"
-		"  - ExcludedApplications: optional applications to exclude from the tunnel.\n\n"
+		"  - ExcludedApplications: optional blacklist of applications to exclude from the tunnel.\n\n"
+		"  - IncludedApplications: optional whitelist of applications to include in the tunnel.\n\n"
 		"  See wg-quick(8) for more info and examples.\n");
 }
 
@@ -1077,7 +1096,7 @@ static void cmd_up_cleanup(void)
 	free(cleanup_iface);
 }
 
-static void cmd_up(const char *iface, const char *config, unsigned int mtu, const char *addrs, const char *dnses, const char *excluded_applications)
+static void cmd_up(const char *iface, const char *config, unsigned int mtu, const char *addrs, const char *dnses, const char *excluded_applications, const char *included_applications)
 {
 	DEFINE_CMD(c);
 	unsigned int netid = 0;
@@ -1099,7 +1118,7 @@ static void cmd_up(const char *iface, const char *config, unsigned int mtu, cons
 	set_dnses(netid, dnses);
 	set_routes(iface, netid);
 	set_mtu(iface, mtu);
-	set_users(netid, excluded_applications);
+	set_users(netid, excluded_applications, included_applications);
 	broadcast_change();
 
 	free(cleanup_iface);
@@ -1131,7 +1150,7 @@ static void cmd_down(const char *iface)
 	exit(EXIT_SUCCESS);
 }
 
-static void parse_options(char **iface, char **config, unsigned int *mtu, char **addrs, char **dnses, char **excluded_applications, const char *arg)
+static void parse_options(char **iface, char **config, unsigned int *mtu, char **addrs, char **dnses, char **excluded_applications, char **included_applications, const char *arg)
 {
 	_cleanup_fclose_ FILE *file = NULL;
 	_cleanup_free_ char *line = NULL;
@@ -1215,6 +1234,9 @@ static void parse_options(char **iface, char **config, unsigned int *mtu, char *
 			} else if (!strncasecmp(clean, "ExcludedApplications=", 21) && j > 4) {
 				*excluded_applications = concat_and_free(*excluded_applications, ",", clean + 21);
 				continue;
+			} else if (!strncasecmp(clean, "IncludedApplications=", 21) && j > 4) {
+				*included_applications = concat_and_free(*included_applications, ",", clean + 21);
+				continue;
 			} else if (!strncasecmp(clean, "MTU=", 4) && j > 4) {
 				*mtu = atoi(clean + 4);
 				continue;
@@ -1240,17 +1262,18 @@ int main(int argc, char *argv[])
 	_cleanup_free_ char *addrs = NULL;
 	_cleanup_free_ char *dnses = NULL;
 	_cleanup_free_ char *excluded_applications = NULL;
+	_cleanup_free_ char *included_applications = NULL;
 	unsigned int mtu;
 
 	if (argc == 2 && (!strcmp(argv[1], "help") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "-h")))
 		cmd_usage(argv[0]);
 	else if (argc == 3 && !strcmp(argv[1], "up")) {
 		auto_su(argc, argv);
-		parse_options(&iface, &config, &mtu, &addrs, &dnses, &excluded_applications, argv[2]);
-		cmd_up(iface, config, mtu, addrs, dnses, excluded_applications);
+		parse_options(&iface, &config, &mtu, &addrs, &dnses, &excluded_applications, &included_applications, argv[2]);
+		cmd_up(iface, config, mtu, addrs, dnses, excluded_applications, included_applications);
 	} else if (argc == 3 && !strcmp(argv[1], "down")) {
 		auto_su(argc, argv);
-		parse_options(&iface, &config, &mtu, &addrs, &dnses, &excluded_applications, argv[2]);
+		parse_options(&iface, &config, &mtu, &addrs, &dnses, &excluded_applications, &included_applications, argv[2]);
 		cmd_down(iface);
 	} else {
 		cmd_usage(argv[0]);

commit 20e28d2b0f4ae522cf14abcc5a29f9ade24f217b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Apr 3 23:14:07 2020 -0600

    highlighter: insist on 256-bit keys, not 257-bit or 258-bit
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/highlighter/highlighter.c b/contrib/highlighter/highlighter.c
index 9f0e53a..e0d4e04 100644
--- a/contrib/highlighter/highlighter.c
+++ b/contrib/highlighter/highlighter.c
@@ -62,11 +62,32 @@ static bool is_valid_key(string_span_t s)
 	if (s.len != 44 || s.s[43] != '=')
 		return false;
 
-	for (size_t i = 0; i < 43; ++i) {
+	for (size_t i = 0; i < 42; ++i) {
 		if (!is_decimal(s.s[i]) && !is_alphabet(s.s[i]) &&
 		    s.s[i] != '/' && s.s[i] != '+')
 			return false;
 	}
+	switch (s.s[42]) {
+	case 'A':
+	case 'E':
+	case 'I':
+	case 'M':
+	case 'Q':
+	case 'U':
+	case 'Y':
+	case 'c':
+	case 'g':
+	case 'k':
+	case 'o':
+	case 's':
+	case 'w':
+	case '4':
+	case '8':
+	case '0':
+		break;
+	default:
+		return false;
+	}
 	return true;
 }
 

commit dc00c8c577bb8260da9c9c937af907751d7ffd24
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Mar 23 00:06:24 2020 -0600

    Makefile: simplify silent cleaning
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index ec5d3a6..341a90e 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -67,18 +67,14 @@ LINK.o += $(BUILT_IN_LINK.o)
 BUILT_IN_COMPILE.c := $(COMPILE.c)
 COMPILE.c = @echo "  CC      $@";
 COMPILE.c += $(BUILT_IN_COMPILE.c)
+BUILT_IN_RM := $(RM)
+RM := @a() { echo "  CLEAN   $$@"; $(BUILT_IN_RM) "$$@"; }; a
 endif
 
 wg: $(sort $(patsubst %.c,%.o,$(wildcard *.c)))
 
-ifneq ($(V),1)
-clean:
-	@echo "  CLEAN   {wg,*.o,*.d}"
-	@$(RM) wg *.o *.d
-else
 clean:
 	$(RM) wg *.o *.d
-endif
 
 install: wg
 	@install -v -d "$(DESTDIR)$(BINDIR)" && install -v -m 0755 wg "$(DESTDIR)$(BINDIR)/wg"

commit a8063adc8ae9b4fc9848500e93f94bee8ad2e585
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Mar 19 16:46:35 2020 -0600

    version: bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
index c1782f6..ea2fd63 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1,3 +1,3 @@
 #ifndef WIREGUARD_TOOLS_VERSION
-#define WIREGUARD_TOOLS_VERSION "1.0.20200206"
+#define WIREGUARD_TOOLS_VERSION "1.0.20200319"
 #endif

commit be969b7fe1ceda4f2df839e622ec1e27db0667c9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Mar 19 16:33:14 2020 -0600

    wincompat: use new protected prefix on Windows
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wincompat/ipc.c b/src/wincompat/ipc.c
index ce8fdb6..86fab07 100644
--- a/src/wincompat/ipc.c
+++ b/src/wincompat/ipc.c
@@ -115,6 +115,7 @@ err:
 
 static int userspace_get_wireguard_interfaces(struct string_list *list)
 {
+	static const char prefix[] = "ProtectedPrefix\\Administrators\\WireGuard\\";
 	WIN32_FIND_DATA find_data;
 	HANDLE find_handle;
 	int ret = 0;
@@ -123,9 +124,9 @@ static int userspace_get_wireguard_interfaces(struct string_list *list)
 	if (find_handle == INVALID_HANDLE_VALUE)
 		return -GetLastError();
 	do {
-		if (strncmp("WireGuard\\", find_data.cFileName, 10))
+		if (strncmp(prefix, find_data.cFileName, strlen(prefix)))
 			continue;
-		ret = string_list_add(list, find_data.cFileName + 10);
+		ret = string_list_add(list, find_data.cFileName + strlen(prefix));
 		if (ret < 0)
 			goto out;
 	} while (FindNextFile(find_handle, &find_data));

commit e98b84ab84ca11948f5b3dc0dddea9e0d8fd21e4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Mar 19 16:29:27 2020 -0600

    wincompat: use string_list instead of inflatable_buffer
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wincompat/ipc.c b/src/wincompat/ipc.c
index 9dce816..ce8fdb6 100644
--- a/src/wincompat/ipc.c
+++ b/src/wincompat/ipc.c
@@ -113,7 +113,7 @@ err:
 	return NULL;
 }
 
-static int userspace_get_wireguard_interfaces(struct inflatable_buffer *buffer)
+static int userspace_get_wireguard_interfaces(struct string_list *list)
 {
 	WIN32_FIND_DATA find_data;
 	HANDLE find_handle;
@@ -125,9 +125,7 @@ static int userspace_get_wireguard_interfaces(struct inflatable_buffer *buffer)
 	do {
 		if (strncmp("WireGuard\\", find_data.cFileName, 10))
 			continue;
-		buffer->next = strdup(find_data.cFileName + 10);
-		buffer->good = true;
-		ret = add_next_to_inflatable_buffer(buffer);
+		ret = string_list_add(list, find_data.cFileName + 10);
 		if (ret < 0)
 			goto out;
 	} while (FindNextFile(find_handle, &find_data));

commit 828ffc88cd6d6813a82520640d09e7827bf2dcd2
Author: Luis Ressel <aranea@aixah.de>
Date:   Mon Feb 24 13:00:08 2020 +0100

    man: add a warning to the SaveConfig description
    
    Signed-off-by: Luis Ressel <aranea@aixah.de>
    [zx2c4: slightly adjusted wording]
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg-quick.8 b/src/man/wg-quick.8
index c38c7d9..eca3b48 100644
--- a/src/man/wg-quick.8
+++ b/src/man/wg-quick.8
@@ -99,7 +99,8 @@ is expanded to \fIINTERFACE\fP. Each one may be specified multiple times, in whi
 the commands are executed in order.
 .IP \(bu
 SaveConfig \(em if set to `true', the configuration is saved from the current state of the
-interface upon shutdown.
+interface upon shutdown. Any changes made to the configuration file before the
+interface is removed will therefore be overwritten.
 
 .P
 Recommended \fIINTERFACE\fP names include `wg0' or `wgvpn0' or even `wgmgmtlan0'.

commit bd4f84737258b78a3a4cdcbaddb94b263268efdc
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 12 15:46:23 2020 +0100

    man: backlink wg-quick(8) in wg(8)
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg.8 b/src/man/wg.8
index f5edfec..2786623 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -233,6 +233,7 @@ If set to \fInever\fP, then the pretty-printing \fBshow\fP sub-command will show
 If set to an integer or to \fIinfinity\fP, DNS resolution for each peer's endpoint will be retried that many times for non-permanent errors, with an increasing delay between retries. If unset, the default is 15 retries.
 
 .SH SEE ALSO
+.BR wg-quick (8),
 .BR ip (8),
 .BR ip-link (8),
 .BR ip-address (8),

commit 6fabf9c2fbd056c8c6d5ee9ffd69685aab6baaeb
Author: Kai Haberzettl <khaberz@gmail.com>
Date:   Sat Feb 8 21:23:47 2020 +0100

    man: fix grammar in wg(8) and wg-quick(8)
    
    This fixes a few grammatical errors.
    
    Signed-off-by: Kai Haberzettl <khaberz@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg-quick.8 b/src/man/wg-quick.8
index 6250adc..c38c7d9 100644
--- a/src/man/wg-quick.8
+++ b/src/man/wg-quick.8
@@ -56,7 +56,7 @@ as usual.
 
 The configuration file adds a few extra configuration values to the format understood by
 .BR wg (8)
-in order to configure additional attribute of an interface. It handles the
+in order to configure additional attributes of an interface. It handles the
 values that it understands, and then it passes the remaining ones directly to
 .BR wg (8)
 for further processing.
diff --git a/src/man/wg.8 b/src/man/wg.8
index 27860c8..f5edfec 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -40,7 +40,7 @@ Sub-commands that take an INTERFACE must be passed a WireGuard interface.
 Shows current WireGuard configuration and runtime information of specified \fI<interface>\fP.
 If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
 If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,
-one per line, and quit. If no options are given after the interface
+one per line, and quits. If no options are given after the interface
 specification, then prints a list of all attributes in a visually pleasing way
 meant for the terminal. Otherwise, prints specified information grouped by
 newlines and tabs, meant to be used in scripts. For this script-friendly display,
@@ -61,7 +61,7 @@ Sets configuration values for the specified \fI<interface>\fP. Multiple
 for a peer, that peer is removed, not configured. If \fIlisten-port\fP
 is not specified, or set to 0, the port will be chosen randomly when the
 interface comes up. Both \fIprivate-key\fP and \fIpreshared-key\fP must
-be a files, because command line arguments are not considered private on
+be files, because command line arguments are not considered private on
 most systems but if you are using
 .BR bash (1),
 you may safely pass in a string by specifying as \fIprivate-key\fP or

commit d68b8b189c2671c261d0e49b02eaf2b86b5947fa
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Feb 7 15:46:59 2020 +0100

    curve25519: squelch warnings on clang
    
    These are generic helper functions we don't want to move into the actual
    implementations, so that it's easy to keep parity with the kernel code.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 7d3fd15..1739a9e 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -39,35 +39,39 @@ typedef int64_t s64;
 #define le32_to_cpup(a) (*(a))
 #define cpu_to_le64(a) (a)
 #endif
-static inline __le32 get_unaligned_le32(const u8 *a)
+#ifndef __unused
+#define __unused  __attribute__((unused))
+#endif
+#ifndef __always_inline
+#define __always_inline __inline __attribute__((__always_inline__))
+#endif
+#ifndef noinline
+#define noinline __attribute__((noinline))
+#endif
+#ifndef __aligned
+#define __aligned(x) __attribute__((aligned(x)))
+#endif
+#ifndef __force
+#define __force
+#endif
+
+static __always_inline __unused __le32 get_unaligned_le32(const u8 *a)
 {
 	__le32 l;
 	__builtin_memcpy(&l, a, sizeof(l));
 	return le32_to_cpup(&l);
 }
-static inline __le64 get_unaligned_le64(const u8 *a)
+static __always_inline __unused __le64 get_unaligned_le64(const u8 *a)
 {
 	__le64 l;
 	__builtin_memcpy(&l, a, sizeof(l));
 	return le64_to_cpup(&l);
 }
-static inline void put_unaligned_le64(u64 s, u8 *d)
+static __always_inline __unused void put_unaligned_le64(u64 s, u8 *d)
 {
 	__le64 l = cpu_to_le64(s);
 	__builtin_memcpy(d, &l, sizeof(l));
 }
-#ifndef __always_inline
-#define __always_inline __inline __attribute__((__always_inline__))
-#endif
-#ifndef noinline
-#define noinline __attribute__((noinline))
-#endif
-#ifndef __aligned
-#define __aligned(x) __attribute__((aligned(x)))
-#endif
-#ifndef __force
-#define __force
-#endif
 
 static noinline void memzero_explicit(void *s, size_t count)
 {

commit e5b08c2849256367fc6bf37be9e737bdb21ee66d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Feb 6 17:20:15 2020 +0100

    netlink: initialize mostly unused field
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/netlink.h b/src/netlink.h
index 9d936c0..f9729ee 100644
--- a/src/netlink.h
+++ b/src/netlink.h
@@ -737,6 +737,7 @@ static struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t ver
 	nlg = malloc(sizeof(*nlg));
 	if (!nlg)
 		return NULL;
+	nlg->id = 0;
 
 	err = -ENOMEM;
 	nlg->buf = malloc(mnl_ideal_socket_buffer_size());

commit 0bf1f7a3e877aff8fb435c3ba8624f35ff985a7e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Feb 6 16:19:47 2020 +0100

    version: bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
index 09282b0..c1782f6 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1,3 +1,3 @@
 #ifndef WIREGUARD_TOOLS_VERSION
-#define WIREGUARD_TOOLS_VERSION "1.0.20200121"
+#define WIREGUARD_TOOLS_VERSION "1.0.20200206"
 #endif

commit 0dc32bbeaf05c0ac7f4b6d131c0473434e12e25a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 5 23:59:55 2020 +0100

    netlink: don't pretend that sysconf isn't a function
    
    We can cache the value of this instead of evaluating every time.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index a0bf607..b9d2532 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -40,7 +40,7 @@
 #define SOCK_PATH RUNSTATEDIR "/wireguard/"
 #define SOCK_SUFFIX ".sock"
 #ifdef __linux__
-#define SOCKET_BUFFER_SIZE MNL_SOCKET_BUFFER_SIZE
+#define SOCKET_BUFFER_SIZE (mnl_ideal_socket_buffer_size())
 #else
 #define SOCKET_BUFFER_SIZE 8192
 #endif
diff --git a/src/netlink.h b/src/netlink.h
index 2e36369..9d936c0 100644
--- a/src/netlink.h
+++ b/src/netlink.h
@@ -20,7 +20,6 @@
 #include <linux/genetlink.h>
 
 #define MNL_SOCKET_AUTOPID 0
-#define MNL_SOCKET_BUFFER_SIZE (sysconf(_SC_PAGESIZE) < 8192L ? sysconf(_SC_PAGESIZE) : 8192L)
 #define MNL_ALIGNTO 4
 #define MNL_ALIGN(len) (((len)+MNL_ALIGNTO-1) & ~(MNL_ALIGNTO-1))
 #define MNL_NLMSG_HDRLEN MNL_ALIGN(sizeof(struct nlmsghdr))
@@ -68,6 +67,18 @@ typedef int (*mnl_cb_t)(const struct nlmsghdr *nlh, void *data);
 #define MNL_ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))
 #endif
 
+static size_t mnl_ideal_socket_buffer_size(void)
+{
+	static size_t size = 0;
+
+	if (size)
+		return size;
+	size = (size_t)sysconf(_SC_PAGESIZE);
+	if (size > 8192)
+		size = 8192;
+	return size;
+}
+
 static size_t mnl_nlmsg_size(size_t len)
 {
 	return len + MNL_NLMSG_HDRLEN;
@@ -680,7 +691,7 @@ static int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void
 
 	do {
 		err = mnl_socket_recvfrom(nlg->nl, nlg->buf,
-					  MNL_SOCKET_BUFFER_SIZE);
+					  mnl_ideal_socket_buffer_size());
 		if (err <= 0)
 			break;
 		err = mnl_cb_run2(nlg->buf, err, nlg->seq, nlg->portid,
@@ -728,7 +739,7 @@ static struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t ver
 		return NULL;
 
 	err = -ENOMEM;
-	nlg->buf = malloc(MNL_SOCKET_BUFFER_SIZE);
+	nlg->buf = malloc(mnl_ideal_socket_buffer_size());
 	if (!nlg->buf)
 		goto err_buf_alloc;
 

commit ef117a91d1aa3caf02f89d0a824fee80a8f88b88
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Feb 3 16:52:29 2020 +0100

    netlink: remove libmnl requirement
    
    It turns out that the binary actually gets smaller if we simply inline
    the very small parts of libmnl that we need. Since we wind up needing
    the mnlg bits anyway, there's little benefit in linking to libmnl.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/README.md b/README.md
index be66e21..58795f7 100644
--- a/README.md
+++ b/README.md
@@ -14,9 +14,7 @@ Android.
     $ cd src
     $ make
 
-On Linux, [`libmnl`](https://netfilter.org/projects/libmnl/index.html) is
-required. On Windows, the [MinGW](http://www.mingw.org/) compiler is required.
-On other platforms, only a sane libc is required.
+There are no dependencies other than a good C compiler and a sane libc.
 
 ## Installing
 
diff --git a/src/Makefile b/src/Makefile
index 0e11d2b..ec5d3a6 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -50,12 +50,6 @@ WIREGUARD_TOOLS_VERSION = $(patsubst v%,%,$(shell GIT_CEILING_DIRECTORIES="$(PWD
 ifneq ($(WIREGUARD_TOOLS_VERSION),)
 CFLAGS += -D'WIREGUARD_TOOLS_VERSION="$(WIREGUARD_TOOLS_VERSION)"'
 endif
-ifeq ($(PLATFORM),linux)
-LIBMNL_CFLAGS := $(shell $(PKG_CONFIG) --cflags libmnl 2>/dev/null)
-LIBMNL_LDLIBS := $(shell $(PKG_CONFIG) --libs libmnl 2>/dev/null || echo -lmnl)
-CFLAGS += $(LIBMNL_CFLAGS)
-LDLIBS += $(LIBMNL_LDLIBS)
-endif
 ifeq ($(PLATFORM),haiku)
 LDLIBS += -lnetwork -lbsd
 endif
diff --git a/src/fuzz/Makefile b/src/fuzz/Makefile
index eaa0eca..0f6ef2c 100644
--- a/src/fuzz/Makefile
+++ b/src/fuzz/Makefile
@@ -20,13 +20,13 @@ stringlist: stringlist.c ../ipc.c ../curve25519.c ../encoding.c
 	$(CC) $(CFLAGS) -o $@ $<
 
 cmd: cmd.c $(wildcard ../*.c)
-	$(CC) $(CFLAGS) -D'RUNSTATEDIR="/var/empty"' -D'main(a,b)=wg_main(a,b)' -o $@ $^ -lmnl
+	$(CC) $(CFLAGS) -D'RUNSTATEDIR="/var/empty"' -D'main(a,b)=wg_main(a,b)' -o $@ $^
 
-set: set.c ../set.c ../ipc.c ../encoding.c ../mnlg.c ../curve25519.c ../config.c
-	$(CC) $(CFLAGS) -o $@ $< -lmnl
+set: set.c ../set.c ../ipc.c ../encoding.c ../curve25519.c ../config.c
+	$(CC) $(CFLAGS) -o $@ $<
 
-setconf: setconf.c ../setconf.c ../ipc.c ../encoding.c ../mnlg.c ../curve25519.c ../config.c
-	$(CC) $(CFLAGS) -o $@ $< -lmnl
+setconf: setconf.c ../setconf.c ../ipc.c ../encoding.c ../curve25519.c ../config.c
+	$(CC) $(CFLAGS) -o $@ $<
 
 clean:
 	$(RM) $(FUZZERS)
diff --git a/src/fuzz/set.c b/src/fuzz/set.c
index 22f953b..2f40615 100644
--- a/src/fuzz/set.c
+++ b/src/fuzz/set.c
@@ -15,7 +15,6 @@
 static FILE *hacked_fopen(const char *pathname, const char *mode);
 #define fopen hacked_fopen
 #include "../config.c"
-#include "../mnlg.c"
 #include "../set.c"
 #undef stderr
 
diff --git a/src/fuzz/setconf.c b/src/fuzz/setconf.c
index 44bfeb9..1f2bd75 100644
--- a/src/fuzz/setconf.c
+++ b/src/fuzz/setconf.c
@@ -13,7 +13,6 @@
 #undef parse_allowedips
 #include "../encoding.c"
 #include "../config.c"
-#include "../mnlg.c"
 static FILE *hacked_fopen(const char *pathname, const char *mode);
 #define fopen hacked_fopen
 #include "../setconf.c"
diff --git a/src/ipc.c b/src/ipc.c
index 8b74b5c..a0bf607 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -4,13 +4,10 @@
  */
 
 #ifdef __linux__
-#include <libmnl/libmnl.h>
 #include <linux/if_link.h>
-#include <linux/netlink.h>
 #include <linux/rtnetlink.h>
-#include <linux/genetlink.h>
 #include <linux/wireguard.h>
-#include "mnlg.h"
+#include "netlink.h"
 #endif
 #include <netinet/in.h>
 #include <sys/socket.h>
diff --git a/src/mnlg.c b/src/mnlg.c
deleted file mode 100644
index 0651896..0000000
--- a/src/mnlg.c
+++ /dev/null
@@ -1,330 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- *
- * Original author: Jiri Pirko <jiri@mellanox.com>
- */
-
-#ifdef __linux__
-
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <errno.h>
-#include <unistd.h>
-#include <time.h>
-#include <libmnl/libmnl.h>
-#include <linux/genetlink.h>
-
-#include "mnlg.h"
-
-struct mnlg_socket {
-	struct mnl_socket *nl;
-	char *buf;
-	uint16_t id;
-	uint8_t version;
-	unsigned int seq;
-	unsigned int portid;
-};
-
-static struct nlmsghdr *__mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
-					   uint16_t flags, uint16_t id,
-					   uint8_t version)
-{
-	struct nlmsghdr *nlh;
-	struct genlmsghdr *genl;
-
-	nlh = mnl_nlmsg_put_header(nlg->buf);
-	nlh->nlmsg_type	= id;
-	nlh->nlmsg_flags = flags;
-	nlg->seq = time(NULL);
-	nlh->nlmsg_seq = nlg->seq;
-
-	genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
-	genl->cmd = cmd;
-	genl->version = version;
-
-	return nlh;
-}
-
-struct nlmsghdr *mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
-				  uint16_t flags)
-{
-	return __mnlg_msg_prepare(nlg, cmd, flags, nlg->id, nlg->version);
-}
-
-int mnlg_socket_send(struct mnlg_socket *nlg, const struct nlmsghdr *nlh)
-{
-	return mnl_socket_sendto(nlg->nl, nlh, nlh->nlmsg_len);
-}
-
-static int mnlg_cb_noop(const struct nlmsghdr *nlh, void *data)
-{
-	(void)nlh;
-	(void)data;
-	return MNL_CB_OK;
-}
-
-static int mnlg_cb_error(const struct nlmsghdr *nlh, void *data)
-{
-	const struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);
-	(void)data;
-
-	if (nlh->nlmsg_len < mnl_nlmsg_size(sizeof(struct nlmsgerr))) {
-		errno = EBADMSG;
-		return MNL_CB_ERROR;
-	}
-	/* Netlink subsystems returns the errno value with different signess */
-	if (err->error < 0)
-		errno = -err->error;
-	else
-		errno = err->error;
-
-	return err->error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
-}
-
-static int mnlg_cb_stop(const struct nlmsghdr *nlh, void *data)
-{
-	(void)data;
-	if (nlh->nlmsg_flags & NLM_F_MULTI && nlh->nlmsg_len == mnl_nlmsg_size(sizeof(int))) {
-		int error = *(int *)mnl_nlmsg_get_payload(nlh);
-		/* Netlink subsystems returns the errno value with different signess */
-		if (error < 0)
-			errno = -error;
-		else
-			errno = error;
-
-		return error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
-	}
-	return MNL_CB_STOP;
-}
-
-static mnl_cb_t mnlg_cb_array[] = {
-	[NLMSG_NOOP]	= mnlg_cb_noop,
-	[NLMSG_ERROR]	= mnlg_cb_error,
-	[NLMSG_DONE]	= mnlg_cb_stop,
-	[NLMSG_OVERRUN]	= mnlg_cb_noop,
-};
-
-int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data)
-{
-	int err;
-
-	do {
-		err = mnl_socket_recvfrom(nlg->nl, nlg->buf,
-					  MNL_SOCKET_BUFFER_SIZE);
-		if (err <= 0)
-			break;
-		err = mnl_cb_run2(nlg->buf, err, nlg->seq, nlg->portid,
-				  data_cb, data, mnlg_cb_array, MNL_ARRAY_SIZE(mnlg_cb_array));
-	} while (err > 0);
-
-	return err;
-}
-
-struct group_info {
-	bool found;
-	uint32_t id;
-	const char *name;
-};
-
-static int parse_mc_grps_cb(const struct nlattr *attr, void *data)
-{
-	const struct nlattr **tb = data;
-	int type = mnl_attr_get_type(attr);
-
-	if (mnl_attr_type_valid(attr, CTRL_ATTR_MCAST_GRP_MAX) < 0)
-		return MNL_CB_OK;
-
-	switch (type) {
-	case CTRL_ATTR_MCAST_GRP_ID:
-		if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0)
-			return MNL_CB_ERROR;
-		break;
-	case CTRL_ATTR_MCAST_GRP_NAME:
-		if (mnl_attr_validate(attr, MNL_TYPE_STRING) < 0)
-			return MNL_CB_ERROR;
-		break;
-	}
-	tb[type] = attr;
-	return MNL_CB_OK;
-}
-
-static void parse_genl_mc_grps(struct nlattr *nested,
-			       struct group_info *group_info)
-{
-	struct nlattr *pos;
-	const char *name;
-
-	mnl_attr_for_each_nested(pos, nested) {
-		struct nlattr *tb[CTRL_ATTR_MCAST_GRP_MAX + 1] = {};
-
-		mnl_attr_parse_nested(pos, parse_mc_grps_cb, tb);
-		if (!tb[CTRL_ATTR_MCAST_GRP_NAME] ||
-		    !tb[CTRL_ATTR_MCAST_GRP_ID])
-			continue;
-
-		name = mnl_attr_get_str(tb[CTRL_ATTR_MCAST_GRP_NAME]);
-		if (strcmp(name, group_info->name) != 0)
-			continue;
-
-		group_info->id = mnl_attr_get_u32(tb[CTRL_ATTR_MCAST_GRP_ID]);
-		group_info->found = true;
-	}
-}
-
-static int get_group_id_attr_cb(const struct nlattr *attr, void *data)
-{
-	const struct nlattr **tb = data;
-	int type = mnl_attr_get_type(attr);
-
-	if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
-		return MNL_CB_ERROR;
-
-	if (type == CTRL_ATTR_MCAST_GROUPS &&
-	    mnl_attr_validate(attr, MNL_TYPE_NESTED) < 0)
-		return MNL_CB_ERROR;
-	tb[type] = attr;
-	return MNL_CB_OK;
-}
-
-static int get_group_id_cb(const struct nlmsghdr *nlh, void *data)
-{
-	struct group_info *group_info = data;
-	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
-
-	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_group_id_attr_cb, tb);
-	if (!tb[CTRL_ATTR_MCAST_GROUPS])
-		return MNL_CB_ERROR;
-	parse_genl_mc_grps(tb[CTRL_ATTR_MCAST_GROUPS], group_info);
-	return MNL_CB_OK;
-}
-
-int mnlg_socket_group_add(struct mnlg_socket *nlg, const char *group_name)
-{
-	struct nlmsghdr *nlh;
-	struct group_info group_info;
-	int err;
-
-	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
-				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
-	mnl_attr_put_u16(nlh, CTRL_ATTR_FAMILY_ID, nlg->id);
-
-	err = mnlg_socket_send(nlg, nlh);
-	if (err < 0)
-		return err;
-
-	group_info.found = false;
-	group_info.name = group_name;
-	err = mnlg_socket_recv_run(nlg, get_group_id_cb, &group_info);
-	if (err < 0)
-		return err;
-
-	if (!group_info.found) {
-		errno = ENOENT;
-		return -1;
-	}
-
-	err = mnl_socket_setsockopt(nlg->nl, NETLINK_ADD_MEMBERSHIP,
-				    &group_info.id, sizeof(group_info.id));
-	if (err < 0)
-		return err;
-
-	return 0;
-}
-
-static int get_family_id_attr_cb(const struct nlattr *attr, void *data)
-{
-	const struct nlattr **tb = data;
-	int type = mnl_attr_get_type(attr);
-
-	if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
-		return MNL_CB_ERROR;
-
-	if (type == CTRL_ATTR_FAMILY_ID &&
-	    mnl_attr_validate(attr, MNL_TYPE_U16) < 0)
-		return MNL_CB_ERROR;
-	tb[type] = attr;
-	return MNL_CB_OK;
-}
-
-static int get_family_id_cb(const struct nlmsghdr *nlh, void *data)
-{
-	uint16_t *p_id = data;
-	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
-
-	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_family_id_attr_cb, tb);
-	if (!tb[CTRL_ATTR_FAMILY_ID])
-		return MNL_CB_ERROR;
-	*p_id = mnl_attr_get_u16(tb[CTRL_ATTR_FAMILY_ID]);
-	return MNL_CB_OK;
-}
-
-struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t version)
-{
-	struct mnlg_socket *nlg;
-	struct nlmsghdr *nlh;
-	int err;
-
-	nlg = malloc(sizeof(*nlg));
-	if (!nlg)
-		return NULL;
-
-	err = -ENOMEM;
-	nlg->buf = malloc(MNL_SOCKET_BUFFER_SIZE);
-	if (!nlg->buf)
-		goto err_buf_alloc;
-
-	nlg->nl = mnl_socket_open(NETLINK_GENERIC);
-	if (!nlg->nl) {
-		err = -errno;
-		goto err_mnl_socket_open;
-	}
-
-	if (mnl_socket_bind(nlg->nl, 0, MNL_SOCKET_AUTOPID) < 0) {
-		err = -errno;
-		goto err_mnl_socket_bind;
-	}
-
-	nlg->portid = mnl_socket_get_portid(nlg->nl);
-
-	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
-				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
-	mnl_attr_put_strz(nlh, CTRL_ATTR_FAMILY_NAME, family_name);
-
-	if (mnlg_socket_send(nlg, nlh) < 0) {
-		err = -errno;
-		goto err_mnlg_socket_send;
-	}
-
-	errno = 0;
-	if (mnlg_socket_recv_run(nlg, get_family_id_cb, &nlg->id) < 0) {
-		errno = errno == ENOENT ? EPROTONOSUPPORT : errno;
-		err = errno ? -errno : -ENOSYS;
-		goto err_mnlg_socket_recv_run;
-	}
-
-	nlg->version = version;
-	errno = 0;
-	return nlg;
-
-err_mnlg_socket_recv_run:
-err_mnlg_socket_send:
-err_mnl_socket_bind:
-	mnl_socket_close(nlg->nl);
-err_mnl_socket_open:
-	free(nlg->buf);
-err_buf_alloc:
-	free(nlg);
-	errno = -err;
-	return NULL;
-}
-
-void mnlg_socket_close(struct mnlg_socket *nlg)
-{
-	mnl_socket_close(nlg->nl);
-	free(nlg->buf);
-	free(nlg);
-}
-
-#endif
diff --git a/src/mnlg.h b/src/mnlg.h
deleted file mode 100644
index 8585491..0000000
--- a/src/mnlg.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- *
- * Original author: Jiri Pirko <jiri@mellanox.com>
- */
-
-#ifndef MNLG_H
-#define MNLG_H
-#ifdef __linux__
-
-#include <libmnl/libmnl.h>
-
-struct mnlg_socket;
-
-struct nlmsghdr *mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
-				  uint16_t flags);
-int mnlg_socket_send(struct mnlg_socket *nlg, const struct nlmsghdr *nlh);
-int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data);
-int mnlg_socket_group_add(struct mnlg_socket *nlg, const char *group_name);
-struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t version);
-void mnlg_socket_close(struct mnlg_socket *nlg);
-
-#endif
-#endif
diff --git a/src/netlink.h b/src/netlink.h
new file mode 100644
index 0000000..2e36369
--- /dev/null
+++ b/src/netlink.h
@@ -0,0 +1,785 @@
+// SPDX-License-Identifier: LGPL-2.1+
+/*
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2008-2012 Pablo Neira Ayuso <pablo@netfilter.org>.
+ */
+
+/* This is a minimized version of libmnl meant to be #include'd */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <linux/netlink.h>
+#include <linux/genetlink.h>
+
+#define MNL_SOCKET_AUTOPID 0
+#define MNL_SOCKET_BUFFER_SIZE (sysconf(_SC_PAGESIZE) < 8192L ? sysconf(_SC_PAGESIZE) : 8192L)
+#define MNL_ALIGNTO 4
+#define MNL_ALIGN(len) (((len)+MNL_ALIGNTO-1) & ~(MNL_ALIGNTO-1))
+#define MNL_NLMSG_HDRLEN MNL_ALIGN(sizeof(struct nlmsghdr))
+#define MNL_ATTR_HDRLEN MNL_ALIGN(sizeof(struct nlattr))
+
+enum mnl_attr_data_type {
+	MNL_TYPE_UNSPEC,
+	MNL_TYPE_U8,
+	MNL_TYPE_U16,
+	MNL_TYPE_U32,
+	MNL_TYPE_U64,
+	MNL_TYPE_STRING,
+	MNL_TYPE_FLAG,
+	MNL_TYPE_MSECS,
+	MNL_TYPE_NESTED,
+	MNL_TYPE_NESTED_COMPAT,
+	MNL_TYPE_NUL_STRING,
+	MNL_TYPE_BINARY,
+	MNL_TYPE_MAX,
+};
+
+#define mnl_attr_for_each(attr, nlh, offset) \
+	for ((attr) = mnl_nlmsg_get_payload_offset((nlh), (offset)); \
+	     mnl_attr_ok((attr), (char *)mnl_nlmsg_get_payload_tail(nlh) - (char *)(attr)); \
+	     (attr) = mnl_attr_next(attr))
+
+#define mnl_attr_for_each_nested(attr, nest) \
+	for ((attr) = mnl_attr_get_payload(nest); \
+	     mnl_attr_ok((attr), (char *)mnl_attr_get_payload(nest) + mnl_attr_get_payload_len(nest) - (char *)(attr)); \
+	     (attr) = mnl_attr_next(attr))
+
+#define mnl_attr_for_each_payload(payload, payload_size) \
+	for ((attr) = (payload); \
+	     mnl_attr_ok((attr), (char *)(payload) + payload_size - (char *)(attr)); \
+	     (attr) = mnl_attr_next(attr))
+
+#define MNL_CB_ERROR	-1
+#define MNL_CB_STOP	0
+#define MNL_CB_OK	1
+
+typedef int (*mnl_attr_cb_t)(const struct nlattr *attr, void *data);
+typedef int (*mnl_cb_t)(const struct nlmsghdr *nlh, void *data);
+
+#ifndef MNL_ARRAY_SIZE
+#define MNL_ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))
+#endif
+
+static size_t mnl_nlmsg_size(size_t len)
+{
+	return len + MNL_NLMSG_HDRLEN;
+}
+
+static struct nlmsghdr *mnl_nlmsg_put_header(void *buf)
+{
+	int len = MNL_ALIGN(sizeof(struct nlmsghdr));
+	struct nlmsghdr *nlh = buf;
+
+	memset(buf, 0, len);
+	nlh->nlmsg_len = len;
+	return nlh;
+}
+
+static void *mnl_nlmsg_put_extra_header(struct nlmsghdr *nlh, size_t size)
+{
+	char *ptr = (char *)nlh + nlh->nlmsg_len;
+	size_t len = MNL_ALIGN(size);
+	nlh->nlmsg_len += len;
+	memset(ptr, 0, len);
+	return ptr;
+}
+
+static void *mnl_nlmsg_get_payload(const struct nlmsghdr *nlh)
+{
+	return (void *)nlh + MNL_NLMSG_HDRLEN;
+}
+
+static void *mnl_nlmsg_get_payload_offset(const struct nlmsghdr *nlh, size_t offset)
+{
+	return (void *)nlh + MNL_NLMSG_HDRLEN + MNL_ALIGN(offset);
+}
+
+static bool mnl_nlmsg_ok(const struct nlmsghdr *nlh, int len)
+{
+	return len >= (int)sizeof(struct nlmsghdr) &&
+	       nlh->nlmsg_len >= sizeof(struct nlmsghdr) &&
+	       (int)nlh->nlmsg_len <= len;
+}
+
+static struct nlmsghdr *mnl_nlmsg_next(const struct nlmsghdr *nlh, int *len)
+{
+	*len -= MNL_ALIGN(nlh->nlmsg_len);
+	return (struct nlmsghdr *)((void *)nlh + MNL_ALIGN(nlh->nlmsg_len));
+}
+
+static void *mnl_nlmsg_get_payload_tail(const struct nlmsghdr *nlh)
+{
+	return (void *)nlh + MNL_ALIGN(nlh->nlmsg_len);
+}
+
+static bool mnl_nlmsg_seq_ok(const struct nlmsghdr *nlh, unsigned int seq)
+{
+	return nlh->nlmsg_seq && seq ? nlh->nlmsg_seq == seq : true;
+}
+
+static bool mnl_nlmsg_portid_ok(const struct nlmsghdr *nlh, unsigned int portid)
+{
+	return nlh->nlmsg_pid && portid ? nlh->nlmsg_pid == portid : true;
+}
+
+static uint16_t mnl_attr_get_type(const struct nlattr *attr)
+{
+	return attr->nla_type & NLA_TYPE_MASK;
+}
+
+static uint16_t mnl_attr_get_payload_len(const struct nlattr *attr)
+{
+	return attr->nla_len - MNL_ATTR_HDRLEN;
+}
+
+static void *mnl_attr_get_payload(const struct nlattr *attr)
+{
+	return (void *)attr + MNL_ATTR_HDRLEN;
+}
+
+static bool mnl_attr_ok(const struct nlattr *attr, int len)
+{
+	return len >= (int)sizeof(struct nlattr) &&
+	       attr->nla_len >= sizeof(struct nlattr) &&
+	       (int)attr->nla_len <= len;
+}
+
+static struct nlattr *mnl_attr_next(const struct nlattr *attr)
+{
+	return (struct nlattr *)((void *)attr + MNL_ALIGN(attr->nla_len));
+}
+
+static int mnl_attr_type_valid(const struct nlattr *attr, uint16_t max)
+{
+	if (mnl_attr_get_type(attr) > max) {
+		errno = EOPNOTSUPP;
+		return -1;
+	}
+	return 1;
+}
+
+static int __mnl_attr_validate(const struct nlattr *attr,
+			       enum mnl_attr_data_type type, size_t exp_len)
+{
+	uint16_t attr_len = mnl_attr_get_payload_len(attr);
+	const char *attr_data = mnl_attr_get_payload(attr);
+
+	if (attr_len < exp_len) {
+		errno = ERANGE;
+		return -1;
+	}
+	switch(type) {
+	case MNL_TYPE_FLAG:
+		if (attr_len > 0) {
+			errno = ERANGE;
+			return -1;
+		}
+		break;
+	case MNL_TYPE_NUL_STRING:
+		if (attr_len == 0) {
+			errno = ERANGE;
+			return -1;
+		}
+		if (attr_data[attr_len-1] != '\0') {
+			errno = EINVAL;
+			return -1;
+		}
+		break;
+	case MNL_TYPE_STRING:
+		if (attr_len == 0) {
+			errno = ERANGE;
+			return -1;
+		}
+		break;
+	case MNL_TYPE_NESTED:
+
+		if (attr_len == 0)
+			break;
+
+		if (attr_len < MNL_ATTR_HDRLEN) {
+			errno = ERANGE;
+			return -1;
+		}
+		break;
+	default:
+
+		break;
+	}
+	if (exp_len && attr_len > exp_len) {
+		errno = ERANGE;
+		return -1;
+	}
+	return 0;
+}
+
+static const size_t mnl_attr_data_type_len[MNL_TYPE_MAX] = {
+	[MNL_TYPE_U8]		= sizeof(uint8_t),
+	[MNL_TYPE_U16]		= sizeof(uint16_t),
+	[MNL_TYPE_U32]		= sizeof(uint32_t),
+	[MNL_TYPE_U64]		= sizeof(uint64_t),
+	[MNL_TYPE_MSECS]	= sizeof(uint64_t),
+};
+
+static int mnl_attr_validate(const struct nlattr *attr, enum mnl_attr_data_type type)
+{
+	int exp_len;
+
+	if (type >= MNL_TYPE_MAX) {
+		errno = EINVAL;
+		return -1;
+	}
+	exp_len = mnl_attr_data_type_len[type];
+	return __mnl_attr_validate(attr, type, exp_len);
+}
+
+static int mnl_attr_parse(const struct nlmsghdr *nlh, unsigned int offset,
+			  mnl_attr_cb_t cb, void *data)
+{
+	int ret = MNL_CB_OK;
+	const struct nlattr *attr;
+
+	mnl_attr_for_each(attr, nlh, offset)
+		if ((ret = cb(attr, data)) <= MNL_CB_STOP)
+			return ret;
+	return ret;
+}
+
+static int mnl_attr_parse_nested(const struct nlattr *nested, mnl_attr_cb_t cb,
+				 void *data)
+{
+	int ret = MNL_CB_OK;
+	const struct nlattr *attr;
+
+	mnl_attr_for_each_nested(attr, nested)
+		if ((ret = cb(attr, data)) <= MNL_CB_STOP)
+			return ret;
+	return ret;
+}
+
+static uint8_t mnl_attr_get_u8(const struct nlattr *attr)
+{
+	return *((uint8_t *)mnl_attr_get_payload(attr));
+}
+
+static uint16_t mnl_attr_get_u16(const struct nlattr *attr)
+{
+	return *((uint16_t *)mnl_attr_get_payload(attr));
+}
+
+static uint32_t mnl_attr_get_u32(const struct nlattr *attr)
+{
+	return *((uint32_t *)mnl_attr_get_payload(attr));
+}
+
+static uint64_t mnl_attr_get_u64(const struct nlattr *attr)
+{
+	uint64_t tmp;
+	memcpy(&tmp, mnl_attr_get_payload(attr), sizeof(tmp));
+	return tmp;
+}
+
+static const char *mnl_attr_get_str(const struct nlattr *attr)
+{
+	return mnl_attr_get_payload(attr);
+}
+
+static void mnl_attr_put(struct nlmsghdr *nlh, uint16_t type, size_t len,
+			 const void *data)
+{
+	struct nlattr *attr = mnl_nlmsg_get_payload_tail(nlh);
+	uint16_t payload_len = MNL_ALIGN(sizeof(struct nlattr)) + len;
+	int pad;
+
+	attr->nla_type = type;
+	attr->nla_len = payload_len;
+	memcpy(mnl_attr_get_payload(attr), data, len);
+	nlh->nlmsg_len += MNL_ALIGN(payload_len);
+	pad = MNL_ALIGN(len) - len;
+	if (pad > 0)
+		memset(mnl_attr_get_payload(attr) + len, 0, pad);
+}
+
+static void mnl_attr_put_u16(struct nlmsghdr *nlh, uint16_t type, uint16_t data)
+{
+	mnl_attr_put(nlh, type, sizeof(uint16_t), &data);
+}
+
+static void mnl_attr_put_u32(struct nlmsghdr *nlh, uint16_t type, uint32_t data)
+{
+	mnl_attr_put(nlh, type, sizeof(uint32_t), &data);
+}
+
+static void mnl_attr_put_strz(struct nlmsghdr *nlh, uint16_t type, const char *data)
+{
+	mnl_attr_put(nlh, type, strlen(data)+1, data);
+}
+
+static struct nlattr *mnl_attr_nest_start(struct nlmsghdr *nlh, uint16_t type)
+{
+	struct nlattr *start = mnl_nlmsg_get_payload_tail(nlh);
+
+	start->nla_type = NLA_F_NESTED | type;
+	nlh->nlmsg_len += MNL_ALIGN(sizeof(struct nlattr));
+	return start;
+}
+
+static bool mnl_attr_put_check(struct nlmsghdr *nlh, size_t buflen,
+			       uint16_t type, size_t len, const void *data)
+{
+	if (nlh->nlmsg_len + MNL_ATTR_HDRLEN + MNL_ALIGN(len) > buflen)
+		return false;
+	mnl_attr_put(nlh, type, len, data);
+	return true;
+}
+
+static bool mnl_attr_put_u8_check(struct nlmsghdr *nlh, size_t buflen,
+				  uint16_t type, uint8_t data)
+{
+	return mnl_attr_put_check(nlh, buflen, type, sizeof(uint8_t), &data);
+}
+
+static bool mnl_attr_put_u16_check(struct nlmsghdr *nlh, size_t buflen,
+				   uint16_t type, uint16_t data)
+{
+	return mnl_attr_put_check(nlh, buflen, type, sizeof(uint16_t), &data);
+}
+
+static bool mnl_attr_put_u32_check(struct nlmsghdr *nlh, size_t buflen,
+				   uint16_t type, uint32_t data)
+{
+	return mnl_attr_put_check(nlh, buflen, type, sizeof(uint32_t), &data);
+}
+
+static struct nlattr *mnl_attr_nest_start_check(struct nlmsghdr *nlh, size_t buflen,
+						uint16_t type)
+{
+	if (nlh->nlmsg_len + MNL_ATTR_HDRLEN > buflen)
+		return NULL;
+	return mnl_attr_nest_start(nlh, type);
+}
+
+static void mnl_attr_nest_end(struct nlmsghdr *nlh, struct nlattr *start)
+{
+	start->nla_len = mnl_nlmsg_get_payload_tail(nlh) - (void *)start;
+}
+
+static void mnl_attr_nest_cancel(struct nlmsghdr *nlh, struct nlattr *start)
+{
+	nlh->nlmsg_len -= mnl_nlmsg_get_payload_tail(nlh) - (void *)start;
+}
+
+static int mnl_cb_noop(__attribute__((unused)) const struct nlmsghdr *nlh, __attribute__((unused)) void *data)
+{
+	return MNL_CB_OK;
+}
+
+static int mnl_cb_error(const struct nlmsghdr *nlh, __attribute__((unused)) void *data)
+{
+	const struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);
+
+	if (nlh->nlmsg_len < mnl_nlmsg_size(sizeof(struct nlmsgerr))) {
+		errno = EBADMSG;
+		return MNL_CB_ERROR;
+	}
+
+	if (err->error < 0)
+		errno = -err->error;
+	else
+		errno = err->error;
+
+	return err->error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+}
+
+static int mnl_cb_stop(__attribute__((unused)) const struct nlmsghdr *nlh, __attribute__((unused)) void *data)
+{
+	return MNL_CB_STOP;
+}
+
+static const mnl_cb_t default_cb_array[NLMSG_MIN_TYPE] = {
+	[NLMSG_NOOP]	= mnl_cb_noop,
+	[NLMSG_ERROR]	= mnl_cb_error,
+	[NLMSG_DONE]	= mnl_cb_stop,
+	[NLMSG_OVERRUN]	= mnl_cb_noop,
+};
+
+static int __mnl_cb_run(const void *buf, size_t numbytes,
+			unsigned int seq, unsigned int portid,
+			mnl_cb_t cb_data, void *data,
+			const mnl_cb_t *cb_ctl_array,
+			unsigned int cb_ctl_array_len)
+{
+	int ret = MNL_CB_OK, len = numbytes;
+	const struct nlmsghdr *nlh = buf;
+
+	while (mnl_nlmsg_ok(nlh, len)) {
+
+		if (!mnl_nlmsg_portid_ok(nlh, portid)) {
+			errno = ESRCH;
+			return -1;
+		}
+
+		if (!mnl_nlmsg_seq_ok(nlh, seq)) {
+			errno = EPROTO;
+			return -1;
+		}
+
+		if (nlh->nlmsg_flags & NLM_F_DUMP_INTR) {
+			errno = EINTR;
+			return -1;
+		}
+
+		if (nlh->nlmsg_type >= NLMSG_MIN_TYPE) {
+			if (cb_data){
+				ret = cb_data(nlh, data);
+				if (ret <= MNL_CB_STOP)
+					goto out;
+			}
+		} else if (nlh->nlmsg_type < cb_ctl_array_len) {
+			if (cb_ctl_array && cb_ctl_array[nlh->nlmsg_type]) {
+				ret = cb_ctl_array[nlh->nlmsg_type](nlh, data);
+				if (ret <= MNL_CB_STOP)
+					goto out;
+			}
+		} else if (default_cb_array[nlh->nlmsg_type]) {
+			ret = default_cb_array[nlh->nlmsg_type](nlh, data);
+			if (ret <= MNL_CB_STOP)
+				goto out;
+		}
+		nlh = mnl_nlmsg_next(nlh, &len);
+	}
+out:
+	return ret;
+}
+
+static int mnl_cb_run2(const void *buf, size_t numbytes, unsigned int seq,
+		       unsigned int portid, mnl_cb_t cb_data, void *data,
+		       const mnl_cb_t *cb_ctl_array, unsigned int cb_ctl_array_len)
+{
+	return __mnl_cb_run(buf, numbytes, seq, portid, cb_data, data,
+			    cb_ctl_array, cb_ctl_array_len);
+}
+
+static int mnl_cb_run(const void *buf, size_t numbytes, unsigned int seq,
+		      unsigned int portid, mnl_cb_t cb_data, void *data)
+{
+	return __mnl_cb_run(buf, numbytes, seq, portid, cb_data, data, NULL, 0);
+}
+
+struct mnl_socket {
+	int 			fd;
+	struct sockaddr_nl	addr;
+};
+
+static unsigned int mnl_socket_get_portid(const struct mnl_socket *nl)
+{
+	return nl->addr.nl_pid;
+}
+
+static struct mnl_socket *__mnl_socket_open(int bus, int flags)
+{
+	struct mnl_socket *nl;
+
+	nl = calloc(1, sizeof(struct mnl_socket));
+	if (nl == NULL)
+		return NULL;
+
+	nl->fd = socket(AF_NETLINK, SOCK_RAW | flags, bus);
+	if (nl->fd == -1) {
+		free(nl);
+		return NULL;
+	}
+
+	return nl;
+}
+
+static struct mnl_socket *mnl_socket_open(int bus)
+{
+	return __mnl_socket_open(bus, 0);
+}
+
+static int mnl_socket_bind(struct mnl_socket *nl, unsigned int groups, pid_t pid)
+{
+	int ret;
+	socklen_t addr_len;
+
+	nl->addr.nl_family = AF_NETLINK;
+	nl->addr.nl_groups = groups;
+	nl->addr.nl_pid = pid;
+
+	ret = bind(nl->fd, (struct sockaddr *) &nl->addr, sizeof (nl->addr));
+	if (ret < 0)
+		return ret;
+
+	addr_len = sizeof(nl->addr);
+	ret = getsockname(nl->fd, (struct sockaddr *) &nl->addr, &addr_len);
+	if (ret < 0)
+		return ret;
+
+	if (addr_len != sizeof(nl->addr)) {
+		errno = EINVAL;
+		return -1;
+	}
+	if (nl->addr.nl_family != AF_NETLINK) {
+		errno = EINVAL;
+		return -1;
+	}
+	return 0;
+}
+
+static ssize_t mnl_socket_sendto(const struct mnl_socket *nl, const void *buf,
+				 size_t len)
+{
+	static const struct sockaddr_nl snl = {
+		.nl_family = AF_NETLINK
+	};
+	return sendto(nl->fd, buf, len, 0,
+		      (struct sockaddr *) &snl, sizeof(snl));
+}
+
+static ssize_t mnl_socket_recvfrom(const struct mnl_socket *nl, void *buf,
+				   size_t bufsiz)
+{
+	ssize_t ret;
+	struct sockaddr_nl addr;
+	struct iovec iov = {
+		.iov_base	= buf,
+		.iov_len	= bufsiz,
+	};
+	struct msghdr msg = {
+		.msg_name	= &addr,
+		.msg_namelen	= sizeof(struct sockaddr_nl),
+		.msg_iov	= &iov,
+		.msg_iovlen	= 1,
+		.msg_control	= NULL,
+		.msg_controllen	= 0,
+		.msg_flags	= 0,
+	};
+	ret = recvmsg(nl->fd, &msg, 0);
+	if (ret == -1)
+		return ret;
+
+	if (msg.msg_flags & MSG_TRUNC) {
+		errno = ENOSPC;
+		return -1;
+	}
+	if (msg.msg_namelen != sizeof(struct sockaddr_nl)) {
+		errno = EINVAL;
+		return -1;
+	}
+	return ret;
+}
+
+static int mnl_socket_close(struct mnl_socket *nl)
+{
+	int ret = close(nl->fd);
+	free(nl);
+	return ret;
+}
+
+/* This is a wrapper for generic netlink, originally from Jiri Pirko <jiri@mellanox.com>: */
+
+struct mnlg_socket {
+	struct mnl_socket *nl;
+	char *buf;
+	uint16_t id;
+	uint8_t version;
+	unsigned int seq;
+	unsigned int portid;
+};
+
+static struct nlmsghdr *__mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
+					   uint16_t flags, uint16_t id,
+					   uint8_t version)
+{
+	struct nlmsghdr *nlh;
+	struct genlmsghdr *genl;
+
+	nlh = mnl_nlmsg_put_header(nlg->buf);
+	nlh->nlmsg_type	= id;
+	nlh->nlmsg_flags = flags;
+	nlg->seq = time(NULL);
+	nlh->nlmsg_seq = nlg->seq;
+
+	genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
+	genl->cmd = cmd;
+	genl->version = version;
+
+	return nlh;
+}
+
+static struct nlmsghdr *mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
+					 uint16_t flags)
+{
+	return __mnlg_msg_prepare(nlg, cmd, flags, nlg->id, nlg->version);
+}
+
+static int mnlg_socket_send(struct mnlg_socket *nlg, const struct nlmsghdr *nlh)
+{
+	return mnl_socket_sendto(nlg->nl, nlh, nlh->nlmsg_len);
+}
+
+static int mnlg_cb_noop(const struct nlmsghdr *nlh, void *data)
+{
+	(void)nlh;
+	(void)data;
+	return MNL_CB_OK;
+}
+
+static int mnlg_cb_error(const struct nlmsghdr *nlh, void *data)
+{
+	const struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);
+	(void)data;
+
+	if (nlh->nlmsg_len < mnl_nlmsg_size(sizeof(struct nlmsgerr))) {
+		errno = EBADMSG;
+		return MNL_CB_ERROR;
+	}
+	/* Netlink subsystems returns the errno value with different signess */
+	if (err->error < 0)
+		errno = -err->error;
+	else
+		errno = err->error;
+
+	return err->error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+}
+
+static int mnlg_cb_stop(const struct nlmsghdr *nlh, void *data)
+{
+	(void)data;
+	if (nlh->nlmsg_flags & NLM_F_MULTI && nlh->nlmsg_len == mnl_nlmsg_size(sizeof(int))) {
+		int error = *(int *)mnl_nlmsg_get_payload(nlh);
+		/* Netlink subsystems returns the errno value with different signess */
+		if (error < 0)
+			errno = -error;
+		else
+			errno = error;
+
+		return error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+	}
+	return MNL_CB_STOP;
+}
+
+static const mnl_cb_t mnlg_cb_array[] = {
+	[NLMSG_NOOP]	= mnlg_cb_noop,
+	[NLMSG_ERROR]	= mnlg_cb_error,
+	[NLMSG_DONE]	= mnlg_cb_stop,
+	[NLMSG_OVERRUN]	= mnlg_cb_noop,
+};
+
+static int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data)
+{
+	int err;
+
+	do {
+		err = mnl_socket_recvfrom(nlg->nl, nlg->buf,
+					  MNL_SOCKET_BUFFER_SIZE);
+		if (err <= 0)
+			break;
+		err = mnl_cb_run2(nlg->buf, err, nlg->seq, nlg->portid,
+				  data_cb, data, mnlg_cb_array, MNL_ARRAY_SIZE(mnlg_cb_array));
+	} while (err > 0);
+
+	return err;
+}
+
+static int get_family_id_attr_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
+		return MNL_CB_ERROR;
+
+	if (type == CTRL_ATTR_FAMILY_ID &&
+	    mnl_attr_validate(attr, MNL_TYPE_U16) < 0)
+		return MNL_CB_ERROR;
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static int get_family_id_cb(const struct nlmsghdr *nlh, void *data)
+{
+	uint16_t *p_id = data;
+	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
+
+	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_family_id_attr_cb, tb);
+	if (!tb[CTRL_ATTR_FAMILY_ID])
+		return MNL_CB_ERROR;
+	*p_id = mnl_attr_get_u16(tb[CTRL_ATTR_FAMILY_ID]);
+	return MNL_CB_OK;
+}
+
+static struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t version)
+{
+	struct mnlg_socket *nlg;
+	struct nlmsghdr *nlh;
+	int err;
+
+	nlg = malloc(sizeof(*nlg));
+	if (!nlg)
+		return NULL;
+
+	err = -ENOMEM;
+	nlg->buf = malloc(MNL_SOCKET_BUFFER_SIZE);
+	if (!nlg->buf)
+		goto err_buf_alloc;
+
+	nlg->nl = mnl_socket_open(NETLINK_GENERIC);
+	if (!nlg->nl) {
+		err = -errno;
+		goto err_mnl_socket_open;
+	}
+
+	if (mnl_socket_bind(nlg->nl, 0, MNL_SOCKET_AUTOPID) < 0) {
+		err = -errno;
+		goto err_mnl_socket_bind;
+	}
+
+	nlg->portid = mnl_socket_get_portid(nlg->nl);
+
+	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
+				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
+	mnl_attr_put_strz(nlh, CTRL_ATTR_FAMILY_NAME, family_name);
+
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		err = -errno;
+		goto err_mnlg_socket_send;
+	}
+
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, get_family_id_cb, &nlg->id) < 0) {
+		errno = errno == ENOENT ? EPROTONOSUPPORT : errno;
+		err = errno ? -errno : -ENOSYS;
+		goto err_mnlg_socket_recv_run;
+	}
+
+	nlg->version = version;
+	errno = 0;
+	return nlg;
+
+err_mnlg_socket_recv_run:
+err_mnlg_socket_send:
+err_mnl_socket_bind:
+	mnl_socket_close(nlg->nl);
+err_mnl_socket_open:
+	free(nlg->buf);
+err_buf_alloc:
+	free(nlg);
+	errno = -err;
+	return NULL;
+}
+
+static void mnlg_socket_close(struct mnlg_socket *nlg)
+{
+	mnl_socket_close(nlg->nl);
+	free(nlg->buf);
+	free(nlg);
+}

commit db5cb4f15c053c250047cf83390c1ec0cbdcd07c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Feb 3 16:35:01 2020 +0100

    embeddable-wg-library: use newer string_list
    
    This ports 1d2d6200b8ff517db0f7530645180df3cc4afa74.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/test.c b/contrib/embeddable-wg-library/test.c
index 4c95373..f9a8bd4 100644
--- a/contrib/embeddable-wg-library/test.c
+++ b/contrib/embeddable-wg-library/test.c
@@ -27,8 +27,11 @@ void list_devices(void)
 			perror("Unable to get device");
 			continue;
 		}
-		wg_key_to_base64(key, device->public_key);
-		printf("%s has public key %s\n", device_name, key);
+		if (device->flags & WGDEVICE_HAS_PUBLIC_KEY) {
+			wg_key_to_base64(key, device->public_key);
+			printf("%s has public key %s\n", device_name, key);
+		} else
+			printf("%s has no public key\n", device_name);
 		wg_for_each_peer(device, peer) {
 			wg_key_to_base64(key, peer->public_key);
 			printf(" - peer %s\n", key);
diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index fd68918..a9cda20 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -856,85 +856,73 @@ static void mnlg_socket_close(struct mnlg_socket *nlg)
 
 /* wireguard-specific parts: */
 
-struct inflatable_buffer {
+struct string_list {
 	char *buffer;
-	char *next;
-	bool good;
 	size_t len;
-	size_t pos;
+	size_t cap;
 };
 
-#define max(a, b) ((a) > (b) ? (a) : (b))
-
-static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
+static int string_list_add(struct string_list *list, const char *str)
 {
-	size_t len, expand_to;
-	char *new_buffer;
+	size_t len = strlen(str) + 1;
 
-	if (!buffer->good || !buffer->next) {
-		free(buffer->next);
-		buffer->good = false;
+	if (len == 1)
 		return 0;
-	}
-
-	len = strlen(buffer->next) + 1;
 
-	if (len == 1) {
-		free(buffer->next);
-		buffer->good = false;
-		return 0;
-	}
+	if (len >= list->cap - list->len) {
+		char *new_buffer;
+		size_t new_cap = list->cap * 2;
 
-	if (buffer->len - buffer->pos <= len) {
-		expand_to = max(buffer->len * 2, buffer->len + len + 1);
-		new_buffer = realloc(buffer->buffer, expand_to);
-		if (!new_buffer) {
-			free(buffer->next);
-			buffer->good = false;
+		if (new_cap <  list->len +len + 1)
+			new_cap = list->len + len + 1;
+		new_buffer = realloc(list->buffer, new_cap);
+		if (!new_buffer)
 			return -errno;
-		}
-		memset(&new_buffer[buffer->len], 0, expand_to - buffer->len);
-		buffer->buffer = new_buffer;
-		buffer->len = expand_to;
+		list->buffer = new_buffer;
+		list->cap = new_cap;
 	}
-	memcpy(&buffer->buffer[buffer->pos], buffer->next, len);
-	free(buffer->next);
-	buffer->good = false;
-	buffer->pos += len;
+	memcpy(list->buffer + list->len, str, len);
+	list->len += len;
+	list->buffer[list->len] = '\0';
 	return 0;
 }
 
+struct interface {
+	const char *name;
+	bool is_wireguard;
+};
+
 static int parse_linkinfo(const struct nlattr *attr, void *data)
 {
-	struct inflatable_buffer *buffer = data;
+	struct interface *interface = data;
 
 	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp(WG_GENL_NAME, mnl_attr_get_str(attr)))
-		buffer->good = true;
+		interface->is_wireguard = true;
 	return MNL_CB_OK;
 }
 
 static int parse_infomsg(const struct nlattr *attr, void *data)
 {
-	struct inflatable_buffer *buffer = data;
+	struct interface *interface = data;
 
 	if (mnl_attr_get_type(attr) == IFLA_LINKINFO)
 		return mnl_attr_parse_nested(attr, parse_linkinfo, data);
 	else if (mnl_attr_get_type(attr) == IFLA_IFNAME)
-		buffer->next = strdup(mnl_attr_get_str(attr));
+		interface->name = mnl_attr_get_str(attr);
 	return MNL_CB_OK;
 }
 
 static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
 {
-	struct inflatable_buffer *buffer = data;
+	struct string_list *list = data;
+	struct interface interface = { 0 };
 	int ret;
 
-	buffer->good = false;
-	buffer->next = NULL;
-	ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, data);
+	ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, &interface);
 	if (ret != MNL_CB_OK)
 		return ret;
-	ret = add_next_to_inflatable_buffer(buffer);
+	if (interface.name && interface.is_wireguard)
+		ret = string_list_add(list, interface.name);
 	if (ret < 0)
 		return ret;
 	if (nlh->nlmsg_type != NLMSG_DONE)
@@ -942,7 +930,7 @@ static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
 	return MNL_CB_OK;
 }
 
-static int fetch_device_names(struct inflatable_buffer *buffer)
+static int fetch_device_names(struct string_list *list)
 {
 	struct mnl_socket *nl = NULL;
 	char *rtnl_buffer = NULL;
@@ -989,7 +977,7 @@ another:
 		ret = -errno;
 		goto cleanup;
 	}
-	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, buffer)) < 0) {
+	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, list)) < 0) {
 		/* Netlink returns NLM_F_DUMP_INTR if the set of all tunnels changed
 		 * during the dump. That's unfortunate, but is pretty common on busy
 		 * systems that are adding and removing tunnels all the time. Rather
@@ -1463,22 +1451,15 @@ out:
 /* first\0second\0third\0forth\0last\0\0 */
 char *wg_list_device_names(void)
 {
-	struct inflatable_buffer buffer = { .len = MNL_SOCKET_BUFFER_SIZE };
-	int ret;
-
-	ret = -ENOMEM;
-	buffer.buffer = calloc(1, buffer.len);
-	if (!buffer.buffer)
-		goto err;
+	struct string_list list = { 0 };
+	int ret = fetch_device_names(&list);
 
-	ret = fetch_device_names(&buffer);
-err:
 	errno = -ret;
 	if (errno) {
-		free(buffer.buffer);
+		free(list.buffer);
 		return NULL;
 	}
-	return buffer.buffer;
+	return list.buffer ?: strdup("\0");
 }
 
 int wg_add_device(const char *device_name)

commit 1ad6b17c35d98677459b32fdbeba1129b80c5995
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Feb 1 00:48:25 2020 +0100

    extract-{handshakes,keys}: rework for upstream kernel
    
    Now that WireGuard has been upstreamed and the repos split, we have to
    look elsewhere for these headers.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/extract-handshakes/Makefile b/contrib/extract-handshakes/Makefile
index 77b42f1..241b0d5 100644
--- a/contrib/extract-handshakes/Makefile
+++ b/contrib/extract-handshakes/Makefile
@@ -20,10 +20,5 @@ clean:
 
 .PHONY: clean
 else
-offset-finder-m := offset-finder.o
-oldsrc := $(src)
-src := $(src)/../../../src
-include $(src)/compat/Kbuild.include
-include $(src)/crypto/Kbuild.include
-src := $(oldsrc)
+obj-m := offset-finder.o
 endif
diff --git a/contrib/extract-handshakes/offset-finder.c b/contrib/extract-handshakes/offset-finder.c
index 1b54cf3..4c10341 100644
--- a/contrib/extract-handshakes/offset-finder.c
+++ b/contrib/extract-handshakes/offset-finder.c
@@ -11,7 +11,7 @@ struct def {
 extern const struct def defs[];
 
 #ifdef __KERNEL__
-#include "../../../src/noise.h"
+#include "../drivers/net/wireguard/noise.h"
 
 const struct def defs[] = {
 	{ "LOCAL_STATIC_PRIVATE_KEY", offsetof(struct noise_static_identity, static_private), offsetof(struct noise_handshake, static_identity) },
diff --git a/contrib/extract-keys/Makefile b/contrib/extract-keys/Makefile
index 1f7308d..53e7767 100644
--- a/contrib/extract-keys/Makefile
+++ b/contrib/extract-keys/Makefile
@@ -23,10 +23,5 @@ clean:
 
 .PHONY: clean
 else
-config-m := config.o
-oldsrc := $(src)
-src := $(src)/../../../src
-include $(src)/compat/Kbuild.include
-include $(src)/crypto/Kbuild.include
-src := $(oldsrc)
+obj-m := config.o
 endif
diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index 640c61b..59009ef 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -10,9 +10,9 @@ struct def {
 extern const struct def defs[];
 
 #ifdef __KERNEL__
-#include "../../../src/device.h"
-#include "../../../src/peer.h"
-#include "../../../src/noise.h"
+#include "../drivers/net/wireguard/device.h"
+#include "../drivers/net/wireguard/peer.h"
+#include "../drivers/net/wireguard/noise.h"
 const struct def defs[] = {
 	{ "SOCK_DEVICE_OFFSET", offsetof(struct sock, sk_user_data) },
 	{ "DEVICE_NAME_OFFSET", -ALIGN(sizeof(struct net_device), NETDEV_ALIGN) + offsetof(struct net_device, name) },

commit 27c885ff0844c3391a8fc4ef1165edb354455ec5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jan 31 23:17:12 2020 +0100

    man: document dynamic debug trick for Linux
    
    This comes up occasionally, so it may be useful to mention its
    possibility in the man page. At least the Arch Linux and Ubuntu kernels
    support dynamic debugging, so this advise will at least help somebody.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg.8 b/src/man/wg.8
index 07b9694..27860c8 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -212,6 +212,15 @@ are thus ignored.
 .br
     AllowedIPs = 10.10.10.230/32
 
+.SH DEBUGGING INFORMATION
+Sometimes it is useful to have information on the current runtime state of a tunnel. When using the Linux kernel module on a kernel that supports dynamic debugging, debugging information can be written into
+.BR dmesg (1)
+by running as root:
+
+\fB    # modprobe wireguard && echo module wireguard +p > /sys/kernel/debug/dynamic_debug/control\fP
+
+On userspace implementations, it is customary to set the \fILOG_LEVEL\fP environment variable to \fIdebug\fP.
+
 .SH ENVIRONMENT VARIABLES
 .TP
 .I WG_COLOR_MODE

commit 6771c4454eab2661166c1c672db7b76ff3f18020
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jan 31 18:56:52 2020 +0100

    wg-quick: android: split uids into multiple commands
    
    Different versions of netd have different limits on how many can be
    passed at once.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reported-by: Alexey <zaranecc@bk.ru>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index cedc8a7..54ea81c 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -785,6 +785,7 @@ static uid_t *get_uid_list(const char *selected_applications)
 static void set_users(unsigned int netid, const char *excluded_applications)
 {
 	_cleanup_free_ uid_t *excluded_uids = get_uid_list(excluded_applications);
+	unsigned int args_per_command = 0;
 	_cleanup_free_ char *ranges = NULL;
 	char range[22];
 	uid_t start;
@@ -797,13 +798,19 @@ static void set_users(unsigned int netid, const char *excluded_applications)
 		else
 			snprintf(range, sizeof(range), "%u-%u", start, *excluded_uids - 1);
 		ranges = concat_and_free(ranges, " ", range);
+		if (++args_per_command % 18 == 0) {
+			cndc("network users add %u %s", netid, ranges);
+			free(ranges);
+			ranges = NULL;
+		}
 	}
 	if (start < 99999) {
 		snprintf(range, sizeof(range), "%u-99999", start);
 		ranges = concat_and_free(ranges, " ", range);
 	}
 
-	cndc("network users add %u %s", netid, ranges);
+	if (ranges)
+		cndc("network users add %u %s", netid, ranges);
 }
 
 static void set_dnses(unsigned int netid, const char *dnses)

commit 8082f7e6a88af9299952c472feae2bb6153dbb6c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 21 15:51:31 2020 +0100

    version: bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
index d3e9719..09282b0 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1,3 +1,3 @@
 #ifndef WIREGUARD_TOOLS_VERSION
-#define WIREGUARD_TOOLS_VERSION "1.0.20200102"
+#define WIREGUARD_TOOLS_VERSION "1.0.20200121"
 #endif

commit 3a3a56e217be35c4844420d670fbb58407927e81
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 21 13:05:42 2020 +0100

    Makefile: sort inputs to linker so that build is reproducible
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 08389ef..0e11d2b 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -75,7 +75,7 @@ COMPILE.c = @echo "  CC      $@";
 COMPILE.c += $(BUILT_IN_COMPILE.c)
 endif
 
-wg: $(patsubst %.c,%.o,$(wildcard *.c))
+wg: $(sort $(patsubst %.c,%.o,$(wildcard *.c)))
 
 ifneq ($(V),1)
 clean:

commit 64576f9a062516ff29a6186bac7527d55e29d258
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Jan 11 12:16:13 2020 -0500

    netlink: make sure to clear return value when trying again
    
    Otherwise this runs in an infinite loop if at some point a dump was
    interrupted.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 1110670..8b74b5c 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -881,11 +881,12 @@ static void coalesce_peers(struct wgdevice *device)
 
 static int kernel_get_device(struct wgdevice **device, const char *iface)
 {
-	int ret = 0;
+	int ret;
 	struct nlmsghdr *nlh;
 	struct mnlg_socket *nlg;
 
 try_again:
+	ret = 0;
 	*device = calloc(1, sizeof(**device));
 	if (!*device)
 		return -errno;

commit 95c30bc0344b4e3085336c5b957ea1d1281b0d0b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Jan 11 16:28:19 2020 +0100

    fuzz: add set and setconf fuzzers
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/fuzz/.gitignore b/src/fuzz/.gitignore
index 3b69fda..04f5323 100644
--- a/src/fuzz/.gitignore
+++ b/src/fuzz/.gitignore
@@ -2,3 +2,5 @@ config
 uapi
 stringlist
 cmd
+set
+setconf
diff --git a/src/fuzz/Makefile b/src/fuzz/Makefile
index cb9db3b..eaa0eca 100644
--- a/src/fuzz/Makefile
+++ b/src/fuzz/Makefile
@@ -2,7 +2,9 @@
 #
 # Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
-all: config uapi stringlist cmd
+FUZZERS := config uapi stringlist cmd set setconf
+
+all: $(FUZZERS)
 
 CFLAGS ?= -O3 -march=native -g
 CFLAGS += -fsanitize=fuzzer -fsanitize=address -std=gnu11 -idirafter ../uapi -D_GNU_SOURCE
@@ -20,7 +22,13 @@ stringlist: stringlist.c ../ipc.c ../curve25519.c ../encoding.c
 cmd: cmd.c $(wildcard ../*.c)
 	$(CC) $(CFLAGS) -D'RUNSTATEDIR="/var/empty"' -D'main(a,b)=wg_main(a,b)' -o $@ $^ -lmnl
 
+set: set.c ../set.c ../ipc.c ../encoding.c ../mnlg.c ../curve25519.c ../config.c
+	$(CC) $(CFLAGS) -o $@ $< -lmnl
+
+setconf: setconf.c ../setconf.c ../ipc.c ../encoding.c ../mnlg.c ../curve25519.c ../config.c
+	$(CC) $(CFLAGS) -o $@ $< -lmnl
+
 clean:
-	rm -f config uapi stringlist cmd
+	$(RM) $(FUZZERS)
 
 .PHONY: all clean
diff --git a/src/fuzz/set.c b/src/fuzz/set.c
new file mode 100644
index 0000000..22f953b
--- /dev/null
+++ b/src/fuzz/set.c
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdio.h>
+#undef stderr
+#define stderr stdin
+#define RUNSTATEDIR "/var/empty"
+#include "../curve25519.c"
+#define parse_allowedips parse_allowedips_ipc
+#include "../ipc.c"
+#undef parse_allowedips
+#include "../encoding.c"
+static FILE *hacked_fopen(const char *pathname, const char *mode);
+#define fopen hacked_fopen
+#include "../config.c"
+#include "../mnlg.c"
+#include "../set.c"
+#undef stderr
+
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+
+const char *__asan_default_options()
+{
+	return "verbosity=1";
+}
+
+const char *PROG_NAME = "wg";
+
+static FILE *hacked_fopen(const char *pathname, const char *mode)
+{
+	return fmemopen((char *)pathname, strlen(pathname), "r");
+}
+
+int LLVMFuzzerTestOneInput(const char *data, size_t data_len)
+{
+	char *argv[8192] = { "set", "wg0" }, *args;
+	size_t argc = 2;
+
+	if (!data_len)
+		return 0;
+
+	assert((args = malloc(data_len)));
+	memcpy(args, data, data_len);
+	args[data_len - 1] = '\0';
+
+	for (char *arg = strtok(args, " \t\n\r"); arg && argc < 8192; arg = strtok(NULL, " \t\n\r")) {
+		if (arg[0])
+			argv[argc++] = arg;
+	}
+	set_main(argc, argv);
+	free(args);
+	return 0;
+}
diff --git a/src/fuzz/setconf.c b/src/fuzz/setconf.c
new file mode 100644
index 0000000..44bfeb9
--- /dev/null
+++ b/src/fuzz/setconf.c
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdio.h>
+#undef stderr
+#define stderr stdin
+#define RUNSTATEDIR "/var/empty"
+#include "../curve25519.c"
+#define parse_allowedips parse_allowedips_ipc
+#include "../ipc.c"
+#undef parse_allowedips
+#include "../encoding.c"
+#include "../config.c"
+#include "../mnlg.c"
+static FILE *hacked_fopen(const char *pathname, const char *mode);
+#define fopen hacked_fopen
+#include "../setconf.c"
+#undef fopen
+#undef stderr
+
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+
+const char *__asan_default_options()
+{
+	return "verbosity=1";
+}
+
+const char *PROG_NAME = "wg";
+
+struct hacked_pointers {
+	const char *data;
+	size_t data_len;
+};
+
+static FILE *hacked_fopen(const char *pathname, const char *mode)
+{
+	struct hacked_pointers *h = (struct hacked_pointers *)strtoul(pathname, NULL, 10);
+	return fmemopen((char *)h->data, h->data_len, "r");
+}
+
+int LLVMFuzzerTestOneInput(const char *data, size_t data_len)
+{
+	char strptr[32];
+	char *argv[3] = { "setconf", "wg0", strptr };
+	struct hacked_pointers h = { data, data_len };
+
+	snprintf(strptr, sizeof(strptr), "%lu", (unsigned long)&h);
+	setconf_main(3, argv);
+	return 0;
+}

commit f7f1e7da2c7b7c7dfbede08260119ff9a99d1da8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 8 17:59:58 2020 -0500

    Makefile: evaluate git version lazily
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 9221181..08389ef 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -46,9 +46,9 @@ CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
 ifeq ($(DEBUG),yes)
 CFLAGS += -g
 endif
-GIT_VERSION := $(shell GIT_CEILING_DIRECTORIES="$(PWD)/../.." git describe --dirty 2>/dev/null)
-ifneq ($(GIT_VERSION),)
-CFLAGS += -D'WIREGUARD_TOOLS_VERSION="$(GIT_VERSION:v%=%)"'
+WIREGUARD_TOOLS_VERSION = $(patsubst v%,%,$(shell GIT_CEILING_DIRECTORIES="$(PWD)/../.." git describe --dirty 2>/dev/null))
+ifneq ($(WIREGUARD_TOOLS_VERSION),)
+CFLAGS += -D'WIREGUARD_TOOLS_VERSION="$(WIREGUARD_TOOLS_VERSION)"'
 endif
 ifeq ($(PLATFORM),linux)
 LIBMNL_CFLAGS := $(shell $(PKG_CONFIG) --cflags libmnl 2>/dev/null)

commit cdd8d8ba9f7026b0a68d34d27aa4a7901505caf4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Jan 4 15:34:28 2020 +0100

    fuzz: add generic command argument fuzzer
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/fuzz/.gitignore b/src/fuzz/.gitignore
index 988712e..3b69fda 100644
--- a/src/fuzz/.gitignore
+++ b/src/fuzz/.gitignore
@@ -1,2 +1,4 @@
 config
 uapi
+stringlist
+cmd
diff --git a/src/fuzz/Makefile b/src/fuzz/Makefile
index 3fb2970..cb9db3b 100644
--- a/src/fuzz/Makefile
+++ b/src/fuzz/Makefile
@@ -2,10 +2,10 @@
 #
 # Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
-all: config uapi stringlist
+all: config uapi stringlist cmd
 
 CFLAGS ?= -O3 -march=native -g
-CFLAGS += -fsanitize=fuzzer -fsanitize=address -std=gnu11 -idirafter ../uapi
+CFLAGS += -fsanitize=fuzzer -fsanitize=address -std=gnu11 -idirafter ../uapi -D_GNU_SOURCE
 CC := clang
 
 config: config.c ../config.c ../encoding.c
@@ -17,7 +17,10 @@ uapi: uapi.c ../ipc.c ../curve25519.c ../encoding.c
 stringlist: stringlist.c ../ipc.c ../curve25519.c ../encoding.c
 	$(CC) $(CFLAGS) -o $@ $<
 
+cmd: cmd.c $(wildcard ../*.c)
+	$(CC) $(CFLAGS) -D'RUNSTATEDIR="/var/empty"' -D'main(a,b)=wg_main(a,b)' -o $@ $^ -lmnl
+
 clean:
-	rm -f config uapi stringlist
+	rm -f config uapi stringlist cmd
 
 .PHONY: all clean
diff --git a/src/fuzz/cmd.c b/src/fuzz/cmd.c
new file mode 100644
index 0000000..8d75eb7
--- /dev/null
+++ b/src/fuzz/cmd.c
@@ -0,0 +1,72 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+
+const char *__asan_default_options()
+{
+	return "verbosity=1";
+}
+
+int wg_main(int argc, char *argv[]);
+
+static FILE *devnull;
+
+int LLVMFuzzerTestOneInput(const char *data, size_t data_len)
+{
+	char *argv[8192] = { 0 }, *args;
+	size_t argc = 0;
+	FILE *fake_stdin = NULL;
+
+	if (!devnull) {
+		assert((devnull = fopen("/dev/null", "r+")));
+		stdin = stdout = stderr = devnull;
+	}
+
+	assert((args = malloc(data_len)));
+	memcpy(args, data, data_len);
+	if (data_len)
+		args[data_len - 1] = '\0';
+
+	for (const char *arg = args; argc < 8192 && arg - args < data_len; arg += strlen(arg) + 1) {
+		if (arg[0])
+			assert((argv[argc++] = strdup(arg)));
+	}
+	if (!argc)
+		assert((argv[argc++] = strdup("no argv[0]!")));
+	if (argc > 2 && (!strcmp(argv[1], "show") || !strcmp(argv[1], "showconf") || !strcmp(argv[1], "set") || !strcmp(argv[1], "setconf") || !strcmp(argv[1], "addconf") || !strcmp(argv[1], "syncconf"))) {
+		free(argv[2]);
+		assert((argv[2] = strdup("wg0")));
+	}
+	if (argc >= 2 && !strcmp(argv[1], "pubkey")) {
+		char *arg;
+		size_t len;
+
+		for (size_t i = 2; i < argc; ++i)
+			free(argv[i]);
+		argc = 2;
+		arg = args;
+		for (; !arg[0]; ++arg);
+		arg += strlen(arg) + 1;
+		for (; !arg[0]; ++arg);
+		arg += strlen(arg) + 1;
+		len = data_len - (arg - args);
+		if (len <= 1)
+			goto done;
+		assert((fake_stdin = fmemopen(arg, len - 1, "r")));
+		stdin = fake_stdin;
+	}
+	wg_main(argc, argv);
+done:
+	for (size_t i = 0; i < argc; ++i)
+		free(argv[i]);
+	free(args);
+	if (fake_stdin)
+		fclose(fake_stdin);
+	return 0;
+}
diff --git a/src/fuzz/stringlist.c b/src/fuzz/stringlist.c
index 85f7330..9823aa0 100644
--- a/src/fuzz/stringlist.c
+++ b/src/fuzz/stringlist.c
@@ -4,9 +4,9 @@
  */
 
 #define RUNSTATEDIR "/var/empty"
+#include "../curve25519.c"
 #undef __linux__
 #include "../ipc.c"
-#include "../curve25519.c"
 #include "../encoding.c"
 
 #include <stdint.h>
diff --git a/src/fuzz/uapi.c b/src/fuzz/uapi.c
index a387125..46576bd 100644
--- a/src/fuzz/uapi.c
+++ b/src/fuzz/uapi.c
@@ -8,9 +8,9 @@
 static FILE *hacked_userspace_interface_file(const char *iface);
 #define stat(a, b) ({ return hacked_userspace_interface_file(iface); 0; })
 #define RUNSTATEDIR "/var/empty"
+#include "../curve25519.c"
 #undef __linux__
 #include "../ipc.c"
-#include "../curve25519.c"
 #include "../encoding.c"
 
 #include <stdint.h>

commit 1d2d6200b8ff517db0f7530645180df3cc4afa74
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Jan 4 14:46:27 2020 +0100

    ipc: simplify inflatable buffer and add fuzzer
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/fuzz/Makefile b/src/fuzz/Makefile
index 98a16dd..3fb2970 100644
--- a/src/fuzz/Makefile
+++ b/src/fuzz/Makefile
@@ -2,10 +2,10 @@
 #
 # Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
-all: config uapi
+all: config uapi stringlist
 
 CFLAGS ?= -O3 -march=native -g
-CFLAGS += -fsanitize=fuzzer -std=gnu11 -idirafter ../uapi
+CFLAGS += -fsanitize=fuzzer -fsanitize=address -std=gnu11 -idirafter ../uapi
 CC := clang
 
 config: config.c ../config.c ../encoding.c
@@ -14,7 +14,10 @@ config: config.c ../config.c ../encoding.c
 uapi: uapi.c ../ipc.c ../curve25519.c ../encoding.c
 	$(CC) $(CFLAGS) -o $@ $<
 
+stringlist: stringlist.c ../ipc.c ../curve25519.c ../encoding.c
+	$(CC) $(CFLAGS) -o $@ $<
+
 clean:
-	rm -f config uapi
+	rm -f config uapi stringlist
 
 .PHONY: all clean
diff --git a/src/fuzz/config.c b/src/fuzz/config.c
index 49c87b4..5812b4c 100644
--- a/src/fuzz/config.c
+++ b/src/fuzz/config.c
@@ -18,7 +18,7 @@
 
 const char *__asan_default_options()
 {
-        return "verbosity=1";
+	return "verbosity=1";
 }
 
 int LLVMFuzzerTestOneInput(const uint8_t *data, size_t len)
diff --git a/src/fuzz/stringlist.c b/src/fuzz/stringlist.c
new file mode 100644
index 0000000..85f7330
--- /dev/null
+++ b/src/fuzz/stringlist.c
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#define RUNSTATEDIR "/var/empty"
+#undef __linux__
+#include "../ipc.c"
+#include "../curve25519.c"
+#include "../encoding.c"
+
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+
+const char *__asan_default_options()
+{
+	return "verbosity=1";
+}
+
+int LLVMFuzzerTestOneInput(const uint8_t *data, size_t data_len)
+{
+	struct string_list list = { 0 };
+	char *interfaces;
+
+	if (!data_len)
+		return 0;
+
+	interfaces = malloc(data_len);
+	assert(interfaces);
+	memcpy(interfaces, data, data_len);
+	interfaces[data_len - 1] = '\0';
+
+	for (char *interface = interfaces; interface - interfaces < data_len; interface += strlen(interface) + 1)
+		assert(string_list_add(&list, interface) == 0);
+
+	for (char *interface = interfaces, *interface2 = list.buffer;;) {
+		size_t len;
+
+		if (interface - interfaces >= data_len) {
+			assert(!interface2 || !strlen(interface2));
+			break;
+		}
+		len = strlen(interface);
+		if (!len) {
+			++interface;
+			continue;
+		}
+		assert(strlen(interface2) == len);
+		assert(!memcmp(interface, interface2, len + 1));
+		interface += len + 1;
+		interface2 += len + 1;
+	}
+	free(list.buffer);
+	free(interfaces);
+	return 0;
+}
diff --git a/src/fuzz/uapi.c b/src/fuzz/uapi.c
index 90b2ba6..a387125 100644
--- a/src/fuzz/uapi.c
+++ b/src/fuzz/uapi.c
@@ -20,7 +20,7 @@ static FILE *hacked_userspace_interface_file(const char *iface);
 
 const char *__asan_default_options()
 {
-        return "verbosity=1";
+	return "verbosity=1";
 }
 
 union hackiface {
diff --git a/src/ipc.c b/src/ipc.c
index 9833b33..1110670 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -48,50 +48,34 @@
 #define SOCKET_BUFFER_SIZE 8192
 #endif
 
-struct inflatable_buffer {
+struct string_list {
 	char *buffer;
-	char *next;
-	bool good;
 	size_t len;
-	size_t pos;
+	size_t cap;
 };
 
-#define max(a, b) ((a) > (b) ? (a) : (b))
-static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
+static int string_list_add(struct string_list *list, const char *str)
 {
-	size_t len, expand_to;
-	char *new_buffer;
+	size_t len = strlen(str) + 1;
 
-	if (!buffer->good || !buffer->next) {
-		free(buffer->next);
-		buffer->good = false;
+	if (len == 1)
 		return 0;
-	}
-
-	len = strlen(buffer->next) + 1;
 
-	if (len == 1) {
-		free(buffer->next);
-		buffer->good = false;
-		return 0;
-	}
+	if (len >= list->cap - list->len) {
+		char *new_buffer;
+		size_t new_cap = list->cap * 2;
 
-	if (buffer->len - buffer->pos <= len) {
-		expand_to = max(buffer->len * 2, buffer->len + len + 1);
-		new_buffer = realloc(buffer->buffer, expand_to);
-		if (!new_buffer) {
-			free(buffer->next);
-			buffer->good = false;
+		if (new_cap <  list->len +len + 1)
+			new_cap = list->len + len + 1;
+		new_buffer = realloc(list->buffer, new_cap);
+		if (!new_buffer)
 			return -errno;
-		}
-		memset(&new_buffer[buffer->len], 0, expand_to - buffer->len);
-		buffer->buffer = new_buffer;
-		buffer->len = expand_to;
-	}
-	memcpy(&buffer->buffer[buffer->pos], buffer->next, len);
-	free(buffer->next);
-	buffer->good = false;
-	buffer->pos += len;
+		list->buffer = new_buffer;
+		list->cap = new_cap;
+	}
+	memcpy(list->buffer + list->len, str, len);
+	list->len += len;
+	list->buffer[list->len] = '\0';
 	return 0;
 }
 
@@ -167,7 +151,7 @@ static bool userspace_has_wireguard_interface(const char *iface)
 	return true;
 }
 
-static int userspace_get_wireguard_interfaces(struct inflatable_buffer *buffer)
+static int userspace_get_wireguard_interfaces(struct string_list *list)
 {
 	DIR *dir;
 	struct dirent *ent;
@@ -188,9 +172,7 @@ static int userspace_get_wireguard_interfaces(struct inflatable_buffer *buffer)
 		*end = '\0';
 		if (!userspace_has_wireguard_interface(ent->d_name))
 			continue;
-		buffer->next = strdup(ent->d_name);
-		buffer->good = true;
-		ret = add_next_to_inflatable_buffer(buffer);
+		ret = string_list_add(list, ent->d_name);
 		if (ret < 0)
 			goto out;
 	}
@@ -451,37 +433,42 @@ err:
 
 #ifdef __linux__
 
+struct interface {
+	const char *name;
+	bool is_wireguard;
+};
+
 static int parse_linkinfo(const struct nlattr *attr, void *data)
 {
-	struct inflatable_buffer *buffer = data;
+	struct interface *interface = data;
 
-	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp("wireguard", mnl_attr_get_str(attr)))
-		buffer->good = true;
+	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp(WG_GENL_NAME, mnl_attr_get_str(attr)))
+		interface->is_wireguard = true;
 	return MNL_CB_OK;
 }
 
 static int parse_infomsg(const struct nlattr *attr, void *data)
 {
-	struct inflatable_buffer *buffer = data;
+	struct interface *interface = data;
 
 	if (mnl_attr_get_type(attr) == IFLA_LINKINFO)
 		return mnl_attr_parse_nested(attr, parse_linkinfo, data);
 	else if (mnl_attr_get_type(attr) == IFLA_IFNAME)
-		buffer->next = strdup(mnl_attr_get_str(attr));
+		interface->name = mnl_attr_get_str(attr);
 	return MNL_CB_OK;
 }
 
 static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
 {
-	struct inflatable_buffer *buffer = data;
+	struct string_list *list = data;
+	struct interface interface = { 0 };
 	int ret;
 
-	buffer->good = false;
-	buffer->next = NULL;
-	ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, data);
+	ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, &interface);
 	if (ret != MNL_CB_OK)
 		return ret;
-	ret = add_next_to_inflatable_buffer(buffer);
+	if (interface.name && interface.is_wireguard)
+		ret = string_list_add(list, interface.name);
 	if (ret < 0)
 		return ret;
 	if (nlh->nlmsg_type != NLMSG_DONE)
@@ -489,7 +476,7 @@ static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
 	return MNL_CB_OK;
 }
 
-static int kernel_get_wireguard_interfaces(struct inflatable_buffer *buffer)
+static int kernel_get_wireguard_interfaces(struct string_list *list)
 {
 	struct mnl_socket *nl = NULL;
 	char *rtnl_buffer = NULL;
@@ -536,7 +523,7 @@ another:
 		ret = -errno;
 		goto cleanup;
 	}
-	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, buffer)) < 0) {
+	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, list)) < 0) {
 		/* Netlink returns NLM_F_DUMP_INTR if the set of all tunnels changed
 		 * during the dump. That's unfortunate, but is pretty common on busy
 		 * systems that are adding and removing tunnels all the time. Rather
@@ -940,30 +927,25 @@ out:
 /* first\0second\0third\0forth\0last\0\0 */
 char *ipc_list_devices(void)
 {
-	struct inflatable_buffer buffer = { .len = SOCKET_BUFFER_SIZE };
+	struct string_list list = { 0 };
 	int ret;
 
-	ret = -ENOMEM;
-	buffer.buffer = calloc(1, buffer.len);
-	if (!buffer.buffer)
-		goto cleanup;
-
 #ifdef __linux__
-	ret = kernel_get_wireguard_interfaces(&buffer);
+	ret = kernel_get_wireguard_interfaces(&list);
 	if (ret < 0)
 		goto cleanup;
 #endif
-	ret = userspace_get_wireguard_interfaces(&buffer);
+	ret = userspace_get_wireguard_interfaces(&list);
 	if (ret < 0)
 		goto cleanup;
 
 cleanup:
 	errno = -ret;
 	if (errno) {
-		free(buffer.buffer);
+		free(list.buffer);
 		return NULL;
 	}
-	return buffer.buffer;
+	return list.buffer ?: strdup("\0");
 }
 
 int ipc_get_device(struct wgdevice **dev, const char *iface)

commit f59f63f4620e89588eaaadb55280e6ca8d8dba1d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jan 3 21:22:22 2020 +0100

    Makefile: add standard 'all' target
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reported-by: Bruno Wolff III <bruno@wolff.to>

diff --git a/src/Makefile b/src/Makefile
index 5331894..9221181 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -103,6 +103,8 @@ install: wg
 check: clean
 	scan-build --html-title=wireguard-tools -maxloop 100 --view --keep-going $(MAKE) wg
 
+all: wg
+.DEFAULT_GOAL: all
 .PHONY: clean install check
 
 -include *.d

commit bfb31ac953a3ccffc95c7f24d617e081b899f6c1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jan 3 12:36:10 2020 +0100

    Makefile: remove pwd from compile output
    
    We previously included $(pwd) in the compile output pretty printer,
    because it matched our parent out-of-tree module build. Since we're no
    longer coupled to the module, we can return to a prettier scheme of just
    using the object name.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Fixes: eb68ad07 ("Makefile: even prettier output")

diff --git a/src/Makefile b/src/Makefile
index dc7452d..5331894 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -68,10 +68,10 @@ endif
 
 ifneq ($(V),1)
 BUILT_IN_LINK.o := $(LINK.o)
-LINK.o = @echo "  LD      $$(pwd)/$@";
+LINK.o = @echo "  LD      $@";
 LINK.o += $(BUILT_IN_LINK.o)
 BUILT_IN_COMPILE.c := $(COMPILE.c)
-COMPILE.c = @echo "  CC      $$(pwd)/$@";
+COMPILE.c = @echo "  CC      $@";
 COMPILE.c += $(BUILT_IN_COMPILE.c)
 endif
 
@@ -79,7 +79,7 @@ wg: $(patsubst %.c,%.o,$(wildcard *.c))
 
 ifneq ($(V),1)
 clean:
-	@echo "  CLEAN   $$(pwd)/{wg,*.o,*.d}"
+	@echo "  CLEAN   {wg,*.o,*.d}"
 	@$(RM) wg *.o *.d
 else
 clean:

commit 3bf1b64d44fdbe589ac145b61bd4b3aa62b625bf
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 2 19:53:11 2020 +0100

    version: bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
index 92406d5..d3e9719 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1,3 +1,3 @@
 #ifndef WIREGUARD_TOOLS_VERSION
-#define WIREGUARD_TOOLS_VERSION "1.0.20191226"
+#define WIREGUARD_TOOLS_VERSION "1.0.20200102"
 #endif

commit d8230ea0dcb02d716125b2b3c076f2de40ebed99
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 2 19:52:25 2020 +0100

    global: bump copyright
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/dns-hatchet/apply.sh b/contrib/dns-hatchet/apply.sh
index 44e5980..d98e4c8 100755
--- a/contrib/dns-hatchet/apply.sh
+++ b/contrib/dns-hatchet/apply.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 ME="$(readlink -f "$(dirname "$(readlink -f "$0")")")"
 TOOLS="$ME/../../src"
diff --git a/contrib/embeddable-wg-library/test.c b/contrib/embeddable-wg-library/test.c
index 25fc9ea..4c95373 100644
--- a/contrib/embeddable-wg-library/test.c
+++ b/contrib/embeddable-wg-library/test.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: LGPL-2.1+
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include "wireguard.h"
diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index 54b8700..fd68918 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: LGPL-2.1+
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  * Copyright (C) 2008-2012 Pablo Neira Ayuso <pablo@netfilter.org>.
  */
 
diff --git a/contrib/embeddable-wg-library/wireguard.h b/contrib/embeddable-wg-library/wireguard.h
index e7a1bbf..fbd8765 100644
--- a/contrib/embeddable-wg-library/wireguard.h
+++ b/contrib/embeddable-wg-library/wireguard.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: LGPL-2.1+ */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef WIREGUARD_H
diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 0f8deda..a52f16e 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 package main
 
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index 9fb78f2..4b6ebcc 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 extern crate snow;
 extern crate base64;
diff --git a/contrib/extract-handshakes/extract-handshakes.sh b/contrib/extract-handshakes/extract-handshakes.sh
index f794ffe..688f4e4 100755
--- a/contrib/extract-handshakes/extract-handshakes.sh
+++ b/contrib/extract-handshakes/extract-handshakes.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 # Copyright (C) 2017-2018 Peter Wu <peter@lekensteyn.nl>. All Rights Reserved.
 
 set -e
diff --git a/contrib/extract-handshakes/offset-finder.c b/contrib/extract-handshakes/offset-finder.c
index ecde5ac..1b54cf3 100644
--- a/contrib/extract-handshakes/offset-finder.c
+++ b/contrib/extract-handshakes/offset-finder.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 struct def {
diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index 09252a2..640c61b 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 struct def {
diff --git a/contrib/extract-keys/extract-keys.c b/contrib/extract-keys/extract-keys.c
index 1906be6..3d05f7c 100644
--- a/contrib/extract-keys/extract-keys.c
+++ b/contrib/extract-keys/extract-keys.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <endian.h>
diff --git a/contrib/highlighter/fuzz.c b/contrib/highlighter/fuzz.c
index e308157..eaade6b 100644
--- a/contrib/highlighter/fuzz.c
+++ b/contrib/highlighter/fuzz.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdlib.h>
diff --git a/contrib/highlighter/highlight.c b/contrib/highlighter/highlight.c
index b03f792..e9034f7 100644
--- a/contrib/highlighter/highlight.c
+++ b/contrib/highlighter/highlight.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdio.h>
diff --git a/contrib/highlighter/highlighter.c b/contrib/highlighter/highlighter.c
index 1913e35..9f0e53a 100644
--- a/contrib/highlighter/highlighter.c
+++ b/contrib/highlighter/highlighter.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdbool.h>
diff --git a/contrib/highlighter/highlighter.h b/contrib/highlighter/highlighter.h
index c004e12..65cc230 100644
--- a/contrib/highlighter/highlighter.h
+++ b/contrib/highlighter/highlighter.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <sys/types.h>
diff --git a/contrib/json/wg-json b/contrib/json/wg-json
index 8b35521..c763c54 100755
--- a/contrib/json/wg-json
+++ b/contrib/json/wg-json
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 exec < <(exec wg show all dump)
 
diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
index 939e637..fd5b02b 100644
--- a/contrib/keygen-html/keygen.html
+++ b/contrib/keygen-html/keygen.html
@@ -2,7 +2,7 @@
 <script>
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 function sendPubkeyToServer(pubkey, username, password)
diff --git a/contrib/keygen-html/wireguard.js b/contrib/keygen-html/wireguard.js
index e262459..2349ca2 100644
--- a/contrib/keygen-html/wireguard.js
+++ b/contrib/keygen-html/wireguard.js
@@ -1,6 +1,6 @@
 /*! SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 (function() {
diff --git a/contrib/nat-hole-punching/nat-punch-client.c b/contrib/nat-hole-punching/nat-punch-client.c
index 01bb096..7e53b67 100644
--- a/contrib/nat-hole-punching/nat-punch-client.c
+++ b/contrib/nat-hole-punching/nat-punch-client.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Example only. Do not run in production.
  */
diff --git a/contrib/nat-hole-punching/nat-punch-server.c b/contrib/nat-hole-punching/nat-punch-server.c
index a6a5a4c..428fd6d 100644
--- a/contrib/nat-hole-punching/nat-punch-server.c
+++ b/contrib/nat-hole-punching/nat-punch-server.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Example only. Do not run in production.
  */
diff --git a/contrib/ncat-client-server/client-quick.sh b/contrib/ncat-client-server/client-quick.sh
index bf7d7f1..971f3ec 100755
--- a/contrib/ncat-client-server/client-quick.sh
+++ b/contrib/ncat-client-server/client-quick.sh
@@ -1,7 +1,7 @@
 #!/usr/bin/env bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
 
diff --git a/contrib/ncat-client-server/client.sh b/contrib/ncat-client-server/client.sh
index dd0f575..8df29ab 100755
--- a/contrib/ncat-client-server/client.sh
+++ b/contrib/ncat-client-server/client.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
 [[ $UID == 0 ]] || { echo "You must be root to run this."; exit 1; }
diff --git a/contrib/ncat-client-server/server.sh b/contrib/ncat-client-server/server.sh
index 38a69e1..926661e 100755
--- a/contrib/ncat-client-server/server.sh
+++ b/contrib/ncat-client-server/server.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 if [[ -z $NCAT_REMOTE_ADDR ]]; then
 	ip link del dev wg0 2>/dev/null
diff --git a/contrib/reresolve-dns/reresolve-dns.sh b/contrib/reresolve-dns/reresolve-dns.sh
index 8ab3635..fd38cd4 100755
--- a/contrib/reresolve-dns/reresolve-dns.sh
+++ b/contrib/reresolve-dns/reresolve-dns.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
 shopt -s nocasematch
diff --git a/contrib/sticky-sockets/sticky-sockets.c b/contrib/sticky-sockets/sticky-sockets.c
index d856ef2..d9a11ad 100644
--- a/contrib/sticky-sockets/sticky-sockets.c
+++ b/contrib/sticky-sockets/sticky-sockets.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This implements userspace semantics of "sticky sockets", modeled after
  * WireGuard's kernelspace implementation.
diff --git a/contrib/synergy/synergy-client.sh b/contrib/synergy/synergy-client.sh
index de358ef..d1dfcbd 100755
--- a/contrib/synergy/synergy-client.sh
+++ b/contrib/synergy/synergy-client.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
 if [[ $UID == 0 ]]; then
diff --git a/contrib/synergy/synergy-server.sh b/contrib/synergy/synergy-server.sh
index e04b1f4..b8a7158 100755
--- a/contrib/synergy/synergy-server.sh
+++ b/contrib/synergy/synergy-server.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
 if [[ $UID == 0 ]]; then
diff --git a/src/Makefile b/src/Makefile
index 049d555..dc7452d 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 PKG_CONFIG ?= pkg-config
 PREFIX ?= /usr
diff --git a/src/completion/wg-quick.bash-completion b/src/completion/wg-quick.bash-completion
index 1ec98d9..f8973cd 100644
--- a/src/completion/wg-quick.bash-completion
+++ b/src/completion/wg-quick.bash-completion
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_quick_completion() {
 	local p i a search_paths old_glob
diff --git a/src/completion/wg.bash-completion b/src/completion/wg.bash-completion
index cc6ac06..445f0e8 100644
--- a/src/completion/wg.bash-completion
+++ b/src/completion/wg.bash-completion
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_completion() {
 	local a
diff --git a/src/config.c b/src/config.c
index db90228..b8394a5 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <arpa/inet.h>
diff --git a/src/config.h b/src/config.h
index 9c31e8c..8bbe236 100644
--- a/src/config.h
+++ b/src/config.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef CONFIG_H
diff --git a/src/containers.h b/src/containers.h
index b312c72..2ffc230 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef CONTAINERS_H
diff --git a/src/curve25519-fiat32.h b/src/curve25519-fiat32.h
index 42cfb6c..66f3309 100644
--- a/src/curve25519-fiat32.h
+++ b/src/curve25519-fiat32.h
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
 /*
  * Copyright (C) 2015-2016 The fiat-crypto Authors.
- * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a machine-generated formally verified implementation of Curve25519
  * ECDH from: <https://github.com/mit-plv/fiat-crypto>. Though originally
diff --git a/src/curve25519-hacl64.h b/src/curve25519-hacl64.h
index 0f729ec..1fba1f5 100644
--- a/src/curve25519-hacl64.h
+++ b/src/curve25519-hacl64.h
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
 /*
  * Copyright (C) 2016-2017 INRIA and Microsoft Corporation.
- * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a machine-generated formally verified implementation of Curve25519
  * ECDH from: <https://github.com/mitls/hacl-star>. Though originally machine
diff --git a/src/curve25519.c b/src/curve25519.c
index f1b6358..7d3fd15 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include "curve25519.h"
diff --git a/src/curve25519.h b/src/curve25519.h
index c047019..1569824 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef CURVE25519_H
diff --git a/src/encoding.c b/src/encoding.c
index af2fc82..2540e5b 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a specialized constant-time base64/hex implementation that resists side-channel attacks.
  */
diff --git a/src/encoding.h b/src/encoding.h
index f977ee9..2d2c1e0 100644
--- a/src/encoding.h
+++ b/src/encoding.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef ENCODING_H
diff --git a/src/fuzz/Makefile b/src/fuzz/Makefile
index 0e7ddb5..98a16dd 100644
--- a/src/fuzz/Makefile
+++ b/src/fuzz/Makefile
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 all: config uapi
 
diff --git a/src/fuzz/config.c b/src/fuzz/config.c
index 4877ba7..49c87b4 100644
--- a/src/fuzz/config.c
+++ b/src/fuzz/config.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdio.h>
diff --git a/src/fuzz/uapi.c b/src/fuzz/uapi.c
index 3094f1c..90b2ba6 100644
--- a/src/fuzz/uapi.c
+++ b/src/fuzz/uapi.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2018-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdio.h>
diff --git a/src/genkey.c b/src/genkey.c
index b9c2a86..d1bb643 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <errno.h>
diff --git a/src/ipc.c b/src/ipc.c
index 64d8b20..9833b33 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifdef __linux__
diff --git a/src/ipc.h b/src/ipc.h
index 6c564be..c51c8e7 100644
--- a/src/ipc.h
+++ b/src/ipc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef IPC_H
diff --git a/src/mnlg.c b/src/mnlg.c
index 173e366..0651896 100644
--- a/src/mnlg.c
+++ b/src/mnlg.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
  */
diff --git a/src/mnlg.h b/src/mnlg.h
index b5adbbc..8585491 100644
--- a/src/mnlg.h
+++ b/src/mnlg.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
  */
diff --git a/src/pubkey.c b/src/pubkey.c
index cbf1744..19235fc 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <errno.h>
diff --git a/src/set.c b/src/set.c
index 19f4b92..0a98f7b 100644
--- a/src/set.c
+++ b/src/set.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdio.h>
diff --git a/src/setconf.c b/src/setconf.c
index f778f40..89b3023 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stddef.h>
diff --git a/src/show.c b/src/show.c
index ff0897d..e772339 100644
--- a/src/show.c
+++ b/src/show.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <arpa/inet.h>
diff --git a/src/showconf.c b/src/showconf.c
index ad76b7f..6e6a4a5 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <arpa/inet.h>
diff --git a/src/subcommands.h b/src/subcommands.h
index afac10a..68e9334 100644
--- a/src/subcommands.h
+++ b/src/subcommands.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef SUBCOMMANDS_H
diff --git a/src/terminal.c b/src/terminal.c
index 899d6ca..ba88597 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <ctype.h>
diff --git a/src/terminal.h b/src/terminal.h
index a824ad7..e8cb570 100644
--- a/src/terminal.h
+++ b/src/terminal.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef TERMINAL_H
diff --git a/src/uapi/linux/wireguard.h b/src/uapi/linux/wireguard.h
index ae88be1..0efd52c 100644
--- a/src/uapi/linux/wireguard.h
+++ b/src/uapi/linux/wireguard.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: (GPL-2.0 WITH Linux-syscall-note) OR MIT */
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Documentation
  * =============
diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index ad05895..cedc8a7 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a shell script written in C. It very intentionally still functions like
  * a shell script, calling out to external executables such as ip(8).
diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index d5dd396..d9d07cf 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -1,7 +1,7 @@
 #!/usr/bin/env bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index a72353c..c390dcc 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -1,7 +1,7 @@
 #!/usr/local/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index cd5e066..7c2c002 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index 2cadeec..8d458d1 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -1,7 +1,7 @@
 #!/usr/local/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg.c b/src/wg.c
index dc6dda4..b9952eb 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stddef.h>
diff --git a/src/wincompat/compat.h b/src/wincompat/compat.h
index 4dada77..5decc66 100644
--- a/src/wincompat/compat.h
+++ b/src/wincompat/compat.h
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #define __USE_MINGW_ANSI_STDIO 1
diff --git a/src/wincompat/getrandom.c b/src/wincompat/getrandom.c
index 4e2c4bd..b064b04 100644
--- a/src/wincompat/getrandom.c
+++ b/src/wincompat/getrandom.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdbool.h>
diff --git a/src/wincompat/init.c b/src/wincompat/init.c
index 8d862ff..8943fff 100644
--- a/src/wincompat/init.c
+++ b/src/wincompat/init.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <winsock2.h>
diff --git a/src/wincompat/ipc.c b/src/wincompat/ipc.c
index 25471b0..9dce816 100644
--- a/src/wincompat/ipc.c
+++ b/src/wincompat/ipc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <windows.h>
diff --git a/src/wincompat/libc.c b/src/wincompat/libc.c
index ad30278..870d913 100644
--- a/src/wincompat/libc.c
+++ b/src/wincompat/libc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdio.h>

commit 16e20de72293f048a5a42f78db9781db836d7409
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Dec 28 18:35:12 2019 +0100

    wg-quick: linux: quote ifname for nft
    
    Otherwise nft(8) has strange ideas of what a string is.
    
    Suggested-by: RistiCore <RistiCore@mail.ee>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index e9c9052..cd5e066 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -227,7 +227,7 @@ add_default() {
 	while read -r line; do
 		[[ $line =~ .*inet6?\ ([0-9a-f:.]+)/[0-9]+.* ]] || continue
 		printf -v restore '%s-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${BASH_REMATCH[1]}" "$marker"
-		printf -v nftcmd '%sadd rule %s %s preraw iifname != %s %s daddr %s fib saddr type != local drop\n' "$nftcmd" "$pf" "$nftable" "$INTERFACE" "$pf" "${BASH_REMATCH[1]}"
+		printf -v nftcmd '%sadd rule %s %s preraw iifname != "%s" %s daddr %s fib saddr type != local drop\n' "$nftcmd" "$pf" "$nftable" "$INTERFACE" "$pf" "${BASH_REMATCH[1]}"
 	done < <(ip -o $proto addr show dev "$INTERFACE" 2>/dev/null)
 	printf -v restore '%sCOMMIT\n*mangle\n-I POSTROUTING -m mark --mark %d -p udp -j CONNMARK --save-mark %s\n-I PREROUTING -p udp -j CONNMARK --restore-mark %s\nCOMMIT\n' "$restore" $table "$marker" "$marker"
 	printf -v nftcmd '%sadd rule %s %s postmangle meta l4proto udp mark %d ct mark set mark \n' "$nftcmd" "$pf" "$nftable" $table

commit 3bfe9c41ab9e93646a51e64d53661153d5429817
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 27 18:17:00 2019 +0100

    Makefile: rework automatic version.h mangling
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reported-by: Joe Doss <joe@solidadmin.com>

diff --git a/src/Makefile b/src/Makefile
index e5b2230..049d555 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -46,6 +46,10 @@ CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
 ifeq ($(DEBUG),yes)
 CFLAGS += -g
 endif
+GIT_VERSION := $(shell GIT_CEILING_DIRECTORIES="$(PWD)/../.." git describe --dirty 2>/dev/null)
+ifneq ($(GIT_VERSION),)
+CFLAGS += -D'WIREGUARD_TOOLS_VERSION="$(GIT_VERSION:v%=%)"'
+endif
 ifeq ($(PLATFORM),linux)
 LIBMNL_CFLAGS := $(shell $(PKG_CONFIG) --cflags libmnl 2>/dev/null)
 LIBMNL_LDLIBS := $(shell $(PKG_CONFIG) --libs libmnl 2>/dev/null || echo -lmnl)
@@ -96,17 +100,9 @@ install: wg
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_SYSTEMDUNITS)" = "yes" ] || exit 0; \
 	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -v -m 0644 systemd/wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
 
-wg.o: version.h
-version.h:
-	@export GIT_CEILING_DIRECTORIES="$(PWD)/../.." && \
-	ver="#define WIREGUARD_TOOLS_VERSION \"$$(git describe --dirty 2>/dev/null)\"" && \
-	[ "$$(cat version.h 2>/dev/null)" != "$$ver" ] && \
-	echo "$$ver" > version.h && \
-	git update-index --assume-unchanged version.h || true
-
 check: clean
 	scan-build --html-title=wireguard-tools -maxloop 100 --view --keep-going $(MAKE) wg
 
-.PHONY: clean install version.h check
+.PHONY: clean install check
 
 -include *.d
diff --git a/src/version.h b/src/version.h
index c382f86..92406d5 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1 +1,3 @@
+#ifndef WIREGUARD_TOOLS_VERSION
 #define WIREGUARD_TOOLS_VERSION "1.0.20191226"
+#endif

commit 2d000809ddbebbc6841b4711c2c0440269dce05e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 27 14:57:09 2019 +0100

    fuzz: find bugs when parsing uapi input
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/fuzz/.gitignore b/src/fuzz/.gitignore
index 04204c7..988712e 100644
--- a/src/fuzz/.gitignore
+++ b/src/fuzz/.gitignore
@@ -1 +1,2 @@
 config
+uapi
diff --git a/src/fuzz/Makefile b/src/fuzz/Makefile
index 87a5dcd..0e7ddb5 100644
--- a/src/fuzz/Makefile
+++ b/src/fuzz/Makefile
@@ -2,15 +2,19 @@
 #
 # Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
-all: config
+all: config uapi
 
 CFLAGS ?= -O3 -march=native -g
 CFLAGS += -fsanitize=fuzzer -std=gnu11 -idirafter ../uapi
+CC := clang
 
 config: config.c ../config.c ../encoding.c
-	clang $(CFLAGS) -o $@ $<
+	$(CC) $(CFLAGS) -o $@ $<
+
+uapi: uapi.c ../ipc.c ../curve25519.c ../encoding.c
+	$(CC) $(CFLAGS) -o $@ $<
 
 clean:
-	rm -f config
+	rm -f config uapi
 
 .PHONY: all clean
diff --git a/src/fuzz/uapi.c b/src/fuzz/uapi.c
new file mode 100644
index 0000000..3094f1c
--- /dev/null
+++ b/src/fuzz/uapi.c
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdio.h>
+#include <sys/stat.h>
+static FILE *hacked_userspace_interface_file(const char *iface);
+#define stat(a, b) ({ return hacked_userspace_interface_file(iface); 0; })
+#define RUNSTATEDIR "/var/empty"
+#undef __linux__
+#include "../ipc.c"
+#include "../curve25519.c"
+#include "../encoding.c"
+
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+const char *__asan_default_options()
+{
+        return "verbosity=1";
+}
+
+union hackiface {
+	char ifname[IFNAMSIZ];
+	struct {
+		const uint8_t *data;
+		size_t len;
+	};
+};
+
+static FILE *hacked_userspace_interface_file(const char *iface)
+{
+	union hackiface *hack = (union hackiface *)iface;
+	FILE *f = fmemopen(NULL, hack->len + 7, "r+");
+	fseek(f, 7, SEEK_SET);
+	fwrite(hack->data, hack->len, 1, f);
+	fseek(f, 0, SEEK_SET);
+	memcpy(hack->ifname, "hack", 5);
+	return f;
+}
+
+int LLVMFuzzerTestOneInput(const uint8_t *data, size_t len)
+{
+	union hackiface hack = {
+		.data = data,
+		.len = len
+	};
+	struct wgdevice *dev = NULL;
+
+	userspace_get_device(&dev, (const char *)&hack);
+	free_wgdevice(dev);
+	return 0;
+}

commit cde6f312e4eb8f90a17dd081fcc80433900e2a76
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 27 13:40:26 2019 +0100

    fuzz: find bugs in the config syntax parser
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/fuzz/.gitignore b/src/fuzz/.gitignore
new file mode 100644
index 0000000..04204c7
--- /dev/null
+++ b/src/fuzz/.gitignore
@@ -0,0 +1 @@
+config
diff --git a/src/fuzz/Makefile b/src/fuzz/Makefile
new file mode 100644
index 0000000..87a5dcd
--- /dev/null
+++ b/src/fuzz/Makefile
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
+all: config
+
+CFLAGS ?= -O3 -march=native -g
+CFLAGS += -fsanitize=fuzzer -std=gnu11 -idirafter ../uapi
+
+config: config.c ../config.c ../encoding.c
+	clang $(CFLAGS) -o $@ $<
+
+clean:
+	rm -f config
+
+.PHONY: all clean
diff --git a/src/fuzz/config.c b/src/fuzz/config.c
new file mode 100644
index 0000000..4877ba7
--- /dev/null
+++ b/src/fuzz/config.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdio.h>
+#undef stderr
+#define stderr stdin
+#include "../config.c"
+#include "../encoding.c"
+#undef stderr
+
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "../config.h"
+
+const char *__asan_default_options()
+{
+        return "verbosity=1";
+}
+
+int LLVMFuzzerTestOneInput(const uint8_t *data, size_t len)
+{
+	bool file;
+	char *input;
+
+	if (len < 2)
+		return 0;
+	file = !!(data[0] >> 7);
+	input = malloc(len);
+	if (!input)
+		return 0;
+	memcpy(input, data + 1, len - 1);
+	input[len - 1] = '\0';
+
+	if (file) {
+		struct config_ctx ctx;
+		char *saveptr;
+
+		config_read_init(&ctx, false);
+		for (char *line = strtok_r(input, "\n", &saveptr); line; line = strtok_r(NULL, "\n", &saveptr)) {
+			if (!config_read_line(&ctx, line))
+				config_read_init(&ctx, false);
+		}
+		free_wgdevice(config_read_finish(&ctx));
+	} else {
+		size_t spaces = 0;
+		char **argv, *saveptr;
+
+		for (char *c = input; *c; ++c) {
+			if (*c == ' ')
+				++spaces;
+		}
+		argv = calloc(spaces + 1, sizeof(char *));
+		if (!argv)
+			goto out;
+		spaces = 0;
+		for (char *token = strtok_r(input, " ", &saveptr); token; token = strtok_r(NULL, " ", &saveptr))
+			argv[spaces++] = token;
+		free_wgdevice(config_read_cmd(argv, spaces));
+		free(argv);
+	}
+
+out:
+	free(input);
+	return 0;
+}

commit 318253d932a43f8213f3521b299cf76f9db27286
Author: Devin Smith <thundza@gmail.com>
Date:   Thu Dec 26 21:35:26 2019 -0600

    man: add documentation about removing explicit listen-port
    
    Signed-off-by: Devin Smith <thundza@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg.8 b/src/man/wg.8
index ac281bc..07b9694 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -59,7 +59,7 @@ by \fICONFIGURATION FILE FORMAT\fP below.
 Sets configuration values for the specified \fI<interface>\fP. Multiple
 \fIpeer\fPs may be specified, and if the \fIremove\fP argument is given
 for a peer, that peer is removed, not configured. If \fIlisten-port\fP
-is not specified, the port will be chosen randomly when the
+is not specified, or set to 0, the port will be chosen randomly when the
 interface comes up. Both \fIprivate-key\fP and \fIpreshared-key\fP must
 be a files, because command line arguments are not considered private on
 most systems but if you are using

commit d359ead4dcde5a50414a09fd67c7abbc0cce5f7e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 18:10:37 2019 +0100

    dns-hatchet: adjust path for new repo layout
    
    Reported-by: Joe Doss <joe@solidadmin.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/dns-hatchet/apply.sh b/contrib/dns-hatchet/apply.sh
index 2bf002d..44e5980 100755
--- a/contrib/dns-hatchet/apply.sh
+++ b/contrib/dns-hatchet/apply.sh
@@ -4,6 +4,6 @@
 # Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 ME="$(readlink -f "$(dirname "$(readlink -f "$0")")")"
-TOOLS="$ME/../../../src/tools"
+TOOLS="$ME/../../src"
 
 sed -i "/~~ function override insertion point ~~/r $ME/hatchet.bash" "$TOOLS/wg-quick/linux.bash"

commit f9f1ba795e1293ec1e358f935ac695ebac95018c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 16:54:25 2019 +0100

    Makefile: port static analysis check
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index de1a16c..e5b2230 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -104,6 +104,9 @@ version.h:
 	echo "$$ver" > version.h && \
 	git update-index --assume-unchanged version.h || true
 
-.PHONY: clean install version.h
+check: clean
+	scan-build --html-title=wireguard-tools -maxloop 100 --view --keep-going $(MAKE) wg
+
+.PHONY: clean install version.h check
 
 -include *.d

commit ff7e5dfe30bcb2e49da56aac7566a435fbb09c52
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 16:50:55 2019 +0100

    Makefile: DEBUG_TOOLS -> DEBUG and document
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/README.md b/README.md
index db5a4d5..be66e21 100644
--- a/README.md
+++ b/README.md
@@ -36,6 +36,7 @@ This command takes into account several environment variables:
   * `WITH_BASHCOMPLETION`  default: [auto-detect]
   * `WITH_WGQUICK`         default: [auto-detect]
   * `WITH_SYSTEMDUNITS`    default: [auto-detect]
+  * `DEBUG`                default:
 
 The first section is rather standard. The second section is not:
 
@@ -61,6 +62,8 @@ The first section is rather standard. The second section is not:
     should set it to `no`. If systemd isn't auto-detected, but you still would
     like to install it, set this to `yes`.
 
+  * `DEBUG` decides whether to build with `-g`, when set to `yes`.
+
 If you're a simple `make && make install` kind of user, you can get away with
 not setting these variables and relying on the auto-detection. However, if
 you're writing a package for a distro, you'll want to explicitly set these,
diff --git a/src/Makefile b/src/Makefile
index f8eaebf..de1a16c 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -43,7 +43,7 @@ CFLAGS += -std=gnu99 -D_GNU_SOURCE
 CFLAGS += -Wall -Wextra
 CFLAGS += -MMD -MP
 CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
-ifeq ($(DEBUG_TOOLS),y)
+ifeq ($(DEBUG),yes)
 CFLAGS += -g
 endif
 ifeq ($(PLATFORM),linux)

commit 7861d89b7c12bcd3e461494d0f74454c60d9efcb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 13:57:22 2019 +0100

    systemd: update documentation URL
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/systemd/wg-quick@.service b/src/systemd/wg-quick@.service
index af52848..7c5f9d1 100644
--- a/src/systemd/wg-quick@.service
+++ b/src/systemd/wg-quick@.service
@@ -6,8 +6,8 @@ Documentation=man:wg-quick(8)
 Documentation=man:wg(8)
 Documentation=https://www.wireguard.com/
 Documentation=https://www.wireguard.com/quickstart/
-Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/man/wg-quick.8
-Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/man/wg.8
+Documentation=https://git.zx2c4.com/wireguard-tools/about/src/man/wg-quick.8
+Documentation=https://git.zx2c4.com/wireguard-tools/about/src/man/wg.8
 
 [Service]
 Type=oneshot

commit ae659490cfad766fcee3f8b80a807530c47e4010
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 13:59:11 2019 +0100

    version: bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
index 3b78506..c382f86 100644
--- a/src/version.h
+++ b/src/version.h
@@ -1 +1 @@
-#define WIREGUARD_TOOLS_VERSION "0.0.20191219"
+#define WIREGUARD_TOOLS_VERSION "1.0.20191226"

commit 9130fa0450927fac2e9faa53431873302d78442a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 13:01:00 2019 +0100

    Makefile: add git versioning to dev builds
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 6bbed32..f8eaebf 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -96,6 +96,14 @@ install: wg
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_SYSTEMDUNITS)" = "yes" ] || exit 0; \
 	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -v -m 0644 systemd/wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
 
-.PHONY: clean install
+wg.o: version.h
+version.h:
+	@export GIT_CEILING_DIRECTORIES="$(PWD)/../.." && \
+	ver="#define WIREGUARD_TOOLS_VERSION \"$$(git describe --dirty 2>/dev/null)\"" && \
+	[ "$$(cat version.h 2>/dev/null)" != "$$ver" ] && \
+	echo "$$ver" > version.h && \
+	git update-index --assume-unchanged version.h || true
+
+.PHONY: clean install version.h
 
 -include *.d

commit 011bf3b9f4ef9470ae97fd2b93857a2bdd4f94cb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 12:19:23 2019 +0100

    README: consolidate with INSTALL and rewrite
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/README.md b/README.md
index b8301e2..db5a4d5 100644
--- a/README.md
+++ b/README.md
@@ -1,10 +1,77 @@
-# WireGuard &mdash; fast, modern, secure kernel VPN tunnel
-#### by [Jason A. Donenfeld](mailto:Jason@zx2c4.com) of [Edge Security](https://www.edgesecurity.com/)
+# [wireguard-tools](https://git.zx2c4.com/wireguard-tools/about/) &mdash; tools for configuring [WireGuard](https://www.wireguard.com/)
 
-WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes **state-of-the-art cryptography**. It aims to be faster, simpler, leaner, and more useful than IPsec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. It runs over UDP.
+This supplies the main userspace tooling for using and configuring WireGuard
+tunnels, including the
+[`wg(8)`](https://git.zx2c4.com/wireguard-tools/about/src/man/wg.8) and
+[`wg-quick(8)`](https://git.zx2c4.com/wireguard-tools/about/src/man/wg-quick.8)
+utilities. This project supports Linux, OpenBSD, FreeBSD, macOS, Windows, and
+Android.
 
 **More information may be found at [WireGuard.com](https://www.wireguard.com/).**
 
+## Building
+
+    $ cd src
+    $ make
+
+On Linux, [`libmnl`](https://netfilter.org/projects/libmnl/index.html) is
+required. On Windows, the [MinGW](http://www.mingw.org/) compiler is required.
+On other platforms, only a sane libc is required.
+
+## Installing
+
+    # make install
+
+This command takes into account several environment variables:
+
+  * `PREFIX`               default: `/usr`
+  * `DESTDIR`              default:
+  * `BINDIR`               default: `$(PREFIX)/bin`
+  * `LIBDIR`               default: `$(PREFIX)/lib`
+  * `MANDIR`               default: `$(PREFIX)/share/man`
+  * `BASHCOMPDIR`          default: `$(PREFIX)/share/bash-completion/completions`
+  * `RUNSTATEDIR`          default: `/var/run`
+  * `PKG_CONFIG`           default: `pkg-config`
+
+  * `WITH_BASHCOMPLETION`  default: [auto-detect]
+  * `WITH_WGQUICK`         default: [auto-detect]
+  * `WITH_SYSTEMDUNITS`    default: [auto-detect]
+
+The first section is rather standard. The second section is not:
+
+  * `WITH_BASHCOMPLETION` decides whether or not bash completion files for the
+    tools are installed. This is just a nice thing for people who have bash.
+    If you don't have bash, or don't want this, set the environment variable
+    to `no`. If you'd like to force its use, even if bash-completion isn't
+    detected in `DESTDIR`, then set it to `yes`.
+
+  * `WITH_WGQUICK` decides whether or not the wg-quick(8) script is installed.
+    This is a very quick and dirty bash script for reading a few extra
+    variables from wg(8)-style configuration files, and automatically
+    configures the interface. If you don't have bash, you probably don't want
+    this at all. Likewise, if you already have a working network management
+    tool or configuration, you probably want to integrate wg(8) or the direct
+    WireGuard API into your network manager, rather than using wg-quick(8).
+    But for folks who like simple quick and dirty scripts, this is nice. If you'd
+    like to force its use, even if bash isn't detected in DESTDIR, then set it
+    to `yes`.
+
+  * `WITH_SYSTEMDUNITS` decides whether or not systemd units are installed for
+    wg-quick(8). If you don't use systemd, you certainly don't want this, and
+    should set it to `no`. If systemd isn't auto-detected, but you still would
+    like to install it, set this to `yes`.
+
+If you're a simple `make && make install` kind of user, you can get away with
+not setting these variables and relying on the auto-detection. However, if
+you're writing a package for a distro, you'll want to explicitly set these,
+depending on what you want.
+
+## `contrib/`
+
+The `contrib/` subdirectory contains various scripts and examples. Most of these
+are not immediately useful for production use, but should provide inspiration for
+creating fully-featured tools. See the `README` in each directory.
+
 ## License
 
 This project is released under the [GPLv2](COPYING).
diff --git a/src/INSTALL b/src/INSTALL
deleted file mode 100644
index cc80df5..0000000
--- a/src/INSTALL
+++ /dev/null
@@ -1,48 +0,0 @@
-Installation Makefile Target
-============================
-
-    # make install
-
-This command takes into account several environment variables:
-
-  * PREFIX               default: /usr
-  * DESTDIR              default:
-  * BINDIR               default: $(PREFIX)/bin
-  * LIBDIR               default: $(PREFIX)/lib
-  * MANDIR               default: $(PREFIX)/share/man
-  * BASHCOMPDIR          default: $(PREFIX)/share/bash-completion/completions
-  * RUNSTATEDIR          default: /var/run
-  * PKG_CONFIG           default: pkg-config
-
-  * WITH_BASHCOMPLETION  default: [auto-detect]
-  * WITH_WGQUICK         default: [auto-detect]
-  * WITH_SYSTEMDUNITS    default: [auto-detect]
-
-The first section is rather standard. The second section is not:
-
-  * WITH_BASHCOMPLETION decides whether or not bash completion files for the
-    tools are installed. This is just a nice thing for people who have bash.
-    If you don't have bash, or don't want this, set the environment variable
-    to `no'. If you'd like to force its use, even if bash-completion isn't
-    detected in DESTDIR, then set it to `yes'.
-
-  * WITH_WGQUICK decides whether or not the wg-quick(8) script is installed.
-    This is a very quick and dirty bash script for reading a few extra
-    variables from wg(8)-style configuration files, and automatically
-    configures the interface. If you don't have bash, you probably don't want
-    this at all. Likewise, if you already have a working network management
-    tool or configuration, you probably want to integrate wg(8) or the direct
-    WireGuard API into your network manager, rather than using wg-quick(8).
-    But for folks who like simple quick&dirty scripts, this is nice. If you'd
-    like to force its use, even if bash isn't detected in DESTDIR, then set it
-    to `yes'.
-
-  * WITH_SYSTEMDUNITS decides whether or not systemd units are installed for
-    wg-quick(8). If you don't use systemd, you certainly don't want this, and
-    should set it to `no'. If systemd isn't auto-detected, but you still would
-    like to install it, set this to `yes'.
-
-If you're a simple `make && make install` kind of user, you can get away with
-not setting these variables and relying on the auto-detection. However, if
-you're writing a package for a distro, you'll want to explicitly set these,
-depending on what you want.
diff --git a/src/Makefile b/src/Makefile
index 92ff52b..6bbed32 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -96,9 +96,6 @@ install: wg
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_SYSTEMDUNITS)" = "yes" ] || exit 0; \
 	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -v -m 0644 systemd/wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
 
-help:
-	@cat INSTALL
-
-.PHONY: clean install help
+.PHONY: clean install
 
 -include *.d

commit 262b5196cfead8fc8eaa15d6cbcf8011e647f17c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 12:30:12 2019 +0100

    wg: include tools version
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/version.h b/src/version.h
new file mode 100644
index 0000000..3b78506
--- /dev/null
+++ b/src/version.h
@@ -0,0 +1 @@
+#define WIREGUARD_TOOLS_VERSION "0.0.20191219"
diff --git a/src/wg.c b/src/wg.c
index 7b5d3af..dc6dda4 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -8,6 +8,7 @@
 #include <string.h>
 
 #include "subcommands.h"
+#include "version.h"
 
 const char *PROG_NAME;
 
@@ -40,6 +41,10 @@ int main(int argc, char *argv[])
 {
 	PROG_NAME = argv[0];
 
+	if (argc == 2 && (!strcmp(argv[1], "-v") || !strcmp(argv[1], "--version") || !strcmp(argv[1], "version"))) {
+		printf("wireguard-tools v%s - https://git.zx2c4.com/wireguard-tools/\n", WIREGUARD_TOOLS_VERSION);
+		return 0;
+	}
 	if (argc == 2 && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "help"))) {
 		show_usage(stdout);
 		return 0;

commit 2f74ac29cf5a5c9285be16a118c9db5ed57b6c67
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 12:09:53 2019 +0100

    wg: add back source formerly shared with kernel module
    
    We used to reach back into parent directories for this, but with the
    repo split, we now require our own copy.
    
    We use -idirafter in case system headers are installed for the
    wireguard.h netlink definitions.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index e342779..92ff52b 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -38,6 +38,7 @@ endif
 PLATFORM ?= $(shell uname -s | tr '[:upper:]' '[:lower:]')
 
 CFLAGS ?= -O3
+CFLAGS += -idirafter uapi
 CFLAGS += -std=gnu99 -D_GNU_SOURCE
 CFLAGS += -Wall -Wextra
 CFLAGS += -MMD -MP
diff --git a/src/containers.h b/src/containers.h
index 59a213e..b312c72 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -12,8 +12,7 @@
 #include <sys/socket.h>
 #include <net/if.h>
 #include <netinet/in.h>
-
-#include "../uapi/wireguard.h"
+#include <linux/wireguard.h>
 
 /* Cross platform __kernel_timespec */
 struct timespec64 {
diff --git a/src/curve25519-fiat32.h b/src/curve25519-fiat32.h
new file mode 100644
index 0000000..42cfb6c
--- /dev/null
+++ b/src/curve25519-fiat32.h
@@ -0,0 +1,860 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright (C) 2015-2016 The fiat-crypto Authors.
+ * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * This is a machine-generated formally verified implementation of Curve25519
+ * ECDH from: <https://github.com/mit-plv/fiat-crypto>. Though originally
+ * machine generated, it has been tweaked to be suitable for use in the kernel.
+ * It is optimized for 32-bit machines and machines that cannot work efficiently
+ * with 128-bit integer types.
+ */
+
+/* fe means field element. Here the field is \Z/(2^255-19). An element t,
+ * entries t[0]...t[9], represents the integer t[0]+2^26 t[1]+2^51 t[2]+2^77
+ * t[3]+2^102 t[4]+...+2^230 t[9].
+ * fe limbs are bounded by 1.125*2^26,1.125*2^25,1.125*2^26,1.125*2^25,etc.
+ * Multiplication and carrying produce fe from fe_loose.
+ */
+typedef struct fe { u32 v[10]; } fe;
+
+/* fe_loose limbs are bounded by 3.375*2^26,3.375*2^25,3.375*2^26,3.375*2^25,etc
+ * Addition and subtraction produce fe_loose from (fe, fe).
+ */
+typedef struct fe_loose { u32 v[10]; } fe_loose;
+
+static __always_inline void fe_frombytes_impl(u32 h[10], const u8 *s)
+{
+	/* Ignores top bit of s. */
+	u32 a0 = get_unaligned_le32(s);
+	u32 a1 = get_unaligned_le32(s+4);
+	u32 a2 = get_unaligned_le32(s+8);
+	u32 a3 = get_unaligned_le32(s+12);
+	u32 a4 = get_unaligned_le32(s+16);
+	u32 a5 = get_unaligned_le32(s+20);
+	u32 a6 = get_unaligned_le32(s+24);
+	u32 a7 = get_unaligned_le32(s+28);
+	h[0] = a0&((1<<26)-1);                    /* 26 used, 32-26 left.   26 */
+	h[1] = (a0>>26) | ((a1&((1<<19)-1))<< 6); /* (32-26) + 19 =  6+19 = 25 */
+	h[2] = (a1>>19) | ((a2&((1<<13)-1))<<13); /* (32-19) + 13 = 13+13 = 26 */
+	h[3] = (a2>>13) | ((a3&((1<< 6)-1))<<19); /* (32-13) +  6 = 19+ 6 = 25 */
+	h[4] = (a3>> 6);                          /* (32- 6)              = 26 */
+	h[5] = a4&((1<<25)-1);                    /*                        25 */
+	h[6] = (a4>>25) | ((a5&((1<<19)-1))<< 7); /* (32-25) + 19 =  7+19 = 26 */
+	h[7] = (a5>>19) | ((a6&((1<<12)-1))<<13); /* (32-19) + 12 = 13+12 = 25 */
+	h[8] = (a6>>12) | ((a7&((1<< 6)-1))<<20); /* (32-12) +  6 = 20+ 6 = 26 */
+	h[9] = (a7>> 6)&((1<<25)-1); /*                                     25 */
+}
+
+static __always_inline void fe_frombytes(fe *h, const u8 *s)
+{
+	fe_frombytes_impl(h->v, s);
+}
+
+static __always_inline u8 /*bool*/
+addcarryx_u25(u8 /*bool*/ c, u32 a, u32 b, u32 *low)
+{
+	/* This function extracts 25 bits of result and 1 bit of carry
+	 * (26 total), so a 32-bit intermediate is sufficient.
+	 */
+	u32 x = a + b + c;
+	*low = x & ((1 << 25) - 1);
+	return (x >> 25) & 1;
+}
+
+static __always_inline u8 /*bool*/
+addcarryx_u26(u8 /*bool*/ c, u32 a, u32 b, u32 *low)
+{
+	/* This function extracts 26 bits of result and 1 bit of carry
+	 * (27 total), so a 32-bit intermediate is sufficient.
+	 */
+	u32 x = a + b + c;
+	*low = x & ((1 << 26) - 1);
+	return (x >> 26) & 1;
+}
+
+static __always_inline u8 /*bool*/
+subborrow_u25(u8 /*bool*/ c, u32 a, u32 b, u32 *low)
+{
+	/* This function extracts 25 bits of result and 1 bit of borrow
+	 * (26 total), so a 32-bit intermediate is sufficient.
+	 */
+	u32 x = a - b - c;
+	*low = x & ((1 << 25) - 1);
+	return x >> 31;
+}
+
+static __always_inline u8 /*bool*/
+subborrow_u26(u8 /*bool*/ c, u32 a, u32 b, u32 *low)
+{
+	/* This function extracts 26 bits of result and 1 bit of borrow
+	 *(27 total), so a 32-bit intermediate is sufficient.
+	 */
+	u32 x = a - b - c;
+	*low = x & ((1 << 26) - 1);
+	return x >> 31;
+}
+
+static __always_inline u32 cmovznz32(u32 t, u32 z, u32 nz)
+{
+	t = -!!t; /* all set if nonzero, 0 if 0 */
+	return (t&nz) | ((~t)&z);
+}
+
+static __always_inline void fe_freeze(u32 out[10], const u32 in1[10])
+{
+	{ const u32 x17 = in1[9];
+	{ const u32 x18 = in1[8];
+	{ const u32 x16 = in1[7];
+	{ const u32 x14 = in1[6];
+	{ const u32 x12 = in1[5];
+	{ const u32 x10 = in1[4];
+	{ const u32 x8 = in1[3];
+	{ const u32 x6 = in1[2];
+	{ const u32 x4 = in1[1];
+	{ const u32 x2 = in1[0];
+	{ u32 x20; u8/*bool*/ x21 = subborrow_u26(0x0, x2, 0x3ffffed, &x20);
+	{ u32 x23; u8/*bool*/ x24 = subborrow_u25(x21, x4, 0x1ffffff, &x23);
+	{ u32 x26; u8/*bool*/ x27 = subborrow_u26(x24, x6, 0x3ffffff, &x26);
+	{ u32 x29; u8/*bool*/ x30 = subborrow_u25(x27, x8, 0x1ffffff, &x29);
+	{ u32 x32; u8/*bool*/ x33 = subborrow_u26(x30, x10, 0x3ffffff, &x32);
+	{ u32 x35; u8/*bool*/ x36 = subborrow_u25(x33, x12, 0x1ffffff, &x35);
+	{ u32 x38; u8/*bool*/ x39 = subborrow_u26(x36, x14, 0x3ffffff, &x38);
+	{ u32 x41; u8/*bool*/ x42 = subborrow_u25(x39, x16, 0x1ffffff, &x41);
+	{ u32 x44; u8/*bool*/ x45 = subborrow_u26(x42, x18, 0x3ffffff, &x44);
+	{ u32 x47; u8/*bool*/ x48 = subborrow_u25(x45, x17, 0x1ffffff, &x47);
+	{ u32 x49 = cmovznz32(x48, 0x0, 0xffffffff);
+	{ u32 x50 = (x49 & 0x3ffffed);
+	{ u32 x52; u8/*bool*/ x53 = addcarryx_u26(0x0, x20, x50, &x52);
+	{ u32 x54 = (x49 & 0x1ffffff);
+	{ u32 x56; u8/*bool*/ x57 = addcarryx_u25(x53, x23, x54, &x56);
+	{ u32 x58 = (x49 & 0x3ffffff);
+	{ u32 x60; u8/*bool*/ x61 = addcarryx_u26(x57, x26, x58, &x60);
+	{ u32 x62 = (x49 & 0x1ffffff);
+	{ u32 x64; u8/*bool*/ x65 = addcarryx_u25(x61, x29, x62, &x64);
+	{ u32 x66 = (x49 & 0x3ffffff);
+	{ u32 x68; u8/*bool*/ x69 = addcarryx_u26(x65, x32, x66, &x68);
+	{ u32 x70 = (x49 & 0x1ffffff);
+	{ u32 x72; u8/*bool*/ x73 = addcarryx_u25(x69, x35, x70, &x72);
+	{ u32 x74 = (x49 & 0x3ffffff);
+	{ u32 x76; u8/*bool*/ x77 = addcarryx_u26(x73, x38, x74, &x76);
+	{ u32 x78 = (x49 & 0x1ffffff);
+	{ u32 x80; u8/*bool*/ x81 = addcarryx_u25(x77, x41, x78, &x80);
+	{ u32 x82 = (x49 & 0x3ffffff);
+	{ u32 x84; u8/*bool*/ x85 = addcarryx_u26(x81, x44, x82, &x84);
+	{ u32 x86 = (x49 & 0x1ffffff);
+	{ u32 x88; addcarryx_u25(x85, x47, x86, &x88);
+	out[0] = x52;
+	out[1] = x56;
+	out[2] = x60;
+	out[3] = x64;
+	out[4] = x68;
+	out[5] = x72;
+	out[6] = x76;
+	out[7] = x80;
+	out[8] = x84;
+	out[9] = x88;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
+
+static __always_inline void fe_tobytes(u8 s[32], const fe *f)
+{
+	u32 h[10];
+	fe_freeze(h, f->v);
+	s[0] = h[0] >> 0;
+	s[1] = h[0] >> 8;
+	s[2] = h[0] >> 16;
+	s[3] = (h[0] >> 24) | (h[1] << 2);
+	s[4] = h[1] >> 6;
+	s[5] = h[1] >> 14;
+	s[6] = (h[1] >> 22) | (h[2] << 3);
+	s[7] = h[2] >> 5;
+	s[8] = h[2] >> 13;
+	s[9] = (h[2] >> 21) | (h[3] << 5);
+	s[10] = h[3] >> 3;
+	s[11] = h[3] >> 11;
+	s[12] = (h[3] >> 19) | (h[4] << 6);
+	s[13] = h[4] >> 2;
+	s[14] = h[4] >> 10;
+	s[15] = h[4] >> 18;
+	s[16] = h[5] >> 0;
+	s[17] = h[5] >> 8;
+	s[18] = h[5] >> 16;
+	s[19] = (h[5] >> 24) | (h[6] << 1);
+	s[20] = h[6] >> 7;
+	s[21] = h[6] >> 15;
+	s[22] = (h[6] >> 23) | (h[7] << 3);
+	s[23] = h[7] >> 5;
+	s[24] = h[7] >> 13;
+	s[25] = (h[7] >> 21) | (h[8] << 4);
+	s[26] = h[8] >> 4;
+	s[27] = h[8] >> 12;
+	s[28] = (h[8] >> 20) | (h[9] << 6);
+	s[29] = h[9] >> 2;
+	s[30] = h[9] >> 10;
+	s[31] = h[9] >> 18;
+}
+
+/* h = f */
+static __always_inline void fe_copy(fe *h, const fe *f)
+{
+	memmove(h, f, sizeof(u32) * 10);
+}
+
+static __always_inline void fe_copy_lt(fe_loose *h, const fe *f)
+{
+	memmove(h, f, sizeof(u32) * 10);
+}
+
+/* h = 0 */
+static __always_inline void fe_0(fe *h)
+{
+	memset(h, 0, sizeof(u32) * 10);
+}
+
+/* h = 1 */
+static __always_inline void fe_1(fe *h)
+{
+	memset(h, 0, sizeof(u32) * 10);
+	h->v[0] = 1;
+}
+
+static void fe_add_impl(u32 out[10], const u32 in1[10], const u32 in2[10])
+{
+	{ const u32 x20 = in1[9];
+	{ const u32 x21 = in1[8];
+	{ const u32 x19 = in1[7];
+	{ const u32 x17 = in1[6];
+	{ const u32 x15 = in1[5];
+	{ const u32 x13 = in1[4];
+	{ const u32 x11 = in1[3];
+	{ const u32 x9 = in1[2];
+	{ const u32 x7 = in1[1];
+	{ const u32 x5 = in1[0];
+	{ const u32 x38 = in2[9];
+	{ const u32 x39 = in2[8];
+	{ const u32 x37 = in2[7];
+	{ const u32 x35 = in2[6];
+	{ const u32 x33 = in2[5];
+	{ const u32 x31 = in2[4];
+	{ const u32 x29 = in2[3];
+	{ const u32 x27 = in2[2];
+	{ const u32 x25 = in2[1];
+	{ const u32 x23 = in2[0];
+	out[0] = (x5 + x23);
+	out[1] = (x7 + x25);
+	out[2] = (x9 + x27);
+	out[3] = (x11 + x29);
+	out[4] = (x13 + x31);
+	out[5] = (x15 + x33);
+	out[6] = (x17 + x35);
+	out[7] = (x19 + x37);
+	out[8] = (x21 + x39);
+	out[9] = (x20 + x38);
+	}}}}}}}}}}}}}}}}}}}}
+}
+
+/* h = f + g
+ * Can overlap h with f or g.
+ */
+static __always_inline void fe_add(fe_loose *h, const fe *f, const fe *g)
+{
+	fe_add_impl(h->v, f->v, g->v);
+}
+
+static void fe_sub_impl(u32 out[10], const u32 in1[10], const u32 in2[10])
+{
+	{ const u32 x20 = in1[9];
+	{ const u32 x21 = in1[8];
+	{ const u32 x19 = in1[7];
+	{ const u32 x17 = in1[6];
+	{ const u32 x15 = in1[5];
+	{ const u32 x13 = in1[4];
+	{ const u32 x11 = in1[3];
+	{ const u32 x9 = in1[2];
+	{ const u32 x7 = in1[1];
+	{ const u32 x5 = in1[0];
+	{ const u32 x38 = in2[9];
+	{ const u32 x39 = in2[8];
+	{ const u32 x37 = in2[7];
+	{ const u32 x35 = in2[6];
+	{ const u32 x33 = in2[5];
+	{ const u32 x31 = in2[4];
+	{ const u32 x29 = in2[3];
+	{ const u32 x27 = in2[2];
+	{ const u32 x25 = in2[1];
+	{ const u32 x23 = in2[0];
+	out[0] = ((0x7ffffda + x5) - x23);
+	out[1] = ((0x3fffffe + x7) - x25);
+	out[2] = ((0x7fffffe + x9) - x27);
+	out[3] = ((0x3fffffe + x11) - x29);
+	out[4] = ((0x7fffffe + x13) - x31);
+	out[5] = ((0x3fffffe + x15) - x33);
+	out[6] = ((0x7fffffe + x17) - x35);
+	out[7] = ((0x3fffffe + x19) - x37);
+	out[8] = ((0x7fffffe + x21) - x39);
+	out[9] = ((0x3fffffe + x20) - x38);
+	}}}}}}}}}}}}}}}}}}}}
+}
+
+/* h = f - g
+ * Can overlap h with f or g.
+ */
+static __always_inline void fe_sub(fe_loose *h, const fe *f, const fe *g)
+{
+	fe_sub_impl(h->v, f->v, g->v);
+}
+
+static void fe_mul_impl(u32 out[10], const u32 in1[10], const u32 in2[10])
+{
+	{ const u32 x20 = in1[9];
+	{ const u32 x21 = in1[8];
+	{ const u32 x19 = in1[7];
+	{ const u32 x17 = in1[6];
+	{ const u32 x15 = in1[5];
+	{ const u32 x13 = in1[4];
+	{ const u32 x11 = in1[3];
+	{ const u32 x9 = in1[2];
+	{ const u32 x7 = in1[1];
+	{ const u32 x5 = in1[0];
+	{ const u32 x38 = in2[9];
+	{ const u32 x39 = in2[8];
+	{ const u32 x37 = in2[7];
+	{ const u32 x35 = in2[6];
+	{ const u32 x33 = in2[5];
+	{ const u32 x31 = in2[4];
+	{ const u32 x29 = in2[3];
+	{ const u32 x27 = in2[2];
+	{ const u32 x25 = in2[1];
+	{ const u32 x23 = in2[0];
+	{ u64 x40 = ((u64)x23 * x5);
+	{ u64 x41 = (((u64)x23 * x7) + ((u64)x25 * x5));
+	{ u64 x42 = ((((u64)(0x2 * x25) * x7) + ((u64)x23 * x9)) + ((u64)x27 * x5));
+	{ u64 x43 = (((((u64)x25 * x9) + ((u64)x27 * x7)) + ((u64)x23 * x11)) + ((u64)x29 * x5));
+	{ u64 x44 = (((((u64)x27 * x9) + (0x2 * (((u64)x25 * x11) + ((u64)x29 * x7)))) + ((u64)x23 * x13)) + ((u64)x31 * x5));
+	{ u64 x45 = (((((((u64)x27 * x11) + ((u64)x29 * x9)) + ((u64)x25 * x13)) + ((u64)x31 * x7)) + ((u64)x23 * x15)) + ((u64)x33 * x5));
+	{ u64 x46 = (((((0x2 * ((((u64)x29 * x11) + ((u64)x25 * x15)) + ((u64)x33 * x7))) + ((u64)x27 * x13)) + ((u64)x31 * x9)) + ((u64)x23 * x17)) + ((u64)x35 * x5));
+	{ u64 x47 = (((((((((u64)x29 * x13) + ((u64)x31 * x11)) + ((u64)x27 * x15)) + ((u64)x33 * x9)) + ((u64)x25 * x17)) + ((u64)x35 * x7)) + ((u64)x23 * x19)) + ((u64)x37 * x5));
+	{ u64 x48 = (((((((u64)x31 * x13) + (0x2 * (((((u64)x29 * x15) + ((u64)x33 * x11)) + ((u64)x25 * x19)) + ((u64)x37 * x7)))) + ((u64)x27 * x17)) + ((u64)x35 * x9)) + ((u64)x23 * x21)) + ((u64)x39 * x5));
+	{ u64 x49 = (((((((((((u64)x31 * x15) + ((u64)x33 * x13)) + ((u64)x29 * x17)) + ((u64)x35 * x11)) + ((u64)x27 * x19)) + ((u64)x37 * x9)) + ((u64)x25 * x21)) + ((u64)x39 * x7)) + ((u64)x23 * x20)) + ((u64)x38 * x5));
+	{ u64 x50 = (((((0x2 * ((((((u64)x33 * x15) + ((u64)x29 * x19)) + ((u64)x37 * x11)) + ((u64)x25 * x20)) + ((u64)x38 * x7))) + ((u64)x31 * x17)) + ((u64)x35 * x13)) + ((u64)x27 * x21)) + ((u64)x39 * x9));
+	{ u64 x51 = (((((((((u64)x33 * x17) + ((u64)x35 * x15)) + ((u64)x31 * x19)) + ((u64)x37 * x13)) + ((u64)x29 * x21)) + ((u64)x39 * x11)) + ((u64)x27 * x20)) + ((u64)x38 * x9));
+	{ u64 x52 = (((((u64)x35 * x17) + (0x2 * (((((u64)x33 * x19) + ((u64)x37 * x15)) + ((u64)x29 * x20)) + ((u64)x38 * x11)))) + ((u64)x31 * x21)) + ((u64)x39 * x13));
+	{ u64 x53 = (((((((u64)x35 * x19) + ((u64)x37 * x17)) + ((u64)x33 * x21)) + ((u64)x39 * x15)) + ((u64)x31 * x20)) + ((u64)x38 * x13));
+	{ u64 x54 = (((0x2 * ((((u64)x37 * x19) + ((u64)x33 * x20)) + ((u64)x38 * x15))) + ((u64)x35 * x21)) + ((u64)x39 * x17));
+	{ u64 x55 = (((((u64)x37 * x21) + ((u64)x39 * x19)) + ((u64)x35 * x20)) + ((u64)x38 * x17));
+	{ u64 x56 = (((u64)x39 * x21) + (0x2 * (((u64)x37 * x20) + ((u64)x38 * x19))));
+	{ u64 x57 = (((u64)x39 * x20) + ((u64)x38 * x21));
+	{ u64 x58 = ((u64)(0x2 * x38) * x20);
+	{ u64 x59 = (x48 + (x58 << 0x4));
+	{ u64 x60 = (x59 + (x58 << 0x1));
+	{ u64 x61 = (x60 + x58);
+	{ u64 x62 = (x47 + (x57 << 0x4));
+	{ u64 x63 = (x62 + (x57 << 0x1));
+	{ u64 x64 = (x63 + x57);
+	{ u64 x65 = (x46 + (x56 << 0x4));
+	{ u64 x66 = (x65 + (x56 << 0x1));
+	{ u64 x67 = (x66 + x56);
+	{ u64 x68 = (x45 + (x55 << 0x4));
+	{ u64 x69 = (x68 + (x55 << 0x1));
+	{ u64 x70 = (x69 + x55);
+	{ u64 x71 = (x44 + (x54 << 0x4));
+	{ u64 x72 = (x71 + (x54 << 0x1));
+	{ u64 x73 = (x72 + x54);
+	{ u64 x74 = (x43 + (x53 << 0x4));
+	{ u64 x75 = (x74 + (x53 << 0x1));
+	{ u64 x76 = (x75 + x53);
+	{ u64 x77 = (x42 + (x52 << 0x4));
+	{ u64 x78 = (x77 + (x52 << 0x1));
+	{ u64 x79 = (x78 + x52);
+	{ u64 x80 = (x41 + (x51 << 0x4));
+	{ u64 x81 = (x80 + (x51 << 0x1));
+	{ u64 x82 = (x81 + x51);
+	{ u64 x83 = (x40 + (x50 << 0x4));
+	{ u64 x84 = (x83 + (x50 << 0x1));
+	{ u64 x85 = (x84 + x50);
+	{ u64 x86 = (x85 >> 0x1a);
+	{ u32 x87 = ((u32)x85 & 0x3ffffff);
+	{ u64 x88 = (x86 + x82);
+	{ u64 x89 = (x88 >> 0x19);
+	{ u32 x90 = ((u32)x88 & 0x1ffffff);
+	{ u64 x91 = (x89 + x79);
+	{ u64 x92 = (x91 >> 0x1a);
+	{ u32 x93 = ((u32)x91 & 0x3ffffff);
+	{ u64 x94 = (x92 + x76);
+	{ u64 x95 = (x94 >> 0x19);
+	{ u32 x96 = ((u32)x94 & 0x1ffffff);
+	{ u64 x97 = (x95 + x73);
+	{ u64 x98 = (x97 >> 0x1a);
+	{ u32 x99 = ((u32)x97 & 0x3ffffff);
+	{ u64 x100 = (x98 + x70);
+	{ u64 x101 = (x100 >> 0x19);
+	{ u32 x102 = ((u32)x100 & 0x1ffffff);
+	{ u64 x103 = (x101 + x67);
+	{ u64 x104 = (x103 >> 0x1a);
+	{ u32 x105 = ((u32)x103 & 0x3ffffff);
+	{ u64 x106 = (x104 + x64);
+	{ u64 x107 = (x106 >> 0x19);
+	{ u32 x108 = ((u32)x106 & 0x1ffffff);
+	{ u64 x109 = (x107 + x61);
+	{ u64 x110 = (x109 >> 0x1a);
+	{ u32 x111 = ((u32)x109 & 0x3ffffff);
+	{ u64 x112 = (x110 + x49);
+	{ u64 x113 = (x112 >> 0x19);
+	{ u32 x114 = ((u32)x112 & 0x1ffffff);
+	{ u64 x115 = (x87 + (0x13 * x113));
+	{ u32 x116 = (u32) (x115 >> 0x1a);
+	{ u32 x117 = ((u32)x115 & 0x3ffffff);
+	{ u32 x118 = (x116 + x90);
+	{ u32 x119 = (x118 >> 0x19);
+	{ u32 x120 = (x118 & 0x1ffffff);
+	out[0] = x117;
+	out[1] = x120;
+	out[2] = (x119 + x93);
+	out[3] = x96;
+	out[4] = x99;
+	out[5] = x102;
+	out[6] = x105;
+	out[7] = x108;
+	out[8] = x111;
+	out[9] = x114;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
+
+static __always_inline void fe_mul_ttt(fe *h, const fe *f, const fe *g)
+{
+	fe_mul_impl(h->v, f->v, g->v);
+}
+
+static __always_inline void fe_mul_tlt(fe *h, const fe_loose *f, const fe *g)
+{
+	fe_mul_impl(h->v, f->v, g->v);
+}
+
+static __always_inline void
+fe_mul_tll(fe *h, const fe_loose *f, const fe_loose *g)
+{
+	fe_mul_impl(h->v, f->v, g->v);
+}
+
+static void fe_sqr_impl(u32 out[10], const u32 in1[10])
+{
+	{ const u32 x17 = in1[9];
+	{ const u32 x18 = in1[8];
+	{ const u32 x16 = in1[7];
+	{ const u32 x14 = in1[6];
+	{ const u32 x12 = in1[5];
+	{ const u32 x10 = in1[4];
+	{ const u32 x8 = in1[3];
+	{ const u32 x6 = in1[2];
+	{ const u32 x4 = in1[1];
+	{ const u32 x2 = in1[0];
+	{ u64 x19 = ((u64)x2 * x2);
+	{ u64 x20 = ((u64)(0x2 * x2) * x4);
+	{ u64 x21 = (0x2 * (((u64)x4 * x4) + ((u64)x2 * x6)));
+	{ u64 x22 = (0x2 * (((u64)x4 * x6) + ((u64)x2 * x8)));
+	{ u64 x23 = ((((u64)x6 * x6) + ((u64)(0x4 * x4) * x8)) + ((u64)(0x2 * x2) * x10));
+	{ u64 x24 = (0x2 * ((((u64)x6 * x8) + ((u64)x4 * x10)) + ((u64)x2 * x12)));
+	{ u64 x25 = (0x2 * (((((u64)x8 * x8) + ((u64)x6 * x10)) + ((u64)x2 * x14)) + ((u64)(0x2 * x4) * x12)));
+	{ u64 x26 = (0x2 * (((((u64)x8 * x10) + ((u64)x6 * x12)) + ((u64)x4 * x14)) + ((u64)x2 * x16)));
+	{ u64 x27 = (((u64)x10 * x10) + (0x2 * ((((u64)x6 * x14) + ((u64)x2 * x18)) + (0x2 * (((u64)x4 * x16) + ((u64)x8 * x12))))));
+	{ u64 x28 = (0x2 * ((((((u64)x10 * x12) + ((u64)x8 * x14)) + ((u64)x6 * x16)) + ((u64)x4 * x18)) + ((u64)x2 * x17)));
+	{ u64 x29 = (0x2 * (((((u64)x12 * x12) + ((u64)x10 * x14)) + ((u64)x6 * x18)) + (0x2 * (((u64)x8 * x16) + ((u64)x4 * x17)))));
+	{ u64 x30 = (0x2 * (((((u64)x12 * x14) + ((u64)x10 * x16)) + ((u64)x8 * x18)) + ((u64)x6 * x17)));
+	{ u64 x31 = (((u64)x14 * x14) + (0x2 * (((u64)x10 * x18) + (0x2 * (((u64)x12 * x16) + ((u64)x8 * x17))))));
+	{ u64 x32 = (0x2 * ((((u64)x14 * x16) + ((u64)x12 * x18)) + ((u64)x10 * x17)));
+	{ u64 x33 = (0x2 * ((((u64)x16 * x16) + ((u64)x14 * x18)) + ((u64)(0x2 * x12) * x17)));
+	{ u64 x34 = (0x2 * (((u64)x16 * x18) + ((u64)x14 * x17)));
+	{ u64 x35 = (((u64)x18 * x18) + ((u64)(0x4 * x16) * x17));
+	{ u64 x36 = ((u64)(0x2 * x18) * x17);
+	{ u64 x37 = ((u64)(0x2 * x17) * x17);
+	{ u64 x38 = (x27 + (x37 << 0x4));
+	{ u64 x39 = (x38 + (x37 << 0x1));
+	{ u64 x40 = (x39 + x37);
+	{ u64 x41 = (x26 + (x36 << 0x4));
+	{ u64 x42 = (x41 + (x36 << 0x1));
+	{ u64 x43 = (x42 + x36);
+	{ u64 x44 = (x25 + (x35 << 0x4));
+	{ u64 x45 = (x44 + (x35 << 0x1));
+	{ u64 x46 = (x45 + x35);
+	{ u64 x47 = (x24 + (x34 << 0x4));
+	{ u64 x48 = (x47 + (x34 << 0x1));
+	{ u64 x49 = (x48 + x34);
+	{ u64 x50 = (x23 + (x33 << 0x4));
+	{ u64 x51 = (x50 + (x33 << 0x1));
+	{ u64 x52 = (x51 + x33);
+	{ u64 x53 = (x22 + (x32 << 0x4));
+	{ u64 x54 = (x53 + (x32 << 0x1));
+	{ u64 x55 = (x54 + x32);
+	{ u64 x56 = (x21 + (x31 << 0x4));
+	{ u64 x57 = (x56 + (x31 << 0x1));
+	{ u64 x58 = (x57 + x31);
+	{ u64 x59 = (x20 + (x30 << 0x4));
+	{ u64 x60 = (x59 + (x30 << 0x1));
+	{ u64 x61 = (x60 + x30);
+	{ u64 x62 = (x19 + (x29 << 0x4));
+	{ u64 x63 = (x62 + (x29 << 0x1));
+	{ u64 x64 = (x63 + x29);
+	{ u64 x65 = (x64 >> 0x1a);
+	{ u32 x66 = ((u32)x64 & 0x3ffffff);
+	{ u64 x67 = (x65 + x61);
+	{ u64 x68 = (x67 >> 0x19);
+	{ u32 x69 = ((u32)x67 & 0x1ffffff);
+	{ u64 x70 = (x68 + x58);
+	{ u64 x71 = (x70 >> 0x1a);
+	{ u32 x72 = ((u32)x70 & 0x3ffffff);
+	{ u64 x73 = (x71 + x55);
+	{ u64 x74 = (x73 >> 0x19);
+	{ u32 x75 = ((u32)x73 & 0x1ffffff);
+	{ u64 x76 = (x74 + x52);
+	{ u64 x77 = (x76 >> 0x1a);
+	{ u32 x78 = ((u32)x76 & 0x3ffffff);
+	{ u64 x79 = (x77 + x49);
+	{ u64 x80 = (x79 >> 0x19);
+	{ u32 x81 = ((u32)x79 & 0x1ffffff);
+	{ u64 x82 = (x80 + x46);
+	{ u64 x83 = (x82 >> 0x1a);
+	{ u32 x84 = ((u32)x82 & 0x3ffffff);
+	{ u64 x85 = (x83 + x43);
+	{ u64 x86 = (x85 >> 0x19);
+	{ u32 x87 = ((u32)x85 & 0x1ffffff);
+	{ u64 x88 = (x86 + x40);
+	{ u64 x89 = (x88 >> 0x1a);
+	{ u32 x90 = ((u32)x88 & 0x3ffffff);
+	{ u64 x91 = (x89 + x28);
+	{ u64 x92 = (x91 >> 0x19);
+	{ u32 x93 = ((u32)x91 & 0x1ffffff);
+	{ u64 x94 = (x66 + (0x13 * x92));
+	{ u32 x95 = (u32) (x94 >> 0x1a);
+	{ u32 x96 = ((u32)x94 & 0x3ffffff);
+	{ u32 x97 = (x95 + x69);
+	{ u32 x98 = (x97 >> 0x19);
+	{ u32 x99 = (x97 & 0x1ffffff);
+	out[0] = x96;
+	out[1] = x99;
+	out[2] = (x98 + x72);
+	out[3] = x75;
+	out[4] = x78;
+	out[5] = x81;
+	out[6] = x84;
+	out[7] = x87;
+	out[8] = x90;
+	out[9] = x93;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
+
+static __always_inline void fe_sq_tl(fe *h, const fe_loose *f)
+{
+	fe_sqr_impl(h->v, f->v);
+}
+
+static __always_inline void fe_sq_tt(fe *h, const fe *f)
+{
+	fe_sqr_impl(h->v, f->v);
+}
+
+static __always_inline void fe_loose_invert(fe *out, const fe_loose *z)
+{
+	fe t0;
+	fe t1;
+	fe t2;
+	fe t3;
+	int i;
+
+	fe_sq_tl(&t0, z);
+	fe_sq_tt(&t1, &t0);
+	for (i = 1; i < 2; ++i)
+		fe_sq_tt(&t1, &t1);
+	fe_mul_tlt(&t1, z, &t1);
+	fe_mul_ttt(&t0, &t0, &t1);
+	fe_sq_tt(&t2, &t0);
+	fe_mul_ttt(&t1, &t1, &t2);
+	fe_sq_tt(&t2, &t1);
+	for (i = 1; i < 5; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t1, &t2, &t1);
+	fe_sq_tt(&t2, &t1);
+	for (i = 1; i < 10; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t2, &t2, &t1);
+	fe_sq_tt(&t3, &t2);
+	for (i = 1; i < 20; ++i)
+		fe_sq_tt(&t3, &t3);
+	fe_mul_ttt(&t2, &t3, &t2);
+	fe_sq_tt(&t2, &t2);
+	for (i = 1; i < 10; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t1, &t2, &t1);
+	fe_sq_tt(&t2, &t1);
+	for (i = 1; i < 50; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t2, &t2, &t1);
+	fe_sq_tt(&t3, &t2);
+	for (i = 1; i < 100; ++i)
+		fe_sq_tt(&t3, &t3);
+	fe_mul_ttt(&t2, &t3, &t2);
+	fe_sq_tt(&t2, &t2);
+	for (i = 1; i < 50; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t1, &t2, &t1);
+	fe_sq_tt(&t1, &t1);
+	for (i = 1; i < 5; ++i)
+		fe_sq_tt(&t1, &t1);
+	fe_mul_ttt(out, &t1, &t0);
+}
+
+static __always_inline void fe_invert(fe *out, const fe *z)
+{
+	fe_loose l;
+	fe_copy_lt(&l, z);
+	fe_loose_invert(out, &l);
+}
+
+/* Replace (f,g) with (g,f) if b == 1;
+ * replace (f,g) with (f,g) if b == 0.
+ *
+ * Preconditions: b in {0,1}
+ */
+static __always_inline void fe_cswap(fe *f, fe *g, unsigned int b)
+{
+	unsigned i;
+	b = 0 - b;
+	for (i = 0; i < 10; i++) {
+		u32 x = f->v[i] ^ g->v[i];
+		x &= b;
+		f->v[i] ^= x;
+		g->v[i] ^= x;
+	}
+}
+
+/* NOTE: based on fiat-crypto fe_mul, edited for in2=121666, 0, 0.*/
+static __always_inline void fe_mul_121666_impl(u32 out[10], const u32 in1[10])
+{
+	{ const u32 x20 = in1[9];
+	{ const u32 x21 = in1[8];
+	{ const u32 x19 = in1[7];
+	{ const u32 x17 = in1[6];
+	{ const u32 x15 = in1[5];
+	{ const u32 x13 = in1[4];
+	{ const u32 x11 = in1[3];
+	{ const u32 x9 = in1[2];
+	{ const u32 x7 = in1[1];
+	{ const u32 x5 = in1[0];
+	{ const u32 x38 = 0;
+	{ const u32 x39 = 0;
+	{ const u32 x37 = 0;
+	{ const u32 x35 = 0;
+	{ const u32 x33 = 0;
+	{ const u32 x31 = 0;
+	{ const u32 x29 = 0;
+	{ const u32 x27 = 0;
+	{ const u32 x25 = 0;
+	{ const u32 x23 = 121666;
+	{ u64 x40 = ((u64)x23 * x5);
+	{ u64 x41 = (((u64)x23 * x7) + ((u64)x25 * x5));
+	{ u64 x42 = ((((u64)(0x2 * x25) * x7) + ((u64)x23 * x9)) + ((u64)x27 * x5));
+	{ u64 x43 = (((((u64)x25 * x9) + ((u64)x27 * x7)) + ((u64)x23 * x11)) + ((u64)x29 * x5));
+	{ u64 x44 = (((((u64)x27 * x9) + (0x2 * (((u64)x25 * x11) + ((u64)x29 * x7)))) + ((u64)x23 * x13)) + ((u64)x31 * x5));
+	{ u64 x45 = (((((((u64)x27 * x11) + ((u64)x29 * x9)) + ((u64)x25 * x13)) + ((u64)x31 * x7)) + ((u64)x23 * x15)) + ((u64)x33 * x5));
+	{ u64 x46 = (((((0x2 * ((((u64)x29 * x11) + ((u64)x25 * x15)) + ((u64)x33 * x7))) + ((u64)x27 * x13)) + ((u64)x31 * x9)) + ((u64)x23 * x17)) + ((u64)x35 * x5));
+	{ u64 x47 = (((((((((u64)x29 * x13) + ((u64)x31 * x11)) + ((u64)x27 * x15)) + ((u64)x33 * x9)) + ((u64)x25 * x17)) + ((u64)x35 * x7)) + ((u64)x23 * x19)) + ((u64)x37 * x5));
+	{ u64 x48 = (((((((u64)x31 * x13) + (0x2 * (((((u64)x29 * x15) + ((u64)x33 * x11)) + ((u64)x25 * x19)) + ((u64)x37 * x7)))) + ((u64)x27 * x17)) + ((u64)x35 * x9)) + ((u64)x23 * x21)) + ((u64)x39 * x5));
+	{ u64 x49 = (((((((((((u64)x31 * x15) + ((u64)x33 * x13)) + ((u64)x29 * x17)) + ((u64)x35 * x11)) + ((u64)x27 * x19)) + ((u64)x37 * x9)) + ((u64)x25 * x21)) + ((u64)x39 * x7)) + ((u64)x23 * x20)) + ((u64)x38 * x5));
+	{ u64 x50 = (((((0x2 * ((((((u64)x33 * x15) + ((u64)x29 * x19)) + ((u64)x37 * x11)) + ((u64)x25 * x20)) + ((u64)x38 * x7))) + ((u64)x31 * x17)) + ((u64)x35 * x13)) + ((u64)x27 * x21)) + ((u64)x39 * x9));
+	{ u64 x51 = (((((((((u64)x33 * x17) + ((u64)x35 * x15)) + ((u64)x31 * x19)) + ((u64)x37 * x13)) + ((u64)x29 * x21)) + ((u64)x39 * x11)) + ((u64)x27 * x20)) + ((u64)x38 * x9));
+	{ u64 x52 = (((((u64)x35 * x17) + (0x2 * (((((u64)x33 * x19) + ((u64)x37 * x15)) + ((u64)x29 * x20)) + ((u64)x38 * x11)))) + ((u64)x31 * x21)) + ((u64)x39 * x13));
+	{ u64 x53 = (((((((u64)x35 * x19) + ((u64)x37 * x17)) + ((u64)x33 * x21)) + ((u64)x39 * x15)) + ((u64)x31 * x20)) + ((u64)x38 * x13));
+	{ u64 x54 = (((0x2 * ((((u64)x37 * x19) + ((u64)x33 * x20)) + ((u64)x38 * x15))) + ((u64)x35 * x21)) + ((u64)x39 * x17));
+	{ u64 x55 = (((((u64)x37 * x21) + ((u64)x39 * x19)) + ((u64)x35 * x20)) + ((u64)x38 * x17));
+	{ u64 x56 = (((u64)x39 * x21) + (0x2 * (((u64)x37 * x20) + ((u64)x38 * x19))));
+	{ u64 x57 = (((u64)x39 * x20) + ((u64)x38 * x21));
+	{ u64 x58 = ((u64)(0x2 * x38) * x20);
+	{ u64 x59 = (x48 + (x58 << 0x4));
+	{ u64 x60 = (x59 + (x58 << 0x1));
+	{ u64 x61 = (x60 + x58);
+	{ u64 x62 = (x47 + (x57 << 0x4));
+	{ u64 x63 = (x62 + (x57 << 0x1));
+	{ u64 x64 = (x63 + x57);
+	{ u64 x65 = (x46 + (x56 << 0x4));
+	{ u64 x66 = (x65 + (x56 << 0x1));
+	{ u64 x67 = (x66 + x56);
+	{ u64 x68 = (x45 + (x55 << 0x4));
+	{ u64 x69 = (x68 + (x55 << 0x1));
+	{ u64 x70 = (x69 + x55);
+	{ u64 x71 = (x44 + (x54 << 0x4));
+	{ u64 x72 = (x71 + (x54 << 0x1));
+	{ u64 x73 = (x72 + x54);
+	{ u64 x74 = (x43 + (x53 << 0x4));
+	{ u64 x75 = (x74 + (x53 << 0x1));
+	{ u64 x76 = (x75 + x53);
+	{ u64 x77 = (x42 + (x52 << 0x4));
+	{ u64 x78 = (x77 + (x52 << 0x1));
+	{ u64 x79 = (x78 + x52);
+	{ u64 x80 = (x41 + (x51 << 0x4));
+	{ u64 x81 = (x80 + (x51 << 0x1));
+	{ u64 x82 = (x81 + x51);
+	{ u64 x83 = (x40 + (x50 << 0x4));
+	{ u64 x84 = (x83 + (x50 << 0x1));
+	{ u64 x85 = (x84 + x50);
+	{ u64 x86 = (x85 >> 0x1a);
+	{ u32 x87 = ((u32)x85 & 0x3ffffff);
+	{ u64 x88 = (x86 + x82);
+	{ u64 x89 = (x88 >> 0x19);
+	{ u32 x90 = ((u32)x88 & 0x1ffffff);
+	{ u64 x91 = (x89 + x79);
+	{ u64 x92 = (x91 >> 0x1a);
+	{ u32 x93 = ((u32)x91 & 0x3ffffff);
+	{ u64 x94 = (x92 + x76);
+	{ u64 x95 = (x94 >> 0x19);
+	{ u32 x96 = ((u32)x94 & 0x1ffffff);
+	{ u64 x97 = (x95 + x73);
+	{ u64 x98 = (x97 >> 0x1a);
+	{ u32 x99 = ((u32)x97 & 0x3ffffff);
+	{ u64 x100 = (x98 + x70);
+	{ u64 x101 = (x100 >> 0x19);
+	{ u32 x102 = ((u32)x100 & 0x1ffffff);
+	{ u64 x103 = (x101 + x67);
+	{ u64 x104 = (x103 >> 0x1a);
+	{ u32 x105 = ((u32)x103 & 0x3ffffff);
+	{ u64 x106 = (x104 + x64);
+	{ u64 x107 = (x106 >> 0x19);
+	{ u32 x108 = ((u32)x106 & 0x1ffffff);
+	{ u64 x109 = (x107 + x61);
+	{ u64 x110 = (x109 >> 0x1a);
+	{ u32 x111 = ((u32)x109 & 0x3ffffff);
+	{ u64 x112 = (x110 + x49);
+	{ u64 x113 = (x112 >> 0x19);
+	{ u32 x114 = ((u32)x112 & 0x1ffffff);
+	{ u64 x115 = (x87 + (0x13 * x113));
+	{ u32 x116 = (u32) (x115 >> 0x1a);
+	{ u32 x117 = ((u32)x115 & 0x3ffffff);
+	{ u32 x118 = (x116 + x90);
+	{ u32 x119 = (x118 >> 0x19);
+	{ u32 x120 = (x118 & 0x1ffffff);
+	out[0] = x117;
+	out[1] = x120;
+	out[2] = (x119 + x93);
+	out[3] = x96;
+	out[4] = x99;
+	out[5] = x102;
+	out[6] = x105;
+	out[7] = x108;
+	out[8] = x111;
+	out[9] = x114;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
+
+static __always_inline void fe_mul121666(fe *h, const fe_loose *f)
+{
+	fe_mul_121666_impl(h->v, f->v);
+}
+
+static void curve25519_generic(u8 out[CURVE25519_KEY_SIZE],
+			       const u8 scalar[CURVE25519_KEY_SIZE],
+			       const u8 point[CURVE25519_KEY_SIZE])
+{
+	fe x1, x2, z2, x3, z3;
+	fe_loose x2l, z2l, x3l;
+	unsigned swap = 0;
+	int pos;
+	u8 e[32];
+
+	memcpy(e, scalar, 32);
+	curve25519_clamp_secret(e);
+
+	/* The following implementation was transcribed to Coq and proven to
+	 * correspond to unary scalar multiplication in affine coordinates given
+	 * that x1 != 0 is the x coordinate of some point on the curve. It was
+	 * also checked in Coq that doing a ladderstep with x1 = x3 = 0 gives
+	 * z2' = z3' = 0, and z2 = z3 = 0 gives z2' = z3' = 0. The statement was
+	 * quantified over the underlying field, so it applies to Curve25519
+	 * itself and the quadratic twist of Curve25519. It was not proven in
+	 * Coq that prime-field arithmetic correctly simulates extension-field
+	 * arithmetic on prime-field values. The decoding of the byte array
+	 * representation of e was not considered.
+	 *
+	 * Specification of Montgomery curves in affine coordinates:
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Spec/MontgomeryCurve.v#L27>
+	 *
+	 * Proof that these form a group that is isomorphic to a Weierstrass
+	 * curve:
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/AffineProofs.v#L35>
+	 *
+	 * Coq transcription and correctness proof of the loop
+	 * (where scalarbits=255):
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L118>
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L278>
+	 * preconditions: 0 <= e < 2^255 (not necessarily e < order),
+	 * fe_invert(0) = 0
+	 */
+	fe_frombytes(&x1, point);
+	fe_1(&x2);
+	fe_0(&z2);
+	fe_copy(&x3, &x1);
+	fe_1(&z3);
+
+	for (pos = 254; pos >= 0; --pos) {
+		fe tmp0, tmp1;
+		fe_loose tmp0l, tmp1l;
+		/* loop invariant as of right before the test, for the case
+		 * where x1 != 0:
+		 *   pos >= -1; if z2 = 0 then x2 is nonzero; if z3 = 0 then x3
+		 *   is nonzero
+		 *   let r := e >> (pos+1) in the following equalities of
+		 *   projective points:
+		 *   to_xz (r*P)     === if swap then (x3, z3) else (x2, z2)
+		 *   to_xz ((r+1)*P) === if swap then (x2, z2) else (x3, z3)
+		 *   x1 is the nonzero x coordinate of the nonzero
+		 *   point (r*P-(r+1)*P)
+		 */
+		unsigned b = 1 & (e[pos / 8] >> (pos & 7));
+		swap ^= b;
+		fe_cswap(&x2, &x3, swap);
+		fe_cswap(&z2, &z3, swap);
+		swap = b;
+		/* Coq transcription of ladderstep formula (called from
+		 * transcribed loop):
+		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L89>
+		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L131>
+		 * x1 != 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L217>
+		 * x1  = 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L147>
+		 */
+		fe_sub(&tmp0l, &x3, &z3);
+		fe_sub(&tmp1l, &x2, &z2);
+		fe_add(&x2l, &x2, &z2);
+		fe_add(&z2l, &x3, &z3);
+		fe_mul_tll(&z3, &tmp0l, &x2l);
+		fe_mul_tll(&z2, &z2l, &tmp1l);
+		fe_sq_tl(&tmp0, &tmp1l);
+		fe_sq_tl(&tmp1, &x2l);
+		fe_add(&x3l, &z3, &z2);
+		fe_sub(&z2l, &z3, &z2);
+		fe_mul_ttt(&x2, &tmp1, &tmp0);
+		fe_sub(&tmp1l, &tmp1, &tmp0);
+		fe_sq_tl(&z2, &z2l);
+		fe_mul121666(&z3, &tmp1l);
+		fe_sq_tl(&x3, &x3l);
+		fe_add(&tmp0l, &tmp0, &z3);
+		fe_mul_ttt(&z3, &x1, &z2);
+		fe_mul_tll(&z2, &tmp1l, &tmp0l);
+	}
+	/* here pos=-1, so r=e, so to_xz (e*P) === if swap then (x3, z3)
+	 * else (x2, z2)
+	 */
+	fe_cswap(&x2, &x3, swap);
+	fe_cswap(&z2, &z3, swap);
+
+	fe_invert(&z2, &z2);
+	fe_mul_ttt(&x2, &x2, &z2);
+	fe_tobytes(out, &x2);
+
+	memzero_explicit(&x1, sizeof(x1));
+	memzero_explicit(&x2, sizeof(x2));
+	memzero_explicit(&z2, sizeof(z2));
+	memzero_explicit(&x3, sizeof(x3));
+	memzero_explicit(&z3, sizeof(z3));
+	memzero_explicit(&x2l, sizeof(x2l));
+	memzero_explicit(&z2l, sizeof(z2l));
+	memzero_explicit(&x3l, sizeof(x3l));
+	memzero_explicit(&e, sizeof(e));
+}
diff --git a/src/curve25519-hacl64.h b/src/curve25519-hacl64.h
new file mode 100644
index 0000000..0f729ec
--- /dev/null
+++ b/src/curve25519-hacl64.h
@@ -0,0 +1,784 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright (C) 2016-2017 INRIA and Microsoft Corporation.
+ * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * This is a machine-generated formally verified implementation of Curve25519
+ * ECDH from: <https://github.com/mitls/hacl-star>. Though originally machine
+ * generated, it has been tweaked to be suitable for use in the kernel. It is
+ * optimized for 64-bit machines that can efficiently work with 128-bit
+ * integer types.
+ */
+
+typedef __uint128_t u128;
+
+static __always_inline u64 u64_eq_mask(u64 a, u64 b)
+{
+	u64 x = a ^ b;
+	u64 minus_x = ~x + (u64)1U;
+	u64 x_or_minus_x = x | minus_x;
+	u64 xnx = x_or_minus_x >> (u32)63U;
+	u64 c = xnx - (u64)1U;
+	return c;
+}
+
+static __always_inline u64 u64_gte_mask(u64 a, u64 b)
+{
+	u64 x = a;
+	u64 y = b;
+	u64 x_xor_y = x ^ y;
+	u64 x_sub_y = x - y;
+	u64 x_sub_y_xor_y = x_sub_y ^ y;
+	u64 q = x_xor_y | x_sub_y_xor_y;
+	u64 x_xor_q = x ^ q;
+	u64 x_xor_q_ = x_xor_q >> (u32)63U;
+	u64 c = x_xor_q_ - (u64)1U;
+	return c;
+}
+
+static __always_inline void modulo_carry_top(u64 *b)
+{
+	u64 b4 = b[4];
+	u64 b0 = b[0];
+	u64 b4_ = b4 & 0x7ffffffffffffLLU;
+	u64 b0_ = b0 + 19 * (b4 >> 51);
+	b[4] = b4_;
+	b[0] = b0_;
+}
+
+static __always_inline void fproduct_copy_from_wide_(u64 *output, u128 *input)
+{
+	{
+		u128 xi = input[0];
+		output[0] = ((u64)(xi));
+	}
+	{
+		u128 xi = input[1];
+		output[1] = ((u64)(xi));
+	}
+	{
+		u128 xi = input[2];
+		output[2] = ((u64)(xi));
+	}
+	{
+		u128 xi = input[3];
+		output[3] = ((u64)(xi));
+	}
+	{
+		u128 xi = input[4];
+		output[4] = ((u64)(xi));
+	}
+}
+
+static __always_inline void
+fproduct_sum_scalar_multiplication_(u128 *output, u64 *input, u64 s)
+{
+	output[0] += (u128)input[0] * s;
+	output[1] += (u128)input[1] * s;
+	output[2] += (u128)input[2] * s;
+	output[3] += (u128)input[3] * s;
+	output[4] += (u128)input[4] * s;
+}
+
+static __always_inline void fproduct_carry_wide_(u128 *tmp)
+{
+	{
+		u32 ctr = 0;
+		u128 tctr = tmp[ctr];
+		u128 tctrp1 = tmp[ctr + 1];
+		u64 r0 = ((u64)(tctr)) & 0x7ffffffffffffLLU;
+		u128 c = ((tctr) >> (51));
+		tmp[ctr] = ((u128)(r0));
+		tmp[ctr + 1] = ((tctrp1) + (c));
+	}
+	{
+		u32 ctr = 1;
+		u128 tctr = tmp[ctr];
+		u128 tctrp1 = tmp[ctr + 1];
+		u64 r0 = ((u64)(tctr)) & 0x7ffffffffffffLLU;
+		u128 c = ((tctr) >> (51));
+		tmp[ctr] = ((u128)(r0));
+		tmp[ctr + 1] = ((tctrp1) + (c));
+	}
+
+	{
+		u32 ctr = 2;
+		u128 tctr = tmp[ctr];
+		u128 tctrp1 = tmp[ctr + 1];
+		u64 r0 = ((u64)(tctr)) & 0x7ffffffffffffLLU;
+		u128 c = ((tctr) >> (51));
+		tmp[ctr] = ((u128)(r0));
+		tmp[ctr + 1] = ((tctrp1) + (c));
+	}
+	{
+		u32 ctr = 3;
+		u128 tctr = tmp[ctr];
+		u128 tctrp1 = tmp[ctr + 1];
+		u64 r0 = ((u64)(tctr)) & 0x7ffffffffffffLLU;
+		u128 c = ((tctr) >> (51));
+		tmp[ctr] = ((u128)(r0));
+		tmp[ctr + 1] = ((tctrp1) + (c));
+	}
+}
+
+static __always_inline void fmul_shift_reduce(u64 *output)
+{
+	u64 tmp = output[4];
+	u64 b0;
+	{
+		u32 ctr = 5 - 0 - 1;
+		u64 z = output[ctr - 1];
+		output[ctr] = z;
+	}
+	{
+		u32 ctr = 5 - 1 - 1;
+		u64 z = output[ctr - 1];
+		output[ctr] = z;
+	}
+	{
+		u32 ctr = 5 - 2 - 1;
+		u64 z = output[ctr - 1];
+		output[ctr] = z;
+	}
+	{
+		u32 ctr = 5 - 3 - 1;
+		u64 z = output[ctr - 1];
+		output[ctr] = z;
+	}
+	output[0] = tmp;
+	b0 = output[0];
+	output[0] = 19 * b0;
+}
+
+static __always_inline void fmul_mul_shift_reduce_(u128 *output, u64 *input,
+						   u64 *input21)
+{
+	u32 i;
+	u64 input2i;
+	{
+		u64 input2i = input21[0];
+		fproduct_sum_scalar_multiplication_(output, input, input2i);
+		fmul_shift_reduce(input);
+	}
+	{
+		u64 input2i = input21[1];
+		fproduct_sum_scalar_multiplication_(output, input, input2i);
+		fmul_shift_reduce(input);
+	}
+	{
+		u64 input2i = input21[2];
+		fproduct_sum_scalar_multiplication_(output, input, input2i);
+		fmul_shift_reduce(input);
+	}
+	{
+		u64 input2i = input21[3];
+		fproduct_sum_scalar_multiplication_(output, input, input2i);
+		fmul_shift_reduce(input);
+	}
+	i = 4;
+	input2i = input21[i];
+	fproduct_sum_scalar_multiplication_(output, input, input2i);
+}
+
+static __always_inline void fmul_fmul(u64 *output, u64 *input, u64 *input21)
+{
+	u64 tmp[5] = { input[0], input[1], input[2], input[3], input[4] };
+	{
+		u128 b4;
+		u128 b0;
+		u128 b4_;
+		u128 b0_;
+		u64 i0;
+		u64 i1;
+		u64 i0_;
+		u64 i1_;
+		u128 t[5] = { 0 };
+		fmul_mul_shift_reduce_(t, tmp, input21);
+		fproduct_carry_wide_(t);
+		b4 = t[4];
+		b0 = t[0];
+		b4_ = ((b4) & (((u128)(0x7ffffffffffffLLU))));
+		b0_ = ((b0) + (((u128)(19) * (((u64)(((b4) >> (51))))))));
+		t[4] = b4_;
+		t[0] = b0_;
+		fproduct_copy_from_wide_(output, t);
+		i0 = output[0];
+		i1 = output[1];
+		i0_ = i0 & 0x7ffffffffffffLLU;
+		i1_ = i1 + (i0 >> 51);
+		output[0] = i0_;
+		output[1] = i1_;
+	}
+}
+
+static __always_inline void fsquare_fsquare__(u128 *tmp, u64 *output)
+{
+	u64 r0 = output[0];
+	u64 r1 = output[1];
+	u64 r2 = output[2];
+	u64 r3 = output[3];
+	u64 r4 = output[4];
+	u64 d0 = r0 * 2;
+	u64 d1 = r1 * 2;
+	u64 d2 = r2 * 2 * 19;
+	u64 d419 = r4 * 19;
+	u64 d4 = d419 * 2;
+	u128 s0 = ((((((u128)(r0) * (r0))) + (((u128)(d4) * (r1))))) +
+		   (((u128)(d2) * (r3))));
+	u128 s1 = ((((((u128)(d0) * (r1))) + (((u128)(d4) * (r2))))) +
+		   (((u128)(r3 * 19) * (r3))));
+	u128 s2 = ((((((u128)(d0) * (r2))) + (((u128)(r1) * (r1))))) +
+		   (((u128)(d4) * (r3))));
+	u128 s3 = ((((((u128)(d0) * (r3))) + (((u128)(d1) * (r2))))) +
+		   (((u128)(r4) * (d419))));
+	u128 s4 = ((((((u128)(d0) * (r4))) + (((u128)(d1) * (r3))))) +
+		   (((u128)(r2) * (r2))));
+	tmp[0] = s0;
+	tmp[1] = s1;
+	tmp[2] = s2;
+	tmp[3] = s3;
+	tmp[4] = s4;
+}
+
+static __always_inline void fsquare_fsquare_(u128 *tmp, u64 *output)
+{
+	u128 b4;
+	u128 b0;
+	u128 b4_;
+	u128 b0_;
+	u64 i0;
+	u64 i1;
+	u64 i0_;
+	u64 i1_;
+	fsquare_fsquare__(tmp, output);
+	fproduct_carry_wide_(tmp);
+	b4 = tmp[4];
+	b0 = tmp[0];
+	b4_ = ((b4) & (((u128)(0x7ffffffffffffLLU))));
+	b0_ = ((b0) + (((u128)(19) * (((u64)(((b4) >> (51))))))));
+	tmp[4] = b4_;
+	tmp[0] = b0_;
+	fproduct_copy_from_wide_(output, tmp);
+	i0 = output[0];
+	i1 = output[1];
+	i0_ = i0 & 0x7ffffffffffffLLU;
+	i1_ = i1 + (i0 >> 51);
+	output[0] = i0_;
+	output[1] = i1_;
+}
+
+static __always_inline void fsquare_fsquare_times_(u64 *output, u128 *tmp,
+						   u32 count1)
+{
+	u32 i;
+	fsquare_fsquare_(tmp, output);
+	for (i = 1; i < count1; ++i)
+		fsquare_fsquare_(tmp, output);
+}
+
+static __always_inline void fsquare_fsquare_times(u64 *output, u64 *input,
+						  u32 count1)
+{
+	u128 t[5];
+	memcpy(output, input, 5 * sizeof(*input));
+	fsquare_fsquare_times_(output, t, count1);
+}
+
+static __always_inline void fsquare_fsquare_times_inplace(u64 *output,
+							  u32 count1)
+{
+	u128 t[5];
+	fsquare_fsquare_times_(output, t, count1);
+}
+
+static __always_inline void crecip_crecip(u64 *out, u64 *z)
+{
+	u64 buf[20] = { 0 };
+	u64 *a0 = buf;
+	u64 *t00 = buf + 5;
+	u64 *b0 = buf + 10;
+	u64 *t01;
+	u64 *b1;
+	u64 *c0;
+	u64 *a;
+	u64 *t0;
+	u64 *b;
+	u64 *c;
+	fsquare_fsquare_times(a0, z, 1);
+	fsquare_fsquare_times(t00, a0, 2);
+	fmul_fmul(b0, t00, z);
+	fmul_fmul(a0, b0, a0);
+	fsquare_fsquare_times(t00, a0, 1);
+	fmul_fmul(b0, t00, b0);
+	fsquare_fsquare_times(t00, b0, 5);
+	t01 = buf + 5;
+	b1 = buf + 10;
+	c0 = buf + 15;
+	fmul_fmul(b1, t01, b1);
+	fsquare_fsquare_times(t01, b1, 10);
+	fmul_fmul(c0, t01, b1);
+	fsquare_fsquare_times(t01, c0, 20);
+	fmul_fmul(t01, t01, c0);
+	fsquare_fsquare_times_inplace(t01, 10);
+	fmul_fmul(b1, t01, b1);
+	fsquare_fsquare_times(t01, b1, 50);
+	a = buf;
+	t0 = buf + 5;
+	b = buf + 10;
+	c = buf + 15;
+	fmul_fmul(c, t0, b);
+	fsquare_fsquare_times(t0, c, 100);
+	fmul_fmul(t0, t0, c);
+	fsquare_fsquare_times_inplace(t0, 50);
+	fmul_fmul(t0, t0, b);
+	fsquare_fsquare_times_inplace(t0, 5);
+	fmul_fmul(out, t0, a);
+}
+
+static __always_inline void fsum(u64 *a, u64 *b)
+{
+	a[0] += b[0];
+	a[1] += b[1];
+	a[2] += b[2];
+	a[3] += b[3];
+	a[4] += b[4];
+}
+
+static __always_inline void fdifference(u64 *a, u64 *b)
+{
+	u64 tmp[5] = { 0 };
+	u64 b0;
+	u64 b1;
+	u64 b2;
+	u64 b3;
+	u64 b4;
+	memcpy(tmp, b, 5 * sizeof(*b));
+	b0 = tmp[0];
+	b1 = tmp[1];
+	b2 = tmp[2];
+	b3 = tmp[3];
+	b4 = tmp[4];
+	tmp[0] = b0 + 0x3fffffffffff68LLU;
+	tmp[1] = b1 + 0x3ffffffffffff8LLU;
+	tmp[2] = b2 + 0x3ffffffffffff8LLU;
+	tmp[3] = b3 + 0x3ffffffffffff8LLU;
+	tmp[4] = b4 + 0x3ffffffffffff8LLU;
+	{
+		u64 xi = a[0];
+		u64 yi = tmp[0];
+		a[0] = yi - xi;
+	}
+	{
+		u64 xi = a[1];
+		u64 yi = tmp[1];
+		a[1] = yi - xi;
+	}
+	{
+		u64 xi = a[2];
+		u64 yi = tmp[2];
+		a[2] = yi - xi;
+	}
+	{
+		u64 xi = a[3];
+		u64 yi = tmp[3];
+		a[3] = yi - xi;
+	}
+	{
+		u64 xi = a[4];
+		u64 yi = tmp[4];
+		a[4] = yi - xi;
+	}
+}
+
+static __always_inline void fscalar(u64 *output, u64 *b, u64 s)
+{
+	u128 tmp[5];
+	u128 b4;
+	u128 b0;
+	u128 b4_;
+	u128 b0_;
+	{
+		u64 xi = b[0];
+		tmp[0] = ((u128)(xi) * (s));
+	}
+	{
+		u64 xi = b[1];
+		tmp[1] = ((u128)(xi) * (s));
+	}
+	{
+		u64 xi = b[2];
+		tmp[2] = ((u128)(xi) * (s));
+	}
+	{
+		u64 xi = b[3];
+		tmp[3] = ((u128)(xi) * (s));
+	}
+	{
+		u64 xi = b[4];
+		tmp[4] = ((u128)(xi) * (s));
+	}
+	fproduct_carry_wide_(tmp);
+	b4 = tmp[4];
+	b0 = tmp[0];
+	b4_ = ((b4) & (((u128)(0x7ffffffffffffLLU))));
+	b0_ = ((b0) + (((u128)(19) * (((u64)(((b4) >> (51))))))));
+	tmp[4] = b4_;
+	tmp[0] = b0_;
+	fproduct_copy_from_wide_(output, tmp);
+}
+
+static __always_inline void fmul(u64 *output, u64 *a, u64 *b)
+{
+	fmul_fmul(output, a, b);
+}
+
+static __always_inline void crecip(u64 *output, u64 *input)
+{
+	crecip_crecip(output, input);
+}
+
+static __always_inline void point_swap_conditional_step(u64 *a, u64 *b,
+							u64 swap1, u32 ctr)
+{
+	u32 i = ctr - 1;
+	u64 ai = a[i];
+	u64 bi = b[i];
+	u64 x = swap1 & (ai ^ bi);
+	u64 ai1 = ai ^ x;
+	u64 bi1 = bi ^ x;
+	a[i] = ai1;
+	b[i] = bi1;
+}
+
+static __always_inline void point_swap_conditional5(u64 *a, u64 *b, u64 swap1)
+{
+	point_swap_conditional_step(a, b, swap1, 5);
+	point_swap_conditional_step(a, b, swap1, 4);
+	point_swap_conditional_step(a, b, swap1, 3);
+	point_swap_conditional_step(a, b, swap1, 2);
+	point_swap_conditional_step(a, b, swap1, 1);
+}
+
+static __always_inline void point_swap_conditional(u64 *a, u64 *b, u64 iswap)
+{
+	u64 swap1 = 0 - iswap;
+	point_swap_conditional5(a, b, swap1);
+	point_swap_conditional5(a + 5, b + 5, swap1);
+}
+
+static __always_inline void point_copy(u64 *output, u64 *input)
+{
+	memcpy(output, input, 5 * sizeof(*input));
+	memcpy(output + 5, input + 5, 5 * sizeof(*input));
+}
+
+static __always_inline void addanddouble_fmonty(u64 *pp, u64 *ppq, u64 *p,
+						u64 *pq, u64 *qmqp)
+{
+	u64 *qx = qmqp;
+	u64 *x2 = pp;
+	u64 *z2 = pp + 5;
+	u64 *x3 = ppq;
+	u64 *z3 = ppq + 5;
+	u64 *x = p;
+	u64 *z = p + 5;
+	u64 *xprime = pq;
+	u64 *zprime = pq + 5;
+	u64 buf[40] = { 0 };
+	u64 *origx = buf;
+	u64 *origxprime0 = buf + 5;
+	u64 *xxprime0;
+	u64 *zzprime0;
+	u64 *origxprime;
+	xxprime0 = buf + 25;
+	zzprime0 = buf + 30;
+	memcpy(origx, x, 5 * sizeof(*x));
+	fsum(x, z);
+	fdifference(z, origx);
+	memcpy(origxprime0, xprime, 5 * sizeof(*xprime));
+	fsum(xprime, zprime);
+	fdifference(zprime, origxprime0);
+	fmul(xxprime0, xprime, z);
+	fmul(zzprime0, x, zprime);
+	origxprime = buf + 5;
+	{
+		u64 *xx0;
+		u64 *zz0;
+		u64 *xxprime;
+		u64 *zzprime;
+		u64 *zzzprime;
+		xx0 = buf + 15;
+		zz0 = buf + 20;
+		xxprime = buf + 25;
+		zzprime = buf + 30;
+		zzzprime = buf + 35;
+		memcpy(origxprime, xxprime, 5 * sizeof(*xxprime));
+		fsum(xxprime, zzprime);
+		fdifference(zzprime, origxprime);
+		fsquare_fsquare_times(x3, xxprime, 1);
+		fsquare_fsquare_times(zzzprime, zzprime, 1);
+		fmul(z3, zzzprime, qx);
+		fsquare_fsquare_times(xx0, x, 1);
+		fsquare_fsquare_times(zz0, z, 1);
+		{
+			u64 *zzz;
+			u64 *xx;
+			u64 *zz;
+			u64 scalar;
+			zzz = buf + 10;
+			xx = buf + 15;
+			zz = buf + 20;
+			fmul(x2, xx, zz);
+			fdifference(zz, xx);
+			scalar = 121665;
+			fscalar(zzz, zz, scalar);
+			fsum(zzz, xx);
+			fmul(z2, zzz, zz);
+		}
+	}
+}
+
+static __always_inline void
+ladder_smallloop_cmult_small_loop_step(u64 *nq, u64 *nqpq, u64 *nq2, u64 *nqpq2,
+				       u64 *q, u8 byt)
+{
+	u64 bit0 = (u64)(byt >> 7);
+	u64 bit;
+	point_swap_conditional(nq, nqpq, bit0);
+	addanddouble_fmonty(nq2, nqpq2, nq, nqpq, q);
+	bit = (u64)(byt >> 7);
+	point_swap_conditional(nq2, nqpq2, bit);
+}
+
+static __always_inline void
+ladder_smallloop_cmult_small_loop_double_step(u64 *nq, u64 *nqpq, u64 *nq2,
+					      u64 *nqpq2, u64 *q, u8 byt)
+{
+	u8 byt1;
+	ladder_smallloop_cmult_small_loop_step(nq, nqpq, nq2, nqpq2, q, byt);
+	byt1 = byt << 1;
+	ladder_smallloop_cmult_small_loop_step(nq2, nqpq2, nq, nqpq, q, byt1);
+}
+
+static __always_inline void
+ladder_smallloop_cmult_small_loop(u64 *nq, u64 *nqpq, u64 *nq2, u64 *nqpq2,
+				  u64 *q, u8 byt, u32 i)
+{
+	while (i--) {
+		ladder_smallloop_cmult_small_loop_double_step(nq, nqpq, nq2,
+							      nqpq2, q, byt);
+		byt <<= 2;
+	}
+}
+
+static __always_inline void ladder_bigloop_cmult_big_loop(u8 *n1, u64 *nq,
+							  u64 *nqpq, u64 *nq2,
+							  u64 *nqpq2, u64 *q,
+							  u32 i)
+{
+	while (i--) {
+		u8 byte = n1[i];
+		ladder_smallloop_cmult_small_loop(nq, nqpq, nq2, nqpq2, q,
+						  byte, 4);
+	}
+}
+
+static void ladder_cmult(u64 *result, u8 *n1, u64 *q)
+{
+	u64 point_buf[40] = { 0 };
+	u64 *nq = point_buf;
+	u64 *nqpq = point_buf + 10;
+	u64 *nq2 = point_buf + 20;
+	u64 *nqpq2 = point_buf + 30;
+	point_copy(nqpq, q);
+	nq[0] = 1;
+	ladder_bigloop_cmult_big_loop(n1, nq, nqpq, nq2, nqpq2, q, 32);
+	point_copy(result, nq);
+}
+
+static __always_inline void format_fexpand(u64 *output, const u8 *input)
+{
+	const u8 *x00 = input + 6;
+	const u8 *x01 = input + 12;
+	const u8 *x02 = input + 19;
+	const u8 *x0 = input + 24;
+	u64 i0, i1, i2, i3, i4, output0, output1, output2, output3, output4;
+	i0 = get_unaligned_le64(input);
+	i1 = get_unaligned_le64(x00);
+	i2 = get_unaligned_le64(x01);
+	i3 = get_unaligned_le64(x02);
+	i4 = get_unaligned_le64(x0);
+	output0 = i0 & 0x7ffffffffffffLLU;
+	output1 = i1 >> 3 & 0x7ffffffffffffLLU;
+	output2 = i2 >> 6 & 0x7ffffffffffffLLU;
+	output3 = i3 >> 1 & 0x7ffffffffffffLLU;
+	output4 = i4 >> 12 & 0x7ffffffffffffLLU;
+	output[0] = output0;
+	output[1] = output1;
+	output[2] = output2;
+	output[3] = output3;
+	output[4] = output4;
+}
+
+static __always_inline void format_fcontract_first_carry_pass(u64 *input)
+{
+	u64 t0 = input[0];
+	u64 t1 = input[1];
+	u64 t2 = input[2];
+	u64 t3 = input[3];
+	u64 t4 = input[4];
+	u64 t1_ = t1 + (t0 >> 51);
+	u64 t0_ = t0 & 0x7ffffffffffffLLU;
+	u64 t2_ = t2 + (t1_ >> 51);
+	u64 t1__ = t1_ & 0x7ffffffffffffLLU;
+	u64 t3_ = t3 + (t2_ >> 51);
+	u64 t2__ = t2_ & 0x7ffffffffffffLLU;
+	u64 t4_ = t4 + (t3_ >> 51);
+	u64 t3__ = t3_ & 0x7ffffffffffffLLU;
+	input[0] = t0_;
+	input[1] = t1__;
+	input[2] = t2__;
+	input[3] = t3__;
+	input[4] = t4_;
+}
+
+static __always_inline void format_fcontract_first_carry_full(u64 *input)
+{
+	format_fcontract_first_carry_pass(input);
+	modulo_carry_top(input);
+}
+
+static __always_inline void format_fcontract_second_carry_pass(u64 *input)
+{
+	u64 t0 = input[0];
+	u64 t1 = input[1];
+	u64 t2 = input[2];
+	u64 t3 = input[3];
+	u64 t4 = input[4];
+	u64 t1_ = t1 + (t0 >> 51);
+	u64 t0_ = t0 & 0x7ffffffffffffLLU;
+	u64 t2_ = t2 + (t1_ >> 51);
+	u64 t1__ = t1_ & 0x7ffffffffffffLLU;
+	u64 t3_ = t3 + (t2_ >> 51);
+	u64 t2__ = t2_ & 0x7ffffffffffffLLU;
+	u64 t4_ = t4 + (t3_ >> 51);
+	u64 t3__ = t3_ & 0x7ffffffffffffLLU;
+	input[0] = t0_;
+	input[1] = t1__;
+	input[2] = t2__;
+	input[3] = t3__;
+	input[4] = t4_;
+}
+
+static __always_inline void format_fcontract_second_carry_full(u64 *input)
+{
+	u64 i0;
+	u64 i1;
+	u64 i0_;
+	u64 i1_;
+	format_fcontract_second_carry_pass(input);
+	modulo_carry_top(input);
+	i0 = input[0];
+	i1 = input[1];
+	i0_ = i0 & 0x7ffffffffffffLLU;
+	i1_ = i1 + (i0 >> 51);
+	input[0] = i0_;
+	input[1] = i1_;
+}
+
+static __always_inline void format_fcontract_trim(u64 *input)
+{
+	u64 a0 = input[0];
+	u64 a1 = input[1];
+	u64 a2 = input[2];
+	u64 a3 = input[3];
+	u64 a4 = input[4];
+	u64 mask0 = u64_gte_mask(a0, 0x7ffffffffffedLLU);
+	u64 mask1 = u64_eq_mask(a1, 0x7ffffffffffffLLU);
+	u64 mask2 = u64_eq_mask(a2, 0x7ffffffffffffLLU);
+	u64 mask3 = u64_eq_mask(a3, 0x7ffffffffffffLLU);
+	u64 mask4 = u64_eq_mask(a4, 0x7ffffffffffffLLU);
+	u64 mask = (((mask0 & mask1) & mask2) & mask3) & mask4;
+	u64 a0_ = a0 - (0x7ffffffffffedLLU & mask);
+	u64 a1_ = a1 - (0x7ffffffffffffLLU & mask);
+	u64 a2_ = a2 - (0x7ffffffffffffLLU & mask);
+	u64 a3_ = a3 - (0x7ffffffffffffLLU & mask);
+	u64 a4_ = a4 - (0x7ffffffffffffLLU & mask);
+	input[0] = a0_;
+	input[1] = a1_;
+	input[2] = a2_;
+	input[3] = a3_;
+	input[4] = a4_;
+}
+
+static __always_inline void format_fcontract_store(u8 *output, u64 *input)
+{
+	u64 t0 = input[0];
+	u64 t1 = input[1];
+	u64 t2 = input[2];
+	u64 t3 = input[3];
+	u64 t4 = input[4];
+	u64 o0 = t1 << 51 | t0;
+	u64 o1 = t2 << 38 | t1 >> 13;
+	u64 o2 = t3 << 25 | t2 >> 26;
+	u64 o3 = t4 << 12 | t3 >> 39;
+	u8 *b0 = output;
+	u8 *b1 = output + 8;
+	u8 *b2 = output + 16;
+	u8 *b3 = output + 24;
+	put_unaligned_le64(o0, b0);
+	put_unaligned_le64(o1, b1);
+	put_unaligned_le64(o2, b2);
+	put_unaligned_le64(o3, b3);
+}
+
+static __always_inline void format_fcontract(u8 *output, u64 *input)
+{
+	format_fcontract_first_carry_full(input);
+	format_fcontract_second_carry_full(input);
+	format_fcontract_trim(input);
+	format_fcontract_store(output, input);
+}
+
+static __always_inline void format_scalar_of_point(u8 *scalar, u64 *point)
+{
+	u64 *x = point;
+	u64 *z = point + 5;
+	u64 buf[10] __aligned(32) = { 0 };
+	u64 *zmone = buf;
+	u64 *sc = buf + 5;
+	crecip(zmone, z);
+	fmul(sc, x, zmone);
+	format_fcontract(scalar, sc);
+}
+
+static void curve25519_generic(u8 mypublic[CURVE25519_KEY_SIZE],
+			       const u8 secret[CURVE25519_KEY_SIZE],
+			       const u8 basepoint[CURVE25519_KEY_SIZE])
+{
+	u64 buf0[10] __aligned(32) = { 0 };
+	u64 *x0 = buf0;
+	u64 *z = buf0 + 5;
+	u64 *q;
+	format_fexpand(x0, basepoint);
+	z[0] = 1;
+	q = buf0;
+	{
+		u8 e[32] __aligned(32) = { 0 };
+		u8 *scalar;
+		memcpy(e, secret, 32);
+		curve25519_clamp_secret(e);
+		scalar = e;
+		{
+			u64 buf[15] = { 0 };
+			u64 *nq = buf;
+			u64 *x = nq;
+			x[0] = 1;
+			ladder_cmult(nq, scalar, q);
+			format_scalar_of_point(mypublic, nq);
+			memzero_explicit(buf, sizeof(buf));
+		}
+		memzero_explicit(e, sizeof(e));
+	}
+	memzero_explicit(buf0, sizeof(buf0));
+}
diff --git a/src/curve25519.c b/src/curve25519.c
index c116e21..f1b6358 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -76,9 +76,9 @@ static noinline void memzero_explicit(void *s, size_t count)
 }
 
 #ifdef __SIZEOF_INT128__
-#include "../crypto/zinc/curve25519/curve25519-hacl64.c"
+#include "curve25519-hacl64.h"
 #else
-#include "../crypto/zinc/curve25519/curve25519-fiat32.c"
+#include "curve25519-fiat32.h"
 #endif
 
 void curve25519_generate_public(uint8_t pub[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE])
diff --git a/src/ipc.c b/src/ipc.c
index 7207efc..64d8b20 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -9,6 +9,7 @@
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 #include <linux/genetlink.h>
+#include <linux/wireguard.h>
 #include "mnlg.h"
 #endif
 #include <netinet/in.h>
@@ -38,7 +39,6 @@
 #include "containers.h"
 #include "encoding.h"
 #include "curve25519.h"
-#include "../uapi/wireguard.h"
 
 #define SOCK_PATH RUNSTATEDIR "/wireguard/"
 #define SOCK_SUFFIX ".sock"
diff --git a/src/uapi/linux/wireguard.h b/src/uapi/linux/wireguard.h
new file mode 100644
index 0000000..ae88be1
--- /dev/null
+++ b/src/uapi/linux/wireguard.h
@@ -0,0 +1,196 @@
+/* SPDX-License-Identifier: (GPL-2.0 WITH Linux-syscall-note) OR MIT */
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * Documentation
+ * =============
+ *
+ * The below enums and macros are for interfacing with WireGuard, using generic
+ * netlink, with family WG_GENL_NAME and version WG_GENL_VERSION. It defines two
+ * methods: get and set. Note that while they share many common attributes,
+ * these two functions actually accept a slightly different set of inputs and
+ * outputs.
+ *
+ * WG_CMD_GET_DEVICE
+ * -----------------
+ *
+ * May only be called via NLM_F_REQUEST | NLM_F_DUMP. The command should contain
+ * one but not both of:
+ *
+ *    WGDEVICE_A_IFINDEX: NLA_U32
+ *    WGDEVICE_A_IFNAME: NLA_NUL_STRING, maxlen IFNAMSIZ - 1
+ *
+ * The kernel will then return several messages (NLM_F_MULTI) containing the
+ * following tree of nested items:
+ *
+ *    WGDEVICE_A_IFINDEX: NLA_U32
+ *    WGDEVICE_A_IFNAME: NLA_NUL_STRING, maxlen IFNAMSIZ - 1
+ *    WGDEVICE_A_PRIVATE_KEY: NLA_EXACT_LEN, len WG_KEY_LEN
+ *    WGDEVICE_A_PUBLIC_KEY: NLA_EXACT_LEN, len WG_KEY_LEN
+ *    WGDEVICE_A_LISTEN_PORT: NLA_U16
+ *    WGDEVICE_A_FWMARK: NLA_U32
+ *    WGDEVICE_A_PEERS: NLA_NESTED
+ *        0: NLA_NESTED
+ *            WGPEER_A_PUBLIC_KEY: NLA_EXACT_LEN, len WG_KEY_LEN
+ *            WGPEER_A_PRESHARED_KEY: NLA_EXACT_LEN, len WG_KEY_LEN
+ *            WGPEER_A_ENDPOINT: NLA_MIN_LEN(struct sockaddr), struct sockaddr_in or struct sockaddr_in6
+ *            WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL: NLA_U16
+ *            WGPEER_A_LAST_HANDSHAKE_TIME: NLA_EXACT_LEN, struct __kernel_timespec
+ *            WGPEER_A_RX_BYTES: NLA_U64
+ *            WGPEER_A_TX_BYTES: NLA_U64
+ *            WGPEER_A_ALLOWEDIPS: NLA_NESTED
+ *                0: NLA_NESTED
+ *                    WGALLOWEDIP_A_FAMILY: NLA_U16
+ *                    WGALLOWEDIP_A_IPADDR: NLA_MIN_LEN(struct in_addr), struct in_addr or struct in6_addr
+ *                    WGALLOWEDIP_A_CIDR_MASK: NLA_U8
+ *                0: NLA_NESTED
+ *                    ...
+ *                0: NLA_NESTED
+ *                    ...
+ *                ...
+ *            WGPEER_A_PROTOCOL_VERSION: NLA_U32
+ *        0: NLA_NESTED
+ *            ...
+ *        ...
+ *
+ * It is possible that all of the allowed IPs of a single peer will not
+ * fit within a single netlink message. In that case, the same peer will
+ * be written in the following message, except it will only contain
+ * WGPEER_A_PUBLIC_KEY and WGPEER_A_ALLOWEDIPS. This may occur several
+ * times in a row for the same peer. It is then up to the receiver to
+ * coalesce adjacent peers. Likewise, it is possible that all peers will
+ * not fit within a single message. So, subsequent peers will be sent
+ * in following messages, except those will only contain WGDEVICE_A_IFNAME
+ * and WGDEVICE_A_PEERS. It is then up to the receiver to coalesce these
+ * messages to form the complete list of peers.
+ *
+ * Since this is an NLA_F_DUMP command, the final message will always be
+ * NLMSG_DONE, even if an error occurs. However, this NLMSG_DONE message
+ * contains an integer error code. It is either zero or a negative error
+ * code corresponding to the errno.
+ *
+ * WG_CMD_SET_DEVICE
+ * -----------------
+ *
+ * May only be called via NLM_F_REQUEST. The command should contain the
+ * following tree of nested items, containing one but not both of
+ * WGDEVICE_A_IFINDEX and WGDEVICE_A_IFNAME:
+ *
+ *    WGDEVICE_A_IFINDEX: NLA_U32
+ *    WGDEVICE_A_IFNAME: NLA_NUL_STRING, maxlen IFNAMSIZ - 1
+ *    WGDEVICE_A_FLAGS: NLA_U32, 0 or WGDEVICE_F_REPLACE_PEERS if all current
+ *                      peers should be removed prior to adding the list below.
+ *    WGDEVICE_A_PRIVATE_KEY: len WG_KEY_LEN, all zeros to remove
+ *    WGDEVICE_A_LISTEN_PORT: NLA_U16, 0 to choose randomly
+ *    WGDEVICE_A_FWMARK: NLA_U32, 0 to disable
+ *    WGDEVICE_A_PEERS: NLA_NESTED
+ *        0: NLA_NESTED
+ *            WGPEER_A_PUBLIC_KEY: len WG_KEY_LEN
+ *            WGPEER_A_FLAGS: NLA_U32, 0 and/or WGPEER_F_REMOVE_ME if the
+ *                            specified peer should not exist at the end of the
+ *                            operation, rather than added/updated and/or
+ *                            WGPEER_F_REPLACE_ALLOWEDIPS if all current allowed
+ *                            IPs of this peer should be removed prior to adding
+ *                            the list below and/or WGPEER_F_UPDATE_ONLY if the
+ *                            peer should only be set if it already exists.
+ *            WGPEER_A_PRESHARED_KEY: len WG_KEY_LEN, all zeros to remove
+ *            WGPEER_A_ENDPOINT: struct sockaddr_in or struct sockaddr_in6
+ *            WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL: NLA_U16, 0 to disable
+ *            WGPEER_A_ALLOWEDIPS: NLA_NESTED
+ *                0: NLA_NESTED
+ *                    WGALLOWEDIP_A_FAMILY: NLA_U16
+ *                    WGALLOWEDIP_A_IPADDR: struct in_addr or struct in6_addr
+ *                    WGALLOWEDIP_A_CIDR_MASK: NLA_U8
+ *                0: NLA_NESTED
+ *                    ...
+ *                0: NLA_NESTED
+ *                    ...
+ *                ...
+ *            WGPEER_A_PROTOCOL_VERSION: NLA_U32, should not be set or used at
+ *                                       all by most users of this API, as the
+ *                                       most recent protocol will be used when
+ *                                       this is unset. Otherwise, must be set
+ *                                       to 1.
+ *        0: NLA_NESTED
+ *            ...
+ *        ...
+ *
+ * It is possible that the amount of configuration data exceeds that of
+ * the maximum message length accepted by the kernel. In that case, several
+ * messages should be sent one after another, with each successive one
+ * filling in information not contained in the prior. Note that if
+ * WGDEVICE_F_REPLACE_PEERS is specified in the first message, it probably
+ * should not be specified in fragments that come after, so that the list
+ * of peers is only cleared the first time but appended after. Likewise for
+ * peers, if WGPEER_F_REPLACE_ALLOWEDIPS is specified in the first message
+ * of a peer, it likely should not be specified in subsequent fragments.
+ *
+ * If an error occurs, NLMSG_ERROR will reply containing an errno.
+ */
+
+#ifndef _WG_UAPI_WIREGUARD_H
+#define _WG_UAPI_WIREGUARD_H
+
+#define WG_GENL_NAME "wireguard"
+#define WG_GENL_VERSION 1
+
+#define WG_KEY_LEN 32
+
+enum wg_cmd {
+	WG_CMD_GET_DEVICE,
+	WG_CMD_SET_DEVICE,
+	__WG_CMD_MAX
+};
+#define WG_CMD_MAX (__WG_CMD_MAX - 1)
+
+enum wgdevice_flag {
+	WGDEVICE_F_REPLACE_PEERS = 1U << 0,
+	__WGDEVICE_F_ALL = WGDEVICE_F_REPLACE_PEERS
+};
+enum wgdevice_attribute {
+	WGDEVICE_A_UNSPEC,
+	WGDEVICE_A_IFINDEX,
+	WGDEVICE_A_IFNAME,
+	WGDEVICE_A_PRIVATE_KEY,
+	WGDEVICE_A_PUBLIC_KEY,
+	WGDEVICE_A_FLAGS,
+	WGDEVICE_A_LISTEN_PORT,
+	WGDEVICE_A_FWMARK,
+	WGDEVICE_A_PEERS,
+	__WGDEVICE_A_LAST
+};
+#define WGDEVICE_A_MAX (__WGDEVICE_A_LAST - 1)
+
+enum wgpeer_flag {
+	WGPEER_F_REMOVE_ME = 1U << 0,
+	WGPEER_F_REPLACE_ALLOWEDIPS = 1U << 1,
+	WGPEER_F_UPDATE_ONLY = 1U << 2,
+	__WGPEER_F_ALL = WGPEER_F_REMOVE_ME | WGPEER_F_REPLACE_ALLOWEDIPS |
+			 WGPEER_F_UPDATE_ONLY
+};
+enum wgpeer_attribute {
+	WGPEER_A_UNSPEC,
+	WGPEER_A_PUBLIC_KEY,
+	WGPEER_A_PRESHARED_KEY,
+	WGPEER_A_FLAGS,
+	WGPEER_A_ENDPOINT,
+	WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL,
+	WGPEER_A_LAST_HANDSHAKE_TIME,
+	WGPEER_A_RX_BYTES,
+	WGPEER_A_TX_BYTES,
+	WGPEER_A_ALLOWEDIPS,
+	WGPEER_A_PROTOCOL_VERSION,
+	__WGPEER_A_LAST
+};
+#define WGPEER_A_MAX (__WGPEER_A_LAST - 1)
+
+enum wgallowedip_attribute {
+	WGALLOWEDIP_A_UNSPEC,
+	WGALLOWEDIP_A_FAMILY,
+	WGALLOWEDIP_A_IPADDR,
+	WGALLOWEDIP_A_CIDR_MASK,
+	__WGALLOWEDIP_A_LAST
+};
+#define WGALLOWEDIP_A_MAX (__WGALLOWEDIP_A_LAST - 1)
+
+#endif /* _WG_UAPI_WIREGUARD_H */

commit d5ac56465edcfc1611d257c81fc0d93c7f2845e3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 26 12:02:11 2019 +0100

    gitignore: trim down to basics
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/.gitignore b/.gitignore
index 4f9e9fc..0f03c4d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,22 +2,13 @@ cscope.out
 *.o
 *.d
 *.dwo
-*.ko
-*.mod.c
-src/tools/wg
-Module.symvers
-*.cmd
-.tmp_versions
+src/wg
+src/wg.exe
 *.swp
-modules.order
-modules.builtin
-maint/
-qemu-build/
-src/tests/qemu/distfiles/
 *.id0
 *.id1
 *.id2
 *.nam
 *.til
 *.pro.user
-.cache.mk
+maint/

commit 6262906e5cbce9c2d430348827782a1c177a6d62
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Dec 17 14:14:13 2019 +0100

    wg-quick: linux: use already configured addresses instead of in-memory
    
    The ADDRESSES array might not have addresses added during PreUp. But
    moreover, nft(8) and iptables(8) don't like ip addresses in the form
    somev6prefix::someipv4suffix, such as fd00::1.2.3.4, while ip(8) can
    handle it. So by adding these first and then asking for them back, we
    always get normalized addresses suitable for nft(8) and iptables(8).
    
    Reported-by: Silvan Nagl <mail@53c70r.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 423a2c7..e9c9052 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -205,7 +205,7 @@ remove_firewall() {
 
 HAVE_SET_FIREWALL=0
 add_default() {
-	local table i
+	local table line
 	if ! get_fwmark table; then
 		table=51820
 		while [[ -n $(ip -4 route show table $table 2>/dev/null) || -n $(ip -6 route show table $table 2>/dev/null) ]]; do
@@ -224,11 +224,11 @@ add_default() {
 	printf -v nftcmd '%sadd chain %s %s preraw { type filter hook prerouting priority -300; }\n' "$nftcmd" "$pf" "$nftable"
 	printf -v nftcmd '%sadd chain %s %s premangle { type filter hook prerouting priority -150; }\n' "$nftcmd" "$pf" "$nftable"
 	printf -v nftcmd '%sadd chain %s %s postmangle { type filter hook postrouting priority -150; }\n' "$nftcmd" "$pf" "$nftable"
-	for i in "${ADDRESSES[@]}"; do
-		[[ ( $proto == -4 && $i != *:* ) || ( $proto == -6 && $i == *:* ) ]] || continue
-		printf -v restore '%s-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${i%/*}" "$marker"
-		printf -v nftcmd '%sadd rule %s %s preraw iifname != %s %s daddr %s fib saddr type != local drop\n' "$nftcmd" "$pf" "$nftable" "$INTERFACE" "$pf" "${i%/*}"
-	done
+	while read -r line; do
+		[[ $line =~ .*inet6?\ ([0-9a-f:.]+)/[0-9]+.* ]] || continue
+		printf -v restore '%s-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${BASH_REMATCH[1]}" "$marker"
+		printf -v nftcmd '%sadd rule %s %s preraw iifname != %s %s daddr %s fib saddr type != local drop\n' "$nftcmd" "$pf" "$nftable" "$INTERFACE" "$pf" "${BASH_REMATCH[1]}"
+	done < <(ip -o $proto addr show dev "$INTERFACE" 2>/dev/null)
 	printf -v restore '%sCOMMIT\n*mangle\n-I POSTROUTING -m mark --mark %d -p udp -j CONNMARK --save-mark %s\n-I PREROUTING -p udp -j CONNMARK --restore-mark %s\nCOMMIT\n' "$restore" $table "$marker" "$marker"
 	printf -v nftcmd '%sadd rule %s %s postmangle meta l4proto udp mark %d ct mark set mark \n' "$nftcmd" "$pf" "$nftable" $table
 	printf -v nftcmd '%sadd rule %s %s premangle meta l4proto udp meta mark set ct mark \n' "$nftcmd" "$pf" "$nftable"

commit 64f83e6161204e7930fa4ad05275677f7bec57e4
Author: Kai Haberzettl <khaberz@gmail.com>
Date:   Fri Dec 13 08:42:30 2019 +0100

    wg: adjust wg.8 syntax for consistency in COMMANDS section
    
    Signed-off-by: Kai Haberzettl <khaberz@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg.8 b/src/man/wg.8
index 043ffb0..ac281bc 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -122,7 +122,7 @@ A private key and a corresponding public key may be generated at once by calling
     $ wg genkey | tee private.key | wg pubkey > public.key
 .TP
 \fBhelp\fP
-Show usage message.
+Shows usage message.
 
 .SH CONFIGURATION FILE FORMAT
 The configuration file format is based on \fIINI\fP. There are two top level sections

commit 6fbfa0d7bba47ef1445b2354609c0f1e3886f3dd
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 12 17:24:04 2019 +0100

    wg-quick: linux: try both iptables(8) and nft(8) on teardown
    
    Daniel argues that technically a package manager could install nft(8)
    after previously having started wg-quick(8) using iptables(8).
    
    Suggested-by: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index d52bad3..423a2c7 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -188,7 +188,8 @@ remove_firewall() {
 			[[ $table == *" wg-quick-$INTERFACE" ]] && printf -v nftcmd '%sdelete %s\n' "$nftcmd" "$table"
 		done < <(nft list tables 2>/dev/null)
 		[[ -z $nftcmd ]] || cmd nft -f <(echo -n "$nftcmd")
-	else
+	fi
+	if type -p iptables >/dev/null; then
 		local line iptables found restore
 		for iptables in iptables ip6tables; do
 			restore="" found=0

commit 45417c5c0d20afb347a2daff186299c06af646e5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Dec 10 22:51:40 2019 +0100

    wg-quick: linux: support older nft(8)
    
    Older nft(8), such as that on Ubuntu, does not accept the - parameter to
    the -f argument and doesn't accept symbolic priority names. So instead
    use the canonical numeric priority forms and use <(echo) instead of -.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index dde0295..d52bad3 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -187,7 +187,7 @@ remove_firewall() {
 		while read -r table; do
 			[[ $table == *" wg-quick-$INTERFACE" ]] && printf -v nftcmd '%sdelete %s\n' "$nftcmd" "$table"
 		done < <(nft list tables 2>/dev/null)
-		[[ -z $nftcmd ]] || echo -n "$nftcmd" | cmd nft -f -
+		[[ -z $nftcmd ]] || cmd nft -f <(echo -n "$nftcmd")
 	else
 		local line iptables found restore
 		for iptables in iptables ip6tables; do
@@ -220,9 +220,9 @@ add_default() {
 
 	local marker="-m comment --comment \"wg-quick(8) rule for $INTERFACE\"" restore=$'*raw\n' nftable="wg-quick-$INTERFACE" nftcmd 
 	printf -v nftcmd '%sadd table %s %s\n' "$nftcmd" "$pf" "$nftable"
-	printf -v nftcmd '%sadd chain %s %s preraw { type filter hook prerouting priority raw; }\n' "$nftcmd" "$pf" "$nftable"
-	printf -v nftcmd '%sadd chain %s %s premangle { type filter hook prerouting priority mangle; }\n' "$nftcmd" "$pf" "$nftable"
-	printf -v nftcmd '%sadd chain %s %s postmangle { type filter hook postrouting priority mangle; }\n' "$nftcmd" "$pf" "$nftable"
+	printf -v nftcmd '%sadd chain %s %s preraw { type filter hook prerouting priority -300; }\n' "$nftcmd" "$pf" "$nftable"
+	printf -v nftcmd '%sadd chain %s %s premangle { type filter hook prerouting priority -150; }\n' "$nftcmd" "$pf" "$nftable"
+	printf -v nftcmd '%sadd chain %s %s postmangle { type filter hook postrouting priority -150; }\n' "$nftcmd" "$pf" "$nftable"
 	for i in "${ADDRESSES[@]}"; do
 		[[ ( $proto == -4 && $i != *:* ) || ( $proto == -6 && $i == *:* ) ]] || continue
 		printf -v restore '%s-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${i%/*}" "$marker"
@@ -233,7 +233,7 @@ add_default() {
 	printf -v nftcmd '%sadd rule %s %s premangle meta l4proto udp meta mark set ct mark \n' "$nftcmd" "$pf" "$nftable"
 	[[ $proto == -4 ]] && cmd sysctl -q net.ipv4.conf.all.src_valid_mark=1
 	if type -p nft >/dev/null; then
-		echo -n "$nftcmd" | cmd nft -f -
+		cmd nft -f <(echo -n "$nftcmd")
 	else
 		echo -n "$restore" | cmd $iptables-restore -n
 	fi

commit a863be0148345f879a17440462e213e8d7d576fd
Author: Josh Soref <jsoref@gmail.com>
Date:   Tue Dec 10 17:22:58 2019 +0100

    global: fix up spelling
    
    Signed-off-by: Josh Soref <jsoref@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/nat-hole-punching/README b/contrib/nat-hole-punching/README
index 46e6201..99c20e5 100644
--- a/contrib/nat-hole-punching/README
+++ b/contrib/nat-hole-punching/README
@@ -9,8 +9,8 @@ Compile with:
 
 
 Server is 1.2.3.4 and is on the public internet accepting UDP:49918.
-Client A is NAT'd and doesnt't know its IP address.
-Client B is NAT'd and doesnt't know its IP address.
+Client A is NAT'd and doesn't know its IP address.
+Client B is NAT'd and doesn't know its IP address.
 
 
 Server runs:
diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 144d462..ad05895 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -390,10 +390,10 @@ static int32_t string_array_size(char *const *array)
 	return size;
 }
 
-static const char *string_array_getter(const void *array_data, size_t index, int32_t *outlength)
+static const char *string_array_getter(const void *array_data, size_t index, int32_t *out_length)
 {
 	const char **array = (const char **)array_data;
-	*outlength = array[index] ? strlen(array[index]) : -1;
+	*out_length = array[index] ? strlen(array[index]) : -1;
 	return array[index];
 }
 

commit 17c78d31c27a3c311a2ff42a881057753c6ef2a4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Dec 10 16:37:34 2019 +0100

    wg-quick: linux: add support for nft and prefer it
    
    If nft(8) is installed, use it. These rules should be identical to the
    iptables-restore(8) ones, with the advantage that cleanup is easy
    because we use custom table names.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 9bfeed1..dde0295 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -95,7 +95,7 @@ add_if() {
 del_if() {
 	local table
 	[[ $HAVE_SET_DNS -eq 0 ]] || unset_dns
-	[[ $HAVE_SET_IPTABLES -eq 0 ]] || remove_iptables
+	[[ $HAVE_SET_FIREWALL -eq 0 ]] || remove_firewall
 	if [[ -z $TABLE || $TABLE == auto ]] && get_fwmark table && [[ $(wg show "$INTERFACE" allowed-ips) =~ /0(\ |$'\n'|$) ]]; then
 		while [[ $(ip -4 rule show 2>/dev/null) == *"lookup $table"* ]]; do
 			cmd ip -4 rule delete table $table
@@ -181,22 +181,30 @@ get_fwmark() {
 	return 0
 }
 
-remove_iptables() {
-	local line iptables found restore
-	for iptables in iptables ip6tables; do
-		restore="" found=0
-		while read -r line; do
-			[[ $line == "*"* || $line == COMMIT || $line == "-A "*"-m comment --comment \"wg-quick(8) rule for $INTERFACE\""* ]] || continue
-			[[ $line == "-A"* ]] && found=1
-			printf -v restore '%s%s\n' "$restore" "${line/#-A/-D}"
-		done < <($iptables-save 2>/dev/null)
-		[[ $found -ne 1 ]] || echo -n "$restore" | cmd $iptables-restore -n
-	done
+remove_firewall() {
+	if type -p nft >/dev/null; then
+		local table nftcmd
+		while read -r table; do
+			[[ $table == *" wg-quick-$INTERFACE" ]] && printf -v nftcmd '%sdelete %s\n' "$nftcmd" "$table"
+		done < <(nft list tables 2>/dev/null)
+		[[ -z $nftcmd ]] || echo -n "$nftcmd" | cmd nft -f -
+	else
+		local line iptables found restore
+		for iptables in iptables ip6tables; do
+			restore="" found=0
+			while read -r line; do
+				[[ $line == "*"* || $line == COMMIT || $line == "-A "*"-m comment --comment \"wg-quick(8) rule for $INTERFACE\""* ]] || continue
+				[[ $line == "-A"* ]] && found=1
+				printf -v restore '%s%s\n' "$restore" "${line/#-A/-D}"
+			done < <($iptables-save 2>/dev/null)
+			[[ $found -ne 1 ]] || echo -n "$restore" | cmd $iptables-restore -n
+		done
+	fi
 }
 
-HAVE_SET_IPTABLES=0
+HAVE_SET_FIREWALL=0
 add_default() {
-	local table proto i iptables
+	local table i
 	if ! get_fwmark table; then
 		table=51820
 		while [[ -n $(ip -4 route show table $table 2>/dev/null) || -n $(ip -6 route show table $table 2>/dev/null) ]]; do
@@ -204,21 +212,32 @@ add_default() {
 		done
 		cmd wg set "$INTERFACE" fwmark $table
 	fi
-	proto=-4 iptables=iptables
-	[[ $1 == *:* ]] && proto=-6 iptables=ip6tables
+	local proto=-4 iptables=iptables pf=ip
+	[[ $1 == *:* ]] && proto=-6 iptables=ip6tables pf=ip6
 	cmd ip $proto route add "$1" dev "$INTERFACE" table $table
 	cmd ip $proto rule add not fwmark $table table $table
 	cmd ip $proto rule add table main suppress_prefixlength 0
 
-	local marker="-m comment --comment \"wg-quick(8) rule for $INTERFACE\"" restore=$'*raw\n'
+	local marker="-m comment --comment \"wg-quick(8) rule for $INTERFACE\"" restore=$'*raw\n' nftable="wg-quick-$INTERFACE" nftcmd 
+	printf -v nftcmd '%sadd table %s %s\n' "$nftcmd" "$pf" "$nftable"
+	printf -v nftcmd '%sadd chain %s %s preraw { type filter hook prerouting priority raw; }\n' "$nftcmd" "$pf" "$nftable"
+	printf -v nftcmd '%sadd chain %s %s premangle { type filter hook prerouting priority mangle; }\n' "$nftcmd" "$pf" "$nftable"
+	printf -v nftcmd '%sadd chain %s %s postmangle { type filter hook postrouting priority mangle; }\n' "$nftcmd" "$pf" "$nftable"
 	for i in "${ADDRESSES[@]}"; do
 		[[ ( $proto == -4 && $i != *:* ) || ( $proto == -6 && $i == *:* ) ]] || continue
 		printf -v restore '%s-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${i%/*}" "$marker"
+		printf -v nftcmd '%sadd rule %s %s preraw iifname != %s %s daddr %s fib saddr type != local drop\n' "$nftcmd" "$pf" "$nftable" "$INTERFACE" "$pf" "${i%/*}"
 	done
 	printf -v restore '%sCOMMIT\n*mangle\n-I POSTROUTING -m mark --mark %d -p udp -j CONNMARK --save-mark %s\n-I PREROUTING -p udp -j CONNMARK --restore-mark %s\nCOMMIT\n' "$restore" $table "$marker" "$marker"
+	printf -v nftcmd '%sadd rule %s %s postmangle meta l4proto udp mark %d ct mark set mark \n' "$nftcmd" "$pf" "$nftable" $table
+	printf -v nftcmd '%sadd rule %s %s premangle meta l4proto udp meta mark set ct mark \n' "$nftcmd" "$pf" "$nftable"
 	[[ $proto == -4 ]] && cmd sysctl -q net.ipv4.conf.all.src_valid_mark=1
-	echo -n "$restore" | cmd $iptables-restore -n
-	HAVE_SET_IPTABLES=1
+	if type -p nft >/dev/null; then
+		echo -n "$nftcmd" | cmd nft -f -
+	else
+		echo -n "$restore" | cmd $iptables-restore -n
+	fi
+	HAVE_SET_FIREWALL=1
 	return 0
 }
 
@@ -323,7 +342,7 @@ cmd_down() {
 	[[ $SAVE_CONFIG -eq 0 ]] || save_config
 	del_if
 	unset_dns || true
-	remove_iptables || true
+	remove_firewall || true
 	execute_hooks "${POST_DOWN[@]}"
 }
 

commit bc8bf541854a79cdd83be20d630451a418797299
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 6 16:51:05 2019 +0100

    wg-quick: linux: ignore save warnings for iptables-nft
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 4e1f8ee..9bfeed1 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -189,7 +189,7 @@ remove_iptables() {
 			[[ $line == "*"* || $line == COMMIT || $line == "-A "*"-m comment --comment \"wg-quick(8) rule for $INTERFACE\""* ]] || continue
 			[[ $line == "-A"* ]] && found=1
 			printf -v restore '%s%s\n' "$restore" "${line/#-A/-D}"
-		done < <($iptables-save)
+		done < <($iptables-save 2>/dev/null)
 		[[ $found -ne 1 ]] || echo -n "$restore" | cmd $iptables-restore -n
 	done
 }

commit 8d4e4f3a8697cd0843db1cb34cdecfe04d2b91f8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 6 16:22:18 2019 +0100

    wg-quick: linux: suppress more warnings on weird kernels
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index d2c2ba9..4e1f8ee 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -97,16 +97,16 @@ del_if() {
 	[[ $HAVE_SET_DNS -eq 0 ]] || unset_dns
 	[[ $HAVE_SET_IPTABLES -eq 0 ]] || remove_iptables
 	if [[ -z $TABLE || $TABLE == auto ]] && get_fwmark table && [[ $(wg show "$INTERFACE" allowed-ips) =~ /0(\ |$'\n'|$) ]]; then
-		while [[ $(ip -4 rule show) == *"lookup $table"* ]]; do
+		while [[ $(ip -4 rule show 2>/dev/null) == *"lookup $table"* ]]; do
 			cmd ip -4 rule delete table $table
 		done
-		while [[ $(ip -4 rule show) == *"from all lookup main suppress_prefixlength 0"* ]]; do
+		while [[ $(ip -4 rule show 2>/dev/null) == *"from all lookup main suppress_prefixlength 0"* ]]; do
 			cmd ip -4 rule delete table main suppress_prefixlength 0
 		done
-		while [[ $(ip -6 rule show) == *"lookup $table"* ]]; do
+		while [[ $(ip -6 rule show 2>/dev/null) == *"lookup $table"* ]]; do
 			cmd ip -6 rule delete table $table
 		done
-		while [[ $(ip -6 rule show) == *"from all lookup main suppress_prefixlength 0"* ]]; do
+		while [[ $(ip -6 rule show 2>/dev/null) == *"from all lookup main suppress_prefixlength 0"* ]]; do
 			cmd ip -6 rule delete table main suppress_prefixlength 0
 		done
 	fi

commit 3928ebb87de6069be44d520e6bf82ef57f8b7f91
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 5 18:33:15 2019 +0100

    wg-quick: linux: some iptables don't like empty lines
    
    Reported-by: Kenneth R. Crudup <kenny@panix.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index fc90e55..d2c2ba9 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -188,9 +188,9 @@ remove_iptables() {
 		while read -r line; do
 			[[ $line == "*"* || $line == COMMIT || $line == "-A "*"-m comment --comment \"wg-quick(8) rule for $INTERFACE\""* ]] || continue
 			[[ $line == "-A"* ]] && found=1
-			printf -v restore '%s\n%s' "$restore" "${line/#-A/-D}"
+			printf -v restore '%s%s\n' "$restore" "${line/#-A/-D}"
 		done < <($iptables-save)
-		[[ $found -ne 1 ]] || echo "$restore" | cmd $iptables-restore -n
+		[[ $found -ne 1 ]] || echo -n "$restore" | cmd $iptables-restore -n
 	done
 }
 
@@ -210,14 +210,14 @@ add_default() {
 	cmd ip $proto rule add not fwmark $table table $table
 	cmd ip $proto rule add table main suppress_prefixlength 0
 
-	local marker="-m comment --comment \"wg-quick(8) rule for $INTERFACE\"" restore="*raw"
+	local marker="-m comment --comment \"wg-quick(8) rule for $INTERFACE\"" restore=$'*raw\n'
 	for i in "${ADDRESSES[@]}"; do
 		[[ ( $proto == -4 && $i != *:* ) || ( $proto == -6 && $i == *:* ) ]] || continue
-		printf -v restore '%s\n-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${i%/*}" "$marker"
+		printf -v restore '%s-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${i%/*}" "$marker"
 	done
-	printf -v restore '%s\nCOMMIT\n*mangle\n-I POSTROUTING -m mark --mark %d -p udp -j CONNMARK --save-mark %s\n-I PREROUTING -p udp -j CONNMARK --restore-mark %s\nCOMMIT\n' "$restore" $table "$marker" "$marker"
+	printf -v restore '%sCOMMIT\n*mangle\n-I POSTROUTING -m mark --mark %d -p udp -j CONNMARK --save-mark %s\n-I PREROUTING -p udp -j CONNMARK --restore-mark %s\nCOMMIT\n' "$restore" $table "$marker" "$marker"
 	[[ $proto == -4 ]] && cmd sysctl -q net.ipv4.conf.all.src_valid_mark=1
-	echo "$restore" | cmd $iptables-restore -n
+	echo -n "$restore" | cmd $iptables-restore -n
 	HAVE_SET_IPTABLES=1
 	return 0
 }

commit 9eab3487cdd78b11306e9f80e041d6da80060ef2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 5 11:47:57 2019 +0100

    wg-quick: linux: iptables-* -w is not widely supported
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 4fecabb..fc90e55 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -190,7 +190,7 @@ remove_iptables() {
 			[[ $line == "-A"* ]] && found=1
 			printf -v restore '%s\n%s' "$restore" "${line/#-A/-D}"
 		done < <($iptables-save)
-		[[ $found -ne 1 ]] || echo "$restore" | cmd $iptables-restore -nw
+		[[ $found -ne 1 ]] || echo "$restore" | cmd $iptables-restore -n
 	done
 }
 
@@ -217,7 +217,7 @@ add_default() {
 	done
 	printf -v restore '%s\nCOMMIT\n*mangle\n-I POSTROUTING -m mark --mark %d -p udp -j CONNMARK --save-mark %s\n-I PREROUTING -p udp -j CONNMARK --restore-mark %s\nCOMMIT\n' "$restore" $table "$marker" "$marker"
 	[[ $proto == -4 ]] && cmd sysctl -q net.ipv4.conf.all.src_valid_mark=1
-	echo "$restore" | cmd $iptables-restore -nw
+	echo "$restore" | cmd $iptables-restore -n
 	HAVE_SET_IPTABLES=1
 	return 0
 }

commit faa55d8b19a269c2a1c5ada3098dfb775ba17419
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Dec 2 19:19:38 2019 +0100

    ipc: make sure userspace communication frees wgdevice
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 89484b1..7207efc 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -303,8 +303,12 @@ static int userspace_get_device(struct wgdevice **out, const char *iface)
 		return -errno;
 
 	f = userspace_interface_file(iface);
-	if (!f)
-		return -errno;
+	if (!f) {
+		ret = -errno;
+		free(dev);
+		*out = NULL;
+		return ret;
+	}
 
 	fprintf(f, "get=1\n\n");
 	fflush(f);
@@ -314,11 +318,8 @@ static int userspace_get_device(struct wgdevice **out, const char *iface)
 
 	while (getline(&key, &line_buffer_len, f) > 0) {
 		line_len = strlen(key);
-		if (line_len == 1 && key[0] == '\n') {
-			free(key);
-			fclose(f);
-			return ret;
-		}
+		if (line_len == 1 && key[0] == '\n')
+			goto err;
 		value = strchr(key, '=');
 		if (!value || line_len == 0 || key[line_len - 1] != '\n')
 			break;
@@ -382,7 +383,7 @@ static int userspace_get_device(struct wgdevice **out, const char *iface)
 				*end++ = '\0';
 			}
 			if (getaddrinfo(begin, end, &hints, &resolved) != 0) {
-				errno = ENETUNREACH;
+				ret = ENETUNREACH;
 				goto err;
 			}
 			if ((resolved->ai_family == AF_INET && resolved->ai_addrlen == sizeof(struct sockaddr_in)) ||
@@ -437,8 +438,10 @@ static int userspace_get_device(struct wgdevice **out, const char *iface)
 	ret = -EPROTO;
 err:
 	free(key);
-	free_wgdevice(dev);
-	*out = NULL;
+	if (ret) {
+		free_wgdevice(dev);
+		*out = NULL;
+	}
 	fclose(f);
 	errno = -ret;
 	return ret;
diff --git a/src/setconf.c b/src/setconf.c
index a244c07..f778f40 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -45,8 +45,10 @@ static bool sync_conf(struct wgdevice *file)
 		return false;
 	}
 
-	if (!runtime->first_peer)
+	if (!runtime->first_peer) {
+		free_wgdevice(runtime);
 		return true;
+	}
 
 	file->flags &= ~WGDEVICE_REPLACE_PEERS;
 

commit 207aeed010c84d837b5c041f07df48e6edfd33e4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Nov 28 18:15:41 2019 +0100

    wg-quick: linux: have remove_iptables return true
    
    Reported-by: Thomas Sattler <sattler@med.uni-frankfurt.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index dca7b3d..4fecabb 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -190,7 +190,7 @@ remove_iptables() {
 			[[ $line == "-A"* ]] && found=1
 			printf -v restore '%s\n%s' "$restore" "${line/#-A/-D}"
 		done < <($iptables-save)
-		[[ $found -eq 1 ]] && echo "$restore" | cmd $iptables-restore -nw
+		[[ $found -ne 1 ]] || echo "$restore" | cmd $iptables-restore -nw
 	done
 }
 

commit af69113e02e7812ca370fedf36ba2f0d05886d13
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Nov 28 13:49:34 2019 +0100

    wg-quick: linux: ensure postdown hooks execute
    
    Reported-by: Thomas Sattler <sattler@med.uni-frankfurt.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 81b1629..dca7b3d 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -322,8 +322,8 @@ cmd_down() {
 	execute_hooks "${PRE_DOWN[@]}"
 	[[ $SAVE_CONFIG -eq 0 ]] || save_config
 	del_if
-	unset_dns
-	remove_iptables
+	unset_dns || true
+	remove_iptables || true
 	execute_hooks "${POST_DOWN[@]}"
 }
 

commit a9abb2157547ad6e60931e741ce3707ab3c8788e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Nov 27 17:12:08 2019 +0100

    wg-quick: linux: suppress error when finding unused table
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 0764dc6..81b1629 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -199,7 +199,7 @@ add_default() {
 	local table proto i iptables
 	if ! get_fwmark table; then
 		table=51820
-		while [[ -n $(ip -4 route show table $table) || -n $(ip -6 route show table $table) ]]; do
+		while [[ -n $(ip -4 route show table $table 2>/dev/null) || -n $(ip -6 route show table $table 2>/dev/null) ]]; do
 			((table++))
 		done
 		cmd wg set "$INTERFACE" fwmark $table

commit ae374129ab46d7cfc6f089e6a1ad71968764397d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jun 11 19:22:52 2019 +0200

    wg: add syncconf command
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg.8 b/src/man/wg.8
index afff749..043ffb0 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -94,6 +94,14 @@ Appends the contents of \fI<configuration-filename>\fP, which must
 be in the format described by \fICONFIGURATION FILE FORMAT\fP below,
 to the current configuration of \fI<interface>\fP.
 .TP
+\fBsyncconf\fP \fI<interface>\fP \fI<configuration-filename>\fP
+Like \fBsetconf\fP, but reads back the existing configuration first
+and only makes changes that are explicitly different between the configuration
+file and the interface. This is much less efficient than \fBsetconf\fP,
+but has the benefit of not disrupting current peer sessions. The contents of
+\fI<configuration-filename>\fP must be in the format described by
+\fICONFIGURATION FILE FORMAT\fP below.
+.TP
 \fBgenkey\fP
 Generates a random \fIprivate\fP key in base64 and prints it to
 standard output.
diff --git a/src/setconf.c b/src/setconf.c
index 8211ebd..a244c07 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -13,6 +13,89 @@
 #include "ipc.h"
 #include "subcommands.h"
 
+struct pubkey_origin {
+	uint8_t *pubkey;
+	bool from_file;
+};
+
+static int pubkey_cmp(const void *first, const void *second)
+{
+	const struct pubkey_origin *a = first, *b = second;
+	int ret = memcmp(a->pubkey, b->pubkey, WG_KEY_LEN);
+	if (ret)
+		return ret;
+	return a->from_file - b->from_file;
+}
+
+static bool sync_conf(struct wgdevice *file)
+{
+	struct wgdevice *runtime;
+	struct wgpeer *peer;
+	struct pubkey_origin *pubkeys;
+	size_t peer_count = 0, i = 0;
+
+	if (!file->first_peer)
+		return true;
+
+	for_each_wgpeer(file, peer)
+		++peer_count;
+
+	if (ipc_get_device(&runtime, file->name) != 0) {
+		perror("Unable to retrieve current interface configuration");
+		return false;
+	}
+
+	if (!runtime->first_peer)
+		return true;
+
+	file->flags &= ~WGDEVICE_REPLACE_PEERS;
+
+	for_each_wgpeer(runtime, peer)
+		++peer_count;
+
+	pubkeys = calloc(peer_count, sizeof(*pubkeys));
+	if (!pubkeys) {
+		free_wgdevice(runtime);
+		perror("Public key allocation");
+		return false;
+	}
+
+	for_each_wgpeer(file, peer) {
+		pubkeys[i].pubkey = peer->public_key;
+		pubkeys[i].from_file = true;
+		++i;
+	}
+	for_each_wgpeer(runtime, peer) {
+		pubkeys[i].pubkey = peer->public_key;
+		pubkeys[i].from_file = false;
+		++i;
+	}
+	qsort(pubkeys, peer_count, sizeof(*pubkeys), pubkey_cmp);
+
+	for (i = 0; i < peer_count; ++i) {
+		if (pubkeys[i].from_file)
+			continue;
+		if (i == peer_count - 1 || !pubkeys[i + 1].from_file || memcmp(pubkeys[i].pubkey, pubkeys[i + 1].pubkey, WG_KEY_LEN)) {
+			peer = calloc(1, sizeof(struct wgpeer));
+			if (!peer) {
+				free_wgdevice(runtime);
+				free(pubkeys);
+				perror("Peer allocation");
+				return false;
+			}
+			peer->flags = WGPEER_REMOVE_ME;
+			memcpy(peer->public_key, pubkeys[i].pubkey, WG_KEY_LEN);
+			peer->next_peer = file->first_peer;
+			file->first_peer = peer;
+			if (!file->last_peer)
+				file->last_peer = peer;
+		}
+	}
+	free_wgdevice(runtime);
+	free(pubkeys);
+	return true;
+}
+
 int setconf_main(int argc, char *argv[])
 {
 	struct wgdevice *device = NULL;
@@ -50,6 +133,11 @@ int setconf_main(int argc, char *argv[])
 	strncpy(device->name, argv[1], IFNAMSIZ - 1);
 	device->name[IFNAMSIZ - 1] = '\0';
 
+	if (!strcmp(argv[0], "syncconf")) {
+		if (!sync_conf(device))
+			goto cleanup;
+	}
+
 	if (ipc_set_device(device) != 0) {
 		perror("Unable to modify interface");
 		goto cleanup;
diff --git a/src/wg.c b/src/wg.c
index 550d9b4..7b5d3af 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -21,6 +21,7 @@ static const struct {
 	{ "set", set_main, "Change the current configuration, add peers, remove peers, or change peers" },
 	{ "setconf", setconf_main, "Applies a configuration file to a WireGuard interface" },
 	{ "addconf", setconf_main, "Appends a configuration file to a WireGuard interface" },
+	{ "syncconf", setconf_main, "Synchronizes a configuration file to a WireGuard interface" },
 	{ "genkey", genkey_main, "Generates a new private key and writes it to stdout" },
 	{ "genpsk", genkey_main, "Generates a new preshared key and writes it to stdout" },
 	{ "pubkey", pubkey_main, "Reads a private key from stdin and writes a public key to stdout" }

commit 34ea0caf1fd0b3364f85e5d72e1674bea5ee84ba
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Nov 27 13:30:43 2019 +0100

    reresolve-dns: remove invalid anchors on regex match
    
    Reported-by: Conrad Meyer <cem@freebsd.org>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/reresolve-dns/reresolve-dns.sh b/contrib/reresolve-dns/reresolve-dns.sh
index e579f86..8ab3635 100755
--- a/contrib/reresolve-dns/reresolve-dns.sh
+++ b/contrib/reresolve-dns/reresolve-dns.sh
@@ -15,7 +15,7 @@ INTERFACE="${BASH_REMATCH[1]}"
 
 process_peer() {
 	[[ $PEER_SECTION -ne 1 || -z $PUBLIC_KEY || -z $ENDPOINT ]] && return 0
-	[[ $(wg show "$INTERFACE" latest-handshakes) =~ ^${PUBLIC_KEY//+/\\+}\	([0-9]+)$ ]] || return 0
+	[[ $(wg show "$INTERFACE" latest-handshakes) =~ ${PUBLIC_KEY//+/\\+}\	([0-9]+) ]] || return 0
 	(( ($(date +%s) - ${BASH_REMATCH[1]}) > 135 )) || return 0
 	wg set "$INTERFACE" peer "$PUBLIC_KEY" endpoint "$ENDPOINT"
 	reset_peer_section

commit ebcf1ef8b1addbb888a6753fdee8f21231b656e6
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Nov 21 11:19:43 2019 +0100

    wg-quick: linux: filter bogus injected packets and don't disable rpfilter
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index cf72d41..0764dc6 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -95,6 +95,7 @@ add_if() {
 del_if() {
 	local table
 	[[ $HAVE_SET_DNS -eq 0 ]] || unset_dns
+	[[ $HAVE_SET_IPTABLES -eq 0 ]] || remove_iptables
 	if [[ -z $TABLE || $TABLE == auto ]] && get_fwmark table && [[ $(wg show "$INTERFACE" allowed-ips) =~ /0(\ |$'\n'|$) ]]; then
 		while [[ $(ip -4 rule show) == *"lookup $table"* ]]; do
 			cmd ip -4 rule delete table $table
@@ -180,8 +181,22 @@ get_fwmark() {
 	return 0
 }
 
+remove_iptables() {
+	local line iptables found restore
+	for iptables in iptables ip6tables; do
+		restore="" found=0
+		while read -r line; do
+			[[ $line == "*"* || $line == COMMIT || $line == "-A "*"-m comment --comment \"wg-quick(8) rule for $INTERFACE\""* ]] || continue
+			[[ $line == "-A"* ]] && found=1
+			printf -v restore '%s\n%s' "$restore" "${line/#-A/-D}"
+		done < <($iptables-save)
+		[[ $found -eq 1 ]] && echo "$restore" | cmd $iptables-restore -nw
+	done
+}
+
+HAVE_SET_IPTABLES=0
 add_default() {
-	local table proto key value
+	local table proto i iptables
 	if ! get_fwmark table; then
 		table=51820
 		while [[ -n $(ip -4 route show table $table) || -n $(ip -6 route show table $table) ]]; do
@@ -189,16 +204,21 @@ add_default() {
 		done
 		cmd wg set "$INTERFACE" fwmark $table
 	fi
-	proto=-4
-	[[ $1 == *:* ]] && proto=-6
+	proto=-4 iptables=iptables
+	[[ $1 == *:* ]] && proto=-6 iptables=ip6tables
 	cmd ip $proto route add "$1" dev "$INTERFACE" table $table
 	cmd ip $proto rule add not fwmark $table table $table
 	cmd ip $proto rule add table main suppress_prefixlength 0
-	if [[ $proto == -4 ]]; then
-		while read -r key _ value; do
-			[[ $value -eq 1 ]] && sysctl -q "$key=2"
-		done < <(sysctl -a -r '^net\.ipv4.conf\.[^ .=]+\.rp_filter$')
-	fi
+
+	local marker="-m comment --comment \"wg-quick(8) rule for $INTERFACE\"" restore="*raw"
+	for i in "${ADDRESSES[@]}"; do
+		[[ ( $proto == -4 && $i != *:* ) || ( $proto == -6 && $i == *:* ) ]] || continue
+		printf -v restore '%s\n-I PREROUTING ! -i %s -d %s -m addrtype ! --src-type LOCAL -j DROP %s\n' "$restore" "$INTERFACE" "${i%/*}" "$marker"
+	done
+	printf -v restore '%s\nCOMMIT\n*mangle\n-I POSTROUTING -m mark --mark %d -p udp -j CONNMARK --save-mark %s\n-I PREROUTING -p udp -j CONNMARK --restore-mark %s\nCOMMIT\n' "$restore" $table "$marker" "$marker"
+	[[ $proto == -4 ]] && cmd sysctl -q net.ipv4.conf.all.src_valid_mark=1
+	echo "$restore" | cmd $iptables-restore -nw
+	HAVE_SET_IPTABLES=1
 	return 0
 }
 
@@ -303,6 +323,7 @@ cmd_down() {
 	[[ $SAVE_CONFIG -eq 0 ]] || save_config
 	del_if
 	unset_dns
+	remove_iptables
 	execute_hooks "${POST_DOWN[@]}"
 }
 

commit a59aa6c404f45055e59e59e603b7faf297f28425
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Nov 21 10:53:45 2019 +0100

    wg-quick: linux: only touch net.ipv4 for v4
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index e690944..cf72d41 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -194,9 +194,11 @@ add_default() {
 	cmd ip $proto route add "$1" dev "$INTERFACE" table $table
 	cmd ip $proto rule add not fwmark $table table $table
 	cmd ip $proto rule add table main suppress_prefixlength 0
-	while read -r key _ value; do
-		[[ $value -eq 1 ]] && sysctl -q "$key=2"
-	done < <(sysctl -a -r '^net\.ipv4.conf\.[^ .=]+\.rp_filter$')
+	if [[ $proto == -4 ]]; then
+		while read -r key _ value; do
+			[[ $value -eq 1 ]] && sysctl -q "$key=2"
+		done < <(sysctl -a -r '^net\.ipv4.conf\.[^ .=]+\.rp_filter$')
+	fi
 	return 0
 }
 

commit cf7ec31d2d74458781d37d52fb4245def24123e7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Oct 16 14:23:27 2019 +0200

    wg-quick: android: check for null in binder cleanup functions
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index fefbe38..144d462 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -358,15 +358,18 @@ static	__attribute__((__constructor__(65535))) void load_symbols(void)
 
 static void cleanup_binder(AIBinder **binder)
 {
-	AIBinder_decStrong(*binder);
+	if (*binder)
+		AIBinder_decStrong(*binder);
 }
 static void cleanup_status(AStatus **status)
 {
-	AStatus_delete(*status);
+	if (*status)
+		AStatus_delete(*status);
 }
 static void cleanup_parcel(AParcel **parcel)
 {
-	AParcel_delete(*parcel);
+	if (*parcel)
+		AParcel_delete(*parcel);
 }
 
 #define _cleanup_status_ __attribute__((__cleanup__(cleanup_status)))

commit 792727cf641a9d1a7694f3d17e4853a5817d1522
Author: Nicolas Douma <nicolas@serveur.io>
Date:   Wed Oct 2 21:10:51 2019 +0200

    wg-quick: android: use Binder for setting DNS on Android 10
    
    Signed-off-by: Nicolas Douma <nicolas@serveur.io>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index e8ea4b4..fefbe38 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -20,6 +20,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <regex.h>
+#include <dlfcn.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
@@ -37,6 +38,7 @@
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
 
 static bool is_exiting = false;
+static bool binder_available = false;
 
 static void *xmalloc(size_t size)
 {
@@ -235,6 +237,373 @@ _printf_(1, 2) static void cndc(const char *cmd_fmt, ...)
 	}
 }
 
+/* Values are from AOSP repository platform/frameworks/native in libs/binder/ndk/include_ndk/android/binder_status.h. */
+enum {
+	STATUS_OK = 0,
+	STATUS_UNKNOWN_ERROR = -2147483647 - 1,
+	STATUS_NO_MEMORY = -ENOMEM,
+	STATUS_INVALID_OPERATION = -ENOSYS,
+	STATUS_BAD_VALUE = -EINVAL,
+	STATUS_BAD_TYPE = STATUS_UNKNOWN_ERROR + 1,
+	STATUS_NAME_NOT_FOUND = -ENOENT,
+	STATUS_PERMISSION_DENIED = -EPERM,
+	STATUS_NO_INIT = -ENODEV,
+	STATUS_ALREADY_EXISTS = -EEXIST,
+	STATUS_DEAD_OBJECT = -EPIPE,
+	STATUS_FAILED_TRANSACTION = STATUS_UNKNOWN_ERROR + 2,
+	STATUS_BAD_INDEX = -EOVERFLOW,
+	STATUS_NOT_ENOUGH_DATA = -ENODATA,
+	STATUS_WOULD_BLOCK = -EWOULDBLOCK,
+	STATUS_TIMED_OUT = -ETIMEDOUT,
+	STATUS_UNKNOWN_TRANSACTION = -EBADMSG,
+	STATUS_FDS_NOT_ALLOWED = STATUS_UNKNOWN_ERROR + 7,
+	STATUS_UNEXPECTED_NULL = STATUS_UNKNOWN_ERROR + 8
+};
+enum {
+	EX_NONE = 0,
+	EX_SECURITY = -1,
+	EX_BAD_PARCELABLE = -2,
+	EX_ILLEGAL_ARGUMENT = -3,
+	EX_NULL_POINTER = -4,
+	EX_ILLEGAL_STATE = -5,
+	EX_NETWORK_MAIN_THREAD = -6,
+	EX_UNSUPPORTED_OPERATION = -7,
+	EX_SERVICE_SPECIFIC = -8,
+	EX_PARCELABLE = -9,
+	EX_TRANSACTION_FAILED = -129
+};
+enum {
+	FLAG_ONEWAY = 0x01,
+};
+enum {
+	FIRST_CALL_TRANSACTION = 0x00000001,
+	LAST_CALL_TRANSACTION = 0x00ffffff
+};
+struct AIBinder;
+struct AParcel;
+struct AStatus;
+struct AIBinder_Class;
+typedef struct AIBinder AIBinder;
+typedef struct AParcel AParcel;
+typedef struct AStatus AStatus;
+typedef struct AIBinder_Class AIBinder_Class;
+typedef int32_t binder_status_t;
+typedef int32_t binder_exception_t;
+typedef uint32_t transaction_code_t;
+typedef uint32_t binder_flags_t;
+typedef void *(*AIBinder_Class_onCreate)(void *args);
+typedef void (*AIBinder_Class_onDestroy)(void *userData);
+typedef binder_status_t (*AIBinder_Class_onTransact)(AIBinder *binder, transaction_code_t code, const AParcel *in, AParcel *out);
+typedef const char *(*AParcel_stringArrayElementGetter)(const void *arrayData, size_t index, int32_t *outLength);
+static AIBinder_Class *(*AIBinder_Class_define)(const char *interfaceDescriptor, AIBinder_Class_onCreate onCreate, AIBinder_Class_onDestroy onDestroy, AIBinder_Class_onTransact onTransact) __attribute__((warn_unused_result));
+static bool (*AIBinder_associateClass)(AIBinder *binder, const AIBinder_Class *clazz);
+static void (*AIBinder_decStrong)(AIBinder *binder);
+static binder_status_t (*AIBinder_prepareTransaction)(AIBinder *binder, AParcel **in);
+static binder_status_t (*AIBinder_transact)(AIBinder *binder, transaction_code_t code, AParcel **in, AParcel **out, binder_flags_t flags);
+static binder_status_t (*AIBinder_ping)(AIBinder *binder);
+static binder_status_t (*AIBinder_dump)(AIBinder *binder, int fd, const char **args, uint32_t numArgs);
+static binder_status_t (*AParcel_readStatusHeader)(const AParcel *parcel, AStatus **status);
+static binder_status_t (*AParcel_readBool)(const AParcel *parcel, bool *value);
+static void (*AParcel_delete)(AParcel *parcel);
+static binder_status_t (*AParcel_setDataPosition)(const AParcel *parcel, int32_t position);
+static int32_t (*AParcel_getDataPosition)(const AParcel *parcel);
+static binder_status_t (*AParcel_writeInt32)(AParcel *parcel, int32_t value);
+static binder_status_t (*AParcel_writeStringArray)(AParcel *parcel, const void *arrayData, int32_t length, AParcel_stringArrayElementGetter getter);
+static binder_status_t (*AParcel_writeString)(AParcel *parcel, const char *string, int32_t length);
+static bool (*AStatus_isOk)(const AStatus *status);
+static void (*AStatus_delete)(AStatus *status);
+static binder_exception_t (*AStatus_getExceptionCode)(const AStatus *status);
+static int32_t (*AStatus_getServiceSpecificError)(const AStatus *status);
+static const char* (*AStatus_getMessage)(const AStatus *status);
+static binder_status_t (*AStatus_getStatus)(const AStatus *status);
+static AIBinder *(*AServiceManager_getService)(const char *instance) __attribute__((__warn_unused_result__));
+
+static	__attribute__((__constructor__(65535))) void load_symbols(void)
+{
+	void *handle = dlopen("libbinder_ndk.so", RTLD_LAZY);
+	binder_available = !!handle;
+	if (!binder_available)
+		return;
+
+#define X(symb) do {												\
+			if (!((symb) = (typeof(symb))dlsym(handle, #symb))) {					\
+				fprintf(stderr, "Error: unable to import " #symb " from libbinder_ndk.so\n");	\
+				exit(ELIBACC);									\
+			}											\
+		} while (0)
+	X(AIBinder_Class_define);
+	X(AIBinder_associateClass);
+	X(AIBinder_decStrong);
+	X(AIBinder_prepareTransaction);
+	X(AIBinder_transact);
+	X(AIBinder_ping);
+	X(AIBinder_dump);
+	X(AParcel_readStatusHeader);
+	X(AParcel_readBool);
+	X(AParcel_delete);
+	X(AParcel_setDataPosition);
+	X(AParcel_getDataPosition);
+	X(AParcel_writeInt32);
+	X(AParcel_writeStringArray);
+	X(AParcel_writeString);
+	X(AStatus_isOk);
+	X(AStatus_delete);
+	X(AStatus_getExceptionCode);
+	X(AStatus_getServiceSpecificError);
+	X(AStatus_getMessage);
+	X(AStatus_getStatus);
+	X(AServiceManager_getService);
+#undef X
+}
+
+static void cleanup_binder(AIBinder **binder)
+{
+	AIBinder_decStrong(*binder);
+}
+static void cleanup_status(AStatus **status)
+{
+	AStatus_delete(*status);
+}
+static void cleanup_parcel(AParcel **parcel)
+{
+	AParcel_delete(*parcel);
+}
+
+#define _cleanup_status_ __attribute__((__cleanup__(cleanup_status)))
+#define _cleanup_parcel_ __attribute__((__cleanup__(cleanup_parcel)))
+#define _cleanup_binder_ __attribute__((__cleanup__(cleanup_binder)))
+
+static int32_t string_size(const char *str)
+{
+	return str ? strlen(str) : -1;
+}
+
+static int32_t string_array_size(char *const *array)
+{
+	int32_t size = -1;
+	if (!array)
+		return size;
+	for (size = 0; array[size]; ++size);
+	return size;
+}
+
+static const char *string_array_getter(const void *array_data, size_t index, int32_t *outlength)
+{
+	const char **array = (const char **)array_data;
+	*outlength = array[index] ? strlen(array[index]) : -1;
+	return array[index];
+}
+
+static binder_status_t meaningful_binder_status(const AStatus *status_out)
+{
+	binder_status_t status = STATUS_OK;
+	binder_exception_t exc_code;
+	int32_t exc_code_service;
+	const char *message;
+
+	if (!AStatus_isOk(status_out)) {
+		exc_code = AStatus_getExceptionCode(status_out);
+		if (exc_code == EX_TRANSACTION_FAILED) {
+			status = AStatus_getStatus(status_out);
+			fprintf(stderr, "Error: transaction failed: %d\n", status);
+		}
+		else {
+			message = AStatus_getMessage(status_out);
+
+			if (exc_code == EX_SERVICE_SPECIFIC) {
+				exc_code_service = AStatus_getServiceSpecificError(status_out);
+				fprintf(stderr, "Error: service specific exception code: %d%s%s\n", exc_code_service, message ? ": " : "", message ?: "");
+			}
+			else
+				fprintf(stderr, "Error: exception code: %d%s%s\n", exc_code, message ? ": " : "", message ?: "");
+
+			status = STATUS_FAILED_TRANSACTION;
+		}
+	}
+
+	return status;
+}
+
+/* These values are default values observed in AOSP. */
+enum {
+	DNSRESOLVER_SAMPLE_VALIDITY = 1800 /* sec */,
+	DNSRESOLVER_SUCCESS_THRESHOLD = 25,
+	DNSRESOLVER_MIN_SAMPLES = 8,
+	DNSRESOLVER_MAX_SAMPLES = 8,
+	DNSRESOLVER_BASE_TIMEOUT = 5000 /* msec */,
+	DNSRESOLVER_RETRY_COUNT = 2
+};
+
+struct dnsresolver_params {
+	int32_t netid;
+	int32_t sample_validity_seconds;
+	int32_t success_threshold;
+	int32_t min_samples;
+	int32_t max_samples;
+	int32_t base_timeout_msec;
+	int32_t retry_count;
+	char **servers;          /* NULL terminated array of zero-terminated UTF-8 strings */
+	char **domains;          /* NULL terminated array of zero-terminated UTF-8 strings */
+	char *tls_name;          /* zero-terminated UTF-8 string													 */
+	char **tls_servers;      /* NULL terminated array of zero-terminated UTF-8 strings */
+	char **tls_fingerprints; /* NULL terminated array of zero-terminated UTF-8 strings */
+};
+
+static void *on_create()
+{
+	fprintf(stderr, "Error: on_create called on proxy object\n");
+	exit(ENOTSUP);
+	return NULL;
+}
+
+static void on_destroy()
+{
+	fprintf(stderr, "Error: on_destroy called on proxy object\n");
+	exit(ENOTSUP);
+}
+
+static binder_status_t on_transact()
+{
+	fprintf(stderr, "Error: on_transact called on a proxy object\n");
+	exit(ENOTSUP);
+	return 0;
+}
+
+static AIBinder *dnsresolver_get_handle(void)
+{
+	AIBinder *binder;
+	AIBinder_Class *clazz;
+
+	if (!binder_available)
+		return NULL;
+
+	binder = AServiceManager_getService("dnsresolver");
+	if (!binder)
+		return NULL;
+	clazz = AIBinder_Class_define("android.net.IDnsResolver", &on_create, &on_destroy, &on_transact);
+	if (!clazz)
+		goto error;
+
+	if (!AIBinder_associateClass(binder, clazz))
+		goto error;
+
+	return binder;
+error:
+	AIBinder_decStrong(binder);
+	return NULL;
+}
+
+static int32_t dnsresolver_create_network_cache(void *handle, int32_t netid)
+{
+	AIBinder *const binder = handle;
+	binder_status_t status;
+	_cleanup_parcel_ AParcel *parcel_in = NULL;
+	_cleanup_parcel_ AParcel *parcel_out = NULL;
+	_cleanup_status_ AStatus *status_out = NULL;
+
+	status = AIBinder_prepareTransaction(binder, &parcel_in);
+	if (status != STATUS_OK)
+		return status;
+
+	status = AParcel_writeInt32(parcel_in, netid);
+	if (status != STATUS_OK)
+		return status;
+
+	status = AIBinder_transact(binder, FIRST_CALL_TRANSACTION + 7 /* createNetworkCache */, &parcel_in, &parcel_out, 0);
+	if (status != STATUS_OK)
+		return status;
+
+	status = AParcel_readStatusHeader(parcel_out, &status_out);
+	if (status != STATUS_OK)
+		return status;
+
+	if (!AStatus_isOk(status_out))
+		return meaningful_binder_status(status_out);
+
+	return STATUS_OK;
+}
+
+static int32_t dnsresolver_set_resolver_configuration(void *handle, const struct dnsresolver_params *params)
+{
+	AIBinder *const binder = handle;
+	binder_status_t status;
+	_cleanup_parcel_ AParcel *parcel_in = NULL;
+	_cleanup_parcel_ AParcel *parcel_out = NULL;
+	_cleanup_status_ AStatus *status_out = NULL;
+	int32_t start_position, end_position;
+
+	status = AIBinder_prepareTransaction(binder, &parcel_in);
+	if (status != STATUS_OK)
+		return status;
+
+	status = AParcel_writeInt32(parcel_in, 1);
+	if (status != STATUS_OK)
+		return status;
+
+	start_position = AParcel_getDataPosition(parcel_in);
+	status = AParcel_writeInt32(parcel_in, 0);
+	if (status != STATUS_OK)
+		return status;
+
+	status = AParcel_writeInt32(parcel_in, params->netid);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeInt32(parcel_in, params->sample_validity_seconds);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeInt32(parcel_in, params->success_threshold);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeInt32(parcel_in, params->min_samples);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeInt32(parcel_in, params->max_samples);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeInt32(parcel_in, params->base_timeout_msec);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeInt32(parcel_in, params->retry_count);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeStringArray(parcel_in, params->servers, string_array_size(params->servers), &string_array_getter);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeStringArray(parcel_in, params->domains, string_array_size(params->domains), &string_array_getter);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeString(parcel_in, params->tls_name, string_size(params->tls_name));
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeStringArray(parcel_in, params->tls_servers, string_array_size(params->tls_servers), &string_array_getter);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeStringArray(parcel_in, params->tls_fingerprints, string_array_size(params->tls_fingerprints), &string_array_getter);
+	if (status != STATUS_OK)
+		return status;
+
+	end_position = AParcel_getDataPosition(parcel_in);
+	status = AParcel_setDataPosition(parcel_in, start_position);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_writeInt32(parcel_in, end_position - start_position);
+	if (status != STATUS_OK)
+		return status;
+	status = AParcel_setDataPosition(parcel_in, end_position);
+	if (status != STATUS_OK)
+		return status;
+
+	status = AIBinder_transact(binder, FIRST_CALL_TRANSACTION + 2 /* setResolverConfiguration */, &parcel_in, &parcel_out, 0);
+	if (status != STATUS_OK)
+		return status;
+
+	status = AParcel_readStatusHeader(parcel_out, &status_out);
+	if (status != STATUS_OK)
+		return status;
+
+	return meaningful_binder_status(status_out);
+}
+
 static void auto_su(int argc, char *argv[])
 {
 	char *args[argc + 4];
@@ -440,22 +809,75 @@ static void set_dnses(unsigned int netid, const char *dnses)
 	if (len > (1<<16))
 		return;
 	_cleanup_free_ char *mutable = xstrdup(dnses);
-	_cleanup_free_ char *arglist = xmalloc(len * 4 + 1);
+	_cleanup_free_ char *shell_arglist = xmalloc(len * 4 + 1);
+	_cleanup_free_ char *function_arglist = xmalloc(len * 4 + 1);
 	_cleanup_free_ char *arg = xmalloc(len + 4);
+	_cleanup_free_ char **dns_list = NULL;
+	_cleanup_binder_ AIBinder *handle = NULL;
+	size_t dns_list_size = 0;
 
 	if (!len)
 		return;
-	arglist[0] = '\0';
+	for (char *dns = strtok(mutable, ", \t\n"); dns; dns = strtok(NULL, ", \t\n")) {
+		if (strchr(dns, '\'') || strchr(dns, '\\'))
+			continue;
+		++dns_list_size;
+	}
+	if (!dns_list_size)
+		return;
+	dns_list = xcalloc(dns_list_size + 1, sizeof(*dns_list));
+	free(mutable);
+	mutable = xstrdup(dnses);
 
+	shell_arglist[0] = '\0';
+	function_arglist[0] = '\0';
+	dns_list_size = 0;
 	for (char *dns = strtok(mutable, ", \t\n"); dns; dns = strtok(NULL, ", \t\n")) {
 		if (strchr(dns, '\'') || strchr(dns, '\\'))
 			continue;
 		snprintf(arg, len + 3, "'%s' ", dns);
-		strncat(arglist, arg, len * 4 - 1);
+		strncat(shell_arglist, arg, len * 4 - 1);
+		snprintf(arg, len + 2, function_arglist[0] == '\0' ? "%s" : ", %s", dns);
+		strncat(function_arglist, arg, len * 4 - 1);
+		dns_list[dns_list_size++] = dns;
 	}
-	if (!strlen(arglist))
-		return;
-	cndc("resolver setnetdns %u '' %s", netid, arglist);
+
+	if ((handle = dnsresolver_get_handle())) {
+		binder_status_t status;
+
+		printf("[#] <binder>::dnsResolver->createNetworkCache(%u)\n", netid);
+		status = dnsresolver_create_network_cache(handle, netid);
+		if (status != 0) {
+			fprintf(stderr, "Error: unable to create network cache\n");
+			exit(ENONET);
+		}
+
+		struct dnsresolver_params params = {
+			.netid = netid,
+			.sample_validity_seconds = DNSRESOLVER_SAMPLE_VALIDITY,
+			.success_threshold = DNSRESOLVER_SUCCESS_THRESHOLD,
+			.min_samples = DNSRESOLVER_MIN_SAMPLES,
+			.max_samples = DNSRESOLVER_MAX_SAMPLES,
+			.base_timeout_msec = DNSRESOLVER_BASE_TIMEOUT,
+			.retry_count = DNSRESOLVER_RETRY_COUNT,
+			.servers = dns_list,
+			.domains = (char *[]){NULL},
+			.tls_name = "",
+			.tls_servers = (char *[]){NULL},
+			.tls_fingerprints = (char *[]){NULL}
+		};
+
+		printf("[#] <binder>::dnsResolver->setResolverConfiguration(%u, [%s], [], %d, %d, %d, %d, %d, %d, [], [])\n",
+		       netid, function_arglist, DNSRESOLVER_SAMPLE_VALIDITY, DNSRESOLVER_SUCCESS_THRESHOLD,
+		       DNSRESOLVER_MIN_SAMPLES, DNSRESOLVER_MAX_SAMPLES, DNSRESOLVER_BASE_TIMEOUT, DNSRESOLVER_RETRY_COUNT);
+		status = dnsresolver_set_resolver_configuration(handle, &params);
+
+		if (status != 0) {
+			fprintf(stderr, "Error: unable to set DNS servers through Binder: %d\n", status);
+			exit(ENONET);
+		}
+	} else
+		cndc("resolver setnetdns %u '' %s", netid, shell_arglist);
 }
 
 static void add_addr(const char *iface, const char *addr)
@@ -662,8 +1084,8 @@ static void cmd_up(const char *iface, const char *config, unsigned int mtu, cons
 	add_if(iface);
 	set_config(iface, config);
 	listen_port = determine_listen_port(iface);
-	set_addr(iface, addrs);
 	up_if(&netid, iface, listen_port);
+	set_addr(iface, addrs);
 	set_dnses(netid, dnses);
 	set_routes(iface, netid);
 	set_mtu(iface, mtu);

commit 959937672ae1fb3dc6af1ae2edfbb2ae0894f41f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Aug 30 13:51:27 2019 -0600

    wg: windows: enforce named pipe ownership and use protected prefix
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index e0be413..89484b1 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -96,7 +96,7 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 }
 
 #ifndef WINCOMPAT
-static FILE *userspace_interface_file(const char *interface)
+static FILE *userspace_interface_file(const char *iface)
 {
 	struct stat sbuf;
 	struct sockaddr_un addr = { .sun_family = AF_UNIX };
@@ -104,9 +104,9 @@ static FILE *userspace_interface_file(const char *interface)
 	FILE *f = NULL;
 
 	errno = EINVAL;
-	if (strchr(interface, '/'))
+	if (strchr(iface, '/'))
 		goto out;
-	ret = snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, interface);
+	ret = snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, iface);
 	if (ret < 0)
 		goto out;
 	ret = stat(addr.sun_path, &sbuf);
@@ -140,15 +140,15 @@ out:
 	return f;
 }
 
-static bool userspace_has_wireguard_interface(const char *interface)
+static bool userspace_has_wireguard_interface(const char *iface)
 {
 	struct stat sbuf;
 	struct sockaddr_un addr = { .sun_family = AF_UNIX };
 	int fd, ret;
 
-	if (strchr(interface, '/'))
+	if (strchr(iface, '/'))
 		return false;
-	if (snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, interface) < 0)
+	if (snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, iface) < 0)
 		return false;
 	if (stat(addr.sun_path, &sbuf) < 0)
 		return false;
@@ -288,7 +288,7 @@ static int userspace_set_device(struct wgdevice *dev)
 	num; \
 })
 
-static int userspace_get_device(struct wgdevice **out, const char *interface)
+static int userspace_get_device(struct wgdevice **out, const char *iface)
 {
 	struct wgdevice *dev;
 	struct wgpeer *peer = NULL;
@@ -302,14 +302,14 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 	if (!dev)
 		return -errno;
 
-	f = userspace_interface_file(interface);
+	f = userspace_interface_file(iface);
 	if (!f)
 		return -errno;
 
 	fprintf(f, "get=1\n\n");
 	fflush(f);
 
-	strncpy(dev->name, interface, IFNAMSIZ - 1);
+	strncpy(dev->name, iface, IFNAMSIZ - 1);
 	dev->name[IFNAMSIZ - 1] = '\0';
 
 	while (getline(&key, &line_buffer_len, f) > 0) {
@@ -889,7 +889,7 @@ static void coalesce_peers(struct wgdevice *device)
 	}
 }
 
-static int kernel_get_device(struct wgdevice **device, const char *interface)
+static int kernel_get_device(struct wgdevice **device, const char *iface)
 {
 	int ret = 0;
 	struct nlmsghdr *nlh;
@@ -908,7 +908,7 @@ try_again:
 	}
 
 	nlh = mnlg_msg_prepare(nlg, WG_CMD_GET_DEVICE, NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP);
-	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, interface);
+	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, iface);
 	if (mnlg_socket_send(nlg, nlh) < 0) {
 		ret = -errno;
 		goto out;
@@ -963,14 +963,14 @@ cleanup:
 	return buffer.buffer;
 }
 
-int ipc_get_device(struct wgdevice **dev, const char *interface)
+int ipc_get_device(struct wgdevice **dev, const char *iface)
 {
 #ifdef __linux__
-	if (userspace_has_wireguard_interface(interface))
-		return userspace_get_device(dev, interface);
-	return kernel_get_device(dev, interface);
+	if (userspace_has_wireguard_interface(iface))
+		return userspace_get_device(dev, iface);
+	return kernel_get_device(dev, iface);
 #else
-	return userspace_get_device(dev, interface);
+	return userspace_get_device(dev, iface);
 #endif
 }
 
diff --git a/src/wincompat/ipc.c b/src/wincompat/ipc.c
index a7a59f8..25471b0 100644
--- a/src/wincompat/ipc.c
+++ b/src/wincompat/ipc.c
@@ -5,18 +5,23 @@
 
 #include <windows.h>
 #include <tlhelp32.h>
+#include <accctrl.h>
+#include <aclapi.h>
 #include <stdio.h>
 #include <stdbool.h>
 #include <fcntl.h>
 
-static FILE *userspace_interface_file(const char *interface)
+static FILE *userspace_interface_file(const char *iface)
 {
 	char fname[MAX_PATH], error_message[1024 * 128] = { 0 };
 	HANDLE thread_token, process_snapshot, winlogon_process, winlogon_token, duplicated_token, pipe_handle = INVALID_HANDLE_VALUE;
 	PROCESSENTRY32 entry = { .dwSize = sizeof(PROCESSENTRY32) };
+	PSECURITY_DESCRIPTOR pipe_sd;
+	PSID pipe_sid;
+	SID expected_sid;
 	BOOL ret;
 	int fd;
-	DWORD last_error = ERROR_SUCCESS;
+	DWORD last_error = ERROR_SUCCESS, bytes = sizeof(expected_sid);
 	TOKEN_PRIVILEGES privileges = {
 		.PrivilegeCount = 1,
 		.Privileges = {{ .Attributes = SE_PRIVILEGE_ENABLED }}
@@ -24,6 +29,8 @@ static FILE *userspace_interface_file(const char *interface)
 
 	if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &privileges.Privileges[0].Luid))
 		goto err;
+	if (!CreateWellKnownSid(WinLocalSystemSid, NULL, &expected_sid, &bytes))
+		goto err;
 
 	process_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
 	if (process_snapshot == INVALID_HANDLE_VALUE)
@@ -63,13 +70,24 @@ static FILE *userspace_interface_file(const char *interface)
 		}
 		CloseHandle(duplicated_token);
 
-		snprintf(fname, sizeof(fname), "\\\\.\\pipe\\WireGuard\\%s", interface);
+		snprintf(fname, sizeof(fname), "\\\\.\\pipe\\ProtectedPrefix\\Administrators\\WireGuard\\%s", iface);
 		pipe_handle = CreateFile(fname, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
 		last_error = GetLastError();
-		if (pipe_handle != INVALID_HANDLE_VALUE) {
-			last_error = ERROR_SUCCESS;
-			break;
+		if (pipe_handle == INVALID_HANDLE_VALUE)
+			continue;
+		last_error = GetSecurityInfo(pipe_handle, SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, &pipe_sid, NULL, NULL, NULL, &pipe_sd);
+		if (last_error != ERROR_SUCCESS) {
+			CloseHandle(pipe_handle);
+			continue;
+		}
+		last_error = EqualSid(&expected_sid, pipe_sid) ? ERROR_SUCCESS : ERROR_ACCESS_DENIED;
+		LocalFree(pipe_sd);
+		if (last_error != ERROR_SUCCESS) {
+			CloseHandle(pipe_handle);
+			continue;
 		}
+		last_error = ERROR_SUCCESS;
+		break;
 	}
 	RevertToSelf();
 	CloseHandle(process_snapshot);

commit 4154476d89b66006ad28c6d2971de5c8aba7d527
Author: Ronan Pigott <rpigott@berkeley.edu>
Date:   Tue Aug 27 18:42:14 2019 -0700

    wg-quick: linux: don't fail down when using systemd-resolved
    
    systemd-resolved has a compatibility interface for use with resolvconf
    scripts when resolvectl is called from a symlink from resolvconf.
    However, when tearing down the interface, cmd_down calls del_if and then
    unset_dns. In the case of systemd-resolved, deleting the interface also
    removes the systemd-resolved entry and causes resolvconf -d to fail when
    resolvconf really is a symlink to resolvectl. This causes `wg-quick
    down` and 'wg-quick@.service' to exit with failure.
    
    Instead we use the resolvconf '-f' flag to ignore non-existent
    interfaces, supported by both openresolv and sd-resolved resolvconf.
    
    Signed-off-by: Ronan Pigott <rpigott@berkeley.edu>
    [zx2c4: moved -f argument to end to remain compatible with Debian's resolvconf]
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 2f36dee..e690944 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -155,7 +155,7 @@ set_dns() {
 
 unset_dns() {
 	[[ ${#DNS[@]} -gt 0 ]] || return 0
-	cmd resolvconf -d "$(resolvconf_iface_prefix)$INTERFACE"
+	cmd resolvconf -d "$(resolvconf_iface_prefix)$INTERFACE" -f
 }
 
 add_route() {

commit 5df58a945d839991dd270e3d5d4d853dc1c50f6f
Author: Ankur Kothari <ankur@lipidity.com>
Date:   Tue Aug 6 08:57:28 2019 +1000

    wg-quick: openbsd: fix alternate routing table syntax
    
    route(8) has always used the `-T` option to specify the
    routing table; there is no `rdomain` option.
    
    Signed-off-by: Ankur Kothari <ankur@lipidity.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index b234609..2cadeec 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -293,7 +293,7 @@ add_route() {
 	fi
 
 	if [[ -n $TABLE && $TABLE != auto ]]; then
-		cmd route -q -n add "-$family" -rdomain "$TABLE" "$1" -iface "$ifaceroute"
+		cmd route -q -n -T "$TABLE" add "-$family" "$1" -iface "$ifaceroute"
 	elif [[ $1 == */0 ]]; then
 		if [[ $1 == *:* ]]; then
 			AUTO_ROUTE6=1

commit 6a5906608ca81b5610a9a56e40284149030dc75e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jul 8 12:56:41 2019 +0200

    wg-quick: android: refactor and add incoming allow rules
    
    Suggested-by: Yamur Oymak <yagmur.oymak@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 5eec36f..e8ea4b4 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -263,30 +263,84 @@ static void add_if(const char *iface)
 
 static void del_if(const char *iface)
 {
-	DEFINE_CMD(c);
-	_cleanup_regfree_ regex_t reg = { 0 };
+	DEFINE_CMD(c_rule);
+	DEFINE_CMD(c_iptables);
+	DEFINE_CMD(c_ip6tables);
+	_cleanup_regfree_ regex_t rule_reg = { 0 }, iptables_reg = { 0 };
 	regmatch_t matches[2];
 	char *netid = NULL;
-	_cleanup_free_ char *regex = concat("0xc([0-9a-f]+)/0xcffff lookup ", iface, NULL);
+	_cleanup_free_ char *rule_regex = concat("0xc([0-9a-f]+)/0xcffff lookup ", iface, NULL);
+	_cleanup_free_ char *iptables_regex = concat("^-A (.* --comment \"wireguard rule ", iface, "\"[^\n]*)\n*$", NULL);
 
-	xregcomp(&reg, regex, REG_EXTENDED);
+	xregcomp(&rule_reg, rule_regex, REG_EXTENDED);
+	xregcomp(&iptables_reg, iptables_regex, REG_EXTENDED);
 
-	cmd("iptables -D OUTPUT -m mark --mark 0x20000 -j ACCEPT -m comment --comment \"wireguard rule %s\"", iface);
-	cmd("ip6tables -D OUTPUT -m mark --mark 0x20000 -j ACCEPT -m comment --comment \"wireguard rule %s\"", iface);
 	cmd("ip link del %s", iface);
-	for (char *ret = cmd_ret(&c, "ip rule show"); ret; ret = cmd_ret(&c, NULL)) {
-		if (!regexec(&reg, ret, ARRAY_SIZE(matches), matches, 0)) {
-			ret[matches[1].rm_eo] = '\0';
-			netid = &ret[matches[1].rm_so];
-			break;
+
+	for (char *rule = cmd_ret(&c_iptables, "iptables-save"); rule; rule = cmd_ret(&c_iptables, NULL)) {
+		if (!regexec(&iptables_reg, rule, ARRAY_SIZE(matches), matches, 0)) {
+			rule[matches[1].rm_eo] = '\0';
+			cmd("iptables -D %s", &rule[matches[1].rm_so]);
+		}
+	}
+	for (char *rule = cmd_ret(&c_ip6tables, "ip6tables-save"); rule; rule = cmd_ret(&c_ip6tables, NULL)) {
+		if (!regexec(&iptables_reg, rule, ARRAY_SIZE(matches), matches, 0)) {
+			rule[matches[1].rm_eo] = '\0';
+			cmd("ip6tables -D %s", &rule[matches[1].rm_so]);
 		}
 	}
 
+	for (char *rule = cmd_ret(&c_rule, "ip rule show"); rule; rule = cmd_ret(&c_rule, NULL)) {
+		if (!regexec(&rule_reg, rule, ARRAY_SIZE(matches), matches, 0)) {
+			rule[matches[1].rm_eo] = '\0';
+			netid = &rule[matches[1].rm_so];
+			break;
+		}
+	}
 	if (netid)
 		cndc("network destroy %lu", strtoul(netid, NULL, 16));
 }
 
-static void up_if(unsigned int *netid, const char *iface)
+static bool should_block_ipv6(const char *iface)
+{
+	DEFINE_CMD(c);
+	bool has_ipv6 = false, has_all_none = true;
+
+	for (char *endpoint = cmd_ret(&c, "wg show %s endpoints", iface); endpoint; endpoint = cmd_ret(&c, NULL)) {
+		char *start = strchr(endpoint, '\t');
+
+		if (!start)
+			continue;
+		++start;
+		if (start[0] != '(')
+			has_all_none = false;
+		if (start[0] == '[')
+			has_ipv6 = true;
+	}
+	return !has_ipv6 && !has_all_none;
+}
+
+static uint16_t determine_listen_port(const char *iface)
+{
+	DEFINE_CMD(c);
+	unsigned long listen_port = 0;
+	char *value;
+
+	cmd("ip link set up dev %s", iface);
+	value = cmd_ret(&c, "wg show %s listen-port", iface);
+	if (!value)
+		goto set_back_down;
+	listen_port = strtoul(value, NULL, 10);
+	if (listen_port > UINT16_MAX || !listen_port) {
+		listen_port = 0;
+		goto set_back_down;
+	}
+set_back_down:
+	cmd("ip link set down dev %s", iface);
+	return listen_port;
+}
+
+static void up_if(unsigned int *netid, const char *iface, uint16_t listen_port)
 {
 	srandom(time(NULL) ^ getpid()); /* Not real randomness. */
 
@@ -296,6 +350,10 @@ static void up_if(unsigned int *netid, const char *iface)
 	cmd("wg set %s fwmark 0x20000", iface);
 	cmd("iptables -I OUTPUT 1 -m mark --mark 0x20000 -j ACCEPT -m comment --comment \"wireguard rule %s\"", iface);
 	cmd("ip6tables -I OUTPUT 1 -m mark --mark 0x20000 -j ACCEPT -m comment --comment \"wireguard rule %s\"", iface);
+	if (listen_port) {
+		cmd("iptables -I INPUT 1 -p udp --dport %u -j ACCEPT -m comment --comment \"wireguard rule %s\"", listen_port, iface);
+		cmd("ip6tables -I INPUT 1 -p udp --dport %u -j %s -m comment --comment \"wireguard rule %s\"", listen_port, should_block_ipv6(iface) ? "DROP" : "ACCEPT", iface);
+	}
 	cndc("interface setcfg %s up", iface);
 	cndc("network create %u vpn 1 1", *netid);
 	cndc("network interface add %u %s", *netid, iface);
@@ -520,56 +578,6 @@ static void set_routes(const char *iface, unsigned int netid)
 	}
 }
 
-static void maybe_block_ipv6(const char *iface)
-{
-	DEFINE_CMD(c_endpoints);
-	DEFINE_CMD(c_listenport);
-	bool has_ipv6 = false, has_all_none = true;
-	char *value;
-	unsigned long listenport;
-
-	for (char *endpoint = cmd_ret(&c_endpoints, "wg show %s endpoints", iface); endpoint; endpoint = cmd_ret(&c_endpoints, NULL)) {
-		char *start = strchr(endpoint, '\t');
-
-		if (!start)
-			continue;
-		++start;
-		if (start[0] != '(')
-			has_all_none = false;
-		if (start[0] == '[')
-			has_ipv6 = true;
-	}
-	if (has_ipv6 || has_all_none)
-		return;
-
-	cmd("ip link set up dev %s", iface);
-	value = cmd_ret(&c_listenport, "wg show %s listen-port", iface);
-	if (!value)
-		goto set_back_down;
-	listenport = strtoul(value, NULL, 10);
-	if (listenport > UINT16_MAX || !listenport)
-		goto set_back_down;
-	cmd("ip6tables -I INPUT 1 -p udp --dport %lu -j DROP -m comment --comment \"wireguard rule %s\"", listenport, iface);
-set_back_down:
-	cmd("ip link set down dev %s", iface);
-}
-
-static void maybe_unblock_ipv6(const char *iface)
-{
-	regmatch_t matches[2];
-	_cleanup_regfree_ regex_t reg = { 0 };
-	_cleanup_free_ char *regex = concat("^-A (.* --comment \"wireguard rule ", iface, "\"[^\n]*)\n*$", NULL);
-	DEFINE_CMD(c);
-
-	xregcomp(&reg, regex, REG_EXTENDED);
-	for (char *rule = cmd_ret(&c, "ip6tables-save"); rule; rule = cmd_ret(&c, NULL)) {
-		if (!regexec(&reg, rule, ARRAY_SIZE(matches), matches, 0)) {
-			rule[matches[1].rm_eo] = '\0';
-			cmd("ip6tables -D %s", &rule[matches[1].rm_so]);
-		}
-	}
-}
-
 static void set_config(const char *iface, const char *config)
 {
 	FILE *config_writer;
@@ -641,6 +649,7 @@ static void cmd_up(const char *iface, const char *config, unsigned int mtu, cons
 {
 	DEFINE_CMD(c);
 	unsigned int netid = 0;
+	uint16_t listen_port;
 
 	if (cmd_ret(&c, "ip link show dev %s 2>/dev/null", iface)) {
 		fprintf(stderr, "Error: %s already exists\n", iface);
@@ -652,9 +661,9 @@ static void cmd_up(const char *iface, const char *config, unsigned int mtu, cons
 
 	add_if(iface);
 	set_config(iface, config);
-	maybe_block_ipv6(iface);
+	listen_port = determine_listen_port(iface);
 	set_addr(iface, addrs);
-	up_if(&netid, iface);
+	up_if(&netid, iface, listen_port);
 	set_dnses(netid, dnses);
 	set_routes(iface, netid);
 	set_mtu(iface, mtu);
@@ -686,7 +695,6 @@ static void cmd_down(const char *iface)
 	}
 
 	del_if(iface);
-	maybe_unblock_ipv6(iface);
 	broadcast_change();
 	exit(EXIT_SUCCESS);
 }

commit b30e74b5956ac770dec5c98d6324b41b6e022d98
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jun 19 13:18:34 2019 +0200

    wg-quick: darwin: support being called from launchd
    
    This causes wg-quick up to wait for the monitor to exit before it exits,
    so that launchd can correctly wait on it.
    
    Reported-by: Cameron Palmer <cameron@promon.no>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/launchd/README b/contrib/launchd/README
new file mode 100644
index 0000000..67f8d3c
--- /dev/null
+++ b/contrib/launchd/README
@@ -0,0 +1,12 @@
+WireGuard for Launchd
+=====================
+
+The example `com.wireguard.wg0.plist` file may be used for running wg-quick(8)
+as a launchd service. Note that the `PATH` variable is modified to point to
+the PATH used by Homebrew or Macports, so that it uses the non-system bash(1).
+
+Usage
+-----
+
+$ sudo cp com.wireguard.wg0.plist /Library/LaunchDaemons
+$ sudo launchctl load /Library/LaunchDaemons/com.wireguard.wg0.plist
diff --git a/contrib/launchd/com.wireguard.wg0.plist b/contrib/launchd/com.wireguard.wg0.plist
new file mode 100644
index 0000000..9fc0141
--- /dev/null
+++ b/contrib/launchd/com.wireguard.wg0.plist
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd";>
+<plist version="1.0">
+<dict>
+  <key>Label</key>
+  <string>com.wireguard.wg0</string>
+  <key>ProgramArguments</key>
+  <array>
+    <string>/usr/local/bin/wg-quick</string>
+    <string>up</string>
+    <string>/usr/local/etc/wireguard/wg0.conf</string>
+  </array>
+  <key>OnDemand</key>
+  <false/>
+  <key>RunAtLoad</key>
+  <true/>
+  <key>TimeOut</key>
+  <integer>90</integer>
+  <key>EnvironmentVariables</key>
+  <dict>
+    <key>PATH</key>
+    <string>/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>
+  </dict>
+</dict>
+</plist>
diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index a2b3789..d5dd396 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -81,6 +81,17 @@ parse_options() {
 	shopt -u nocasematch
 }
 
+detect_launchd() {
+	unset LAUNCHED_BY_LAUNCHD
+	local line
+	while read -r line; do
+		if [[ $line =~ ^\s*domain\ =\  ]]; then
+			LAUNCHED_BY_LAUNCHD=1
+			break
+		fi
+	done < <(launchctl procinfo $$ 2>/dev/null)
+}
+
 read_bool() {
 	case "$2" in
 	true) printf -v "$1" 1 ;;
@@ -308,7 +319,8 @@ monitor_daemon() {
 			set_dns
 			sleep 2 && kill -ALRM $pid 2>/dev/null &
 		fi
-	done < <(route -n monitor)) & disown
+	done < <(route -n monitor)) &
+	[[ -n $LAUNCHED_BY_LAUNCHD ]] || disown
 }
 
 add_route() {
@@ -463,6 +475,7 @@ if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
 	cmd_usage
 elif [[ $# -eq 2 && $1 == up ]]; then
 	auto_su
+	detect_launchd
 	parse_options "$2"
 	cmd_up
 elif [[ $# -eq 2 && $1 == down ]]; then
@@ -482,4 +495,6 @@ else
 	exit 1
 fi
 
+[[ -n $LAUNCHED_BY_LAUNCHD ]] && wait
+
 exit 0

commit 15f2e2ef345b2a13d975d1163b7ea8e55eaae187
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 31 21:10:41 2019 +0200

    wg: pass WG_ENDPOINT_RESOLUTION_RETRIES=infinity to systemd unit
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/systemd/wg-quick@.service b/src/systemd/wg-quick@.service
index 9c67af9..af52848 100644
--- a/src/systemd/wg-quick@.service
+++ b/src/systemd/wg-quick@.service
@@ -14,6 +14,7 @@ Type=oneshot
 RemainAfterExit=yes
 ExecStart=/usr/bin/wg-quick up %i
 ExecStop=/usr/bin/wg-quick down %i
+Environment=WG_ENDPOINT_RESOLUTION_RETRIES=infinity
 
 [Install]
 WantedBy=multi-user.target

commit 838039b8793ece67a2b9d5d93ec2b745027831d4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat May 11 19:34:19 2019 +0200

    wg: add wincompat layer to wg(8)
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 0eecc57..e342779 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -54,6 +54,12 @@ endif
 ifeq ($(PLATFORM),haiku)
 LDLIBS += -lnetwork -lbsd
 endif
+ifeq ($(PLATFORM),windows)
+CC := x86_64-w64-mingw32-gcc
+CFLAGS += -Iwincompat/include -include wincompat/compat.h
+LDLIBS += -lws2_32
+wg: wincompat/libc.o wincompat/init.o
+endif
 
 ifneq ($(V),1)
 BUILT_IN_LINK.o := $(LINK.o)
diff --git a/src/genkey.c b/src/genkey.c
index 21d2f7a..b9c2a86 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -28,6 +28,7 @@
 #include "encoding.h"
 #include "subcommands.h"
 
+#ifndef WINCOMPAT
 static inline bool __attribute__((__warn_unused_result__)) get_random_bytes(uint8_t *out, size_t len)
 {
 	ssize_t ret = 0;
@@ -63,6 +64,9 @@ static inline bool __attribute__((__warn_unused_result__)) get_random_bytes(uint
 	errno = -ret;
 	return i == len;
 }
+#else
+#include "wincompat/getrandom.c"
+#endif
 
 int genkey_main(int argc, char *argv[])
 {
diff --git a/src/ipc.c b/src/ipc.c
index 7ab3a62..e0be413 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -95,6 +95,7 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
+#ifndef WINCOMPAT
 static FILE *userspace_interface_file(const char *interface)
 {
 	struct stat sbuf;
@@ -197,6 +198,9 @@ out:
 	closedir(dir);
 	return ret;
 }
+#else
+#include "wincompat/ipc.c"
+#endif
 
 static int userspace_set_device(struct wgdevice *dev)
 {
diff --git a/src/wincompat/compat.h b/src/wincompat/compat.h
new file mode 100644
index 0000000..4dada77
--- /dev/null
+++ b/src/wincompat/compat.h
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#define __USE_MINGW_ANSI_STDIO 1
+#include <stdio.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <winsock2.h>
+#include <ws2ipdef.h>
+#include <ws2tcpip.h>
+#include <in6addr.h>
+#include <windows.h>
+
+#undef interface
+#undef min
+#undef max
+
+#define WINCOMPAT
+
+#define IFNAMSIZ 64
+#define EAI_SYSTEM -99
+
+/* libc.c */
+char *strsep(char **str, const char *sep);
+ssize_t getdelim(char **buf, size_t *bufsiz, int delimiter, FILE *fp);
+ssize_t getline(char **buf, size_t *bufsiz, FILE *fp);
+int inet_pton(int af, const char *src, void *dst);
+const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
diff --git a/src/wincompat/getrandom.c b/src/wincompat/getrandom.c
new file mode 100644
index 0000000..4e2c4bd
--- /dev/null
+++ b/src/wincompat/getrandom.c
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdbool.h>
+#include <ntsecapi.h>
+
+static inline bool __attribute__((__warn_unused_result__)) get_random_bytes(uint8_t *out, size_t len)
+{
+	return RtlGenRandom(out, len);
+}
diff --git a/src/wincompat/include/arpa/inet.h b/src/wincompat/include/arpa/inet.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/wincompat/include/net/if.h b/src/wincompat/include/net/if.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/wincompat/include/netdb.h b/src/wincompat/include/netdb.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/wincompat/include/netinet/in.h b/src/wincompat/include/netinet/in.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/wincompat/include/sys/ioctl.h b/src/wincompat/include/sys/ioctl.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/wincompat/include/sys/socket.h b/src/wincompat/include/sys/socket.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/wincompat/include/sys/un.h b/src/wincompat/include/sys/un.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/wincompat/init.c b/src/wincompat/init.c
new file mode 100644
index 0000000..8d862ff
--- /dev/null
+++ b/src/wincompat/init.c
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <winsock2.h>
+#include <windows.h>
+
+#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
+#define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x4
+#endif
+
+__attribute__((constructor)) static void init(void)
+{
+	char *colormode;
+	DWORD console_mode;
+	HANDLE stdout_handle;
+	WSADATA wsaData;
+	WSAStartup(MAKEWORD(2, 2), &wsaData);
+
+	stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE); // We don't close this.
+	if (stdout_handle == INVALID_HANDLE_VALUE)
+		goto no_color;
+	if (!GetConsoleMode(stdout_handle, &console_mode))
+		goto no_color;
+	if (!SetConsoleMode(stdout_handle, ENABLE_VIRTUAL_TERMINAL_PROCESSING | console_mode))
+		goto no_color;
+	return;
+
+no_color:
+	colormode = getenv("WG_COLOR_MODE");
+	if (!colormode)
+		putenv("WG_COLOR_MODE=never");
+}
+
+__attribute__((destructor)) static void deinit(void)
+{
+	WSACleanup();
+}
diff --git a/src/wincompat/ipc.c b/src/wincompat/ipc.c
new file mode 100644
index 0000000..a7a59f8
--- /dev/null
+++ b/src/wincompat/ipc.c
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <windows.h>
+#include <tlhelp32.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <fcntl.h>
+
+static FILE *userspace_interface_file(const char *interface)
+{
+	char fname[MAX_PATH], error_message[1024 * 128] = { 0 };
+	HANDLE thread_token, process_snapshot, winlogon_process, winlogon_token, duplicated_token, pipe_handle = INVALID_HANDLE_VALUE;
+	PROCESSENTRY32 entry = { .dwSize = sizeof(PROCESSENTRY32) };
+	BOOL ret;
+	int fd;
+	DWORD last_error = ERROR_SUCCESS;
+	TOKEN_PRIVILEGES privileges = {
+		.PrivilegeCount = 1,
+		.Privileges = {{ .Attributes = SE_PRIVILEGE_ENABLED }}
+	};
+
+	if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &privileges.Privileges[0].Luid))
+		goto err;
+
+	process_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+	if (process_snapshot == INVALID_HANDLE_VALUE)
+		goto err;
+	for (ret = Process32First(process_snapshot, &entry); ret; last_error = GetLastError(), ret = Process32Next(process_snapshot, &entry)) {
+		if (strcasecmp(entry.szExeFile, "winlogon.exe"))
+			continue;
+
+		RevertToSelf();
+		if (!ImpersonateSelf(SecurityImpersonation))
+			continue;
+		if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES, FALSE, &thread_token))
+			continue;
+		if (!AdjustTokenPrivileges(thread_token, FALSE, &privileges, sizeof(privileges), NULL, NULL)) {
+			last_error = GetLastError();
+			CloseHandle(thread_token);
+			continue;
+		}
+		CloseHandle(thread_token);
+
+		winlogon_process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, entry.th32ProcessID);
+		if (!winlogon_process)
+			continue;
+		if (!OpenProcessToken(winlogon_process, TOKEN_IMPERSONATE | TOKEN_DUPLICATE, &winlogon_token))
+			continue;
+		CloseHandle(winlogon_process);
+		if (!DuplicateToken(winlogon_token, SecurityImpersonation, &duplicated_token)) {
+			last_error = GetLastError();
+			RevertToSelf();
+			continue;
+		}
+		CloseHandle(winlogon_token);
+		if (!SetThreadToken(NULL, duplicated_token)) {
+			last_error = GetLastError();
+			CloseHandle(duplicated_token);
+			continue;
+		}
+		CloseHandle(duplicated_token);
+
+		snprintf(fname, sizeof(fname), "\\\\.\\pipe\\WireGuard\\%s", interface);
+		pipe_handle = CreateFile(fname, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
+		last_error = GetLastError();
+		if (pipe_handle != INVALID_HANDLE_VALUE) {
+			last_error = ERROR_SUCCESS;
+			break;
+		}
+	}
+	RevertToSelf();
+	CloseHandle(process_snapshot);
+
+	if (last_error != ERROR_SUCCESS || pipe_handle == INVALID_HANDLE_VALUE)
+		goto err;
+	fd = _open_osfhandle((intptr_t)pipe_handle, _O_RDWR);
+	if (fd == -1) {
+		last_error = GetLastError();
+		CloseHandle(pipe_handle);
+		goto err;
+	}
+	return _fdopen(fd, "r+");
+
+err:
+	if (last_error == ERROR_SUCCESS)
+		last_error = GetLastError();
+	if (last_error == ERROR_SUCCESS)
+		last_error = ERROR_ACCESS_DENIED;
+	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, last_error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), error_message, sizeof(error_message) - 1, NULL);
+	fprintf(stderr, "Error: Unable to open IPC handle via SYSTEM impersonation: %ld: %s\n", last_error, error_message);
+	errno = EACCES;
+	return NULL;
+}
+
+static int userspace_get_wireguard_interfaces(struct inflatable_buffer *buffer)
+{
+	WIN32_FIND_DATA find_data;
+	HANDLE find_handle;
+	int ret = 0;
+
+	find_handle = FindFirstFile("\\\\.\\pipe\\*", &find_data);
+	if (find_handle == INVALID_HANDLE_VALUE)
+		return -GetLastError();
+	do {
+		if (strncmp("WireGuard\\", find_data.cFileName, 10))
+			continue;
+		buffer->next = strdup(find_data.cFileName + 10);
+		buffer->good = true;
+		ret = add_next_to_inflatable_buffer(buffer);
+		if (ret < 0)
+			goto out;
+	} while (FindNextFile(find_handle, &find_data));
+
+out:
+	FindClose(find_handle);
+	return ret;
+}
diff --git a/src/wincompat/libc.c b/src/wincompat/libc.c
new file mode 100644
index 0000000..ad30278
--- /dev/null
+++ b/src/wincompat/libc.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <windows.h>
+
+char *strsep(char **str, const char *sep)
+{
+	char *s = *str, *end;
+	if (!s)
+		return NULL;
+	end = s + strcspn(s, sep);
+	if (*end)
+		*end++ = 0;
+	else
+		end = 0;
+	*str = end;
+	return s;
+}
+
+ssize_t getdelim(char **buf, size_t *bufsiz, int delimiter, FILE *fp)
+{
+	char *ptr, *eptr;
+
+	if (!*buf || !*bufsiz) {
+		*bufsiz = BUFSIZ;
+		if (!(*buf = malloc(*bufsiz)))
+			return -1;
+	}
+
+	for (ptr = *buf, eptr = *buf + *bufsiz;;) {
+		int c = fgetc(fp);
+		if (c == -1) {
+			if (feof(fp)) {
+				ssize_t diff = (ssize_t)(ptr - *buf);
+				if (diff != 0) {
+					*ptr = '\0';
+					return diff;
+				}
+			}
+			return -1;
+		}
+		*ptr++ = c;
+		if (c == delimiter) {
+			*ptr = '\0';
+			return ptr - *buf;
+		}
+		if (ptr + 2 >= eptr) {
+			char *nbuf;
+			size_t nbufsiz = *bufsiz * 2;
+			ssize_t d = ptr - *buf;
+			if ((nbuf = realloc(*buf, nbufsiz)) == NULL)
+				return -1;
+			*buf = nbuf;
+			*bufsiz = nbufsiz;
+			eptr = nbuf + nbufsiz;
+			ptr = nbuf + d;
+		}
+	}
+}
+
+ssize_t getline(char **buf, size_t *bufsiz, FILE *fp)
+{
+	return getdelim(buf, bufsiz, '\n', fp);
+}
+
+int inet_pton(int af, const char *src, void *dst)
+{
+	struct sockaddr_storage ss = { 0 };
+	int size = sizeof(ss);
+	char s[INET6_ADDRSTRLEN + 1];
+
+	strncpy(s, src, INET6_ADDRSTRLEN + 1);
+	s[INET6_ADDRSTRLEN] = '\0';
+
+	if (WSAStringToAddress(s, af, NULL, (struct sockaddr *)&ss, &size))
+		return 0;
+	if (af == AF_INET)
+		*(struct in_addr *)dst = ((struct sockaddr_in *)&ss)->sin_addr;
+	else if (af == AF_INET6)
+		*(struct in6_addr *)dst = ((struct sockaddr_in6 *)&ss)->sin6_addr;
+	else
+		return 0;
+	return 1;
+}
+
+const char *inet_ntop(int af, const void *src, char *dst, socklen_t size)
+{
+	struct sockaddr_storage ss = { .ss_family = af };
+	unsigned long s = size;
+
+	if (af == AF_INET)
+		((struct sockaddr_in *)&ss)->sin_addr = *(struct in_addr *)src;
+	else if (af == AF_INET6)
+		((struct sockaddr_in6 *)&ss)->sin6_addr = *(struct in6_addr *)src;
+	else
+		return NULL;
+	return WSAAddressToString((struct sockaddr *)&ss, sizeof(ss), NULL, dst, &s) ? NULL : dst;
+}

commit 10487e7215c48ebc11dab4d838791739e81dadd0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 28 22:45:15 2019 +0200

    wg: allow setting WG_ENDPOINT_RESOLUTION_RETRIES
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index d510ea7..db90228 100644
--- a/src/config.c
+++ b/src/config.c
@@ -174,11 +174,29 @@ static inline bool parse_ip(struct wgallowedip *allowedip, const char *value)
 	return true;
 }
 
+static inline int parse_dns_retries(void)
+{
+	unsigned long ret;
+	char *retries = getenv("WG_ENDPOINT_RESOLUTION_RETRIES"), *end;
+
+	if (!retries)
+		return 15;
+	if (!strcmp(retries, "infinity"))
+		return -1;
+
+	ret = strtoul(retries, &end, 10);
+	if (*end || ret > INT_MAX) {
+		fprintf(stderr, "Unable to parse WG_ENDPOINT_RESOLUTION_RETRIES: `%s'\n", retries);
+		exit(1);
+	}
+	return (int)ret;
+}
+
 static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 {
 	char *mutable = strdup(value);
 	char *begin, *end;
-	int ret;
+	int ret, retries = parse_dns_retries();
 	struct addrinfo *resolved;
 	struct addrinfo hints = {
 		.ai_family = AF_UNSPEC,
@@ -219,11 +237,11 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 		*end++ = '\0';
 	}
 
-	for (unsigned int timeout = 1000000;;) {
+	#define min(a, b) ((a) < (b) ? (a) : (b))
+	for (unsigned int timeout = 1000000;; timeout = min(20000000, timeout * 6 / 5)) {
 		ret = getaddrinfo(begin, end, &hints, &resolved);
 		if (!ret)
 			break;
-		timeout = timeout * 3 / 2;
 		/* The set of return codes that are "permanent failures". All other possibilities are potentially transient.
 		 *
 		 * This is according to https://sourceware.org/glibc/wiki/NameResolver which states:
@@ -238,7 +256,7 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 			#ifdef EAI_NODATA
 				ret == EAI_NODATA ||
 			#endif
-				timeout >= 90000000) {
+				(retries >= 0 && !retries--)) {
 			free(mutable);
 			fprintf(stderr, "%s: `%s'\n", ret == EAI_SYSTEM ? strerror(errno) : gai_strerror(ret), value);
 			return false;
diff --git a/src/man/wg.8 b/src/man/wg.8
index 2013825..afff749 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -211,6 +211,9 @@ If set to \fIalways\fP, always print ANSI colorized output. If set to \fInever\f
 .TP
 .I WG_HIDE_KEYS
 If set to \fInever\fP, then the pretty-printing \fBshow\fP sub-command will show private and preshared keys in the output. If set to \fIalways\fP, something invalid, or unset, then private and preshared keys will be printed as "(hidden)".
+.TP
+.I WG_ENDPOINT_RESOLUTION_RETRIES
+If set to an integer or to \fIinfinity\fP, DNS resolution for each peer's endpoint will be retried that many times for non-permanent errors, with an increasing delay between retries. If unset, the default is 15 retries.
 
 .SH SEE ALSO
 .BR ip (8),

commit 604b5a9fa7d2d1a77f7647198ab04a54b5e04ab5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 17 17:30:38 2019 +0200

    wg-quick: specify protocol to ip(8), because of inconsistencies
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 8f1812c..2f36dee 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -113,7 +113,9 @@ del_if() {
 }
 
 add_addr() {
-	cmd ip address add "$1" dev "$INTERFACE"
+	local proto=-4
+	[[ $1 == *:* ]] && proto=-6
+	cmd ip $proto address add "$1" dev "$INTERFACE"
 }
 
 set_mtu_up() {
@@ -157,14 +159,16 @@ unset_dns() {
 }
 
 add_route() {
+	local proto=-4
+	[[ $1 == *:* ]] && proto=-6
 	[[ $TABLE != off ]] || return 0
 
 	if [[ -n $TABLE && $TABLE != auto ]]; then
-		cmd ip route add "$1" dev "$INTERFACE" table "$TABLE"
+		cmd ip $proto route add "$1" dev "$INTERFACE" table "$TABLE"
 	elif [[ $1 == */0 ]]; then
 		add_default "$1"
 	else
-		[[ -n $(ip route show dev "$INTERFACE" match "$1" 2>/dev/null) ]] || cmd ip route add "$1" dev "$INTERFACE"
+		[[ -n $(ip $proto route show dev "$INTERFACE" match "$1" 2>/dev/null) ]] || cmd ip $proto route add "$1" dev "$INTERFACE"
 	fi
 }
 

commit ce55f857ffff12a57d072991a0ec6625829f614f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 17 12:32:46 2019 +0200

    wg-quick: look up existing routes properly
    
    This was never really correct, and then 5.1 broke it entirely.
    
    Reported-by: piraty1@inbox.ru
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 5eaa504..8f1812c 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -164,7 +164,7 @@ add_route() {
 	elif [[ $1 == */0 ]]; then
 		add_default "$1"
 	else
-		[[ $(ip route get "$1" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || cmd ip route add "$1" dev "$INTERFACE"
+		[[ -n $(ip route show dev "$INTERFACE" match "$1" 2>/dev/null) ]] || cmd ip route add "$1" dev "$INTERFACE"
 	fi
 }
 

commit c2355e00aabcec110b5e48b54c44e6720984f764
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Apr 23 18:16:16 2019 +0900

    wg-quick: make darwin and freebsd path search strict like linux
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index aa3edeb..a2b3789 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -47,7 +47,8 @@ parse_options() {
 	CONFIG_FILE="$1"
 	if [[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]]; then
 		for path in "${CONFIG_SEARCH_PATHS[@]}"; do
-			[[ -e $path/$CONFIG_FILE.conf ]] && { CONFIG_FILE="$path/$CONFIG_FILE.conf"; break; }
+			CONFIG_FILE="$path/$1.conf"
+			[[ -e $CONFIG_FILE ]] && break
 		done
 	fi
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index 72e0bd0..a72353c 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -64,7 +64,8 @@ parse_options() {
 	CONFIG_FILE="$1"
 	if [[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]]; then
 		for path in "${CONFIG_SEARCH_PATHS[@]}"; do
-			[[ -e $path/$CONFIG_FILE.conf ]] && { CONFIG_FILE="$path/$CONFIG_FILE.conf"; break; }
+			CONFIG_FILE="$path/$1.conf"
+			[[ -e $CONFIG_FILE ]] && break
 		done
 	fi
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"

commit 090639ae90fb45ac05e3158e1e31e5bf15fd9559
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 21 10:11:36 2019 +0900

    wg-quick: freebsd: workaround SIOCGIFSTATUS race in FreeBSD kernel
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index 9d3a402..72e0bd0 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -137,18 +137,30 @@ del_routes() {
 	done
 }
 
+if_exists() {
+	# HACK: The goal is simply to determine whether or not the interface exists. The
+	# straight-forward way of doing this would be `ifconfig $INTERFACE`, but this
+	# invokes the SIOCGIFSTATUS ioctl, which races with interface shutdown inside
+	# the tun driver, resulting in a kernel panic. So we work around it the stupid
+	# way by using the one utility that appears to call if_nametoindex fairly early
+	# and fails if it doesn't exist: `arp`.
+	if arp -i "$INTERFACE" -a -n >/dev/null 2>&1; then
+		return 0
+	else
+		return 1
+	fi
+}
+
 del_if() {
-	local line monitor_pid
 	[[ $HAVE_SET_DNS -eq 0 ]] || unset_dns
-	exec 39< <(exec route -n monitor 2>/dev/null)
-	monitor_pid=$!
 	cmd rm -f "/var/run/wireguard/$INTERFACE.sock"
-	while ifconfig "$INTERFACE" >/dev/null 2>&1; do
-		while read -r line; do
-			[[ $line =~ ^RTM_IFANNOUNCE:.* ]] && break
-		done <&39
+	while if_exists; do
+		# HACK: it would be nice to `route monitor` here and wait for RTM_IFANNOUNCE
+		# but it turns out that the announcement is made before the interface
+		# disappears so we sometimes get a hang. So, we're instead left with polling
+		# in a sleep loop like this.
+		sleep 0.1
 	done
-	kill $monitor_pid
 }
 
 up_if() {
@@ -274,7 +286,8 @@ monitor_daemon() {
 	# endpoints change.
 	while read -r event; do
 		[[ $event == RTM_* ]] || continue
-		ifconfig "$INTERFACE" >/dev/null 2>&1 || break
+		[[ -e /var/run/wireguard/$INTERFACE.sock ]] || break
+		if_exists || break
 		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
 		# TODO: set the mtu as well, but only if up
 	done < <(route -n monitor)) & disown

commit 4471ee711ceb9ffa595ffdc76061a2a2dc030edc
Author: Luis Ressel <aranea@aixah.de>
Date:   Sat Mar 23 01:31:19 2019 +0100

    wg: avoid unneccessary next_peer assignments in sort_peers()
    
    Signed-off-by: Luis Ressel <aranea@aixah.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/show.c b/src/show.c
index 4cc34ab..ff0897d 100644
--- a/src/show.c
+++ b/src/show.c
@@ -60,11 +60,10 @@ static void sort_peers(struct wgdevice *device)
 		peers[i++] = peer;
 	qsort(peers, peer_count, sizeof(*peers), peer_cmp);
 	device->first_peer = peers[0];
-	peers[0]->next_peer = NULL;
 	for (i = 1; i < peer_count; ++i) {
 		peers[i - 1]->next_peer = peers[i];
-		peers[i]->next_peer = NULL;
 	}
+	peers[peer_count - 1]->next_peer = NULL;
 	free(peers);
 }
 

commit cdb687cc0bcaed3f4f6bba4ad884eac64e9e5cf2
Author: Luis Ressel <aranea@aixah.de>
Date:   Thu Mar 14 00:36:22 2019 +0100

    wg-quick: add 'strip' subcommand
    
    `wg-quick strip` prints the config file to stdout after stripping it of
    all wg-quick-specific options.
    
    This enables tricks such as `wg addconf $DEV <(wg-quick strip $DEV)`.
    
    Signed-off-by: Luis Ressel <aranea@aixah.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg-quick.8 b/src/man/wg-quick.8
index 00d7dba..6250adc 100644
--- a/src/man/wg-quick.8
+++ b/src/man/wg-quick.8
@@ -11,6 +11,8 @@ wg-quick - set up a WireGuard interface simply
 .I down
 |
 .I save
+|
+.I strip
 ] [
 .I CONFIG_FILE
 |
@@ -27,7 +29,11 @@ an interface. Running \fIup\fP adds a WireGuard interface, brings up the interfa
 supplied IP addresses, sets up mtu and routes, and optionally runs pre/post up scripts. Running \fIdown\fP
 optionally saves the current configuration, removes the WireGuard interface, and optionally
 runs pre/post down scripts. Running \fIsave\fP saves the configuration of an existing
-interface without bringing the interface down.
+interface without bringing the interface down. Use \fIstrip\fP to output a configuration file
+with all
+.BR wg-quick (8)-specific
+options removed, suitable for use with
+.BR wg (8).
 
 \fICONFIG_FILE\fP is a configuration file, whose filename is the interface name
 followed by `.conf'. Otherwise, \fIINTERFACE\fP is an interface name, with configuration
@@ -243,6 +249,13 @@ For convenience, if only an interface name is supplied, it automatically chooses
 
 This will load the configuration file `/etc/wireguard/wgnet0.conf'.
 
+The \fIstrip\fP command is useful for reloading configuration files without disrupting active
+sessions:
+
+\fB    # wg addconf wgnet0 <(wg-quick strip wgnet0)\fP
+
+(Note that the above command will add and update peers but will not remove peers.)
+
 .SH SEE ALSO
 .BR wg (8),
 .BR ip (8),
diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index bf07fdb..aa3edeb 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -385,7 +385,7 @@ execute_hooks() {
 
 cmd_usage() {
 	cat >&2 <<-_EOF
-	Usage: $PROGRAM [ up | down | save ] [ CONFIG_FILE | INTERFACE ]
+	Usage: $PROGRAM [ up | down | save | strip ] [ CONFIG_FILE | INTERFACE ]
 
 	  CONFIG_FILE is a configuration file, whose filename is the interface name
 	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
@@ -452,6 +452,10 @@ cmd_save() {
 	save_config
 }
 
+cmd_strip() {
+	echo "$WG_CONFIG"
+}
+
 # ~~ function override insertion point ~~
 
 if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
@@ -468,6 +472,10 @@ elif [[ $# -eq 2 && $1 == save ]]; then
 	auto_su
 	parse_options "$2"
 	cmd_save
+elif [[ $# -eq 2 && $1 == strip ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_strip
 else
 	cmd_usage
 	exit 1
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index c3fa47a..9d3a402 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -368,7 +368,7 @@ execute_hooks() {
 
 cmd_usage() {
 	cat >&2 <<-_EOF
-	Usage: $PROGRAM [ up | down | save ] [ CONFIG_FILE | INTERFACE ]
+	Usage: $PROGRAM [ up | down | save | strip ] [ CONFIG_FILE | INTERFACE ]
 
 	  CONFIG_FILE is a configuration file, whose filename is the interface name
 	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
@@ -431,6 +431,10 @@ cmd_save() {
 	save_config
 }
 
+cmd_strip() {
+	echo "$WG_CONFIG"
+}
+
 # ~~ function override insertion point ~~
 
 make_temp
@@ -450,6 +454,10 @@ elif [[ $# -eq 2 && $1 == save ]]; then
 	auto_su
 	parse_options "$2"
 	cmd_save
+elif [[ $# -eq 2 && $1 == strip ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_strip
 else
 	cmd_usage
 	exit 1
diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 84643c4..5eaa504 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -247,7 +247,7 @@ execute_hooks() {
 
 cmd_usage() {
 	cat >&2 <<-_EOF
-	Usage: $PROGRAM [ up | down | save ] [ CONFIG_FILE | INTERFACE ]
+	Usage: $PROGRAM [ up | down | save | strip ] [ CONFIG_FILE | INTERFACE ]
 
 	  CONFIG_FILE is a configuration file, whose filename is the interface name
 	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
@@ -305,6 +305,10 @@ cmd_save() {
 	save_config
 }
 
+cmd_strip() {
+	echo "$WG_CONFIG"
+}
+
 # ~~ function override insertion point ~~
 
 if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
@@ -321,6 +325,10 @@ elif [[ $# -eq 2 && $1 == save ]]; then
 	auto_su
 	parse_options "$2"
 	cmd_save
+elif [[ $# -eq 2 && $1 == strip ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_strip
 else
 	cmd_usage
 	exit 1
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index 9996162..b234609 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -361,7 +361,7 @@ execute_hooks() {
 
 cmd_usage() {
 	cat >&2 <<-_EOF
-	Usage: $PROGRAM [ up | down | save ] [ CONFIG_FILE | INTERFACE ]
+	Usage: $PROGRAM [ up | down | save | strip ] [ CONFIG_FILE | INTERFACE ]
 
 	  CONFIG_FILE is a configuration file, whose filename is the interface name
 	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
@@ -426,6 +426,10 @@ cmd_save() {
 	save_config
 }
 
+cmd_strip() {
+	echo "$WG_CONFIG"
+}
+
 # ~~ function override insertion point ~~
 
 if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
@@ -442,6 +446,10 @@ elif [[ $# -eq 2 && $1 == save ]]; then
 	auto_su
 	parse_options "$2"
 	cmd_save
+elif [[ $# -eq 2 && $1 == strip ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_strip
 else
 	cmd_usage
 	exit 1

commit 84cf22da0d11719eea9d82ada9978d8fc19712ee
Author: Luis Ressel <aranea@aixah.de>
Date:   Sun Mar 17 00:02:32 2019 +0100

    wg: warn if an AllowedIP has a nonzero host part
    
    Signed-off-by: Luis Ressel <aranea@aixah.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 5d15356..d510ea7 100644
--- a/src/config.c
+++ b/src/config.c
@@ -287,6 +287,37 @@ err:
 	return false;
 }
 
+static bool validate_netmask(struct wgallowedip *allowedip)
+{
+	uint32_t *ip;
+	int last;
+
+	switch (allowedip->family) {
+		case AF_INET:
+			last = 0;
+			ip = (uint32_t *)&allowedip->ip4;
+			break;
+		case AF_INET6:
+			last = 3;
+			ip = (uint32_t *)&allowedip->ip6;
+			break;
+		default:
+			return true; /* We don't know how to validate it, so say 'okay'. */
+	}
+
+	for (int i = last; i >= 0; --i) {
+		uint32_t mask = ~0;
+
+		if (allowedip->cidr >= 32 * (i + 1))
+			break;
+		if (allowedip->cidr > 32 * i)
+			mask >>= (allowedip->cidr - 32 * i);
+		if (ntohl(ip[i]) & mask)
+			return false;
+	}
+
+	return true;
+}
 
 static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **last_allowedip, const char *value)
 {
@@ -339,6 +370,9 @@ static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **la
 			goto err;
 		new_allowedip->cidr = cidr;
 
+		if (!validate_netmask(new_allowedip))
+			fprintf(stderr, "Warning: AllowedIP has nonzero host part: %s/%s\n", ip, mask);
+
 		if (allowedip)
 			allowedip->next_allowedip = new_allowedip;
 		else

commit 7c20ac5ce255fe17616a5622cbebdc1d0e571439
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Mar 18 14:41:10 2019 -0600

    wg-quick: freebsd: export TMPDIR when restoring and don't make empty
    
    Otherwise mktemp doesn't see it, and if it's empty we wind up in /.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index e83dbef..c3fa47a 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -42,8 +42,9 @@ unset ORIGINAL_TMPDIR
 make_temp() {
 	local old_umask
 
-	[[ -v ORIGINAL_TMPDIR ]] && TMPDIR="$ORIGINAL_TMPDIR"
+	[[ -v ORIGINAL_TMPDIR ]] && export TMPDIR="$ORIGINAL_TMPDIR"
 	ORIGINAL_TMPDIR="$TMPDIR"
+	[[ -z $TMPDIR ]] && unset TMPDIR
 
 	old_umask="$(umask)"
 	umask 077

commit fc719b7d7ed3abf2b2ed495195584d90eb62e983
Author: Alexander von Gluck IV <kallisti5@unixzen.com>
Date:   Thu Feb 28 10:23:45 2019 -0600

    wg: add support for Haiku
    
    Signed-off-by: Alexander von Gluck IV <kallisti5@unixzen.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index f2904f2..0eecc57 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -51,6 +51,9 @@ LIBMNL_LDLIBS := $(shell $(PKG_CONFIG) --libs libmnl 2>/dev/null || echo -lmnl)
 CFLAGS += $(LIBMNL_CFLAGS)
 LDLIBS += $(LIBMNL_LDLIBS)
 endif
+ifeq ($(PLATFORM),haiku)
+LDLIBS += -lnetwork -lbsd
+endif
 
 ifneq ($(V),1)
 BUILT_IN_LINK.o := $(LINK.o)

commit 74a6f97b7ae3efec010148ed990880400c27c722
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Feb 28 23:37:24 2019 +0100

    wg: genkey: account for short reads of /dev/urandom
    
    Apparently Haiku has a misbehaving /dev/urandom.
    
    While we're at it, simplify the function signature to completely succeed
    or completely fail and make sure the caller checks the result.
    
    Reported-by: Alexander von Gluck IV <kallisti5@unixzen.com>
    Nitpicked-by: Aaron Jones <aaronmdjones@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index 51da8ec..54b8700 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -1751,16 +1751,21 @@ void wg_generate_private_key(wg_key private_key)
 void wg_generate_preshared_key(wg_key preshared_key)
 {
 	ssize_t ret;
+	size_t i;
 	int fd;
-
-#if defined(__NR_getrandom)
-	ret = syscall(__NR_getrandom, preshared_key, sizeof(wg_key), 0);
-	if (ret == sizeof(wg_key))
+#if defined(__OpenBSD__) || (defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_12) || (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 25)))
+	if (!getentropy(preshared_key, sizeof(wg_key)))
+		return;
+#endif
+#if defined(__NR_getrandom) && defined(__linux__)
+	if (syscall(__NR_getrandom, preshared_key, sizeof(wg_key), 0) == sizeof(wg_key))
 		return;
 #endif
 	fd = open("/dev/urandom", O_RDONLY);
 	assert(fd >= 0);
-	ret = read(fd, preshared_key, sizeof(wg_key));
+	for (i = 0; i < sizeof(wg_key); i += ret) {
+		ret = read(fd, preshared_key + i, sizeof(wg_key) - i);
+		assert(ret > 0);
+	}
 	close(fd);
-	assert(ret == sizeof(wg_key));
 }
diff --git a/src/genkey.c b/src/genkey.c
index 645f614..21d2f7a 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -5,6 +5,7 @@
 
 #include <errno.h>
 #include <stdio.h>
+#include <stdbool.h>
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -27,29 +28,40 @@
 #include "encoding.h"
 #include "subcommands.h"
 
-static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
+static inline bool __attribute__((__warn_unused_result__)) get_random_bytes(uint8_t *out, size_t len)
 {
-	ssize_t ret;
+	ssize_t ret = 0;
+	size_t i;
 	int fd;
 
+	if (len > 256) {
+		errno = EOVERFLOW;
+		return false;
+	}
+
 #if defined(__OpenBSD__) || (defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_12) || (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 25)))
-	ret = getentropy(out, len);
-	if (!ret)
-		return len;
+	if (!getentropy(out, len))
+		return true;
 #endif
 
 #if defined(__NR_getrandom) && defined(__linux__)
-	ret = syscall(__NR_getrandom, out, len, 0);
-	if (ret >= 0)
-		return ret;
+	if (syscall(__NR_getrandom, out, len, 0) == (ssize_t)len)
+		return true;
 #endif
 
 	fd = open("/dev/urandom", O_RDONLY);
 	if (fd < 0)
-		return fd;
-	ret = read(fd, out, len);
+		return false;
+	for (errno = 0, i = 0; i < len; i += ret, ret = 0) {
+		ret = read(fd, out + i, len - i);
+		if (ret <= 0) {
+			ret = errno ? -errno : -EIO;
+			break;
+		}
+	}
 	close(fd);
-	return ret;
+	errno = -ret;
+	return i == len;
 }
 
 int genkey_main(int argc, char *argv[])
@@ -66,7 +78,7 @@ int genkey_main(int argc, char *argv[])
 	if (!fstat(STDOUT_FILENO, &stat) && S_ISREG(stat.st_mode) && stat.st_mode & S_IRWXO)
 		fputs("Warning: writing to world accessible file.\nConsider setting the umask to 077 and trying again.\n", stderr);
 
-	if (get_random_bytes(key, WG_KEY_LEN) != WG_KEY_LEN) {
+	if (!get_random_bytes(key, WG_KEY_LEN)) {
 		perror("getrandom");
 		return 1;
 	}

commit 2c6cabd73dfb23990c245250ef2e502bdb33d189
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Feb 28 19:03:11 2019 +0100

    wg-quick: freebsd: rebreak interface loopback, while fixing localhost
    
    The commit 7c833642 ("wg-quick: freebsd: allow loopback to work") was
    supposed to make things better, but actually it just started sending
    legitimate localhost traffic over the WireGuard interface, which is
    really quite bad.
    
    This reverts commit 7c833642dfa342218602ab18e7091e86408d2982.
    
    Reported-by: Matt Smith <matt.xtaz@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index 93f1a3b..e83dbef 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -158,7 +158,7 @@ add_addr() {
 	if [[ $1 == *:* ]]; then
 		cmd ifconfig "$INTERFACE" inet6 "$1" alias
 	else
-		cmd ifconfig "$INTERFACE" inet "$1" 127.0.0.1 alias
+		cmd ifconfig "$INTERFACE" inet "$1" "${1%%/*}" alias
 	fi
 }
 

commit 86e0c306b8eafcea33e58013ef478ab207d59f00
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Feb 8 02:32:15 2019 +0100

    wg: c_acc doesn't need to be initialized
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/encoding.c b/src/encoding.c
index bf5fd54..af2fc82 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -84,7 +84,7 @@ void key_to_hex(char hex[static WG_KEY_LEN_HEX], const uint8_t key[static WG_KEY
 
 bool key_from_hex(uint8_t key[static WG_KEY_LEN], const char *hex)
 {
-	uint8_t c, c_acc = 0, c_alpha0, c_alpha, c_num0, c_num, c_val;
+	uint8_t c, c_acc, c_alpha0, c_alpha, c_num0, c_num, c_val;
 	volatile uint8_t ret = 0;
 
 	if (strlen(hex) != WG_KEY_LEN_HEX - 1)

commit 8ba549859092de652ebfa67cdc6bcfce5a2d1f0c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Feb 5 01:00:52 2019 +0100

    wg: fight compiler slightly harder
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 648daed..c116e21 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -72,7 +72,7 @@ static inline void put_unaligned_le64(u64 s, u8 *d)
 static noinline void memzero_explicit(void *s, size_t count)
 {
 	memset(s, 0, count);
-	asm volatile("": :"r"(s) :"memory");
+	asm volatile("": :"r"(s) : "memory");
 }
 
 #ifdef __SIZEOF_INT128__
diff --git a/src/encoding.c b/src/encoding.c
index efe004f..bf5fd54 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -119,7 +119,7 @@ bool key_is_zero(const uint8_t key[static WG_KEY_LEN])
 
 	for (unsigned int i = 0; i < WG_KEY_LEN; ++i) {
 		acc |= key[i];
-		asm("" : "=r" (acc) : "0" (acc));
+		asm volatile("" : "=r"(acc) : "0"(acc));
 	}
 	return 1 & ((acc - 1) >> 8);
 }

commit 17281d9369b2b684e88b2982e6f756aa9760df72
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Feb 3 21:50:54 2019 +0100

    noise: store clamped key instead of raw key
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 0d52bc8..648daed 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -68,7 +68,6 @@ static inline void put_unaligned_le64(u64 s, u8 *d)
 #ifndef __force
 #define __force
 #endif
-#define clamp_secret(a) curve25519_clamp_secret(a)
 
 static noinline void memzero_explicit(void *s, size_t count)
 {
diff --git a/src/curve25519.h b/src/curve25519.h
index badcda0..c047019 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -10,7 +10,7 @@
 #include <sys/types.h>
 
 enum curve25519_lengths {
-	CURVE25519_KEY_SIZE = 32,
+	CURVE25519_KEY_SIZE = 32
 };
 
 void curve25519(uint8_t mypublic[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE], const uint8_t basepoint[static CURVE25519_KEY_SIZE]);
@@ -18,8 +18,7 @@ void curve25519_generate_public(uint8_t pub[static CURVE25519_KEY_SIZE], const u
 static inline void curve25519_clamp_secret(uint8_t secret[static CURVE25519_KEY_SIZE])
 {
 	secret[0] &= 248;
-	secret[31] &= 127;
-	secret[31] |= 64;
+	secret[31] = (secret[31] & 127) | 64;
 }
 
 #endif

commit 1e58a0525edd39f18c6ebdae3e021a18ed98ba59
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 31 02:03:10 2019 +0100

    highlighter: when subtracting char, cast to unsigned
    
    Windows.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/highlighter/highlighter.c b/contrib/highlighter/highlighter.c
index 171a84c..1913e35 100644
--- a/contrib/highlighter/highlighter.c
+++ b/contrib/highlighter/highlighter.c
@@ -166,9 +166,9 @@ static bool is_valid_uint(string_span_t s, bool support_hex, uint64_t min, uint6
 
 	if (support_hex && s.len > 2 && s.s[0] == '0' && s.s[1] == 'x') {
 		for (size_t i = 2; i < s.len; ++i) {
-			if (s.s[i] - '0' < 10)
+			if ((unsigned)s.s[i] - '0' < 10)
 				val = 16 * val + (s.s[i] - '0');
-			else if ((s.s[i] | 32) - 'a' < 6)
+			else if (((unsigned)s.s[i] | 32) - 'a' < 6)
 				val = 16 * val + (s.s[i] | 32) - 'a' + 10;
 			else
 				return false;

commit 4bc6ef00898e3c5fb1e9f4ddc5f71006e0045a7d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 30 18:53:37 2019 +0100

    systemd: wg-quick should depend on nss-lookup.target
    
    Since wg-quick(8) calls wg(8) which does hostname lookups, we should
    probably only run this after we're allowed to look up hostnames.
    
    Reported-by: Anton Castelli <anton.c42@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/systemd/wg-quick@.service b/src/systemd/wg-quick@.service
index da5d787..9c67af9 100644
--- a/src/systemd/wg-quick@.service
+++ b/src/systemd/wg-quick@.service
@@ -1,7 +1,7 @@
 [Unit]
 Description=WireGuard via wg-quick(8) for %I
-After=network-online.target
-Wants=network-online.target
+After=network-online.target nss-lookup.target
+Wants=network-online.target nss-lookup.target
 Documentation=man:wg-quick(8)
 Documentation=man:wg(8)
 Documentation=https://www.wireguard.com/

commit 643a002603f7899903006cf9bb368c4ae85fd4c8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 24 18:14:38 2019 +0100

    wg: remove unused check phony declaration
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 483b703..f2904f2 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -89,6 +89,6 @@ install: wg
 help:
 	@cat INSTALL
 
-.PHONY: clean install check help
+.PHONY: clean install help
 
 -include *.d

commit 3f7a31faea0654a4b4333d47f338151558eced00
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 24 03:26:51 2019 +0100

    wg-quick: freebsd: allow loopback to work
    
    FreeBSD adds a route for point-to-point destination addresses. We don't
    really want to specify any destination address, but unfortunately we
    have to. Before we tried to cheat by giving our own address as the
    destination, but this had the unfortunate effect of preventing
    loopback from working on our local ip address. We work around this with
    yet another kludge: we set the destination address to 127.0.0.1. Since
    127.0.0.1 is already assigned to an interface, this has the same effect
    of not specifying a destination address, and therefore we accomplish the
    intended behavior.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index e83dbef..93f1a3b 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -158,7 +158,7 @@ add_addr() {
 	if [[ $1 == *:* ]]; then
 		cmd ifconfig "$INTERFACE" inet6 "$1" alias
 	else
-		cmd ifconfig "$INTERFACE" inet "$1" "${1%%/*}" alias
+		cmd ifconfig "$INTERFACE" inet "$1" 127.0.0.1 alias
 	fi
 }
 

commit a6e4ec487debf11785b3f82a8c821ae9b7356024
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 22 13:38:52 2019 +0100

    netlink: use __kernel_timespec for handshake time
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.h b/contrib/embeddable-wg-library/wireguard.h
index 9ebe47c..e7a1bbf 100644
--- a/contrib/embeddable-wg-library/wireguard.h
+++ b/contrib/embeddable-wg-library/wireguard.h
@@ -16,6 +16,12 @@
 typedef uint8_t wg_key[32];
 typedef char wg_key_b64_string[((sizeof(wg_key) + 2) / 3) * 4 + 1];
 
+/* Cross platform __kernel_timespec */
+struct timespec64 {
+	int64_t tv_sec;
+	int64_t tv_nsec;
+};
+
 typedef struct wg_allowedip {
 	uint16_t family;
 	union {
@@ -46,7 +52,7 @@ typedef struct wg_peer {
 		struct sockaddr_in6 addr6;
 	} endpoint;
 
-	struct timespec last_handshake_time;
+	struct timespec64 last_handshake_time;
 	uint64_t rx_bytes, tx_bytes;
 	uint16_t persistent_keepalive_interval;
 
diff --git a/src/containers.h b/src/containers.h
index 2144052..59a213e 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -15,6 +15,12 @@
 
 #include "../uapi/wireguard.h"
 
+/* Cross platform __kernel_timespec */
+struct timespec64 {
+	int64_t tv_sec;
+	int64_t tv_nsec;
+};
+
 struct wgallowedip {
 	uint16_t family;
 	union {
@@ -45,7 +51,7 @@ struct wgpeer {
 		struct sockaddr_in6 addr6;
 	} endpoint;
 
-	struct timespec last_handshake_time;
+	struct timespec64 last_handshake_time;
 	uint64_t rx_bytes, tx_bytes;
 	uint16_t persistent_keepalive_interval;
 
diff --git a/src/ipc.c b/src/ipc.c
index da31eff..7ab3a62 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -420,9 +420,9 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			if (*end || allowedip->family == AF_UNSPEC || (allowedip->family == AF_INET6 && allowedip->cidr > 128) || (allowedip->family == AF_INET && allowedip->cidr > 32))
 				break;
 		} else if (peer && !strcmp(key, "last_handshake_time_sec"))
-			peer->last_handshake_time.tv_sec = NUM(0xffffffffffffffffULL);
+			peer->last_handshake_time.tv_sec = NUM(0x7fffffffffffffffULL);
 		else if (peer && !strcmp(key, "last_handshake_time_nsec"))
-			peer->last_handshake_time.tv_nsec = NUM(0xffffffffffffffffULL);
+			peer->last_handshake_time.tv_nsec = NUM(0x7fffffffffffffffULL);
 		else if (peer && !strcmp(key, "rx_bytes"))
 			peer->rx_bytes = NUM(0xffffffffffffffffULL);
 		else if (peer && !strcmp(key, "tx_bytes"))
diff --git a/src/show.c b/src/show.c
index ba6f115..4cc34ab 100644
--- a/src/show.c
+++ b/src/show.c
@@ -155,7 +155,7 @@ static size_t pretty_time(char *buf, const size_t len, unsigned long long left)
 	return offset;
 }
 
-static char *ago(const struct timespec *t)
+static char *ago(const struct timespec64 *t)
 {
 	static char buf[1024];
 	size_t offset;

commit ee880389866b44acb4fae64f9885ada7d964b738
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Jan 5 17:02:14 2019 +0100

    contrib: introduce simple highlighter library
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/highlighter/Makefile b/contrib/highlighter/Makefile
new file mode 100644
index 0000000..29e1402
--- /dev/null
+++ b/contrib/highlighter/Makefile
@@ -0,0 +1,25 @@
+CFLAGS ?= -O3 -march=native
+CFLAGS += -std=gnu99
+CFLAGS += -Wall
+CFLAGS += -MMD -MP
+
+highlight: highlight.o highlighter.o
+
+fuzz: CC := clang
+fuzz: CFLAGS += -fsanitize=fuzzer
+fuzz: fuzz.c highlighter.c
+
+gui/Makefile: gui/highlight.pro
+	cd gui && qmake
+gui: gui/Makefile
+	@$(MAKE) -C gui
+
+clean:
+	rm -f highlight fuzz *.o *.d
+	@if [ -f gui/Makefile ]; then $(MAKE) -C gui distclean; fi
+
+.PHONY: clean gui
+.DEFAULT_GOAL: highlight
+MAKEFLAGS += --no-print-directory
+
+-include *.d
diff --git a/contrib/highlighter/README b/contrib/highlighter/README
new file mode 100644
index 0000000..2ea5141
--- /dev/null
+++ b/contrib/highlighter/README
@@ -0,0 +1,22 @@
+wg(8) and wg-quick(8) syntax highlighter library
+================================================
+
+highlighter.c contains a simple portable highlighter for the wg(8) and
+wg-quick(8) configuration files. Simply copy `highlight.c` and
+`highlight.h` into your project wholesale.
+
+As a demo, a simple console highlighter program is included, alongside a
+simple Qt5 GUI app to show its usage in realtime.
+
+There is also a basic fuzzer, because why not?
+
+Usage:
+
+    $ make
+    $ ./highlight < path/to/tunnel.conf
+
+    $ make gui
+    $ ./gui/highlight
+
+    $ make fuzz
+    $ ./fuzz -workers=$(nproc) -jobs=$(nproc) ./corpus
diff --git a/contrib/highlighter/fuzz.c b/contrib/highlighter/fuzz.c
new file mode 100644
index 0000000..e308157
--- /dev/null
+++ b/contrib/highlighter/fuzz.c
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include "highlighter.h"
+
+int LLVMFuzzerTestOneInput(const char *data, size_t size)
+{
+	char *str = strndup(data, size);
+	if (!str)
+		return 0;
+	struct highlight_span *spans = highlight_config(str);
+	if (!spans)
+		return 0;
+	for (struct highlight_span *span = spans; span->type != HighlightEnd; ++span);
+	free(spans);
+	free(str);
+	return 0;
+}
diff --git a/contrib/highlighter/gui/highlight.cpp b/contrib/highlighter/gui/highlight.cpp
new file mode 100644
index 0000000..a95857b
--- /dev/null
+++ b/contrib/highlighter/gui/highlight.cpp
@@ -0,0 +1,90 @@
+#include <QApplication>
+#include <QPlainTextEdit>
+#include <QPalette>
+#include <QFontDatabase>
+#include <QVBoxLayout>
+#include <QPushButton>
+
+extern "C" {
+#include "../highlighter.h"
+}
+
+static QColor colormap[] = {
+	[HighlightSection] = QColor("#ababab"),
+	[HighlightField] = QColor("#70c0b1"),
+	[HighlightPrivateKey] = QColor("#7aa6da"),
+	[HighlightPublicKey] = QColor("#7aa6da"),
+	[HighlightPresharedKey] = QColor("#7aa6da"),
+	[HighlightIP] = QColor("#b9ca4a"),
+	[HighlightCidr] = QColor("#e78c45"),
+	[HighlightHost] = QColor("#b9ca4a"),
+	[HighlightPort] = QColor("#e78c45"),
+	[HighlightMTU] = QColor("#c397d8"),
+	[HighlightKeepalive] = QColor("#c397d8"),
+	[HighlightComment] = QColor("#969896"),
+	[HighlightDelimiter] = QColor("#7aa6da"),
+#ifndef MOBILE_WGQUICK_SUBSET
+	[HighlightTable] = QColor("#c397d8"),
+	[HighlightFwMark] = QColor("#c397d8"),
+	[HighlightSaveConfig] = QColor("#c397d8"),
+	[HighlightCmd] = QColor("#969896"),
+#endif
+	[HighlightError] = QColor("#d54e53")
+};
+
+int main(int argc, char *argv[])
+{
+	QApplication a(argc, argv);
+	QWidget w;
+	w.setWindowTitle(QObject::tr("WireGuard Configuration Highlighter"));
+	QVBoxLayout v;
+	w.setLayout(&v);
+	QPlainTextEdit e;
+	v.addWidget(&e);
+	QPalette p(e.palette());
+	p.setColor(QPalette::Base, QColor("#010101"));
+	p.setColor(QPalette::Text, QColor("#eaeaea"));
+	e.setPalette(p);
+	QFont f(QFontDatabase::systemFont(QFontDatabase::FixedFont));
+	f.setPointSize(16);
+	e.setFont(f);
+	e.setMinimumSize(400, 500);
+	bool guard = false;
+	QObject::connect(&e, &QPlainTextEdit::textChanged, [&]() {
+		if (guard)
+			return;
+		struct highlight_span *spans = highlight_config(e.toPlainText().toLatin1().data());
+		if (!spans)
+			return;
+		QTextCursor cursor(e.document());
+		QTextCharFormat format;
+		cursor.beginEditBlock();
+		cursor.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor);
+		cursor.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);
+		format.setForeground(p.color(QPalette::Text));
+		format.setUnderlineStyle(QTextCharFormat::NoUnderline);
+		cursor.mergeCharFormat(format);
+		for (struct highlight_span *span = spans; span->type != HighlightEnd; ++span) {
+			cursor.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor);
+			cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::MoveAnchor, span->start);
+			cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor, span->len);
+			format.setForeground(colormap[span->type]);
+			format.setUnderlineStyle(span->type == HighlightError ? QTextCharFormat::SpellCheckUnderline : QTextCharFormat::NoUnderline);
+			cursor.mergeCharFormat(format);
+		}
+		free(spans);
+		guard = true;
+		cursor.endEditBlock();
+		guard = false;
+	});
+	QPushButton b;
+	v.addWidget(&b);
+	b.setText(QObject::tr("&Randomize colors"));
+	QObject::connect(&b, &QPushButton::clicked, [&]() {
+		for (size_t i = 0; i < sizeof(colormap) / sizeof(colormap[0]); ++i)
+			colormap[i] = QColor::fromHsl(qrand() % 360, qrand() % 192 + 64, qrand() % 128 + 128);
+		e.setPlainText(e.toPlainText());
+	});
+	w.show();
+	return a.exec();
+}
diff --git a/contrib/highlighter/gui/highlight.pro b/contrib/highlighter/gui/highlight.pro
new file mode 100644
index 0000000..f25667c
--- /dev/null
+++ b/contrib/highlighter/gui/highlight.pro
@@ -0,0 +1,5 @@
+QT += core gui widgets
+TEMPLATE = app
+TARGET = highlight
+SOURCES += highlight.cpp ../highlighter.c
+HEADERS += ../highlighter.h
diff --git a/contrib/highlighter/highlight.c b/contrib/highlighter/highlight.c
new file mode 100644
index 0000000..b03f792
--- /dev/null
+++ b/contrib/highlighter/highlight.c
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "highlighter.h"
+
+#define TERMINAL_FG_BLACK	"\x1b[30m"
+#define TERMINAL_FG_RED		"\x1b[31m"
+#define TERMINAL_FG_GREEN	"\x1b[32m"
+#define TERMINAL_FG_YELLOW	"\x1b[33m"
+#define TERMINAL_FG_BLUE	"\x1b[34m"
+#define TERMINAL_FG_MAGENTA	"\x1b[35m"
+#define TERMINAL_FG_CYAN	"\x1b[36m"
+#define TERMINAL_FG_WHITE	"\x1b[37m"
+#define TERMINAL_FG_DEFAULT	"\x1b[39m"
+
+#define TERMINAL_BG_BLACK	"\x1b[40m"
+#define TERMINAL_BG_RED		"\x1b[41m"
+#define TERMINAL_BG_GREEN	"\x1b[42m"
+#define TERMINAL_BG_YELLOW	"\x1b[43m"
+#define TERMINAL_BG_BLUE	"\x1b[44m"
+#define TERMINAL_BG_MAGENTA	"\x1b[45m"
+#define TERMINAL_BG_CYAN	"\x1b[46m"
+#define TERMINAL_BG_WHITE	"\x1b[47m"
+#define TERMINAL_BG_DEFAULT	"\x1b[49m"
+
+#define TERMINAL_BOLD		"\x1b[1m"
+#define TERMINAL_NO_BOLD	"\x1b[22m"
+#define TERMINAL_UNDERLINE	"\x1b[4m"
+#define TERMINAL_NO_UNDERLINE	"\x1b[24m"
+
+#define TERMINAL_RESET		"\x1b[0m"
+
+static const char *colormap[] = {
+	[HighlightSection] = TERMINAL_FG_BLACK TERMINAL_BOLD,
+	[HighlightField] = TERMINAL_FG_BLUE TERMINAL_BOLD,
+	[HighlightPrivateKey] = TERMINAL_FG_YELLOW TERMINAL_BOLD,
+	[HighlightPublicKey] = TERMINAL_FG_YELLOW TERMINAL_BOLD,
+	[HighlightPresharedKey] = TERMINAL_FG_YELLOW TERMINAL_BOLD,
+	[HighlightIP] = TERMINAL_FG_GREEN,
+	[HighlightCidr] = TERMINAL_FG_YELLOW,
+	[HighlightHost] = TERMINAL_FG_GREEN TERMINAL_BOLD,
+	[HighlightPort] = TERMINAL_FG_MAGENTA,
+	[HighlightMTU] = TERMINAL_FG_BLUE,
+	[HighlightKeepalive] = TERMINAL_FG_BLUE,
+	[HighlightComment] = TERMINAL_FG_CYAN,
+	[HighlightDelimiter] = TERMINAL_FG_CYAN,
+#ifndef MOBILE_WGQUICK_SUBSET
+	[HighlightTable] = TERMINAL_FG_BLUE,
+	[HighlightFwMark] = TERMINAL_FG_BLUE,
+	[HighlightSaveConfig] = TERMINAL_FG_BLUE,
+	[HighlightCmd] = TERMINAL_FG_WHITE,
+#endif
+	[HighlightError] = TERMINAL_FG_RED TERMINAL_UNDERLINE
+};
+
+int main(int argc, char *argv[])
+{
+	char input[1024 * 1024];
+	struct highlight_span *spans;
+	size_t last = 0, total_len;
+
+	total_len = fread(input, 1, sizeof(input) - 1, stdin);
+	input[total_len] = '\0';
+	spans = highlight_config(input);
+
+	fputs(TERMINAL_RESET, stdout);
+	for (struct highlight_span *span = spans; span->type != HighlightEnd; ++span) {
+		fwrite(input + last, 1, span->start - last, stdout);
+		fputs(colormap[span->type], stdout);
+		fwrite(input + span->start, 1, span->len, stdout);
+		fputs(TERMINAL_RESET, stdout);
+		last = span->start + span->len;
+	}
+	fwrite(input + last, 1, total_len - last, stdout);
+
+	free(spans);
+	return 0;
+}
diff --git a/contrib/highlighter/highlighter.c b/contrib/highlighter/highlighter.c
new file mode 100644
index 0000000..171a84c
--- /dev/null
+++ b/contrib/highlighter/highlighter.c
@@ -0,0 +1,620 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "highlighter.h"
+
+typedef struct {
+	const char *s;
+	size_t len;
+} string_span_t;
+
+static bool is_decimal(char c)
+{
+	return c >= '0' && c <= '9';
+}
+
+static bool is_hexadecimal(char c)
+{
+	return is_decimal(c) || ((c | 32) >= 'a' && (c | 32) <= 'f');
+}
+
+static bool is_alphabet(char c)
+{
+	return (c | 32) >= 'a' && (c | 32) <= 'z';
+}
+
+static bool is_same(string_span_t s, const char *c)
+{
+	size_t len = strlen(c);
+
+	if (len != s.len)
+		return false;
+	return !memcmp(s.s, c, len);
+}
+
+static bool is_caseless_same(string_span_t s, const char *c)
+{
+	size_t len = strlen(c);
+
+	if (len != s.len)
+		return false;
+	for (size_t i = 0; i < len; ++i) {
+		char a = c[i], b = s.s[i];
+		if ((unsigned)a - 'a' < 26)
+			a &= 95;
+		if ((unsigned)b - 'a' < 26)
+			b &= 95;
+		if (a != b)
+			return false;
+	}
+	return true;
+}
+
+static bool is_valid_key(string_span_t s)
+{
+	if (s.len != 44 || s.s[43] != '=')
+		return false;
+
+	for (size_t i = 0; i < 43; ++i) {
+		if (!is_decimal(s.s[i]) && !is_alphabet(s.s[i]) &&
+		    s.s[i] != '/' && s.s[i] != '+')
+			return false;
+	}
+	return true;
+}
+
+static bool is_valid_hostname(string_span_t s)
+{
+	size_t num_digit = 0, num_entity = s.len;
+
+	if (s.len > 63 || !s.len)
+		return false;
+	if (s.s[0] == '-' || s.s[s.len - 1] == '-')
+		return false;
+	if (s.s[0] == '.' || s.s[s.len - 1] == '.')
+		return false;
+
+	for (size_t i = 0; i < s.len; ++i) {
+		if (is_decimal(s.s[i])) {
+			++num_digit;
+			continue;
+		}
+		if (s.s[i] == '.') {
+			--num_entity;
+			continue;
+		}
+
+		if (!is_alphabet(s.s[i]) && s.s[i] != '-')
+			return false;
+
+		if (i && s.s[i] == '.' && s.s[i - 1] == '.')
+			return false;
+	}
+	return num_digit != num_entity;
+}
+
+static bool is_valid_ipv4(string_span_t s)
+{
+	for (size_t j, i = 0, pos = 0; i < 4 && pos < s.len; ++i) {
+		uint32_t val = 0;
+
+		for (j = 0; j < 3 && pos + j < s.len && is_decimal(s.s[pos + j]); ++j)
+			val = 10 * val + s.s[pos + j] - '0';
+		if (j == 0 || (j > 1 && s.s[pos] == '0') || val > 255)
+			return false;
+		if (pos + j == s.len && i == 3)
+			return true;
+		if (s.s[pos + j] != '.')
+			return false;
+		pos += j + 1;
+	}
+	return false;
+}
+
+static bool is_valid_ipv6(string_span_t s)
+{
+	size_t pos = 0;
+	bool seen_colon = false;
+
+	if (s.len < 2)
+		return false;
+	if (s.s[pos] == ':' && s.s[++pos] != ':')
+		return false;
+	if (s.s[s.len - 1] == ':' && s.s[s.len - 2] != ':')
+		return false;
+
+	for (size_t j, i = 0; pos < s.len; ++i) {
+		if (s.s[pos] == ':' && !seen_colon) {
+			seen_colon = true;
+			if (++pos == s.len)
+				break;
+			if (i == 7)
+				return false;
+			continue;
+		}
+		for (j = 0; j < 4 && pos + j < s.len && is_hexadecimal(s.s[pos + j]); ++j);
+		if (j == 0)
+			return false;
+		if (pos + j == s.len && (seen_colon || i == 7))
+			break;
+		if (i == 7)
+			return false;
+		if (s.s[pos + j] != ':') {
+			if (s.s[pos + j] != '.' || (i < 6 && !seen_colon))
+				return false;
+			return is_valid_ipv4((string_span_t){ s.s + pos, s.len - pos });
+		}
+		pos += j + 1;
+	}
+	return true;
+}
+
+static bool is_valid_uint(string_span_t s, bool support_hex, uint64_t min, uint64_t max)
+{
+	uint64_t val = 0;
+
+	/* Bound this around 32 bits, so that we don't have to write overflow logic. */
+	if (s.len > 10 || !s.len)
+		return false;
+
+	if (support_hex && s.len > 2 && s.s[0] == '0' && s.s[1] == 'x') {
+		for (size_t i = 2; i < s.len; ++i) {
+			if (s.s[i] - '0' < 10)
+				val = 16 * val + (s.s[i] - '0');
+			else if ((s.s[i] | 32) - 'a' < 6)
+				val = 16 * val + (s.s[i] | 32) - 'a' + 10;
+			else
+				return false;
+		}
+	} else {
+		for (size_t i = 0; i < s.len; ++i) {
+			if (!is_decimal(s.s[i]))
+				return false;
+			val = 10 * val + s.s[i] - '0';
+		}
+	}
+	return val <= max && val >= min;
+}
+
+static bool is_valid_port(string_span_t s)
+{
+	return is_valid_uint(s, false, 0, 65535);
+}
+
+static bool is_valid_mtu(string_span_t s)
+{
+	return is_valid_uint(s, false, 576, 65535);
+}
+
+static bool is_valid_persistentkeepalive(string_span_t s)
+{
+	if (is_same(s, "off"))
+		return true;
+	return is_valid_uint(s, false, 0, 65535);
+}
+
+#ifndef MOBILE_WGQUICK_SUBSET
+
+static bool is_valid_fwmark(string_span_t s)
+{
+	if (is_same(s, "off"))
+		return true;
+	return is_valid_uint(s, true, 0, 4294967295);
+}
+
+static bool is_valid_table(string_span_t s)
+{
+	if (is_same(s, "auto"))
+		return true;
+	if (is_same(s, "off"))
+		return true;
+	/* This pretty much invalidates the other checks, but rt_names.c's
+	 * fread_id_name does no validation aside from this. */
+	if (s.len < 512)
+		return true;
+	return is_valid_uint(s, false, 0, 4294967295);
+}
+
+static bool is_valid_saveconfig(string_span_t s)
+{
+	return is_same(s, "true") || is_same(s, "false");
+}
+
+static bool is_valid_prepostupdown(string_span_t s)
+{
+	/* It's probably not worthwhile to try to validate a bash expression.
+	 * So instead we just demand non-zero length. */
+	return s.len;
+}
+#endif
+
+static bool is_valid_scope(string_span_t s)
+{
+	if (s.len > 64 || !s.len)
+		return false;
+	for (size_t i = 0; i < s.len; ++i) {
+		if (!is_alphabet(s.s[i]) && !is_decimal(s.s[i]) &&
+		    s.s[i] != '_' && s.s[i] != '=' && s.s[i] != '+' &&
+		    s.s[i] != '.' && s.s[i] != '-')
+			return false;
+	}
+	return true;
+}
+
+static bool is_valid_endpoint(string_span_t s)
+{
+
+	if (!s.len)
+		return false;
+
+	if (s.s[0] == '[') {
+		bool seen_scope = false;
+		string_span_t hostspan = { s.s + 1, 0 };
+
+		for (size_t i = 1; i < s.len; ++i) {
+			if (s.s[i] == '%') {
+				if (seen_scope)
+					return false;
+				seen_scope = true;
+				if (!is_valid_ipv6(hostspan))
+					return false;
+				hostspan = (string_span_t){ s.s + i + 1, 0 };
+			} else if (s.s[i] == ']') {
+				if (seen_scope) {
+					if (!is_valid_scope(hostspan))
+						return false;
+				} else if (!is_valid_ipv6(hostspan)) {
+					return false;
+				}
+				if (i == s.len - 1 || s.s[i + 1] != ':')
+					return false;
+				return is_valid_port((string_span_t){ s.s + i + 2, s.len - i - 2 });
+			} else {
+				++hostspan.len;
+			}
+		}
+		return false;
+	}
+	for (size_t i = 0; i < s.len; ++i) {
+		if (s.s[i] == ':') {
+			string_span_t host = { s.s, i }, port = { s.s + i + 1, s.len - i - 1};
+			return is_valid_port(port) && (is_valid_ipv4(host) || is_valid_hostname(host));
+		}
+	}
+	return false;
+}
+
+static bool is_valid_network(string_span_t s)
+{
+	for (size_t i = 0; i < s.len; ++i) {
+		if (s.s[i] == '/') {
+			string_span_t ip = { s.s, i }, cidr = { s.s + i + 1, s.len - i - 1};
+			uint16_t cidrval = 0;
+
+			if (cidr.len > 3 || !cidr.len)
+				return false;
+
+			for (size_t j = 0; j < cidr.len; ++j) {
+				if (!is_decimal(cidr.s[j]))
+					return false;
+				cidrval = 10 * cidrval + cidr.s[j] - '0';
+			}
+			if (is_valid_ipv4(ip))
+				return cidrval <= 32;
+			else if (is_valid_ipv6(ip))
+				return cidrval <= 128;
+			return false;
+		}
+	}
+	return is_valid_ipv4(s) || is_valid_ipv6(s);
+}
+
+static bool is_valid_dns(string_span_t s)
+{
+	return is_valid_ipv4(s) || is_valid_ipv6(s);
+}
+
+enum field {
+	InterfaceSection,
+	PrivateKey,
+	ListenPort,
+	Address,
+	DNS,
+	MTU,
+#ifndef MOBILE_WGQUICK_SUBSET
+	FwMark,
+	Table,
+	PreUp, PostUp, PreDown, PostDown,
+	SaveConfig,
+#endif
+
+	PeerSection,
+	PublicKey,
+	PresharedKey,
+	AllowedIPs,
+	Endpoint,
+	PersistentKeepalive,
+
+	Invalid
+};
+
+static enum field section_for_field(enum field t)
+{
+	if (t > InterfaceSection && t < PeerSection)
+		return InterfaceSection;
+	if (t > PeerSection && t < Invalid)
+		return PeerSection;
+	return Invalid;
+}
+
+static enum field get_field(string_span_t s)
+{
+#define check_enum(t) do { if (is_caseless_same(s, #t)) return t; } while (0)
+	check_enum(PrivateKey);
+	check_enum(ListenPort);
+	check_enum(Address);
+	check_enum(DNS);
+	check_enum(MTU);
+	check_enum(PublicKey);
+	check_enum(PresharedKey);
+	check_enum(AllowedIPs);
+	check_enum(Endpoint);
+	check_enum(PersistentKeepalive);
+#ifndef MOBILE_WGQUICK_SUBSET
+	check_enum(FwMark);
+	check_enum(Table);
+	check_enum(PreUp);
+	check_enum(PostUp);
+	check_enum(PreDown);
+	check_enum(PostDown);
+	check_enum(SaveConfig);
+#endif
+	return Invalid;
+#undef check_enum
+}
+
+static enum field get_sectiontype(string_span_t s)
+{
+	if (is_caseless_same(s, "[Peer]"))
+		return PeerSection;
+	if (is_caseless_same(s, "[Interface]"))
+		return InterfaceSection;
+	return Invalid;
+}
+
+struct highlight_span_array {
+	size_t len, capacity;
+	struct highlight_span *spans;
+};
+
+/* A useful OpenBSD-ism. */
+static void *realloc_array(void *optr, size_t nmemb, size_t size)
+{
+	if ((nmemb >= (size_t)1 << (sizeof(size_t) * 4) ||
+	     size >= (size_t)1 << (sizeof(size_t) * 4)) &&
+	    nmemb > 0 && SIZE_MAX / nmemb < size) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	return realloc(optr, size * nmemb);
+}
+
+static bool append_highlight_span(struct highlight_span_array *a, const char *o, string_span_t s, enum highlight_type t)
+{
+	if (!s.len)
+		return true;
+	if (a->len >= a->capacity) {
+		struct highlight_span *resized;
+
+		a->capacity = a->capacity ? a->capacity * 2 : 64;
+		resized = realloc_array(a->spans, a->capacity, sizeof(*resized));
+		if (!resized) {
+			free(a->spans);
+			memset(a, 0, sizeof(*a));
+			return false;
+		}
+		a->spans = resized;
+	}
+	a->spans[a->len++] = (struct highlight_span){ t, s.s - o, s.len };
+	return true;
+}
+
+static void highlight_multivalue_value(struct highlight_span_array *ret, const string_span_t parent, const string_span_t s, enum field section)
+{
+	switch (section) {
+	case DNS:
+		append_highlight_span(ret, parent.s, s, is_valid_dns(s) ? HighlightIP : HighlightError);
+		break;
+	case Address:
+	case AllowedIPs: {
+		size_t slash;
+
+		if (!is_valid_network(s)) {
+			append_highlight_span(ret, parent.s, s, HighlightError);
+			break;
+		}
+		for (slash = 0; slash < s.len; ++slash) {
+			if (s.s[slash] == '/')
+				break;
+		}
+		if (slash == s.len) {
+			append_highlight_span(ret, parent.s, s, HighlightIP);
+		} else {
+			append_highlight_span(ret, parent.s, (string_span_t){ s.s, slash }, HighlightIP);
+			append_highlight_span(ret, parent.s, (string_span_t){ s.s + slash, 1 }, HighlightDelimiter);
+			append_highlight_span(ret, parent.s, (string_span_t){ s.s + slash + 1, s.len - slash - 1 }, HighlightCidr);
+		}
+		break;
+	}
+	default:
+		append_highlight_span(ret, parent.s, s, HighlightError);
+	}
+}
+
+static void highlight_multivalue(struct highlight_span_array *ret, const string_span_t parent, const string_span_t s, enum field section)
+{
+	string_span_t current_span = { s.s, 0 };
+	size_t len_at_last_space = 0;
+
+	for (size_t i = 0; i < s.len; ++i) {
+		if (s.s[i] == ',') {
+			current_span.len = len_at_last_space;
+			highlight_multivalue_value(ret, parent, current_span, section);
+			append_highlight_span(ret, parent.s, (string_span_t){ s.s + i, 1 }, HighlightDelimiter);
+			len_at_last_space = 0;
+			current_span = (string_span_t){ s.s + i + 1, 0 };
+		} else if (s.s[i] == ' ' || s.s[i] == '\t') {
+			if (&s.s[i] == current_span.s && !current_span.len)
+				++current_span.s;
+			else
+				++current_span.len;
+		} else {
+			len_at_last_space = ++current_span.len;
+		}
+	}
+	current_span.len = len_at_last_space;
+	if (current_span.len)
+		highlight_multivalue_value(ret, parent, current_span, section);
+	else if (ret->spans[ret->len - 1].type == HighlightDelimiter)
+		ret->spans[ret->len - 1].type = HighlightError;
+}
+
+static void highlight_value(struct highlight_span_array *ret, const string_span_t parent, const string_span_t s, enum field section)
+{
+	switch (section) {
+	case PrivateKey:
+		append_highlight_span(ret, parent.s, s, is_valid_key(s) ? HighlightPrivateKey : HighlightError);
+		break;
+	case PublicKey:
+		append_highlight_span(ret, parent.s, s, is_valid_key(s) ? HighlightPublicKey : HighlightError);
+		break;
+	case PresharedKey:
+		append_highlight_span(ret, parent.s, s, is_valid_key(s) ? HighlightPresharedKey : HighlightError);
+		break;
+	case MTU:
+		append_highlight_span(ret, parent.s, s, is_valid_mtu(s) ? HighlightMTU : HighlightError);
+		break;
+#ifndef MOBILE_WGQUICK_SUBSET
+	case SaveConfig:
+		append_highlight_span(ret, parent.s, s, is_valid_saveconfig(s) ? HighlightSaveConfig : HighlightError);
+		break;
+	case FwMark:
+		append_highlight_span(ret, parent.s, s, is_valid_fwmark(s) ? HighlightFwMark : HighlightError);
+		break;
+	case Table:
+		append_highlight_span(ret, parent.s, s, is_valid_table(s) ? HighlightTable : HighlightError);
+		break;
+	case PreUp:
+	case PostUp:
+	case PreDown:
+	case PostDown:
+		append_highlight_span(ret, parent.s, s, is_valid_prepostupdown(s) ? HighlightCmd : HighlightError);
+		break;
+#endif
+	case ListenPort:
+		append_highlight_span(ret, parent.s, s, is_valid_port(s) ? HighlightPort : HighlightError);
+		break;
+	case PersistentKeepalive:
+		append_highlight_span(ret, parent.s, s, is_valid_persistentkeepalive(s) ? HighlightKeepalive : HighlightError);
+		break;
+	case Endpoint: {
+		size_t colon;
+
+		if (!is_valid_endpoint(s)) {
+			append_highlight_span(ret, parent.s, s, HighlightError);
+			break;
+		}
+		for (colon = s.len; colon --> 0;) {
+			if (s.s[colon] == ':')
+				break;
+		}
+		append_highlight_span(ret, parent.s, (string_span_t){ s.s, colon }, HighlightHost);
+		append_highlight_span(ret, parent.s, (string_span_t){ s.s + colon, 1 }, HighlightDelimiter);
+		append_highlight_span(ret, parent.s, (string_span_t){ s.s + colon + 1, s.len - colon - 1 }, HighlightPort);
+		break;
+	}
+	case Address:
+	case DNS:
+	case AllowedIPs:
+		highlight_multivalue(ret, parent, s, section);
+		break;
+	default:
+		append_highlight_span(ret, parent.s, s, HighlightError);
+	}
+}
+
+struct highlight_span *highlight_config(const char *config)
+{
+	struct highlight_span_array ret = { 0 };
+	const string_span_t s = { config, strlen(config) };
+	string_span_t current_span = { s.s, 0 };
+	enum field current_section = Invalid, current_field = Invalid;
+	enum { OnNone, OnKey, OnValue, OnComment, OnSection } state = OnNone;
+	size_t len_at_last_space = 0, equals_location = 0;
+
+	for (size_t i = 0; i <= s.len; ++i) {
+		if (i == s.len || s.s[i] == '\n' || (state != OnComment && s.s[i] == '#')) {
+			if (state == OnKey) {
+				current_span.len = len_at_last_space;
+				append_highlight_span(&ret, s.s, current_span, HighlightError);
+			} else if (state == OnValue) {
+				if (current_span.len) {
+					append_highlight_span(&ret, s.s, (string_span_t){ s.s + equals_location, 1 }, HighlightDelimiter);
+					current_span.len = len_at_last_space;
+					highlight_value(&ret, s, current_span, current_field);
+				} else {
+					append_highlight_span(&ret, s.s, (string_span_t){ s.s + equals_location, 1 }, HighlightError);
+				}
+			} else if (state == OnSection) {
+				current_span.len = len_at_last_space;
+				current_section = get_sectiontype(current_span);
+				append_highlight_span(&ret, s.s, current_span, current_section == Invalid ? HighlightError : HighlightSection);
+			} else if (state == OnComment) {
+				append_highlight_span(&ret, s.s, current_span, HighlightComment);
+			}
+			if (i == s.len)
+				break;
+			len_at_last_space = 0;
+			current_field = Invalid;
+			if (s.s[i] == '#') {
+				current_span = (string_span_t){ s.s + i, 1 };
+				state = OnComment;
+			} else {
+				current_span = (string_span_t){ s.s + i + 1, 0 };
+				state = OnNone;
+			}
+		} else if (state == OnComment) {
+			++current_span.len;
+		} else if (s.s[i] == ' ' || s.s[i] == '\t') {
+			if (&s.s[i] == current_span.s && !current_span.len)
+				++current_span.s;
+			else
+				++current_span.len;
+		} else if (s.s[i] == '=' && state == OnKey) {
+			current_span.len = len_at_last_space;
+			current_field = get_field(current_span);
+			enum field section = section_for_field(current_field);
+			if (section == Invalid || current_field == Invalid || section != current_section)
+				append_highlight_span(&ret, s.s, current_span, HighlightError);
+			else
+				append_highlight_span(&ret, s.s, current_span, HighlightField);
+			equals_location = i;
+			current_span = (string_span_t){ s.s + i + 1, 0 };
+			state = OnValue;
+		} else {
+			if (state == OnNone)
+				state = s.s[i] == '[' ? OnSection : OnKey;
+			len_at_last_space = ++current_span.len;
+		}
+	}
+
+	append_highlight_span(&ret, s.s, (string_span_t){ s.s, -1 }, HighlightEnd);
+	return ret.spans;
+}
diff --git a/contrib/highlighter/highlighter.h b/contrib/highlighter/highlighter.h
new file mode 100644
index 0000000..c004e12
--- /dev/null
+++ b/contrib/highlighter/highlighter.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <sys/types.h>
+
+enum highlight_type {
+	HighlightSection,
+	HighlightField,
+	HighlightPrivateKey,
+	HighlightPublicKey,
+	HighlightPresharedKey,
+	HighlightIP,
+	HighlightCidr,
+	HighlightHost,
+	HighlightPort,
+	HighlightMTU,
+	HighlightKeepalive,
+	HighlightComment,
+	HighlightDelimiter,
+#ifndef MOBILE_WGQUICK_SUBSET
+	HighlightTable,
+	HighlightFwMark,
+	HighlightSaveConfig,
+	HighlightCmd,
+#endif
+	HighlightError,
+	HighlightEnd
+};
+
+struct highlight_span {
+	enum highlight_type type;
+	size_t start, len;
+};
+
+struct highlight_span *highlight_config(const char *config);

commit 777fe674c4c534bb0b9a97c4e5d90f06343c8f23
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jan 11 01:13:35 2019 -0800

    global: normalize -> clamp
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index 1522c91..51da8ec 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -1688,7 +1688,7 @@ static void invert(fe o, const fe i)
 	memzero_explicit(c, sizeof(c));
 }
 
-static void normalize_key(uint8_t *z)
+static void clamp_key(uint8_t *z)
 {
 	z[31] = (z[31] & 127) | 64;
 	z[0] &= 248;
@@ -1701,7 +1701,7 @@ void wg_generate_public_key(wg_key public_key, const wg_key private_key)
 	fe a = { 1 }, b = { 9 }, c = { 0 }, d = { 1 }, e, f;
 
 	memcpy(z, private_key, sizeof(z));
-	normalize_key(z);
+	clamp_key(z);
 
 	for (i = 254; i >= 0; --i) {
 		r = (z[i >> 3] >> (i & 7)) & 1;
@@ -1745,7 +1745,7 @@ void wg_generate_public_key(wg_key public_key, const wg_key private_key)
 void wg_generate_private_key(wg_key private_key)
 {
 	wg_generate_preshared_key(private_key);
-	normalize_key(private_key);
+	clamp_key(private_key);
 }
 
 void wg_generate_preshared_key(wg_key preshared_key)
diff --git a/contrib/keygen-html/wireguard.js b/contrib/keygen-html/wireguard.js
index e96da3e..e262459 100644
--- a/contrib/keygen-html/wireguard.js
+++ b/contrib/keygen-html/wireguard.js
@@ -91,7 +91,7 @@
 			o[a] = c[a];
 	}
 
-	function normalizeKey(z) {
+	function clamp(z) {
 		z[31] = (z[31] & 127) | 64;
 		z[0] &= 248;
 	}
@@ -108,7 +108,7 @@
 			_9 = gf([9]);
 		for (var i = 0; i < 32; ++i)
 			z[i] = privateKey[i];
-		normalizeKey(z);
+		clamp(z);
 		for (var i = 254; i >= 0; --i) {
 			r = (z[i >>> 3] >>> (i & 7)) & 1;
 			cswap(a, b, r);
@@ -148,7 +148,7 @@
 
 	function generatePrivateKey() {
 		var privateKey = generatePresharedKey();
-		normalizeKey(privateKey);
+		clamp(privateKey);
 		return privateKey;
 	}
 
diff --git a/src/curve25519.c b/src/curve25519.c
index 7949933..0d52bc8 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -68,7 +68,7 @@ static inline void put_unaligned_le64(u64 s, u8 *d)
 #ifndef __force
 #define __force
 #endif
-#define normalize_secret(a) curve25519_normalize_secret(a)
+#define clamp_secret(a) curve25519_clamp_secret(a)
 
 static noinline void memzero_explicit(void *s, size_t count)
 {
diff --git a/src/curve25519.h b/src/curve25519.h
index a5c3066..badcda0 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -15,7 +15,7 @@ enum curve25519_lengths {
 
 void curve25519(uint8_t mypublic[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE], const uint8_t basepoint[static CURVE25519_KEY_SIZE]);
 void curve25519_generate_public(uint8_t pub[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE]);
-static inline void curve25519_normalize_secret(uint8_t secret[static CURVE25519_KEY_SIZE])
+static inline void curve25519_clamp_secret(uint8_t secret[static CURVE25519_KEY_SIZE])
 {
 	secret[0] &= 248;
 	secret[31] &= 127;
diff --git a/src/genkey.c b/src/genkey.c
index 65711e1..645f614 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -71,7 +71,7 @@ int genkey_main(int argc, char *argv[])
 		return 1;
 	}
 	if (!strcmp(argv[0], "genkey"))
-		curve25519_normalize_secret(key);
+		curve25519_clamp_secret(key);
 
 	key_to_base64(base64, key);
 	puts(base64);

commit 3ac679e7a1930c322e9f37e0f106cdaabc18bc13
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 26 20:05:47 2018 +0200

    keygen-html: bring back pure javascript implementation
    
    This reverts commit 9d5baf7d1d14ca7eb0852b41566330259229d489.
    
    Benot Viguier has proofs that values will stay well within 2^53. We
    also have an improved carry function that's much simpler.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/Makefile b/contrib/keygen-html/Makefile
deleted file mode 100644
index a3acec0..0000000
--- a/contrib/keygen-html/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-curve25519_generate.js: src/curve25519_generate.c src/glue.js
-	emcc -O2 --memory-init-file 0 --closure 1 --post-js src/glue.js -s 'EXTRA_EXPORTED_RUNTIME_METHODS=["Pointer_stringify"]' -o $@ src/curve25519_generate.c
-clean:
-	rm -f curve25519_generate.js
-all: curve25519_generate.js
-.PHONY: clean all
diff --git a/contrib/keygen-html/README b/contrib/keygen-html/README
index eaa4244..f1c3412 100644
--- a/contrib/keygen-html/README
+++ b/contrib/keygen-html/README
@@ -17,11 +17,3 @@ introduces interesting side-channel attacks.
 Secrets aren't zerored after use. Maybe you can get around this with
 some tricks taking advantage of browser allocator behavior and different
 processes, but it seems pretty hard.
-
-Building
---------
-
-In order to use the example `keygen.html` file, you must first build
-the C sources using emscripten. Simply run:
-
-    $ make
diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
index af2a545..939e637 100644
--- a/contrib/keygen-html/keygen.html
+++ b/contrib/keygen-html/keygen.html
@@ -1,4 +1,4 @@
-<script src="curve25519_generate.js" onError='document.write("<h3>Did you forget to run \"make\" to compile curve25519_generate.js?</h3><!--");'></script>
+<script src="wireguard.js"></script>
 <script>
 /* SPDX-License-Identifier: GPL-2.0
  *
@@ -26,7 +26,7 @@ function sendPubkeyToServer(pubkey, username, password)
 
 function downloadNewConfiguration()
 {
-	var keypair = WireGuard.generateKeypair();
+	var keypair = wireguard.generateKeypair();
 	var serverResponse = sendPubkeyToServer(keypair.publicKey, "zx2c4", "supersecretpassword");
 
 	var config = [];
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
deleted file mode 100644
index 6329c57..0000000
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ /dev/null
@@ -1,98 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-
-#include <emscripten.h>
-
-typedef unsigned long long  u64;
-typedef unsigned int u32;
-typedef unsigned char u8;
-typedef u32 __le32;
-
-enum { CURVE25519_KEY_SIZE = 32 };
-
-#ifndef __always_inline
-#define __always_inline __inline __attribute__((__always_inline__))
-#endif
-#ifndef noinline
-#define noinline __attribute__((noinline))
-#endif
-#ifndef __aligned
-#define __aligned(x) __attribute__((aligned(x)))
-#endif
-#ifndef __force
-#define __force
-#endif
-
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-#define le32_to_cpup(a) (*(a))
-#else
-#define le32_to_cpup(a) __builtin_bswap32(*(a))
-#endif
-#define get_unaligned_le32(a) le32_to_cpup((u32 *)(a))
-
-#define memset(a, b, c) __builtin_memset(a, b, c)
-#define memcpy(a, b, c) __builtin_memcpy(a, b, c)
-#define memmove(a, b, c) __builtin_memmove(a, b, c)
-/* We don't even attempt to deal with this in javascript. */
-#define memzero_explicit(a, b)
-
-static __always_inline void normalize_secret(u8 secret[CURVE25519_KEY_SIZE])
-{
-	secret[0] &= 248;
-	secret[31] &= 127;
-	secret[31] |= 64;
-}
-
-#include "../../../../src/crypto/zinc/curve25519/curve25519-fiat32.c"
-
-EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(u8 public[static 32], const u8 private[static 32])
-{
-	static const u8 basepoint[32] = { 9 };
-
-	curve25519_generic(public, private, basepoint);
-}
-
-EMSCRIPTEN_KEEPALIVE void curve25519_generate_private(u8 private[static 32])
-{
-	int i;
-
-	EM_ASM({
-		/* Same trick as libsodium */
-		var getRandomValue = function() {
-			var buf = new Uint32Array(1);
-			window.crypto.getRandomValues(buf);
-			return buf[0] >>> 0;
-		};
-		Module.getRandomValue = getRandomValue;
-	});
-	
-	for (i = 0; i < 32; ++i)
-		private[i] = EM_ASM_INT_V({ return Module.getRandomValue(); });
-	normalize_secret(private);
-}
-
-static inline void encode_base64(char dest[static 4], const u8 src[static 3])
-{
-	const u8 input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
-
-	for (unsigned int i = 0; i < 4; ++i)
-		dest[i] = input[i] + 'A'
-			  + (((25 - input[i]) >> 8) & 6)
-			  - (((51 - input[i]) >> 8) & 75)
-			  - (((61 - input[i]) >> 8) & 15)
-			  + (((62 - input[i]) >> 8) & 3);
-
-}
-
-EMSCRIPTEN_KEEPALIVE void key_to_base64(char base64[static 45], const u8 key[static 32])
-{
-	unsigned int i;
-
-	for (i = 0; i < 32 / 3; ++i)
-		encode_base64(&base64[i * 4], &key[i * 3]);
-	encode_base64(&base64[i * 4], (const u8[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
-	base64[45 - 2] = '=';
-	base64[45 - 1] = '\0';
-}
diff --git a/contrib/keygen-html/src/glue.js b/contrib/keygen-html/src/glue.js
deleted file mode 100644
index 5bd2511..0000000
--- a/contrib/keygen-html/src/glue.js
+++ /dev/null
@@ -1,25 +0,0 @@
-/*! SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-window["WireGuard"] = {
-	"generateKeypair": function() {
-		var privateKey = Module["_malloc"](32);
-		var publicKey = Module["_malloc"](32);
-		Module["_curve25519_generate_private"](privateKey);
-		Module["_curve25519_generate_public"](publicKey, privateKey);
-		var privateBase64 = Module["_malloc"](45);
-		var publicBase64 = Module["_malloc"](45);
-		Module["_key_to_base64"](privateBase64, privateKey);
-		Module["_key_to_base64"](publicBase64, publicKey);
-		Module["_free"](privateKey);
-		Module["_free"](publicKey);
-		var keypair = {
-			publicKey: Module["Pointer_stringify"](publicBase64),
-			privateKey: Module["Pointer_stringify"](privateBase64)
-		};
-		Module["_free"](privateBase64);
-		Module["_free"](publicBase64);
-		return keypair;
-	}
-};
diff --git a/contrib/keygen-html/wireguard.js b/contrib/keygen-html/wireguard.js
new file mode 100644
index 0000000..e96da3e
--- /dev/null
+++ b/contrib/keygen-html/wireguard.js
@@ -0,0 +1,184 @@
+/*! SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+(function() {
+	function gf(init) {
+		var r = new Float64Array(16);
+		if (init) {
+			for (var i = 0; i < init.length; ++i)
+				r[i] = init[i];
+		}
+		return r;
+	}
+
+	function pack(o, n) {
+		var b, m = gf(), t = gf();
+		for (var i = 0; i < 16; ++i)
+			t[i] = n[i];
+		carry(t);
+		carry(t);
+		carry(t);
+		for (var j = 0; j < 2; ++j) {
+			m[0] = t[0] - 0xffed;
+			for (var i = 1; i < 15; ++i) {
+				m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
+				m[i - 1] &= 0xffff;
+			}
+			m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
+			b = (m[15] >> 16) & 1;
+			m[14] &= 0xffff;
+			cswap(t, m, 1 - b);
+		}
+		for (var i = 0; i < 16; ++i) {
+			o[2 * i] = t[i] & 0xff;
+			o[2 * i + 1] = t[i] >> 8;
+		}
+	}
+
+	function carry(o) {
+		var c;
+		for (var i = 0; i < 16; ++i) {
+			o[(i + 1) % 16] += (i < 15 ? 1 : 38) * Math.floor(o[i] / 65536);
+			o[i] &= 0xffff;
+		}
+	}
+
+	function cswap(p, q, b) {
+		var t, c = ~(b - 1);
+		for (var i = 0; i < 16; ++i) {
+			t = c & (p[i] ^ q[i]);
+			p[i] ^= t;
+			q[i] ^= t;
+		}
+	}
+
+	function add(o, a, b) {
+		for (var i = 0; i < 16; ++i)
+			o[i] = (a[i] + b[i]) | 0;
+	}
+
+	function subtract(o, a, b) {
+		for (var i = 0; i < 16; ++i)
+			o[i] = (a[i] - b[i]) | 0;
+	}
+
+	function multmod(o, a, b) {
+		var t = new Float64Array(31);
+		for (var i = 0; i < 16; ++i) {
+			for (var j = 0; j < 16; ++j)
+				t[i + j] += a[i] * b[j];
+		}
+		for (var i = 0; i < 15; ++i)
+			t[i] += 38 * t[i + 16];
+		for (var i = 0; i < 16; ++i)
+			o[i] = t[i];
+		carry(o);
+		carry(o);
+	}
+
+	function invert(o, i) {
+		var c = gf();
+		for (var a = 0; a < 16; ++a)
+			c[a] = i[a];
+		for (var a = 253; a >= 0; --a) {
+			multmod(c, c, c);
+			if (a !== 2 && a !== 4)
+				multmod(c, c, i);
+		}
+		for (var a = 0; a < 16; ++a)
+			o[a] = c[a];
+	}
+
+	function normalizeKey(z) {
+		z[31] = (z[31] & 127) | 64;
+		z[0] &= 248;
+	}
+
+	function generatePublicKey(privateKey) {
+		var r, z = new Uint8Array(32);
+		var a = gf([1]),
+			b = gf([9]),
+			c = gf(),
+			d = gf([1]),
+			e = gf(),
+			f = gf(),
+			_121665 = gf([0xdb41, 1]),
+			_9 = gf([9]);
+		for (var i = 0; i < 32; ++i)
+			z[i] = privateKey[i];
+		normalizeKey(z);
+		for (var i = 254; i >= 0; --i) {
+			r = (z[i >>> 3] >>> (i & 7)) & 1;
+			cswap(a, b, r);
+			cswap(c, d, r);
+			add(e, a, c);
+			subtract(a, a, c);
+			add(c, b, d);
+			subtract(b, b, d);
+			multmod(d, e, e);
+			multmod(f, a, a);
+			multmod(a, c, a);
+			multmod(c, b, e);
+			add(e, a, c);
+			subtract(a, a, c);
+			multmod(b, a, a);
+			subtract(c, d, f);
+			multmod(a, c, _121665);
+			add(a, a, d);
+			multmod(c, c, a);
+			multmod(a, d, f);
+			multmod(d, b, _9);
+			multmod(b, e, e);
+			cswap(a, b, r);
+			cswap(c, d, r);
+		}
+		invert(c, c);
+		multmod(a, a, c);
+		pack(z, a);
+		return z;
+	}
+
+	function generatePresharedKey() {
+		var privateKey = new Uint8Array(32);
+		window.crypto.getRandomValues(privateKey);
+		return privateKey;
+	}
+
+	function generatePrivateKey() {
+		var privateKey = generatePresharedKey();
+		normalizeKey(privateKey);
+		return privateKey;
+	}
+
+	function encodeBase64(dest, src) {
+		var input = Uint8Array.from([(src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63]);
+		for (var i = 0; i < 4; ++i)
+			dest[i] = input[i] + 65 +
+			(((25 - input[i]) >> 8) & 6) -
+			(((51 - input[i]) >> 8) & 75) -
+			(((61 - input[i]) >> 8) & 15) +
+			(((62 - input[i]) >> 8) & 3);
+	}
+
+	function keyToBase64(key) {
+		var i, base64 = new Uint8Array(44);
+		for (i = 0; i < 32 / 3; ++i)
+			encodeBase64(base64.subarray(i * 4), key.subarray(i * 3));
+		encodeBase64(base64.subarray(i * 4), Uint8Array.from([key[i * 3 + 0], key[i * 3 + 1], 0]));
+		base64[43] = 61;
+		return String.fromCharCode.apply(null, base64);
+	}
+
+	window.wireguard = {
+		generateKeypair: function() {
+			var privateKey = generatePrivateKey();
+			var publicKey = generatePublicKey(privateKey);
+			return {
+				publicKey: keyToBase64(publicKey),
+				privateKey: keyToBase64(privateKey)
+			};
+		}
+	};
+})();

commit 04f3a4f537e0725023a9d7f3d6f17002578d12f5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jan 7 18:03:39 2019 -0800

    Kconfig: IPsec isn't IPSec
    
    Reported-by: Raf Czlonka <rczlonka@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/README.md b/README.md
index 08f8827..b8301e2 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 # WireGuard &mdash; fast, modern, secure kernel VPN tunnel
 #### by [Jason A. Donenfeld](mailto:Jason@zx2c4.com) of [Edge Security](https://www.edgesecurity.com/)
 
-WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes **state-of-the-art cryptography**. It aims to be faster, simpler, leaner, and more useful than IPSec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. It runs over UDP.
+WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes **state-of-the-art cryptography**. It aims to be faster, simpler, leaner, and more useful than IPsec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. It runs over UDP.
 
 **More information may be found at [WireGuard.com](https://www.wireguard.com/).**
 

commit b8e89f3a0945b02281aa0d456917b421702c9bef
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 2 01:58:10 2019 +0100

    global: update copyright
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/dns-hatchet/apply.sh b/contrib/dns-hatchet/apply.sh
index 35460d1..2bf002d 100755
--- a/contrib/dns-hatchet/apply.sh
+++ b/contrib/dns-hatchet/apply.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 ME="$(readlink -f "$(dirname "$(readlink -f "$0")")")"
 TOOLS="$ME/../../../src/tools"
diff --git a/contrib/embeddable-wg-library/test.c b/contrib/embeddable-wg-library/test.c
index 6a3e7c7..25fc9ea 100644
--- a/contrib/embeddable-wg-library/test.c
+++ b/contrib/embeddable-wg-library/test.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: LGPL-2.1+
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include "wireguard.h"
diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index 370b3da..1522c91 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: LGPL-2.1+
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  * Copyright (C) 2008-2012 Pablo Neira Ayuso <pablo@netfilter.org>.
  */
 
diff --git a/contrib/embeddable-wg-library/wireguard.h b/contrib/embeddable-wg-library/wireguard.h
index e9210a4..9ebe47c 100644
--- a/contrib/embeddable-wg-library/wireguard.h
+++ b/contrib/embeddable-wg-library/wireguard.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: LGPL-2.1+ */
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef WIREGUARD_H
diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index a582797..0f8deda 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 package main
 
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index 5604a43..9fb78f2 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 extern crate snow;
 extern crate base64;
diff --git a/contrib/extract-handshakes/extract-handshakes.sh b/contrib/extract-handshakes/extract-handshakes.sh
index 16ed630..f794ffe 100755
--- a/contrib/extract-handshakes/extract-handshakes.sh
+++ b/contrib/extract-handshakes/extract-handshakes.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 # Copyright (C) 2017-2018 Peter Wu <peter@lekensteyn.nl>. All Rights Reserved.
 
 set -e
diff --git a/contrib/extract-handshakes/offset-finder.c b/contrib/extract-handshakes/offset-finder.c
index bd5824a..ecde5ac 100644
--- a/contrib/extract-handshakes/offset-finder.c
+++ b/contrib/extract-handshakes/offset-finder.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 struct def {
diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index e4033f9..09252a2 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 struct def {
diff --git a/contrib/extract-keys/extract-keys.c b/contrib/extract-keys/extract-keys.c
index f918a2a..1906be6 100644
--- a/contrib/extract-keys/extract-keys.c
+++ b/contrib/extract-keys/extract-keys.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <endian.h>
diff --git a/contrib/json/wg-json b/contrib/json/wg-json
index 3c36e65..8b35521 100755
--- a/contrib/json/wg-json
+++ b/contrib/json/wg-json
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 exec < <(exec wg show all dump)
 
diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
index d9365e0..af2a545 100644
--- a/contrib/keygen-html/keygen.html
+++ b/contrib/keygen-html/keygen.html
@@ -2,7 +2,7 @@
 <script>
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 function sendPubkeyToServer(pubkey, username, password)
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index 1e76787..6329c57 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <emscripten.h>
diff --git a/contrib/keygen-html/src/glue.js b/contrib/keygen-html/src/glue.js
index 981e533..5bd2511 100644
--- a/contrib/keygen-html/src/glue.js
+++ b/contrib/keygen-html/src/glue.js
@@ -1,6 +1,6 @@
 /*! SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 window["WireGuard"] = {
 	"generateKeypair": function() {
diff --git a/contrib/nat-hole-punching/nat-punch-client.c b/contrib/nat-hole-punching/nat-punch-client.c
index 09af278..01bb096 100644
--- a/contrib/nat-hole-punching/nat-punch-client.c
+++ b/contrib/nat-hole-punching/nat-punch-client.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Example only. Do not run in production.
  */
diff --git a/contrib/nat-hole-punching/nat-punch-server.c b/contrib/nat-hole-punching/nat-punch-server.c
index 2f49aa8..a6a5a4c 100644
--- a/contrib/nat-hole-punching/nat-punch-server.c
+++ b/contrib/nat-hole-punching/nat-punch-server.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Example only. Do not run in production.
  */
diff --git a/contrib/ncat-client-server/client-quick.sh b/contrib/ncat-client-server/client-quick.sh
index 8ef8f70..bf7d7f1 100755
--- a/contrib/ncat-client-server/client-quick.sh
+++ b/contrib/ncat-client-server/client-quick.sh
@@ -1,7 +1,7 @@
 #!/usr/bin/env bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
 
diff --git a/contrib/ncat-client-server/client.sh b/contrib/ncat-client-server/client.sh
index 7994f18..dd0f575 100755
--- a/contrib/ncat-client-server/client.sh
+++ b/contrib/ncat-client-server/client.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
 [[ $UID == 0 ]] || { echo "You must be root to run this."; exit 1; }
diff --git a/contrib/ncat-client-server/server.sh b/contrib/ncat-client-server/server.sh
index 08885b0..38a69e1 100755
--- a/contrib/ncat-client-server/server.sh
+++ b/contrib/ncat-client-server/server.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 if [[ -z $NCAT_REMOTE_ADDR ]]; then
 	ip link del dev wg0 2>/dev/null
diff --git a/contrib/reresolve-dns/reresolve-dns.sh b/contrib/reresolve-dns/reresolve-dns.sh
index 5b9394b..e579f86 100755
--- a/contrib/reresolve-dns/reresolve-dns.sh
+++ b/contrib/reresolve-dns/reresolve-dns.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
 shopt -s nocasematch
diff --git a/contrib/sticky-sockets/sticky-sockets.c b/contrib/sticky-sockets/sticky-sockets.c
index a26e29b..d856ef2 100644
--- a/contrib/sticky-sockets/sticky-sockets.c
+++ b/contrib/sticky-sockets/sticky-sockets.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This implements userspace semantics of "sticky sockets", modeled after
  * WireGuard's kernelspace implementation.
diff --git a/contrib/synergy/synergy-client.sh b/contrib/synergy/synergy-client.sh
index 997280a..de358ef 100755
--- a/contrib/synergy/synergy-client.sh
+++ b/contrib/synergy/synergy-client.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
 if [[ $UID == 0 ]]; then
diff --git a/contrib/synergy/synergy-server.sh b/contrib/synergy/synergy-server.sh
index eb3a20f..e04b1f4 100755
--- a/contrib/synergy/synergy-server.sh
+++ b/contrib/synergy/synergy-server.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
 if [[ $UID == 0 ]]; then
diff --git a/src/Makefile b/src/Makefile
index 4f3579f..483b703 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 PKG_CONFIG ?= pkg-config
 PREFIX ?= /usr
diff --git a/src/completion/wg-quick.bash-completion b/src/completion/wg-quick.bash-completion
index 7b14b75..1ec98d9 100644
--- a/src/completion/wg-quick.bash-completion
+++ b/src/completion/wg-quick.bash-completion
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_quick_completion() {
 	local p i a search_paths old_glob
diff --git a/src/completion/wg.bash-completion b/src/completion/wg.bash-completion
index 00ccfd3..cc6ac06 100644
--- a/src/completion/wg.bash-completion
+++ b/src/completion/wg.bash-completion
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_completion() {
 	local a
diff --git a/src/config.c b/src/config.c
index 1daa5ea..5d15356 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <arpa/inet.h>
diff --git a/src/config.h b/src/config.h
index 44f715a..9c31e8c 100644
--- a/src/config.h
+++ b/src/config.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef CONFIG_H
diff --git a/src/containers.h b/src/containers.h
index 619094e..2144052 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef CONTAINERS_H
diff --git a/src/curve25519.c b/src/curve25519.c
index c733a35..7949933 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2018-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include "curve25519.h"
diff --git a/src/curve25519.h b/src/curve25519.h
index ef0a09f..a5c3066 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef CURVE25519_H
diff --git a/src/encoding.c b/src/encoding.c
index d64b86e..efe004f 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a specialized constant-time base64/hex implementation that resists side-channel attacks.
  */
diff --git a/src/encoding.h b/src/encoding.h
index 8815c33..f977ee9 100644
--- a/src/encoding.h
+++ b/src/encoding.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef ENCODING_H
diff --git a/src/genkey.c b/src/genkey.c
index e50d64b..65711e1 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <errno.h>
diff --git a/src/ipc.c b/src/ipc.c
index 5879109..da31eff 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifdef __linux__
diff --git a/src/ipc.h b/src/ipc.h
index e75be20..6c564be 100644
--- a/src/ipc.h
+++ b/src/ipc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef IPC_H
diff --git a/src/mnlg.c b/src/mnlg.c
index 082f1a3..173e366 100644
--- a/src/mnlg.c
+++ b/src/mnlg.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
  */
diff --git a/src/mnlg.h b/src/mnlg.h
index 1bc46c7..b5adbbc 100644
--- a/src/mnlg.h
+++ b/src/mnlg.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
  */
diff --git a/src/pubkey.c b/src/pubkey.c
index 9741bcf..cbf1744 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <errno.h>
diff --git a/src/set.c b/src/set.c
index 9d84ccd..19f4b92 100644
--- a/src/set.c
+++ b/src/set.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdio.h>
diff --git a/src/setconf.c b/src/setconf.c
index 7135e85..8211ebd 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stddef.h>
diff --git a/src/show.c b/src/show.c
index b50af2a..ba6f115 100644
--- a/src/show.c
+++ b/src/show.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <arpa/inet.h>
diff --git a/src/showconf.c b/src/showconf.c
index 777e022..ad76b7f 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <arpa/inet.h>
diff --git a/src/subcommands.h b/src/subcommands.h
index 2a7e36e..afac10a 100644
--- a/src/subcommands.h
+++ b/src/subcommands.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef SUBCOMMANDS_H
diff --git a/src/terminal.c b/src/terminal.c
index bee3a44..899d6ca 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <ctype.h>
diff --git a/src/terminal.h b/src/terminal.h
index 0994895..a824ad7 100644
--- a/src/terminal.h
+++ b/src/terminal.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef TERMINAL_H
diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index e2b6abe..5eec36f 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a shell script written in C. It very intentionally still functions like
  * a shell script, calling out to external executables such as ip(8).
diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 30f3541..bf07fdb 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -1,7 +1,7 @@
 #!/usr/bin/env bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index c302a60..e83dbef 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -1,7 +1,7 @@
 #!/usr/local/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index fd62316..84643c4 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index e0c6d1a..9996162 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -1,7 +1,7 @@
 #!/usr/local/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg.c b/src/wg.c
index 4c24ff0..550d9b4 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stddef.h>

commit 53f9023e7e888a6d9d592a49e376fb75cb148563
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 20 18:30:21 2018 +0100

    wg: curve25519: handle unaligned loads/stores safely
    
    Reported-by: Chris Hewitt <chris@chrishewitt.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index c65b2ca..c733a35 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -39,9 +39,23 @@ typedef int64_t s64;
 #define le32_to_cpup(a) (*(a))
 #define cpu_to_le64(a) (a)
 #endif
-#define get_unaligned_le32(a) le32_to_cpup((u32 *)(a))
-#define get_unaligned_le64(a) le64_to_cpup((u64 *)(a))
-#define put_unaligned_le64(s, d) *(u64 *)(d) = cpu_to_le64(s)
+static inline __le32 get_unaligned_le32(const u8 *a)
+{
+	__le32 l;
+	__builtin_memcpy(&l, a, sizeof(l));
+	return le32_to_cpup(&l);
+}
+static inline __le64 get_unaligned_le64(const u8 *a)
+{
+	__le64 l;
+	__builtin_memcpy(&l, a, sizeof(l));
+	return le64_to_cpup(&l);
+}
+static inline void put_unaligned_le64(u64 s, u8 *d)
+{
+	__le64 l = cpu_to_le64(s);
+	__builtin_memcpy(d, &l, sizeof(l));
+}
 #ifndef __always_inline
 #define __always_inline __inline __attribute__((__always_inline__))
 #endif
@@ -70,7 +84,7 @@ static noinline void memzero_explicit(void *s, size_t count)
 
 void curve25519_generate_public(uint8_t pub[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE])
 {
-	static const uint8_t basepoint[CURVE25519_KEY_SIZE] = { 9 };
+	static const uint8_t basepoint[CURVE25519_KEY_SIZE] __aligned(sizeof(uintptr_t)) = { 9 };
 
 	curve25519(pub, secret, basepoint);
 }
diff --git a/src/pubkey.c b/src/pubkey.c
index cf8e256..9741bcf 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -13,7 +13,7 @@
 
 int pubkey_main(int argc, char *argv[])
 {
-	uint8_t key[WG_KEY_LEN];
+	uint8_t key[WG_KEY_LEN] __attribute__((aligned(sizeof(uintptr_t))));
 	char base64[WG_KEY_LEN_BASE64];
 	int trailing_char;
 

commit 89662178c6838a63834397ddc5363e2a2a6be251
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Dec 16 00:50:39 2018 +0100

    makefile: use immediate expansion and use correct template patterns
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/extract-handshakes/Makefile b/contrib/extract-handshakes/Makefile
index 36e951e..77b42f1 100644
--- a/contrib/extract-handshakes/Makefile
+++ b/contrib/extract-handshakes/Makefile
@@ -24,5 +24,6 @@ offset-finder-m := offset-finder.o
 oldsrc := $(src)
 src := $(src)/../../../src
 include $(src)/compat/Kbuild.include
+include $(src)/crypto/Kbuild.include
 src := $(oldsrc)
 endif
diff --git a/contrib/extract-keys/Makefile b/contrib/extract-keys/Makefile
index 8f5901a..1f7308d 100644
--- a/contrib/extract-keys/Makefile
+++ b/contrib/extract-keys/Makefile
@@ -27,5 +27,6 @@ config-m := config.o
 oldsrc := $(src)
 src := $(src)/../../../src
 include $(src)/compat/Kbuild.include
+include $(src)/crypto/Kbuild.include
 src := $(oldsrc)
 endif

commit 48a31572f199d6c6ac9eeed1015374bb9bbf258b
Author: Aaron Jones <aaronmdjones@gmail.com>
Date:   Sun Dec 16 21:04:02 2018 +0000

    wg-quick: bring interface up while setting MTU
    
    This avoids another ip(8) invocation for little benefit.
    Confirmed to work with iproute2 and busybox.
    
    Signed-off-by: Aaron Jones <aaronmdjones@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 48ce163..fd62316 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -112,18 +112,14 @@ del_if() {
 	cmd ip link delete dev "$INTERFACE"
 }
 
-up_if() {
-	cmd ip link set "$INTERFACE" up
-}
-
 add_addr() {
 	cmd ip address add "$1" dev "$INTERFACE"
 }
 
-set_mtu() {
+set_mtu_up() {
 	local mtu=0 endpoint output
 	if [[ -n $MTU ]]; then
-		cmd ip link set mtu "$MTU" dev "$INTERFACE"
+		cmd ip link set mtu "$MTU" up dev "$INTERFACE"
 		return
 	fi
 	while read -r _ endpoint; do
@@ -136,7 +132,7 @@ set_mtu() {
 		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
 	fi
 	[[ $mtu -gt 0 ]] || mtu=1500
-	cmd ip link set mtu $(( mtu - 80 )) dev "$INTERFACE"
+	cmd ip link set mtu $(( mtu - 80 )) up dev "$INTERFACE"
 }
 
 resolvconf_iface_prefix() {
@@ -286,8 +282,7 @@ cmd_up() {
 	for i in "${ADDRESSES[@]}"; do
 		add_addr "$i"
 	done
-	set_mtu
-	up_if
+	set_mtu_up
 	set_dns
 	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
 		add_route "$i"

commit 586b466394fb5f9ffba170f8ba1efc5e9bef7653
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 7 05:36:26 2018 +0100

    embeddable-wg-library: do not warn on unrecognized netlink attributes
    
    This is a follow up of bcf8684c9ec90fe0d283a67d1654d05fb3eae019.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index f0bdb5f..370b3da 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -66,6 +66,7 @@ enum wgpeer_attribute {
 	WGPEER_A_RX_BYTES,
 	WGPEER_A_TX_BYTES,
 	WGPEER_A_ALLOWEDIPS,
+	WGPEER_A_PROTOCOL_VERSION,
 	__WGPEER_A_LAST
 };
 
@@ -903,15 +904,6 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
-static void warn_unrecognized(const char *which)
-{
-	static bool once = false;
-	if (once)
-		return;
-	once = true;
-	fprintf(stderr, "Warning: one or more unrecognized %s attributes\n", which);
-}
-
 static int parse_linkinfo(const struct nlattr *attr, void *data)
 {
 	struct inflatable_buffer *buffer = data;
@@ -1233,8 +1225,6 @@ static int parse_allowedip(const struct nlattr *attr, void *data)
 		if (!mnl_attr_validate(attr, MNL_TYPE_U8))
 			allowedip->cidr = mnl_attr_get_u8(attr);
 		break;
-	default:
-		warn_unrecognized("netlink");
 	}
 
 	return MNL_CB_OK;
@@ -1326,8 +1316,6 @@ static int parse_peer(const struct nlattr *attr, void *data)
 		break;
 	case WGPEER_A_ALLOWEDIPS:
 		return mnl_attr_parse_nested(attr, parse_allowedips, peer);
-	default:
-		warn_unrecognized("netlink");
 	}
 
 	return MNL_CB_OK;
@@ -1396,8 +1384,6 @@ static int parse_device(const struct nlattr *attr, void *data)
 		break;
 	case WGDEVICE_A_PEERS:
 		return mnl_attr_parse_nested(attr, parse_peers, device);
-	default:
-		warn_unrecognized("netlink");
 	}
 
 	return MNL_CB_OK;

commit 4de77e0646acdd36eee42a8cb343d266764e0d5a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Nov 11 22:35:07 2018 -0500

    global: various formatting tweeks
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index b8368e9..f0bdb5f 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -87,39 +87,39 @@ enum wgallowedip_attribute {
 #define MNL_ATTR_HDRLEN MNL_ALIGN(sizeof(struct nlattr))
 
 enum mnl_attr_data_type {
-        MNL_TYPE_UNSPEC,
-        MNL_TYPE_U8,
-        MNL_TYPE_U16,
-        MNL_TYPE_U32,
-        MNL_TYPE_U64,
-        MNL_TYPE_STRING,
-        MNL_TYPE_FLAG,
-        MNL_TYPE_MSECS,
-        MNL_TYPE_NESTED,
-        MNL_TYPE_NESTED_COMPAT,
-        MNL_TYPE_NUL_STRING,
-        MNL_TYPE_BINARY,
-        MNL_TYPE_MAX,
+	MNL_TYPE_UNSPEC,
+	MNL_TYPE_U8,
+	MNL_TYPE_U16,
+	MNL_TYPE_U32,
+	MNL_TYPE_U64,
+	MNL_TYPE_STRING,
+	MNL_TYPE_FLAG,
+	MNL_TYPE_MSECS,
+	MNL_TYPE_NESTED,
+	MNL_TYPE_NESTED_COMPAT,
+	MNL_TYPE_NUL_STRING,
+	MNL_TYPE_BINARY,
+	MNL_TYPE_MAX,
 };
 
 #define mnl_attr_for_each(attr, nlh, offset) \
-        for ((attr) = mnl_nlmsg_get_payload_offset((nlh), (offset)); \
-             mnl_attr_ok((attr), (char *)mnl_nlmsg_get_payload_tail(nlh) - (char *)(attr)); \
-             (attr) = mnl_attr_next(attr))
+	for ((attr) = mnl_nlmsg_get_payload_offset((nlh), (offset)); \
+	     mnl_attr_ok((attr), (char *)mnl_nlmsg_get_payload_tail(nlh) - (char *)(attr)); \
+	     (attr) = mnl_attr_next(attr))
 
 #define mnl_attr_for_each_nested(attr, nest) \
-        for ((attr) = mnl_attr_get_payload(nest); \
-             mnl_attr_ok((attr), (char *)mnl_attr_get_payload(nest) + mnl_attr_get_payload_len(nest) - (char *)(attr)); \
-             (attr) = mnl_attr_next(attr))
+	for ((attr) = mnl_attr_get_payload(nest); \
+	     mnl_attr_ok((attr), (char *)mnl_attr_get_payload(nest) + mnl_attr_get_payload_len(nest) - (char *)(attr)); \
+	     (attr) = mnl_attr_next(attr))
 
 #define mnl_attr_for_each_payload(payload, payload_size) \
-        for ((attr) = (payload); \
-             mnl_attr_ok((attr), (char *)(payload) + payload_size - (char *)(attr)); \
-             (attr) = mnl_attr_next(attr))
+	for ((attr) = (payload); \
+	     mnl_attr_ok((attr), (char *)(payload) + payload_size - (char *)(attr)); \
+	     (attr) = mnl_attr_next(attr))
 
-#define MNL_CB_ERROR            -1
-#define MNL_CB_STOP              0
-#define MNL_CB_OK                1
+#define MNL_CB_ERROR	-1
+#define MNL_CB_STOP	0
+#define MNL_CB_OK	1
 
 typedef int (*mnl_attr_cb_t)(const struct nlattr *attr, void *data);
 typedef int (*mnl_cb_t)(const struct nlmsghdr *nlh, void *data);

commit 7e106d3a4c645064fc2ed6d5ff2b004391fd5ec2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Nov 11 22:11:56 2018 -0500

    wg-quick: android: do not choke on empty allowed-ips
    
    Reported-by: Samuel Holland <samuel@sholland.org>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index e397664..e2b6abe 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -512,8 +512,11 @@ static void set_routes(const char *iface, unsigned int netid)
 		if (!start)
 			continue;
 		++start;
-		for (char *allowedip = strtok(start, " \n"); allowedip; allowedip = strtok(NULL, " \n"))
+		for (char *allowedip = strtok(start, " \n"); allowedip; allowedip = strtok(NULL, " \n")) {
+			if (!strcmp(allowedip, "(none)"))
+				continue;
 			add_route(iface, netid, allowedip);
+		}
 	}
 }
 

commit 1aa8364b1767a84ce32ecec424820bdb98a286b1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Nov 6 03:30:06 2018 +0100

    keygen-html: add missing glue macro
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index 1e69d28..1e76787 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -30,6 +30,7 @@ enum { CURVE25519_KEY_SIZE = 32 };
 #else
 #define le32_to_cpup(a) __builtin_bswap32(*(a))
 #endif
+#define get_unaligned_le32(a) le32_to_cpup((u32 *)(a))
 
 #define memset(a, b, c) __builtin_memset(a, b, c)
 #define memcpy(a, b, c) __builtin_memcpy(a, b, c)

commit d9f06cbced962b0491c47db18af32e4a90ec8416
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Oct 19 03:35:25 2018 +0200

    wg.8: AllowedIPs isn't actually required
    
    An empty allowed IPs is totally valid, for folks wishing to move IP
    addresses between multiple peers atomically.
    
    Suggested-by: Comex <comexk@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg.8 b/src/man/wg.8
index 264773d..2013825 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -148,7 +148,7 @@ CIDR masks from which incoming traffic for this peer is allowed and to
 which outgoing traffic for this peer is directed. The catch-all
 \fI0.0.0.0/0\fP may be specified for matching all IPv4 addresses, and
 \fI::/0\fP may be specified for matching all IPv6 addresses. May be specified
-multiple times. Required.
+multiple times.
 .IP \(bu
 Endpoint \(em an endpoint IP or hostname, followed by a colon, and then a
 port number. This endpoint will be updated automatically to the most recent

commit b37a1f46ae1c8c90257f3e1a4252c1b6218d789c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Oct 19 03:33:53 2018 +0200

    wg.8: specify that wg(8) shows runtime info too
    
    Suggested-by: Comex <comexk@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg.8 b/src/man/wg.8
index 5bae7ca..264773d 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -37,7 +37,7 @@ Sub-commands that take an INTERFACE must be passed a WireGuard interface.
 
 .TP
 \fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIlisten-port\fP | \fIfwmark\fP | \fIpeers\fP | \fIpreshared-keys\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fItransfer\fP | \fIdump\fP]
-Shows current WireGuard configuration of specified \fI<interface>\fP.
+Shows current WireGuard configuration and runtime information of specified \fI<interface>\fP.
 If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
 If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,
 one per line, and quit. If no options are given after the interface

commit 4410c87c39ccbbd7152bdcb67b0f66ecdcf27c9a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Oct 12 16:55:35 2018 +0200

    wg-quick: wait for interface to disappear on freebsd
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index a2bdafb..c302a60 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -137,8 +137,17 @@ del_routes() {
 }
 
 del_if() {
+	local line monitor_pid
 	[[ $HAVE_SET_DNS -eq 0 ]] || unset_dns
+	exec 39< <(exec route -n monitor 2>/dev/null)
+	monitor_pid=$!
 	cmd rm -f "/var/run/wireguard/$INTERFACE.sock"
+	while ifconfig "$INTERFACE" >/dev/null 2>&1; do
+		while read -r line; do
+			[[ $line =~ ^RTM_IFANNOUNCE:.* ]] && break
+		done <&39
+	done
+	kill $monitor_pid
 }
 
 up_if() {

commit 599b84fbd18a0662661017f9f7e346567587ce31
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Oct 12 16:40:29 2018 +0200

    wg: don't fail if a netlink interface dump is inconsistent
    
    Netlink returns NLM_F_DUMP_INTR if the set of all tunnels changed
    during the dump. That's unfortunate, but is pretty common on busy
    systems that are adding and removing tunnels all the time. Rather
    than retrying, potentially indefinitely, we just work with the
    partial results.
    
    Reported-by: Robert Gerus <ar@is-a.cat>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index a32fd50..b8368e9 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -998,8 +998,15 @@ another:
 		goto cleanup;
 	}
 	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, buffer)) < 0) {
-		ret = -errno;
-		goto cleanup;
+		/* Netlink returns NLM_F_DUMP_INTR if the set of all tunnels changed
+		 * during the dump. That's unfortunate, but is pretty common on busy
+		 * systems that are adding and removing tunnels all the time. Rather
+		 * than retrying, potentially indefinitely, we just work with the
+		 * partial results. */
+		if (errno != EINTR) {
+			ret = -errno;
+			goto cleanup;
+		}
 	}
 	if (len == MNL_CB_OK + 1)
 		goto another;
diff --git a/src/ipc.c b/src/ipc.c
index c64e332..5879109 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -530,8 +530,15 @@ another:
 		goto cleanup;
 	}
 	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, buffer)) < 0) {
-		ret = -errno;
-		goto cleanup;
+		/* Netlink returns NLM_F_DUMP_INTR if the set of all tunnels changed
+		 * during the dump. That's unfortunate, but is pretty common on busy
+		 * systems that are adding and removing tunnels all the time. Rather
+		 * than retrying, potentially indefinitely, we just work with the
+		 * partial results. */
+		if (errno != EINTR) {
+			ret = -errno;
+			goto cleanup;
+		}
 	}
 	if (len == MNL_CB_OK + 1)
 		goto another;

commit 9b1394b2dc1ee4696932fe0db1624f6fa8c9545c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 9 15:23:42 2018 +0200

    wg: compile on gnu99
    
    We don't actually use any C11 features, so we can at least compile with
    ancient gcc.
    
    Reported-by: Aaron M. D. Jones <aaronmdjones@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index a7cdaaa..4f3579f 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -38,7 +38,7 @@ endif
 PLATFORM ?= $(shell uname -s | tr '[:upper:]' '[:lower:]')
 
 CFLAGS ?= -O3
-CFLAGS += -std=gnu11 -D_GNU_SOURCE
+CFLAGS += -std=gnu99 -D_GNU_SOURCE
 CFLAGS += -Wall -Wextra
 CFLAGS += -MMD -MP
 CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""

commit c1ca487f634c3fb382fcc5b65fdd8efa4dfdbe69
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 9 15:21:27 2018 +0200

    wg: use libc's endianness macro if no compiler macro
    
    This lets us be compiled with ancient gcc.
    
    Reported-by: Jeff Brandt <jeff@jeffcolo.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 1852df5..c65b2ca 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -8,6 +8,16 @@
 #include <stdint.h>
 #include <string.h>
 
+#ifndef __BYTE_ORDER__
+#include <sys/param.h>
+#if !defined(BYTE_ORDER) || !defined(BIG_ENDIAN) || !defined(LITTLE_ENDIAN)
+#error "Unable to determine endianness."
+#endif
+#define __BYTE_ORDER__ BYTE_ORDER
+#define __ORDER_BIG_ENDIAN__ BIG_ENDIAN
+#define __ORDER_LITTLE_ENDIAN__ LITTLE_ENDIAN
+#endif
+
 #ifdef __linux__
 #include <linux/types.h>
 typedef __u64 u64;

commit 846d2514c56385aa001b52d00f267f09796a85b9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 8 03:36:20 2018 +0200

    global: rename struct wireguard_ to struct wg_
    
    This required a bit of pruning of our christmas trees.
    
    Suggested-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index 1dad1ce..e4033f9 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -17,11 +17,11 @@ const struct def defs[] = {
 	{ "SOCK_DEVICE_OFFSET", offsetof(struct sock, sk_user_data) },
 	{ "DEVICE_NAME_OFFSET", -ALIGN(sizeof(struct net_device), NETDEV_ALIGN) + offsetof(struct net_device, name) },
 	{ "IFNAMSIZ", IFNAMSIZ },
-	{ "DEVICE_PEERS_OFFSET", offsetof(struct wireguard_device, peer_list) },
-	{ "PEERS_PEER_OFFSET", -offsetof(struct wireguard_peer, peer_list) },
-	{ "PEER_CURRENTKEY_OFFSET", offsetof(struct wireguard_peer, keypairs.current_keypair) },
-	{ "PEER_PREVIOUSKEY_OFFSET", offsetof(struct wireguard_peer, keypairs.previous_keypair) },
-	{ "PEER_NEXTKEY_OFFSET", offsetof(struct wireguard_peer, keypairs.next_keypair) },
+	{ "DEVICE_PEERS_OFFSET", offsetof(struct wg_device, peer_list) },
+	{ "PEERS_PEER_OFFSET", -offsetof(struct wg_peer, peer_list) },
+	{ "PEER_CURRENTKEY_OFFSET", offsetof(struct wg_peer, keypairs.current_keypair) },
+	{ "PEER_PREVIOUSKEY_OFFSET", offsetof(struct wg_peer, keypairs.previous_keypair) },
+	{ "PEER_NEXTKEY_OFFSET", offsetof(struct wg_peer, keypairs.next_keypair) },
 	{ "KEY_LOCALID_OFFSET", offsetof(struct noise_keypair, entry.index) },
 	{ "KEY_REMOTEID_OFFSET", offsetof(struct noise_keypair, remote_index) },
 	{ "KEY_SENDING_OFFSET", offsetof(struct noise_keypair, sending.key) },

commit 54569b7999252c223dd387117383bb3e727cb8aa
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 8 03:06:47 2018 +0200

    netlink: do not stuff index into nla type
    
    It's not used for anything, and LKML doesn't like the type being used as
    an index value.
    
    Suggested-by: Eugene Syromiatnikov <esyr@redhat.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index 6d4ddd8..a32fd50 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -1074,7 +1074,6 @@ cleanup:
 int wg_set_device(wg_device *dev)
 {
 	int ret = 0;
-	size_t i, j;
 	wg_peer *peer = NULL;
 	wg_allowedip *allowedip = NULL;
 	struct nlattr *peers_nest, *peer_nest, *allowedips_nest, *allowedip_nest;
@@ -1107,10 +1106,10 @@ again:
 		goto send;
 	peers_nest = peer_nest = allowedips_nest = allowedip_nest = NULL;
 	peers_nest = mnl_attr_nest_start(nlh, WGDEVICE_A_PEERS);
-	for (i = 0, peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
+	for (peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
 		uint32_t flags = 0;
 
-		peer_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, i++);
+		peer_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, 0);
 		if (!peer_nest)
 			goto toobig_peers;
 		if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PUBLIC_KEY, sizeof(peer->public_key), peer->public_key))
@@ -1146,8 +1145,8 @@ again:
 			allowedips_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ALLOWEDIPS);
 			if (!allowedips_nest)
 				goto toobig_allowedips;
-			for (j = 0; allowedip; allowedip = allowedip->next_allowedip) {
-				allowedip_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, j++);
+			for (; allowedip; allowedip = allowedip->next_allowedip) {
+				allowedip_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, 0);
 				if (!allowedip_nest)
 					goto toobig_allowedips;
 				if (!mnl_attr_put_u16_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_FAMILY, allowedip->family))
diff --git a/src/ipc.c b/src/ipc.c
index bc89f02..c64e332 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -547,7 +547,6 @@ cleanup:
 static int kernel_set_device(struct wgdevice *dev)
 {
 	int ret = 0;
-	size_t i, j;
 	struct wgpeer *peer = NULL;
 	struct wgallowedip *allowedip = NULL;
 	struct nlattr *peers_nest, *peer_nest, *allowedips_nest, *allowedip_nest;
@@ -580,10 +579,10 @@ again:
 		goto send;
 	peers_nest = peer_nest = allowedips_nest = allowedip_nest = NULL;
 	peers_nest = mnl_attr_nest_start(nlh, WGDEVICE_A_PEERS);
-	for (i = 0, peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
+	for (peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
 		uint32_t flags = 0;
 
-		peer_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, i++);
+		peer_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, 0);
 		if (!peer_nest)
 			goto toobig_peers;
 		if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PUBLIC_KEY, sizeof(peer->public_key), peer->public_key))
@@ -619,8 +618,8 @@ again:
 			allowedips_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ALLOWEDIPS);
 			if (!allowedips_nest)
 				goto toobig_allowedips;
-			for (j = 0; allowedip; allowedip = allowedip->next_allowedip) {
-				allowedip_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, j++);
+			for (; allowedip; allowedip = allowedip->next_allowedip) {
+				allowedip_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, 0);
 				if (!allowedip_nest)
 					goto toobig_allowedips;
 				if (!mnl_attr_put_u16_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_FAMILY, allowedip->family))

commit 6790b078687949461799ee6862b283393cebe73f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Oct 7 15:35:51 2018 +0200

    crypto: clean up remaining .h->.c
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index 50d35de..1e69d28 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -44,7 +44,7 @@ static __always_inline void normalize_secret(u8 secret[CURVE25519_KEY_SIZE])
 	secret[31] |= 64;
 }
 
-#include "../../../../src/crypto/zinc/curve25519/curve25519-fiat32.h"
+#include "../../../../src/crypto/zinc/curve25519/curve25519-fiat32.c"
 
 EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(u8 public[static 32], const u8 private[static 32])
 {
diff --git a/src/curve25519.c b/src/curve25519.c
index 5367c06..1852df5 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -53,9 +53,9 @@ static noinline void memzero_explicit(void *s, size_t count)
 }
 
 #ifdef __SIZEOF_INT128__
-#include "../crypto/zinc/curve25519/curve25519-hacl64.h"
+#include "../crypto/zinc/curve25519/curve25519-hacl64.c"
 #else
-#include "../crypto/zinc/curve25519/curve25519-fiat32.h"
+#include "../crypto/zinc/curve25519/curve25519-fiat32.c"
 #endif
 
 void curve25519_generate_public(uint8_t pub[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE])

commit 09c7ab77e92d0de22cbf34262f14cb507132ef22
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Oct 5 19:19:08 2018 +0200

    wg-quick.8: add policy routing example
    
    Suggested-by: Toke Hiland-Jrgensen <toke@toke.dk>
    Suggested-by: Konstantin Ryabitsev <konstantin@linuxfoundation.org>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg-quick.8 b/src/man/wg-quick.8
index 8f0c487..00d7dba 100644
--- a/src/man/wg-quick.8
+++ b/src/man/wg-quick.8
@@ -205,6 +205,32 @@ Notice the two `Address' lines at the top, and that `SaveConfig' is set to `true
 that the configuration file should be saved on shutdown using the current status of the
 interface.
 
+A combination of the `Table', `PostUp', and `PreDown' fields may be used for policy routing
+as well. For example, the following may be used to send SSH traffic (TCP port 22) traffic
+through the tunnel:
+
+    [Interface]
+.br
+    Address = 10.192.122.1/24
+.br
+    PrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=
+.br
+    ListenPort = 51820
+.br
+    \fBTable = 1234\fP
+.br
+    \fBPostUp = ip rule add ipproto tcp dport 22 table 1234\fP
+.br
+    \fBPreDown = ip rule delete ipproto tcp dport 22 table 1234\fP
+.br
+
+.br
+    [Peer]
+.br
+    PublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=
+.br
+    AllowedIPs = 0.0.0.0/0
+
 These configuration files may be placed in any directory, putting the desired interface name
 in the filename:
 

commit 646d7a5c78f98b61feae6c39594de29c3bfc078f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Sep 24 22:02:13 2018 +0200

    crypto: make constant naming scheme consistent
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index c280b89..50d35de 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -10,7 +10,7 @@ typedef unsigned int u32;
 typedef unsigned char u8;
 typedef u32 __le32;
 
-enum { CURVE25519_POINT_SIZE = 32 };
+enum { CURVE25519_KEY_SIZE = 32 };
 
 #ifndef __always_inline
 #define __always_inline __inline __attribute__((__always_inline__))
@@ -37,7 +37,7 @@ enum { CURVE25519_POINT_SIZE = 32 };
 /* We don't even attempt to deal with this in javascript. */
 #define memzero_explicit(a, b)
 
-static __always_inline void normalize_secret(u8 secret[CURVE25519_POINT_SIZE])
+static __always_inline void normalize_secret(u8 secret[CURVE25519_KEY_SIZE])
 {
 	secret[0] &= 248;
 	secret[31] &= 127;
diff --git a/src/curve25519.c b/src/curve25519.c
index e76588b..5367c06 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -58,14 +58,14 @@ static noinline void memzero_explicit(void *s, size_t count)
 #include "../crypto/zinc/curve25519/curve25519-fiat32.h"
 #endif
 
-void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE])
+void curve25519_generate_public(uint8_t pub[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE])
 {
-	static const uint8_t basepoint[CURVE25519_POINT_SIZE] = { 9 };
+	static const uint8_t basepoint[CURVE25519_KEY_SIZE] = { 9 };
 
 	curve25519(pub, secret, basepoint);
 }
 
-void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE])
+void curve25519(uint8_t mypublic[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE], const uint8_t basepoint[static CURVE25519_KEY_SIZE])
 {
 	curve25519_generic(mypublic, secret, basepoint);
 }
diff --git a/src/curve25519.h b/src/curve25519.h
index 09ca6b9..ef0a09f 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -10,12 +10,12 @@
 #include <sys/types.h>
 
 enum curve25519_lengths {
-	CURVE25519_POINT_SIZE = 32,
+	CURVE25519_KEY_SIZE = 32,
 };
 
-void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE]);
-void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE]);
-static inline void curve25519_normalize_secret(uint8_t secret[static CURVE25519_POINT_SIZE])
+void curve25519(uint8_t mypublic[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE], const uint8_t basepoint[static CURVE25519_KEY_SIZE]);
+void curve25519_generate_public(uint8_t pub[static CURVE25519_KEY_SIZE], const uint8_t secret[static CURVE25519_KEY_SIZE]);
+static inline void curve25519_normalize_secret(uint8_t secret[static CURVE25519_KEY_SIZE])
 {
 	secret[0] &= 248;
 	secret[31] &= 127;

commit cef7ac9ef9b9a5ecf75e8e63e32dd745f3c370aa
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Sep 20 01:49:47 2018 +0200

    global: put SPDX identifier on its own line
    
    The kernel has very specific rules correlating file type with comment
    type, and also SPDX identifiers can't be merged with other comments.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/test.c b/contrib/embeddable-wg-library/test.c
index 8d4aae3..6a3e7c7 100644
--- a/contrib/embeddable-wg-library/test.c
+++ b/contrib/embeddable-wg-library/test.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: LGPL-2.1+
- *
+// SPDX-License-Identifier: LGPL-2.1+
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index a65dbce..6d4ddd8 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: LGPL-2.1+
- *
+// SPDX-License-Identifier: LGPL-2.1+
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  * Copyright (C) 2008-2012 Pablo Neira Ayuso <pablo@netfilter.org>.
  */
diff --git a/contrib/embeddable-wg-library/wireguard.h b/contrib/embeddable-wg-library/wireguard.h
index 53d9d5d..e9210a4 100644
--- a/contrib/embeddable-wg-library/wireguard.h
+++ b/contrib/embeddable-wg-library/wireguard.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: LGPL-2.1+
- *
+/* SPDX-License-Identifier: LGPL-2.1+ */
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/contrib/extract-handshakes/offset-finder.c b/contrib/extract-handshakes/offset-finder.c
index d0bc69c..bd5824a 100644
--- a/contrib/extract-handshakes/offset-finder.c
+++ b/contrib/extract-handshakes/offset-finder.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index 4ec6a76..1dad1ce 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/contrib/extract-keys/extract-keys.c b/contrib/extract-keys/extract-keys.c
index fc757a2..f918a2a 100644
--- a/contrib/extract-keys/extract-keys.c
+++ b/contrib/extract-keys/extract-keys.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index ae7bda6..c280b89 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/contrib/nat-hole-punching/nat-punch-client.c b/contrib/nat-hole-punching/nat-punch-client.c
index 0133c3c..09af278 100644
--- a/contrib/nat-hole-punching/nat-punch-client.c
+++ b/contrib/nat-hole-punching/nat-punch-client.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Example only. Do not run in production.
diff --git a/contrib/nat-hole-punching/nat-punch-server.c b/contrib/nat-hole-punching/nat-punch-server.c
index 29e065e..2f49aa8 100644
--- a/contrib/nat-hole-punching/nat-punch-server.c
+++ b/contrib/nat-hole-punching/nat-punch-server.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Example only. Do not run in production.
diff --git a/contrib/sticky-sockets/sticky-sockets.c b/contrib/sticky-sockets/sticky-sockets.c
index 879b296..a26e29b 100644
--- a/contrib/sticky-sockets/sticky-sockets.c
+++ b/contrib/sticky-sockets/sticky-sockets.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This implements userspace semantics of "sticky sockets", modeled after
diff --git a/src/config.c b/src/config.c
index 93525fb..1daa5ea 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/config.h b/src/config.h
index 9dec248..44f715a 100644
--- a/src/config.h
+++ b/src/config.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/containers.h b/src/containers.h
index 455d998..619094e 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/curve25519.c b/src/curve25519.c
index 8197c17..e76588b 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/curve25519.h b/src/curve25519.h
index 6028bb5..09ca6b9 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/encoding.c b/src/encoding.c
index 2e2d915..d64b86e 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a specialized constant-time base64/hex implementation that resists side-channel attacks.
diff --git a/src/encoding.h b/src/encoding.h
index 0e361ff..8815c33 100644
--- a/src/encoding.h
+++ b/src/encoding.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/genkey.c b/src/genkey.c
index d2d4c53..e50d64b 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/ipc.c b/src/ipc.c
index e3ef789..bc89f02 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/ipc.h b/src/ipc.h
index 89e26cc..e75be20 100644
--- a/src/ipc.h
+++ b/src/ipc.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/mnlg.c b/src/mnlg.c
index c68ead1..082f1a3 100644
--- a/src/mnlg.c
+++ b/src/mnlg.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
diff --git a/src/mnlg.h b/src/mnlg.h
index fab3afd..1bc46c7 100644
--- a/src/mnlg.h
+++ b/src/mnlg.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
diff --git a/src/pubkey.c b/src/pubkey.c
index 385145b..cf8e256 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/set.c b/src/set.c
index d44fed9..9d84ccd 100644
--- a/src/set.c
+++ b/src/set.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/setconf.c b/src/setconf.c
index 012c245..7135e85 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/show.c b/src/show.c
index 9f98286..b50af2a 100644
--- a/src/show.c
+++ b/src/show.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/showconf.c b/src/showconf.c
index 313ad23..777e022 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/subcommands.h b/src/subcommands.h
index c4aa4c6..2a7e36e 100644
--- a/src/subcommands.h
+++ b/src/subcommands.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/terminal.c b/src/terminal.c
index e3f6039..bee3a44 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/terminal.h b/src/terminal.h
index 8c2ffa6..0994895 100644
--- a/src/terminal.h
+++ b/src/terminal.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 796607d..e397664 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a shell script written in C. It very intentionally still functions like
diff --git a/src/wg.c b/src/wg.c
index 18a1480..4c24ff0 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+// SPDX-License-Identifier: GPL-2.0
+/*
  * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 

commit 17546fcd755d8f327ddce7d3558361bd36d2dbad
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Sep 4 10:44:42 2018 -0600

    global: prefer sizeof(*pointer) when possible
    
    Suggested-by: Sultan Alsawaf <sultanxda@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 8e327be..93525fb 100644
--- a/src/config.c
+++ b/src/config.c
@@ -310,7 +310,7 @@ static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **la
 		saved_entry = strdup(mask);
 		ip = strsep(&mask, "/");
 
-		new_allowedip = calloc(1, sizeof(struct wgallowedip));
+		new_allowedip = calloc(1, sizeof(*new_allowedip));
 		if (!new_allowedip) {
 			perror("calloc");
 			free(saved_entry);
@@ -464,8 +464,8 @@ out:
 
 bool config_read_init(struct config_ctx *ctx, bool append)
 {
-	memset(ctx, 0, sizeof(struct config_ctx));
-	ctx->device = calloc(1, sizeof(struct wgdevice));
+	memset(ctx, 0, sizeof(*ctx));
+	ctx->device = calloc(1, sizeof(*ctx->device));
 	if (!ctx->device) {
 		perror("calloc");
 		return false;
@@ -511,7 +511,7 @@ static char *strip_spaces(const char *in)
 
 struct wgdevice *config_read_cmd(char *argv[], int argc)
 {
-	struct wgdevice *device = calloc(1, sizeof(struct wgdevice));
+	struct wgdevice *device = calloc(1, sizeof(*device));
 	struct wgpeer *peer = NULL;
 	struct wgallowedip *allowedip = NULL;
 
@@ -537,7 +537,7 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 			argv += 2;
 			argc -= 2;
 		} else if (!strcmp(argv[0], "peer") && argc >= 2) {
-			struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
+			struct wgpeer *new_peer = calloc(1, sizeof(*new_peer));
 
 			allowedip = NULL;
 			if (!new_peer) {
diff --git a/src/ipc.c b/src/ipc.c
index 06590e2..e3ef789 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -294,7 +294,7 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 	FILE *f;
 	int ret = -EPROTO;
 
-	*out = dev = calloc(1, sizeof(struct wgdevice));
+	*out = dev = calloc(1, sizeof(*dev));
 	if (!dev)
 		return -errno;
 
@@ -332,7 +332,7 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			dev->fwmark = NUM(0xffffffffU);
 			dev->flags |= WGDEVICE_HAS_FWMARK;
 		} else if (!strcmp(key, "public_key")) {
-			struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
+			struct wgpeer *new_peer = calloc(1, sizeof(*new_peer));
 
 			if (!new_peer) {
 				ret = -ENOMEM;
@@ -398,7 +398,7 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 
 			if (!mask || !isdigit(mask[0]))
 				break;
-			new_allowedip = calloc(1, sizeof(struct wgallowedip));
+			new_allowedip = calloc(1, sizeof(*new_allowedip));
 			if (!new_allowedip) {
 				ret = -ENOMEM;
 				goto err;
@@ -708,7 +708,7 @@ static int parse_allowedip(const struct nlattr *attr, void *data)
 static int parse_allowedips(const struct nlattr *attr, void *data)
 {
 	struct wgpeer *peer = data;
-	struct wgallowedip *new_allowedip = calloc(1, sizeof(struct wgallowedip));
+	struct wgallowedip *new_allowedip = calloc(1, sizeof(*new_allowedip));
 	int ret;
 
 	if (!new_allowedip) {
@@ -787,7 +787,7 @@ static int parse_peer(const struct nlattr *attr, void *data)
 static int parse_peers(const struct nlattr *attr, void *data)
 {
 	struct wgdevice *device = data;
-	struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
+	struct wgpeer *new_peer = calloc(1, sizeof(*new_peer));
 	int ret;
 
 	if (!new_peer) {
@@ -886,7 +886,7 @@ static int kernel_get_device(struct wgdevice **device, const char *interface)
 	struct mnlg_socket *nlg;
 
 try_again:
-	*device = calloc(1, sizeof(struct wgdevice));
+	*device = calloc(1, sizeof(**device));
 	if (!*device)
 		return -errno;
 
diff --git a/src/show.c b/src/show.c
index b7f665c..9f98286 100644
--- a/src/show.c
+++ b/src/show.c
@@ -53,12 +53,12 @@ static void sort_peers(struct wgdevice *device)
 		++peer_count;
 	if (!peer_count)
 		return;
-	peers = calloc(peer_count, sizeof(struct wgpeer *));
+	peers = calloc(peer_count, sizeof(*peers));
 	if (!peers)
 		return;
 	for_each_wgpeer(device, peer)
 		peers[i++] = peer;
-	qsort(peers, peer_count, sizeof(struct wgpeer *), peer_cmp);
+	qsort(peers, peer_count, sizeof(*peers), peer_cmp);
 	device->first_peer = peers[0];
 	peers[0]->next_peer = NULL;
 	for (i = 1; i < peer_count; ++i) {

commit 4d59d1f2c585d11d459089edbdec3e65b06ebb58
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Aug 28 23:50:35 2018 -0600

    crypto: import zinc
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index 3b560a5..ae7bda6 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -44,7 +44,7 @@ static __always_inline void normalize_secret(u8 secret[CURVE25519_POINT_SIZE])
 	secret[31] |= 64;
 }
 
-#include "../../../../src/crypto/curve25519-fiat32.h"
+#include "../../../../src/crypto/zinc/curve25519/curve25519-fiat32.h"
 
 EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(u8 public[static 32], const u8 private[static 32])
 {
diff --git a/src/curve25519.c b/src/curve25519.c
index 043aefc..8197c17 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -53,9 +53,9 @@ static noinline void memzero_explicit(void *s, size_t count)
 }
 
 #ifdef __SIZEOF_INT128__
-#include "../crypto/curve25519-hacl64.h"
+#include "../crypto/zinc/curve25519/curve25519-hacl64.h"
 #else
-#include "../crypto/curve25519-fiat32.h"
+#include "../crypto/zinc/curve25519/curve25519-fiat32.h"
 #endif
 
 void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE])

commit 407b0cb311d5bb6389ff3f345f5f3669222068c9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Sep 2 19:25:32 2018 -0600

    wg: ipc: do not warn on unrecognized netlink attributes
    
    It makes extending things more difficult.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index e29a939..06590e2 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -95,15 +95,6 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
-static void warn_unrecognized(const char *which)
-{
-	static bool once = false;
-	if (once)
-		return;
-	once = true;
-	fprintf(stderr, "Warning: one or more unrecognized %s attributes\n", which);
-}
-
 static FILE *userspace_interface_file(const char *interface)
 {
 	struct stat sbuf;
@@ -438,8 +429,6 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			peer->tx_bytes = NUM(0xffffffffffffffffULL);
 		else if (!strcmp(key, "errno"))
 			ret = -NUM(0x7fffffffU);
-		else
-			warn_unrecognized("daemon");
 	}
 	ret = -EPROTO;
 err:
@@ -711,8 +700,6 @@ static int parse_allowedip(const struct nlattr *attr, void *data)
 		if (!mnl_attr_validate(attr, MNL_TYPE_U8))
 			allowedip->cidr = mnl_attr_get_u8(attr);
 		break;
-	default:
-		warn_unrecognized("netlink");
 	}
 
 	return MNL_CB_OK;
@@ -792,8 +779,6 @@ static int parse_peer(const struct nlattr *attr, void *data)
 		break;
 	case WGPEER_A_ALLOWEDIPS:
 		return mnl_attr_parse_nested(attr, parse_allowedips, peer);
-	default:
-		warn_unrecognized("netlink");
 	}
 
 	return MNL_CB_OK;
@@ -862,8 +847,6 @@ static int parse_device(const struct nlattr *attr, void *data)
 		break;
 	case WGDEVICE_A_PEERS:
 		return mnl_attr_parse_nested(attr, parse_peers, device);
-	default:
-		warn_unrecognized("netlink");
 	}
 
 	return MNL_CB_OK;

commit 66054f3638852606f71379d96086705166bbaed9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Aug 23 18:08:03 2018 -0700

    crypto: use unaligned helpers
    
    This is not useful for WireGuard, but for the general use case we
    probably want it this way, and the speed difference is mostly lost in
    the noise.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index b030853..043aefc 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -29,6 +29,9 @@ typedef int64_t s64;
 #define le32_to_cpup(a) (*(a))
 #define cpu_to_le64(a) (a)
 #endif
+#define get_unaligned_le32(a) le32_to_cpup((u32 *)(a))
+#define get_unaligned_le64(a) le64_to_cpup((u64 *)(a))
+#define put_unaligned_le64(s, d) *(u64 *)(d) = cpu_to_le64(s)
 #ifndef __always_inline
 #define __always_inline __inline __attribute__((__always_inline__))
 #endif

commit b2ec7892c8c6a87be541ae1ae6d005bc39704398
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Aug 21 15:42:17 2018 -0700

    wg-quick: check correct variable for route deduplication
    
    Reported-by: John Sager <john@sager.me.uk>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 3f1976b..48ce163 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -168,7 +168,7 @@ add_route() {
 	elif [[ $1 == */0 ]]; then
 		add_default "$1"
 	else
-		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || cmd ip route add "$1" dev "$INTERFACE"
+		[[ $(ip route get "$1" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || cmd ip route add "$1" dev "$INTERFACE"
 	fi
 }
 

commit ffcc09358e98aa82f658df21cdaa4aef46b27e83
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Aug 12 00:28:28 2018 -0700

    wg-quick: darwin: prefer system paths for tools
    
    The only things wg-quick(8) needs from Homebrew are bash(1) and wg(8).
    Other than that, it's explicitly coded against the native system
    utilities. Since wg-quick(8) and bash(1) are invoked in auto_su by their
    full absolute path (via $SELF and $BASH, respectively), we can simply
    set the $PATH to be prefixed by the default system binary paths. This
    way, if users install tools that conflict with system tools -- such as
    GNU coreutils -- we won't accidently call those.
    
    Reported-by: Deirdre Connolly <durumcrustulum@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index ece16f2..30f3541 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -11,7 +11,7 @@ export LC_ALL=C
 SELF="${BASH_SOURCE[0]}"
 [[ $SELF == */* ]] || SELF="./$SELF"
 SELF="$(cd "${SELF%/*}" && pwd -P)/${SELF##*/}"
-export PATH="${SELF%/*}:$PATH"
+export PATH="/usr/bin:/bin:/usr/sbin:/sbin:${SELF%/*}:$PATH"
 
 WG_CONFIG=""
 INTERFACE=""

commit 544d965d5fd77a4d314690b678f1e9b614ad34bb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jul 24 18:05:33 2018 +0200

    wg-quick: android: remove compat code
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 610e99c..796607d 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -38,16 +38,6 @@
 
 static bool is_exiting = false;
 
-#if defined(__ANDROID_API__) && __ANDROID_API__ < 24
-static char *strchrnul(const char *s, int c)
-{
-	char *x = strchr(s, c);
-	if (!x)
-		return (char *)s + strlen(s);
-	return x;
-}
-#endif
-
 static void *xmalloc(size_t size)
 {
 	void *ret = malloc(size);

commit f621f368002806982acaae4b5bc92ee72342d587
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jul 24 13:12:40 2018 +0200

    wg-quick: android: allow package to be overridden
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 12108c0..610e99c 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -7,6 +7,7 @@
  */
 
 #define _GNU_SOURCE
+#include <stddef.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdbool.h>
@@ -24,8 +25,11 @@
 #include <sys/wait.h>
 #include <sys/param.h>
 
+#ifndef WG_PACKAGE_NAME
+#define WG_PACKAGE_NAME "com.wireguard.android"
+#endif
 #ifndef WG_CONFIG_SEARCH_PATHS
-#define WG_CONFIG_SEARCH_PATHS "/data/misc/wireguard /data/data/com.wireguard.android/files"
+#define WG_CONFIG_SEARCH_PATHS "/data/misc/wireguard /data/data/" WG_PACKAGE_NAME "/files"
 #endif
 
 #define _printf_(x, y) __attribute__((format(printf, x, y)))
@@ -34,7 +38,7 @@
 
 static bool is_exiting = false;
 
-/* TODO: remove this once the NDK supports it. */
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 24
 static char *strchrnul(const char *s, int c)
 {
 	char *x = strchr(s, c);
@@ -42,6 +46,7 @@ static char *strchrnul(const char *s, int c)
 		return (char *)s + strlen(s);
 	return x;
 }
+#endif
 
 static void *xmalloc(size_t size)
 {
@@ -598,8 +603,8 @@ static void broadcast_change(void)
 {
 	const char *pkg = getenv("CALLING_PACKAGE");
 
-	if (!pkg || strcmp(pkg, "com.wireguard.android"))
-		cmd("am broadcast -a com.wireguard.android.action.REFRESH_TUNNEL_STATES com.wireguard.android");
+	if (!pkg || strcmp(pkg, WG_PACKAGE_NAME))
+		cmd("am broadcast -a com.wireguard.android.action.REFRESH_TUNNEL_STATES " WG_PACKAGE_NAME);
 }
 
 static void print_search_paths(FILE *file, const char *prefix)

commit c61c5a03ee2e3186eae57c3f7934f270df7045a7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 19 19:15:15 2018 +0200

    embeddable-wg-library: do not left shift negative numbers
    
    Otherwise we incur undefined behavior.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index c052355..a65dbce 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -1593,16 +1593,11 @@ static __attribute__((noinline)) void memzero_explicit(void *s, size_t count)
 static void carry(fe o)
 {
 	int i;
-	int64_t c;
 
 	for (i = 0; i < 16; ++i) {
-		o[i] += (1LL << 16);
-		c = o[i] >> 16;
-		o[(i + 1) * (i < 15)] += c - 1 + 37 * (c - 1) * (i == 15);
-		o[i] -= c << 16;
+		o[(i + 1) % 16] += (i == 15 ? 38 : 1) * (o[i] >> 16);
+		o[i] &= 0xffff;
 	}
-
-	memzero_explicit(&c, sizeof(c));
 }
 
 static void cswap(fe p, fe q, int b)

commit 4349005f4e508fed9db2891446d75afdfb83ec0f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jul 16 17:27:00 2018 +0200

    wg-quick: allow link local default gateway
    
    It's unclear why it was like this in the first place, but it apparently
    broke certain IPv6 setups.
    
    Reported-by: Jonas Blahut <j@die-blahuts.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 8bcc404..ece16f2 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -187,7 +187,6 @@ collect_gateways() {
 	GATEWAY6=""
 	while read -r destination gateway _; do
 		[[ $destination == default ]] || continue
-		[[ $gateway == fe80:* ]] && continue
 		GATEWAY6="$gateway"
 		break
 	done < <(netstat -nr -f inet6)
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index 40dc3f1..a2bdafb 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -188,7 +188,6 @@ collect_gateways() {
 	GATEWAY6=""
 	while read -r destination gateway _; do
 		[[ $destination == default ]] || continue
-		[[ $gateway == fe80:* ]] && continue
 		GATEWAY6="$gateway"
 		break
 	done < <(netstat -nr -f inet6)
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index 786d145..e0c6d1a 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -185,7 +185,6 @@ collect_gateways() {
 	GATEWAY6=""
 	while read -r destination gateway _; do
 		[[ $destination == default ]] || continue
-		[[ $gateway == fe80:* ]] && continue
 		GATEWAY6="$gateway"
 		break
 	done < <(netstat -nr -f inet6)

commit 4502f4f2b7e49b0a6ac982000d0ab573e1768bbc
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 8 19:46:05 2018 +0200

    wg: only error on wg show if all interfaces fail
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/show.c b/src/show.c
index 415489b..b7f665c 100644
--- a/src/show.c
+++ b/src/show.c
@@ -14,6 +14,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include <errno.h>
 #include <time.h>
 #include <netdb.h>
 
@@ -394,12 +395,13 @@ int show_main(int argc, char *argv[])
 			perror("Unable to list interfaces");
 			return 1;
 		}
+		ret = !!*interfaces;
 		interface = interfaces;
 		for (size_t len = 0; (len = strlen(interface)); interface += len + 1) {
 			struct wgdevice *device = NULL;
 
 			if (ipc_get_device(&device, interface) < 0) {
-				perror("Unable to access interface");
+				fprintf(stderr, "Unable to access interface %s: %s\n", interface, strerror(errno));
 				continue;
 			}
 			if (argc == 3) {
@@ -414,6 +416,7 @@ int show_main(int argc, char *argv[])
 					printf("\n");
 			}
 			free_wgdevice(device);
+			ret = 0;
 		}
 		free(interfaces);
 	} else if (!strcmp(argv[1], "interfaces")) {

commit 4367cd0d3d391b90a529c46df273e01972251bdb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 5 19:26:13 2018 +0200

    wg-quick: android: support excluding applications
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index b2ca814..12108c0 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -34,6 +34,15 @@
 
 static bool is_exiting = false;
 
+/* TODO: remove this once the NDK supports it. */
+static char *strchrnul(const char *s, int c)
+{
+	char *x = strchr(s, c);
+	if (!x)
+		return (char *)s + strlen(s);
+	return x;
+}
+
 static void *xmalloc(size_t size)
 {
 	void *ret = malloc(size);
@@ -43,6 +52,15 @@ static void *xmalloc(size_t size)
 	exit(errno);
 }
 
+static void *xcalloc(size_t nmemb, size_t size)
+{
+	void *ret = calloc(nmemb, size);
+	if (ret)
+		return ret;
+	perror("Error: calloc");
+	exit(errno);
+}
+
 static void *xstrdup(const char *str)
 {
 	char *ret = strdup(str);
@@ -288,9 +306,79 @@ static void up_if(unsigned int *netid, const char *iface)
 	cndc("network interface add %u %s", *netid, iface);
 }
 
-static void set_users(unsigned int netid)
+static int compare_uid(const void *a, const void *b)
 {
-	cndc("network users add %u 0-99999", netid);
+	return *(const uid_t *)a - *(const uid_t *)b;
+}
+
+static uid_t *get_uid_list(const char *selected_applications)
+{
+	_cleanup_fclose_ FILE *package_list = NULL;
+	_cleanup_free_ char *line = NULL;
+	uid_t package_uid;
+	size_t line_len = 0, i;
+	const char *comma, *start;
+	uid_t *uid_list;
+
+	if (!selected_applications)
+		return xcalloc(1, sizeof(*uid_list));
+
+	for (i = 1, comma = selected_applications; comma; comma = strchr(comma + 1, ','), ++i);
+	uid_list = xcalloc(i, sizeof(*uid_list));
+	i = 0;
+
+	package_list = fopen("/data/system/packages.list", "r");
+	if (!package_list) {
+		perror("Error: Unable to open package list");
+		exit(errno);
+	}
+
+	while (getline(&line, &line_len, package_list) >= 0) {
+		char *package_name, *package_uid_str, *endptr;
+
+		package_name = line;
+		package_uid_str = strchr(package_name, ' ');
+		if (!package_uid_str)
+			continue;
+		*package_uid_str++ = '\0';
+		*strchrnul(package_uid_str, ' ') = '\0';
+		package_uid = strtoul(package_uid_str, &endptr, 10);
+		if (!package_uid || !*package_uid_str || *endptr)
+			continue;
+
+		for (start = selected_applications; comma = strchrnul(start, ','), *start; start = comma + 1) {
+			ptrdiff_t token_len = comma - start;
+
+			if (token_len && strlen(package_name) == token_len && !strncmp(start, package_name, token_len))
+				uid_list[i++] = package_uid;
+		}
+	}
+	qsort(uid_list, i, sizeof(*uid_list), compare_uid);
+	return uid_list;
+}
+
+static void set_users(unsigned int netid, const char *excluded_applications)
+{
+	_cleanup_free_ uid_t *excluded_uids = get_uid_list(excluded_applications);
+	_cleanup_free_ char *ranges = NULL;
+	char range[22];
+	uid_t start;
+
+	for (start = 0; *excluded_uids; start = *excluded_uids + 1, ++excluded_uids) {
+		if (start > *excluded_uids - 1)
+			continue;
+		else if (start == *excluded_uids - 1)
+			snprintf(range, sizeof(range), "%u", start);
+		else
+			snprintf(range, sizeof(range), "%u-%u", start, *excluded_uids - 1);
+		ranges = concat_and_free(ranges, " ", range);
+	}
+	if (start < 99999) {
+		snprintf(range, sizeof(range), "%u-99999", start);
+		ranges = concat_and_free(ranges, " ", range);
+	}
+
+	cndc("network users add %u %s", netid, ranges);
 }
 
 static void set_dnses(unsigned int netid, const char *dnses)
@@ -536,7 +624,8 @@ static void cmd_usage(const char *program)
 		"  - Address: may be specified one or more times and contains one or more\n"
 		"    IP addresses (with an optional CIDR mask) to be set for the interface.\n"
 		"  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.\n"
-		"  - DNS: an optional DNS server to use while the device is up.\n\n"
+		"  - DNS: an optional DNS server to use while the device is up.\n"
+		"  - ExcludedApplications: optional applications to exclude from the tunnel.\n\n"
 		"  See wg-quick(8) for more info and examples.\n");
 }
 
@@ -550,7 +639,7 @@ static void cmd_up_cleanup(void)
 	free(cleanup_iface);
 }
 
-static void cmd_up(const char *iface, const char *config, unsigned int mtu, const char *addrs, const char *dnses)
+static void cmd_up(const char *iface, const char *config, unsigned int mtu, const char *addrs, const char *dnses, const char *excluded_applications)
 {
 	DEFINE_CMD(c);
 	unsigned int netid = 0;
@@ -571,7 +660,7 @@ static void cmd_up(const char *iface, const char *config, unsigned int mtu, cons
 	set_dnses(netid, dnses);
 	set_routes(iface, netid);
 	set_mtu(iface, mtu);
-	set_users(netid);
+	set_users(netid, excluded_applications);
 	broadcast_change();
 
 	free(cleanup_iface);
@@ -604,7 +693,7 @@ static void cmd_down(const char *iface)
 	exit(EXIT_SUCCESS);
 }
 
-static void parse_options(char **iface, char **config, unsigned int *mtu, char **addrs, char **dnses, const char *arg)
+static void parse_options(char **iface, char **config, unsigned int *mtu, char **addrs, char **dnses, char **excluded_applications, const char *arg)
 {
 	_cleanup_fclose_ FILE *file = NULL;
 	_cleanup_free_ char *line = NULL;
@@ -685,6 +774,9 @@ static void parse_options(char **iface, char **config, unsigned int *mtu, char *
 			} else if (!strncasecmp(clean, "DNS=", 4) && j > 4) {
 				*dnses = concat_and_free(*dnses, ",", clean + 4);
 				continue;
+			} else if (!strncasecmp(clean, "ExcludedApplications=", 21) && j > 4) {
+				*excluded_applications = concat_and_free(*excluded_applications, ",", clean + 21);
+				continue;
 			} else if (!strncasecmp(clean, "MTU=", 4) && j > 4) {
 				*mtu = atoi(clean + 4);
 				continue;
@@ -709,17 +801,18 @@ int main(int argc, char *argv[])
 	_cleanup_free_ char *config = NULL;
 	_cleanup_free_ char *addrs = NULL;
 	_cleanup_free_ char *dnses = NULL;
+	_cleanup_free_ char *excluded_applications = NULL;
 	unsigned int mtu;
 
 	if (argc == 2 && (!strcmp(argv[1], "help") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "-h")))
 		cmd_usage(argv[0]);
 	else if (argc == 3 && !strcmp(argv[1], "up")) {
 		auto_su(argc, argv);
-		parse_options(&iface, &config, &mtu, &addrs, &dnses, argv[2]);
-		cmd_up(iface, config, mtu, addrs, dnses);
+		parse_options(&iface, &config, &mtu, &addrs, &dnses, &excluded_applications, argv[2]);
+		cmd_up(iface, config, mtu, addrs, dnses, excluded_applications);
 	} else if (argc == 3 && !strcmp(argv[1], "down")) {
 		auto_su(argc, argv);
-		parse_options(&iface, &config, &mtu, &addrs, &dnses, argv[2]);
+		parse_options(&iface, &config, &mtu, &addrs, &dnses, &excluded_applications, argv[2]);
 		cmd_down(iface);
 	} else {
 		cmd_usage(argv[0]);

commit b3b6d97db8a2cc4159a489483a0a6de81720c060
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jun 25 05:43:16 2018 +0200

    wg-quick: android: prevent outgoing handshake packets from being dropped
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 66e5b3f..b2ca814 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -258,6 +258,8 @@ static void del_if(const char *iface)
 
 	xregcomp(&reg, regex, REG_EXTENDED);
 
+	cmd("iptables -D OUTPUT -m mark --mark 0x20000 -j ACCEPT -m comment --comment \"wireguard rule %s\"", iface);
+	cmd("ip6tables -D OUTPUT -m mark --mark 0x20000 -j ACCEPT -m comment --comment \"wireguard rule %s\"", iface);
 	cmd("ip link del %s", iface);
 	for (char *ret = cmd_ret(&c, "ip rule show"); ret; ret = cmd_ret(&c, NULL)) {
 		if (!regexec(&reg, ret, ARRAY_SIZE(matches), matches, 0)) {
@@ -279,6 +281,8 @@ static void up_if(unsigned int *netid, const char *iface)
 		*netid = random() & 0xfffe;
 
 	cmd("wg set %s fwmark 0x20000", iface);
+	cmd("iptables -I OUTPUT 1 -m mark --mark 0x20000 -j ACCEPT -m comment --comment \"wireguard rule %s\"", iface);
+	cmd("ip6tables -I OUTPUT 1 -m mark --mark 0x20000 -j ACCEPT -m comment --comment \"wireguard rule %s\"", iface);
 	cndc("interface setcfg %s up", iface);
 	cndc("network create %u vpn 1 1", *netid);
 	cndc("network interface add %u %s", *netid, iface);

commit a54a133500436402171c2d6d23aea93bddc993cf
Author: Jonathan Neuschfer <j.neuschaefer@gmx.net>
Date:   Fri Jun 22 01:39:25 2018 +0200

    wg: fix misspelling of strchrnul in comment
    
    Signed-off-by: Jonathan Neuschfer <j.neuschaefer@gmx.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index b07aa46..8e327be 100644
--- a/src/config.c
+++ b/src/config.c
@@ -434,7 +434,7 @@ bool config_read_line(struct config_ctx *ctx, const char *input)
 	char *line, *comment;
 	bool ret = true;
 
-	/* This is what strchrnull is for, but that isn't portable. */
+	/* This is what strchrnul is for, but that isn't portable. */
 	comment = strchr(input, COMMENT_CHAR);
 	if (comment)
 		len = comment - input;

commit ef54cbf56823a309c58a5a97f15a030c32ca9621
Author: Jonathan Neuschfer <j.neuschaefer@gmx.net>
Date:   Fri Jun 22 01:39:25 2018 +0200

    manpages: eliminate whitespace at the end of the line
    
    This eliminates a few style warnings from "mandoc -T lint src/tools/wg*.8".
    
    Signed-off-by: Jonathan Neuschfer <j.neuschaefer@gmx.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/man/wg-quick.8 b/src/man/wg-quick.8
index d97fec9..8f0c487 100644
--- a/src/man/wg-quick.8
+++ b/src/man/wg-quick.8
@@ -112,25 +112,25 @@ and a more complete description may be found there. Bold lines below are for opt
 The following might be used for connecting as a client to a VPN gateway for tunneling all
 traffic:
 
-    [Interface] 
+    [Interface]
 .br
     \fBAddress = 10.200.100.8/24\fP
 .br
     \fBDNS = 10.200.100.1\fP
 .br
-    PrivateKey = oK56DE9Ue9zK76rAc8pBl6opph+1v36lm7cXXsQKrQM= 
+    PrivateKey = oK56DE9Ue9zK76rAc8pBl6opph+1v36lm7cXXsQKrQM=
 .br
-     
+
 .br
-    [Peer] 
+    [Peer]
 .br
-    PublicKey = GtL7fZc/bLnqZldpVofMCD6hDjrK28SsdLxevJ+qtKU= 
+    PublicKey = GtL7fZc/bLnqZldpVofMCD6hDjrK28SsdLxevJ+qtKU=
 .br
-    PresharedKey = /UwcSPg38hW/D9Y3tcS1FOV0K1wuURMbS0sesJEP5ak= 
+    PresharedKey = /UwcSPg38hW/D9Y3tcS1FOV0K1wuURMbS0sesJEP5ak=
 .br
-    AllowedIPs = 0.0.0.0/0 
+    AllowedIPs = 0.0.0.0/0
 .br
-    Endpoint = demo.wireguard.com:51820 
+    Endpoint = demo.wireguard.com:51820
 .br
 
 The `Address` field is added here in order to set up the address for the interface. The `DNS` field
@@ -164,7 +164,7 @@ Or, perhaps it is desirable to store private keys in encrypted form, such as thr
 .br
 
 For use on a server, the following is a more complicated example involving multiple peers:
-    
+
     [Interface]
 .br
     \fBAddress = 10.192.122.1/24\fP
@@ -173,31 +173,31 @@ For use on a server, the following is a more complicated example involving multi
 .br
     \fBSaveConfig = true\fP
 .br
-    PrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk= 
+    PrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=
 .br
-    ListenPort = 51820 
+    ListenPort = 51820
 .br
-     
+
 .br
-    [Peer] 
+    [Peer]
 .br
-    PublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg= 
+    PublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=
 .br
-    AllowedIPs = 10.192.122.3/32, 10.192.124.1/24 
+    AllowedIPs = 10.192.122.3/32, 10.192.124.1/24
 .br
-     
+
 .br
-    [Peer] 
+    [Peer]
 .br
-    PublicKey = TrMvSoP4jYQlY6RIzBgbssQqY3vxI2Pi+y71lOWWXX0= 
+    PublicKey = TrMvSoP4jYQlY6RIzBgbssQqY3vxI2Pi+y71lOWWXX0=
 .br
-    AllowedIPs = 10.192.122.4/32, 192.168.0.0/16 
+    AllowedIPs = 10.192.122.4/32, 192.168.0.0/16
 .br
-     
+
 .br
-    [Peer] 
+    [Peer]
 .br
-    PublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA= 
+    PublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA=
 .br
     AllowedIPs = 10.10.10.230/32
 
diff --git a/src/man/wg.8 b/src/man/wg.8
index 49dc15b..5bae7ca 100644
--- a/src/man/wg.8
+++ b/src/man/wg.8
@@ -5,17 +5,17 @@ wg - set and retrieve configuration of WireGuard interfaces
 
 .SH SYNOPSIS
 .B wg
-[ 
+[
 .I COMMAND
-] [ 
+] [
 .I OPTIONS
-]... [ 
+]... [
 .I ARGS
 ]...
 
 .SH DESCRIPTION
 
-.B wg 
+.B wg
 is the configuration utility for getting and setting the configuration of
 WireGuard tunnel interfaces. The interfaces themselves can be added and removed
 using

commit 02733c681b02106a38debd1c5f4de4d58f3a8ff6
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jun 17 05:13:22 2018 +0200

    wg-quick: android: don't forget to free compiled regexes
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 757f265..66e5b3f 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -120,6 +120,7 @@ static void fclosep(FILE **f)
 }
 #define _cleanup_free_ _cleanup_(freep)
 #define _cleanup_fclose_ _cleanup_(fclosep)
+#define _cleanup_regfree_ _cleanup_(regfree)
 
 #define DEFINE_CMD(name) _cleanup_(free_command_buffer) struct command_buffer name = { 0 };
 
@@ -250,7 +251,7 @@ static void add_if(const char *iface)
 static void del_if(const char *iface)
 {
 	DEFINE_CMD(c);
-	regex_t reg;
+	_cleanup_regfree_ regex_t reg = { 0 };
 	regmatch_t matches[2];
 	char *netid = NULL;
 	_cleanup_free_ char *regex = concat("0xc([0-9a-f]+)/0xcffff lookup ", iface, NULL);
@@ -346,7 +347,7 @@ static int get_route_mtu(const char *endpoint)
 	DEFINE_CMD(c_route);
 	DEFINE_CMD(c_dev);
 	regmatch_t matches[2];
-	regex_t regex_mtu, regex_dev;
+	_cleanup_regfree_ regex_t regex_mtu = { 0 }, regex_dev = { 0 };
 	char *route, *mtu, *dev;
 
 	xregcomp(&regex_mtu, "mtu ([0-9]+)", REG_EXTENDED);
@@ -380,7 +381,7 @@ static int get_route_mtu(const char *endpoint)
 static void set_mtu(const char *iface, unsigned int mtu)
 {
 	DEFINE_CMD(c_endpoints);
-	regex_t regex_endpoint;
+	_cleanup_regfree_ regex_t regex_endpoint = { 0 };
 	regmatch_t matches[2];
 	int endpoint_mtu, next_mtu;
 
@@ -466,7 +467,7 @@ set_back_down:
 static void maybe_unblock_ipv6(const char *iface)
 {
 	regmatch_t matches[2];
-	regex_t reg;
+	_cleanup_regfree_ regex_t reg = { 0 };
 	_cleanup_free_ char *regex = concat("^-A (.* --comment \"wireguard rule ", iface, "\"[^\n]*)\n*$", NULL);
 	DEFINE_CMD(c);
 
@@ -605,7 +606,7 @@ static void parse_options(char **iface, char **config, unsigned int *mtu, char *
 	_cleanup_free_ char *line = NULL;
 	_cleanup_free_ char *filename = NULL;
 	_cleanup_free_ char *paths = strdup(WG_CONFIG_SEARCH_PATHS);
-	regex_t regex_iface, regex_conf;
+	_cleanup_regfree_ regex_t regex_iface = { 0 }, regex_conf = { 0 };
 	regmatch_t matches[2];
 	struct stat sbuf;
 	size_t n = 0;

commit 3bbacaaf143b696f22c89a8c54c557c8a0f8da74
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jun 17 05:06:37 2018 +0200

    wg-quick: android: disable roaming to v6 networks when v4 is specified
    
    This works around an unfortunate bug in 464XLAT transitions.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 5937e14..757f265 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -13,6 +13,7 @@
 #include <string.h>
 #include <strings.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <ctype.h>
 #include <time.h>
 #include <unistd.h>
@@ -428,6 +429,56 @@ static void set_routes(const char *iface, unsigned int netid)
 	}
 }
 
+static void maybe_block_ipv6(const char *iface)
+{
+	DEFINE_CMD(c_endpoints);
+	DEFINE_CMD(c_listenport);
+	bool has_ipv6 = false, has_all_none = true;
+	char *value;
+	unsigned long listenport;
+
+	for (char *endpoint = cmd_ret(&c_endpoints, "wg show %s endpoints", iface); endpoint; endpoint = cmd_ret(&c_endpoints, NULL)) {
+		char *start = strchr(endpoint, '\t');
+
+		if (!start)
+			continue;
+		++start;
+		if (start[0] != '(')
+			has_all_none = false;
+		if (start[0] == '[')
+			has_ipv6 = true;
+	}
+	if (has_ipv6 || has_all_none)
+		return;
+
+	cmd("ip link set up dev %s", iface);
+	value = cmd_ret(&c_listenport, "wg show %s listen-port", iface);
+	if (!value)
+		goto set_back_down;
+	listenport = strtoul(value, NULL, 10);
+	if (listenport > UINT16_MAX || !listenport)
+		goto set_back_down;
+	cmd("ip6tables -I INPUT 1 -p udp --dport %lu -j DROP -m comment --comment \"wireguard rule %s\"", listenport, iface);
+set_back_down:
+	cmd("ip link set down dev %s", iface);
+}
+
+static void maybe_unblock_ipv6(const char *iface)
+{
+	regmatch_t matches[2];
+	regex_t reg;
+	_cleanup_free_ char *regex = concat("^-A (.* --comment \"wireguard rule ", iface, "\"[^\n]*)\n*$", NULL);
+	DEFINE_CMD(c);
+
+	xregcomp(&reg, regex, REG_EXTENDED);
+	for (char *rule = cmd_ret(&c, "ip6tables-save"); rule; rule = cmd_ret(&c, NULL)) {
+		if (!regexec(&reg, rule, ARRAY_SIZE(matches), matches, 0)) {
+			rule[matches[1].rm_eo] = '\0';
+			cmd("ip6tables -D %s", &rule[matches[1].rm_so]);
+		}
+	}
+}
+
 static void set_config(const char *iface, const char *config)
 {
 	FILE *config_writer;
@@ -509,6 +560,7 @@ static void cmd_up(const char *iface, const char *config, unsigned int mtu, cons
 
 	add_if(iface);
 	set_config(iface, config);
+	maybe_block_ipv6(iface);
 	set_addr(iface, addrs);
 	up_if(&netid, iface);
 	set_dnses(netid, dnses);
@@ -542,6 +594,7 @@ static void cmd_down(const char *iface)
 	}
 
 	del_if(iface);
+	maybe_unblock_ipv6(iface);
 	broadcast_change();
 	exit(EXIT_SUCCESS);
 }
@@ -601,7 +654,7 @@ static void parse_options(char **iface, char **config, unsigned int *mtu, char *
 	if (sbuf.st_mode & 0007)
 		fprintf(stderr, "Warning: `%s' is world accessible\n", filename);
 
-	filename[matches[1].rm_eo] = 0;
+	filename[matches[1].rm_eo] = '\0';
 	*iface = xstrdup(&filename[matches[1].rm_so]);
 
 	while (getline(&line, &n, file) >= 0) {

commit 2ce4680bd34f371aacd3c09673c3c907274321cd
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jun 17 00:06:58 2018 +0200

    dns-hatchet: apply resolv.conf's selinux context to new resolv.conf
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/dns-hatchet/hatchet.bash b/contrib/dns-hatchet/hatchet.bash
index 793684c..5857cc1 100644
--- a/contrib/dns-hatchet/hatchet.bash
+++ b/contrib/dns-hatchet/hatchet.bash
@@ -17,9 +17,11 @@ set_dns() {
 		printf 'nameserver %s\n' "${DNS[@]}"
 		} | unshare -m --propagation shared bash -c "$(cat <<-_EOF
 			set -e
+			context="\$(stat -c %C /etc/resolv.conf 2>/dev/null)" || unset context
 			mount --make-private /dev/shm
 			mount -t tmpfs none /dev/shm
 			cat > /dev/shm/resolv.conf
+			[[ -z \$context || \$context == "?" ]] || chcon "\$context" /dev/shm/resolv.conf 2>/dev/null || true
 			mount -o remount,ro /dev/shm
 			mount -o bind,ro /dev/shm/resolv.conf /etc/resolv.conf
 		_EOF

commit 6f85449d79bc4d8bd324852b012456eeaf47ec24
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jun 14 04:18:15 2018 +0200

    wg: getentropy requires 10.12
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/genkey.c b/src/genkey.c
index 04de2ba..d2d4c53 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -14,8 +14,14 @@
 #include <sys/syscall.h>
 #endif
 #ifdef __APPLE__
+#include <AvailabilityMacros.h>
+#ifndef MAC_OS_X_VERSION_10_12
+#define MAC_OS_X_VERSION_10_12 101200
+#endif
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_12
 #include <sys/random.h>
 #endif
+#endif
 
 #include "curve25519.h"
 #include "encoding.h"
@@ -26,7 +32,7 @@ static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
 	ssize_t ret;
 	int fd;
 
-#if defined(__OpenBSD__) || defined(__APPLE__) || (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 25)))
+#if defined(__OpenBSD__) || (defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_12) || (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 25)))
 	ret = getentropy(out, len);
 	if (!ret)
 		return len;

commit 0632c8af68fa566dfd461c758968d2daa9b04f98
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 8 03:18:28 2018 +0200

    wg: support getentropy(3)
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/genkey.c b/src/genkey.c
index 5971528..04de2ba 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -13,6 +13,9 @@
 #ifdef __linux__
 #include <sys/syscall.h>
 #endif
+#ifdef __APPLE__
+#include <sys/random.h>
+#endif
 
 #include "curve25519.h"
 #include "encoding.h"
@@ -22,11 +25,19 @@ static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
 {
 	ssize_t ret;
 	int fd;
+
+#if defined(__OpenBSD__) || defined(__APPLE__) || (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 25)))
+	ret = getentropy(out, len);
+	if (!ret)
+		return len;
+#endif
+
 #if defined(__NR_getrandom) && defined(__linux__)
 	ret = syscall(__NR_getrandom, out, len, 0);
 	if (ret >= 0)
 		return ret;
 #endif
+
 	fd = open("/dev/urandom", O_RDONLY);
 	if (fd < 0)
 		return fd;

commit d90e49599b485ccf5bd8575a05d51b09211576b9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jun 6 00:05:47 2018 +0200

    wg: encoding: add missing static array constraints
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index 560d7ab..c052355 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -1514,7 +1514,7 @@ void wg_free_device(wg_device *dev)
 	free(dev);
 }
 
-static void encode_base64(char dest[4], const uint8_t src[3])
+static void encode_base64(char dest[static 4], const uint8_t src[static 3])
 {
 	const uint8_t input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
 	unsigned int i;
@@ -1539,7 +1539,7 @@ void wg_key_to_base64(wg_key_b64_string base64, const wg_key key)
 	base64[sizeof(wg_key_b64_string) - 1] = '\0';
 }
 
-static int decode_base64(const char src[4])
+static int decode_base64(const char src[static 4])
 {
 	int val = 0;
 	unsigned int i;
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index fc47575..3b560a5 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -72,7 +72,7 @@ EMSCRIPTEN_KEEPALIVE void curve25519_generate_private(u8 private[static 32])
 	normalize_secret(private);
 }
 
-static inline void encode_base64(char dest[4], const u8 src[3])
+static inline void encode_base64(char dest[static 4], const u8 src[static 3])
 {
 	const u8 input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
 
diff --git a/src/encoding.c b/src/encoding.c
index a9ed694..2e2d915 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -8,7 +8,7 @@
 #include <string.h>
 #include "encoding.h"
 
-static inline void encode_base64(char dest[4], const uint8_t src[3])
+static inline void encode_base64(char dest[static 4], const uint8_t src[static 3])
 {
 	const uint8_t input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
 
@@ -32,7 +32,7 @@ void key_to_base64(char base64[static WG_KEY_LEN_BASE64], const uint8_t key[stat
 	base64[WG_KEY_LEN_BASE64 - 1] = '\0';
 }
 
-static inline int decode_base64(const char src[4])
+static inline int decode_base64(const char src[static 4])
 {
 	int val = 0;
 

commit 8c4cf156d518c66de36e7c57e555a9fbb29814e1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jun 4 02:49:20 2018 +0200

    wg-quick: android: change name of intent
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index cd43a13..5937e14 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -455,7 +455,7 @@ static void broadcast_change(void)
 	const char *pkg = getenv("CALLING_PACKAGE");
 
 	if (!pkg || strcmp(pkg, "com.wireguard.android"))
-		cmd("am broadcast -a com.wireguard.android.WGQUICK_CHANGE com.wireguard.android");
+		cmd("am broadcast -a com.wireguard.android.action.REFRESH_TUNNEL_STATES com.wireguard.android");
 }
 
 static void print_search_paths(FILE *file, const char *prefix)

commit 2044bb026d7af480bc00e7849803f0229641e82a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu May 31 16:38:06 2018 +0200

    wg-quick: android: delay setting users until end
    
    `ndc users add` eventually invokes SOCK_DESTROY on user sockets, causing
    them to reconnect. By delaying this until after routes are set, we
    ensure that the sockets reconnect using the tunnel, rather than the old
    route.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
index 25f8f5f..cd43a13 100644
--- a/src/wg-quick/android.c
+++ b/src/wg-quick/android.c
@@ -280,7 +280,11 @@ static void up_if(unsigned int *netid, const char *iface)
 	cndc("interface setcfg %s up", iface);
 	cndc("network create %u vpn 1 1", *netid);
 	cndc("network interface add %u %s", *netid, iface);
-	cndc("network users add %u 0-99999", *netid);
+}
+
+static void set_users(unsigned int netid)
+{
+	cndc("network users add %u 0-99999", netid);
 }
 
 static void set_dnses(unsigned int netid, const char *dnses)
@@ -510,6 +514,7 @@ static void cmd_up(const char *iface, const char *config, unsigned int mtu, cons
 	set_dnses(netid, dnses);
 	set_routes(iface, netid);
 	set_mtu(iface, mtu);
+	set_users(netid);
 	broadcast_change();
 
 	free(cleanup_iface);

commit 2bca99893f711625076aa58463a1b7531df0e0ae
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 30 21:32:27 2018 +0200

    wg: constanter time encoding
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index 16ddd9a..560d7ab 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -1559,25 +1559,25 @@ int wg_key_from_base64(wg_key key, const wg_key_b64_string base64)
 {
 	unsigned int i;
 	int val;
+	volatile uint8_t ret = 0;
 
-	errno = EINVAL;
-	if (strlen(base64) != sizeof(wg_key_b64_string) - 1 || base64[sizeof(wg_key_b64_string) - 2] != '=')
+	if (strlen(base64) != sizeof(wg_key_b64_string) - 1 || base64[sizeof(wg_key_b64_string) - 2] != '=') {
+		errno = EINVAL;
 		goto out;
+	}
 
 	for (i = 0; i < 32 / 3; ++i) {
 		val = decode_base64(&base64[i * 4]);
-		if (val < 0)
-			goto out;
+		ret |= (uint32_t)val >> 31;
 		key[i * 3 + 0] = (val >> 16) & 0xff;
 		key[i * 3 + 1] = (val >> 8) & 0xff;
 		key[i * 3 + 2] = val & 0xff;
 	}
 	val = decode_base64((const char[]){ base64[i * 4 + 0], base64[i * 4 + 1], base64[i * 4 + 2], 'A' });
-	if (val < 0 || val & 0xff)
-		goto out;
+	ret |= ((uint32_t)val >> 31) | (val & 0xff);
 	key[i * 3 + 0] = (val >> 16) & 0xff;
 	key[i * 3 + 1] = (val >> 8) & 0xff;
-	errno = 0;
+	errno = EINVAL & ~((ret - 1) >> 8);
 out:
 	return -errno;
 }
diff --git a/src/encoding.c b/src/encoding.c
index cb1b123..a9ed694 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -50,6 +50,7 @@ static inline int decode_base64(const char src[4])
 bool key_from_base64(uint8_t key[static WG_KEY_LEN], const char *base64)
 {
 	unsigned int i;
+	volatile uint8_t ret = 0;
 	int val;
 
 	if (strlen(base64) != WG_KEY_LEN_BASE64 - 1 || base64[WG_KEY_LEN_BASE64 - 2] != '=')
@@ -57,18 +58,17 @@ bool key_from_base64(uint8_t key[static WG_KEY_LEN], const char *base64)
 
 	for (i = 0; i < WG_KEY_LEN / 3; ++i) {
 		val = decode_base64(&base64[i * 4]);
-		if (val < 0)
-			return false;
+		ret |= (uint32_t)val >> 31;
 		key[i * 3 + 0] = (val >> 16) & 0xff;
 		key[i * 3 + 1] = (val >> 8) & 0xff;
 		key[i * 3 + 2] = val & 0xff;
 	}
 	val = decode_base64((const char[]){ base64[i * 4 + 0], base64[i * 4 + 1], base64[i * 4 + 2], 'A' });
-	if (val < 0 || val & 0xff)
-		return false;
+	ret |= ((uint32_t)val >> 31) | (val & 0xff);
 	key[i * 3 + 0] = (val >> 16) & 0xff;
 	key[i * 3 + 1] = (val >> 8) & 0xff;
-	return true;
+
+	return 1 & ((ret - 1) >> 8);
 }
 
 void key_to_hex(char hex[static WG_KEY_LEN_HEX], const uint8_t key[static WG_KEY_LEN])
@@ -84,27 +84,33 @@ void key_to_hex(char hex[static WG_KEY_LEN_HEX], const uint8_t key[static WG_KEY
 
 bool key_from_hex(uint8_t key[static WG_KEY_LEN], const char *hex)
 {
-	uint8_t c, c_acc = 0, c_alpha0, c_alpha, c_num0, c_num, c_val, state = 0;
+	uint8_t c, c_acc = 0, c_alpha0, c_alpha, c_num0, c_num, c_val;
+	volatile uint8_t ret = 0;
 
 	if (strlen(hex) != WG_KEY_LEN_HEX - 1)
 		return false;
 
-	for (unsigned int i = 0; i < WG_KEY_LEN_HEX - 1; ++i) {
+	for (unsigned int i = 0; i < WG_KEY_LEN_HEX - 1; i += 2) {
 		c = (uint8_t)hex[i];
 		c_num = c ^ 48U;
 		c_num0 = (c_num - 10U) >> 8;
 		c_alpha = (c & ~32U) - 55U;
 		c_alpha0 = ((c_alpha - 10U) ^ (c_alpha - 16U)) >> 8;
-		if (!(c_num0 | c_alpha0))
-			return false;
+		ret |= ((c_num0 | c_alpha0) - 1) >> 8;
 		c_val = (c_num0 & c_num) | (c_alpha0 & c_alpha);
-		if (!state)
-			c_acc = c_val * 16U;
-		else
-			key[i / 2] = c_acc | c_val;
-		state = ~state;
+		c_acc = c_val * 16U;
+
+		c = (uint8_t)hex[i + 1];
+		c_num = c ^ 48U;
+		c_num0 = (c_num - 10U) >> 8;
+		c_alpha = (c & ~32U) - 55U;
+		c_alpha0 = ((c_alpha - 10U) ^ (c_alpha - 16U)) >> 8;
+		ret |= ((c_num0 | c_alpha0) - 1) >> 8;
+		c_val = (c_num0 & c_num) | (c_alpha0 & c_alpha);
+		key[i / 2] = c_acc | c_val;
 	}
-	return true;
+
+	return 1 & ((ret - 1) >> 8);
 }
 
 bool key_is_zero(const uint8_t key[static WG_KEY_LEN])

commit 206e8f08e2413d1b1dfc5724bc9567f9f0ace310
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 30 01:37:57 2018 +0200

    wg-quick: darwin: set DNS servers after delay on route change
    
    This works around a race condition in macOS's network daemons, while
    also adding one in the form of possibly calling kill -ALRM on a stale
    PID; unfortunately bash can't wait from a trap.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 81139e6..8bcc404 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -293,7 +293,8 @@ monitor_daemon() {
 	echo "[+] Backgrounding route monitor" >&2
 	(trap 'del_routes; del_dns; exit 0' INT TERM EXIT
 	exec >/dev/null 2>&1
-	local event
+	local event pid=$BASHPID
+	[[ ${#DNS[@]} -gt 0 ]] && trap set_dns ALRM
 	# TODO: this should also check to see if the endpoint actually changes
 	# in response to incoming packets, and then call set_endpoint_direct_route
 	# then too. That function should be able to gracefully cleanup if the
@@ -303,7 +304,10 @@ monitor_daemon() {
 		ifconfig "$REAL_INTERFACE" >/dev/null 2>&1 || break
 		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
 		[[ -z $MTU ]] && set_mtu
-		[[ ${#DNS[@]} -gt 0 ]] && set_dns
+		if [[ ${#DNS[@]} -gt 0 ]]; then
+			set_dns
+			sleep 2 && kill -ALRM $pid 2>/dev/null &
+		fi
 	done < <(route -n monitor)) & disown
 }
 

commit d532074ef5e80268a9529002ca7f233eb2730ff6
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun May 27 05:24:07 2018 +0200

    wg-quick: freebsd: configure as p2p link
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index d9a0b03..40dc3f1 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -146,9 +146,11 @@ up_if() {
 }
 
 add_addr() {
-	local family=inet
-	[[ $1 == *:* ]] && family=inet6
-	cmd ifconfig "$INTERFACE" "$family" "$1" alias
+	if [[ $1 == *:* ]]; then
+		cmd ifconfig "$INTERFACE" inet6 "$1" alias
+	else
+		cmd ifconfig "$INTERFACE" inet "$1" "${1%%/*}" alias
+	fi
 }
 
 set_mtu() {

commit df6c69e98c33edf5f31c08179fed6a7c5a618d38
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun May 27 05:22:55 2018 +0200

    wg-quick: darwin: add multiple IP addresses
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 18b92ea..81139e6 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -148,9 +148,9 @@ up_if() {
 
 add_addr() {
 	if [[ $1 == *:* ]]; then
-		cmd ifconfig "$REAL_INTERFACE" inet6 "$1"
+		cmd ifconfig "$REAL_INTERFACE" inet6 "$1" alias
 	else
-		cmd ifconfig "$REAL_INTERFACE" inet "$1" "${1%%/*}"
+		cmd ifconfig "$REAL_INTERFACE" inet "$1" "${1%%/*}" alias
 	fi
 }
 

commit 19ce650fb6fab0cbf593d02e7e35f5acd5fe6ab7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun May 27 02:42:04 2018 +0200

    wg-quick: determine IPs when saving interface
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 8e0a71f..18b92ea 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -335,12 +335,12 @@ set_config() {
 }
 
 save_config() {
-	# TODO: actually save addresses and DNS by running ifconfig and networksetup
 	local old_umask new_config current_config address cmd
 	new_config=$'[Interface]\n'
-	for address in "${ADDRESSES[@]}"; do
-		new_config+="Address = $address"$'\n'
-	done
+	while read -r address; do
+		[[ $address =~ inet6?\ ([^ ]+) ]] && new_config+="Address = ${BASH_REMATCH[1]}"$'\n'
+	done < <(ifconfig "$REAL_INTERFACE")
+	# TODO: actually determine current DNS for interface
 	for address in "${DNS[@]}"; do
 		new_config+="DNS = $address"$'\n'
 	done
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index 6e94983..d9a0b03 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -309,12 +309,14 @@ set_config() {
 }
 
 save_config() {
-	# TODO: actually save addresses by running ifconfig
 	local old_umask new_config current_config address cmd
 	new_config=$'[Interface]\n'
-	for address in "${ADDRESSES[@]}"; do
+	{ read -r _; while read -r _ _ _ address _; do
 		new_config+="Address = $address"$'\n'
-	done
+	done } < <(netstat -I "$INTERFACE" -n -W -f inet)
+	{ read -r _; while read -r _ _ _ address _; do
+		new_config+="Address = $address"$'\n'
+	done } < <(netstat -I "$INTERFACE" -n -W -f inet6)
 	while read -r address; do
 		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
 	done < <(resolvconf -l "$INTERFACE" 2>/dev/null)
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index d37e250..786d145 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -315,12 +315,12 @@ set_config() {
 }
 
 save_config() {
-	# TODO: actually save addresses by running ifconfig and dnses too
-	local old_umask new_config current_config address cmd
+	local old_umask new_config current_config address network cmd
 	new_config=$'[Interface]\n'
-	for address in "${ADDRESSES[@]}"; do
-		new_config+="Address = $address"$'\n'
-	done
+	{ read -r _; while read -r _ _ network address _; do
+		[[ $network == *Link* ]] || new_config+="Address = $address"$'\n'
+	done } < <(netstat -I "$REAL_INTERFACE" -n -v)
+	# TODO: actually determine current DNS for interface
 	for address in "${DNS[@]}"; do
 		new_config+="DNS = $address"$'\n'
 	done

commit c99e6beecb3e833006aaf735b38e2dcb84b4f4e3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 23 16:33:14 2018 +0200

    wg-quick: freebsd: work around security vulnerabilities in bash
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index cc3b8e6..6e94983 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -4,8 +4,6 @@
 # Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
-# TODO: Are bash process subsitutions acceptable in FreeBSD, or do they create insecure temporary files?
-
 set -e -o pipefail
 shopt -s extglob
 export LC_ALL=C
@@ -40,6 +38,26 @@ die() {
 
 CONFIG_SEARCH_PATHS=( /etc/wireguard /usr/local/etc/wireguard )
 
+unset ORIGINAL_TMPDIR
+make_temp() {
+	local old_umask
+
+	[[ -v ORIGINAL_TMPDIR ]] && TMPDIR="$ORIGINAL_TMPDIR"
+	ORIGINAL_TMPDIR="$TMPDIR"
+
+	old_umask="$(umask)"
+	umask 077
+	export TMPDIR="$(mktemp -d)"
+	umask "$old_umask"
+
+	[[ -d $TMPDIR ]] || die "Unable to create safe temporary directory"
+	CLEANUP_TMPDIR="$TMPDIR"
+}
+
+clean_temp() {
+	[[ -n $CLEANUP_TMPDIR ]] && rm -rf "$CLEANUP_TMPDIR"
+}
+
 parse_options() {
 	local interface_section=0 line key value stripped path
 	CONFIG_FILE="$1"
@@ -235,7 +253,8 @@ set_endpoint_direct_route() {
 
 monitor_daemon() {
 	echo "[+] Backgrounding route monitor" >&2
-	(trap 'del_routes; exit 0' INT TERM EXIT
+	(make_temp
+	trap 'del_routes; clean_temp; exit 0' INT TERM EXIT
 	exec >/dev/null 2>&1
 	local event
 	# TODO: this should also check to see if the endpoint actually changes
@@ -317,11 +336,11 @@ save_config() {
 	old_umask="$(umask)"
 	umask 077
 	current_config="$(cmd wg showconf "$INTERFACE")"
-	trap 'rm -f "$CONFIG_FILE.tmp"; exit' INT TERM EXIT
+	trap 'rm -f "$CONFIG_FILE.tmp"; clean_temp; exit' INT TERM EXIT
 	echo "${current_config/\[Interface\]$'\n'/$new_config}" > "$CONFIG_FILE.tmp" || die "Could not write configuration file"
 	sync "$CONFIG_FILE.tmp"
 	mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || die "Could not move configuration file"
-	trap - INT TERM EXIT
+	trap 'clean_temp; exit' INT TERM EXIT
 	umask "$old_umask"
 }
 
@@ -366,7 +385,7 @@ cmd_usage() {
 cmd_up() {
 	local i
 	[[ -z $(ifconfig "$INTERFACE" 2>/dev/null) ]] || die "\`$INTERFACE' already exists"
-	trap 'del_if; del_routes; exit' INT TERM EXIT
+	trap 'del_if; del_routes; clean_temp; exit' INT TERM EXIT
 	execute_hooks "${PRE_UP[@]}"
 	add_if
 	set_config
@@ -382,7 +401,7 @@ cmd_up() {
 	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
 	monitor_daemon
 	execute_hooks "${POST_UP[@]}"
-	trap - INT TERM EXIT
+	trap 'clean_temp; exit' INT TERM EXIT
 }
 
 cmd_down() {
@@ -401,6 +420,9 @@ cmd_save() {
 
 # ~~ function override insertion point ~~
 
+make_temp
+trap 'clean_temp; exit' INT TERM EXIT
+
 if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
 	cmd_usage
 elif [[ $# -eq 2 && $1 == up ]]; then

commit 86dd5587a9b3eef4d953253b34908f98a8734999
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 23 15:31:47 2018 +0200

    wg-quick: allow enumeration of socket files
    
    These OSes have an unpriv'd ifconfig, so this isn't an even larger info
    leak.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index d1c83c0..8e0a71f 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -107,7 +107,7 @@ get_real_interface() {
 
 add_if() {
 	export WG_TUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
-	mkdir -m 0700 -p "/var/run/wireguard/"
+	mkdir -p "/var/run/wireguard/"
 	cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" utun
 	get_real_interface
 }
diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
index b8934d4..d37e250 100755
--- a/src/wg-quick/openbsd.bash
+++ b/src/wg-quick/openbsd.bash
@@ -98,7 +98,7 @@ get_real_interface() {
 
 add_if() {
 	export WG_TUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
-	mkdir -m 0700 -p "/var/run/wireguard/"
+	mkdir -p "/var/run/wireguard/"
 	cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" tun
 	get_real_interface
 }

commit 3d089e07e2683576563fa8f163ed0d51543db91a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 23 15:17:41 2018 +0200

    wg-quick: better bash completion for non-renaming OSes
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/completion/wg-quick.bash-completion b/src/completion/wg-quick.bash-completion
index 3474120..7b14b75 100644
--- a/src/completion/wg-quick.bash-completion
+++ b/src/completion/wg-quick.bash-completion
@@ -2,17 +2,18 @@
 # Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_quick_completion() {
-	local p i a search_paths
+	local p i a search_paths old_glob
 	search_paths=( /etc/wireguard )
 
+	old_glob="$(shopt -p nullglob)"
+	shopt -s nullglob
+
 	[[ $OSTYPE == *freebsd* || $OSTYPE == *darwin* ]] && search_paths+=( /usr/local/etc/wireguard )
 
 	if [[ $COMP_CWORD -eq 1 ]]; then
 		COMPREPLY+=( $(compgen -W "up down" -- "${COMP_WORDS[1]}") )
 	elif [[ $COMP_CWORD -eq 2 ]]; then
 		if [[ ${COMP_WORDS[1]} == up ]]; then
-			local old_glob="$(shopt -p nullglob)"
-			shopt -s nullglob
 			for p in "${search_paths[@]}"; do
 				for i in "$p"/*.conf; do
 					i="${i##*/}"; i="${i%.conf}"
@@ -20,15 +21,23 @@ _wg_quick_completion() {
 					COMPREPLY+=( "${a[@]}" )
 				done
 			done
-			eval "$old_glob"
 			mapfile -t a < <(compgen -f -X '!*.conf' -- "${COMP_WORDS[2]}")
 			COMPREPLY+=( "${a[@]}" )
 			mapfile -t a < <(compgen -d -- "${COMP_WORDS[2]}")
 			COMPREPLY+=( "${a[@]}" )
 		elif [[ ${COMP_WORDS[1]} == down ]]; then
-			COMPREPLY+=( $(compgen -W "$(wg show interfaces)" -- "${COMP_WORDS[2]}") )
+			if [[ $OSTYPE == *openbsd* || $OSTYPE == *darwin* ]]; then
+				for i in /var/run/wireguard/*.name; do
+					i="${i##*/}"; i="${i%.name}"
+					mapfile -t a < <(compgen -W "$i" -- "${COMP_WORDS[2]}")
+					COMPREPLY+=( "${a[@]}" )
+				done
+			else
+				COMPREPLY+=( $(compgen -W "$(wg show interfaces)" -- "${COMP_WORDS[2]}") )
+			fi
 		fi
 	fi
+	eval "$old_glob"
 }
 
 complete -o filenames -o nosort -F _wg_quick_completion wg-quick

commit d40231c7667d6c2684105f4e3f1b5d9ac004fb22
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 23 15:08:30 2018 +0200

    wg-quick: support FreeBSD/Darwin search path
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/completion/wg-quick.bash-completion b/src/completion/wg-quick.bash-completion
index e5e3983..3474120 100644
--- a/src/completion/wg-quick.bash-completion
+++ b/src/completion/wg-quick.bash-completion
@@ -2,17 +2,23 @@
 # Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_quick_completion() {
-	local i a
+	local p i a search_paths
+	search_paths=( /etc/wireguard )
+
+	[[ $OSTYPE == *freebsd* || $OSTYPE == *darwin* ]] && search_paths+=( /usr/local/etc/wireguard )
+
 	if [[ $COMP_CWORD -eq 1 ]]; then
 		COMPREPLY+=( $(compgen -W "up down" -- "${COMP_WORDS[1]}") )
 	elif [[ $COMP_CWORD -eq 2 ]]; then
 		if [[ ${COMP_WORDS[1]} == up ]]; then
 			local old_glob="$(shopt -p nullglob)"
 			shopt -s nullglob
-			for i in /etc/wireguard/*.conf; do
-				i="${i##*/}"; i="${i%.conf}"
-				mapfile -t a < <(compgen -W "$i" -- "${COMP_WORDS[2]}")
-				COMPREPLY+=( "${a[@]}" )
+			for p in "${search_paths[@]}"; do
+				for i in "$p"/*.conf; do
+					i="${i##*/}"; i="${i%.conf}"
+					mapfile -t a < <(compgen -W "$i" -- "${COMP_WORDS[2]}")
+					COMPREPLY+=( "${a[@]}" )
+				done
 			done
 			eval "$old_glob"
 			mapfile -t a < <(compgen -f -X '!*.conf' -- "${COMP_WORDS[2]}")
diff --git a/src/man/wg-quick.8 b/src/man/wg-quick.8
index 5e27d10..d97fec9 100644
--- a/src/man/wg-quick.8
+++ b/src/man/wg-quick.8
@@ -31,7 +31,8 @@ interface without bringing the interface down.
 
 \fICONFIG_FILE\fP is a configuration file, whose filename is the interface name
 followed by `.conf'. Otherwise, \fIINTERFACE\fP is an interface name, with configuration
-found at `/etc/wireguard/\fIINTERFACE\fP.conf'.
+found at `/etc/wireguard/\fIINTERFACE\fP.conf', searched first, followed by distro-specific
+search paths.
 
 Generally speaking, this utility is just a simple script that wraps invocations to
 .BR wg (8)
diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 17cf2b8..d1c83c0 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -40,10 +40,16 @@ die() {
 
 [[ ${BASH_VERSINFO[0]} -ge 4 ]] || die "Version mismatch: bash ${BASH_VERSINFO[0]} detected, when bash 4+ required"
 
+CONFIG_SEARCH_PATHS=( /etc/wireguard /usr/local/etc/wireguard )
+
 parse_options() {
-	local interface_section=0 line key value stripped
+	local interface_section=0 line key value stripped path
 	CONFIG_FILE="$1"
-	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
+	if [[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]]; then
+		for path in "${CONFIG_SEARCH_PATHS[@]}"; do
+			[[ -e $path/$CONFIG_FILE.conf ]] && { CONFIG_FILE="$path/$CONFIG_FILE.conf"; break; }
+		done
+	fi
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
 	[[ $CONFIG_FILE =~ (^|/)([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
 	CONFIG_FILE="$(cd "${CONFIG_FILE%/*}" && pwd -P)/${CONFIG_FILE##*/}"
@@ -380,9 +386,11 @@ cmd_usage() {
 
 	  CONFIG_FILE is a configuration file, whose filename is the interface name
 	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
-	  configuration found at /etc/wireguard/INTERFACE.conf. It is to be readable
-	  by wg(8)'s \`setconf' sub-command, with the exception of the following additions
-	  to the [Interface] section, which are handled by $PROGRAM:
+	  configuration found at:
+	  ${CONFIG_SEARCH_PATHS[@]/%//INTERFACE.conf}.
+	  It is to be readable by wg(8)'s \`setconf' sub-command, with the exception
+	  of the following additions to the [Interface] section, which are handled
+	  by $PROGRAM:
 
 	  - Address: may be specified one or more times and contains one or more
 	    IP addresses (with an optional CIDR mask) to be set for the interface.
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
index 6d698e2..cc3b8e6 100755
--- a/src/wg-quick/freebsd.bash
+++ b/src/wg-quick/freebsd.bash
@@ -38,10 +38,16 @@ die() {
 	exit 1
 }
 
+CONFIG_SEARCH_PATHS=( /etc/wireguard /usr/local/etc/wireguard )
+
 parse_options() {
-	local interface_section=0 line key value stripped
+	local interface_section=0 line key value stripped path
 	CONFIG_FILE="$1"
-	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
+	if [[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]]; then
+		for path in "${CONFIG_SEARCH_PATHS[@]}"; do
+			[[ -e $path/$CONFIG_FILE.conf ]] && { CONFIG_FILE="$path/$CONFIG_FILE.conf"; break; }
+		done
+	fi
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
 	[[ $CONFIG_FILE =~ (^|/)([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
 	CONFIG_FILE="$(readlink -f "$CONFIG_FILE")"
@@ -334,9 +340,11 @@ cmd_usage() {
 
 	  CONFIG_FILE is a configuration file, whose filename is the interface name
 	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
-	  configuration found at /etc/wireguard/INTERFACE.conf. It is to be readable
-	  by wg(8)'s \`setconf' sub-command, with the exception of the following additions
-	  to the [Interface] section, which are handled by $PROGRAM:
+	  configuration found at:
+	  ${CONFIG_SEARCH_PATHS[@]/%//INTERFACE.conf}.
+	  It is to be readable by wg(8)'s \`setconf' sub-command, with the exception
+	  of the following additions to the [Interface] section, which are handled
+	  by $PROGRAM:
 
 	  - Address: may be specified one or more times and contains one or more
 	    IP addresses (with an optional CIDR mask) to be set for the interface.

commit b818e71ba56cc78b6c39f305a18582f367b7a65d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 23 05:20:34 2018 +0200

    wg: always pass -v as first argument to install
    
    This lets crippled OSes sed out our -v more easily.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 241293f..a7cdaaa 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -73,18 +73,18 @@ clean:
 endif
 
 install: wg
-	@install -v -d "$(DESTDIR)$(BINDIR)" && install -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"
-	@install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -m 0644 -v man/wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
+	@install -v -d "$(DESTDIR)$(BINDIR)" && install -v -m 0755 wg "$(DESTDIR)$(BINDIR)/wg"
+	@install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -v -m 0644 man/wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
 	@[ "$(WITH_BASHCOMPLETION)" = "yes" ] || exit 0; \
-	install -v -d "$(DESTDIR)$(BASHCOMPDIR)" && install -m 0644 -v completion/wg.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg"
+	install -v -d "$(DESTDIR)$(BASHCOMPDIR)" && install -v -m 0644 completion/wg.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg"
 	@[ "$(WITH_WGQUICK)" = "yes" ] || exit 0; \
-	install -m 0755 -v wg-quick/$(PLATFORM).bash "$(DESTDIR)$(BINDIR)/wg-quick" && install -m 0700 -v -d "$(DESTDIR)$(SYSCONFDIR)/wireguard"
+	install -v -m 0755 wg-quick/$(PLATFORM).bash "$(DESTDIR)$(BINDIR)/wg-quick" && install -v -m 0700 -d "$(DESTDIR)$(SYSCONFDIR)/wireguard"
 	@[ "$(WITH_WGQUICK)" = "yes" ] || exit 0; \
-	install -m 0644 -v man/wg-quick.8 "$(DESTDIR)$(MANDIR)/man8/wg-quick.8"
+	install -v -m 0644 man/wg-quick.8 "$(DESTDIR)$(MANDIR)/man8/wg-quick.8"
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_BASHCOMPLETION)" = "yes" ] || exit 0; \
-	install -m 0644 -v completion/wg-quick.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg-quick"
+	install -v -m 0644 completion/wg-quick.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg-quick"
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_SYSTEMDUNITS)" = "yes" ] || exit 0; \
-	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -m 0644 -v systemd/wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
+	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -v -m 0644 systemd/wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
 
 help:
 	@cat INSTALL

commit 6b7f88aa7d7545bddac91e33698034959abb13d4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 22 16:32:01 2018 +0200

    wg-quick: openbsd: add new implementation
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/openbsd.bash b/src/wg-quick/openbsd.bash
new file mode 100755
index 0000000..b8934d4
--- /dev/null
+++ b/src/wg-quick/openbsd.bash
@@ -0,0 +1,451 @@
+#!/usr/local/bin/bash
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+#
+
+set -e -o pipefail
+shopt -s extglob
+export LC_ALL=C
+
+SELF="$(readlink -f "${BASH_SOURCE[0]}")"
+export PATH="${SELF%/*}:$PATH"
+
+WG_CONFIG=""
+INTERFACE=""
+ADDRESSES=( )
+MTU=""
+DNS=( )
+TABLE=""
+PRE_UP=( )
+POST_UP=( )
+PRE_DOWN=( )
+POST_DOWN=( )
+SAVE_CONFIG=0
+CONFIG_FILE=""
+PROGRAM="${0##*/}"
+ARGS=( "$@" )
+
+cmd() {
+	echo "[#] $*" >&2
+	"$@"
+}
+
+die() {
+	echo "$PROGRAM: $*" >&2
+	exit 1
+}
+
+parse_options() {
+	local interface_section=0 line key value stripped
+	CONFIG_FILE="$1"
+	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
+	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
+	[[ $CONFIG_FILE =~ (^|/)([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
+	CONFIG_FILE="$(readlink -f "$CONFIG_FILE")"
+	((($(stat -f '0%#p' "$CONFIG_FILE") & $(stat -f '0%#p' "${CONFIG_FILE%/*}") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
+	INTERFACE="${BASH_REMATCH[2]}"
+	shopt -s nocasematch
+	while read -r line || [[ -n $line ]]; do
+		stripped="${line%%\#*}"
+		key="${stripped%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
+		value="${stripped#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
+		[[ $key == "["* ]] && interface_section=0
+		[[ $key == "[Interface]" ]] && interface_section=1
+		if [[ $interface_section -eq 1 ]]; then
+			case "$key" in
+			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
+			MTU) MTU="$value"; continue ;;
+			DNS) DNS+=( ${value//,/ } ); continue ;;
+			Table) TABLE="$value"; continue ;;
+			PreUp) PRE_UP+=( "$value" ); continue ;;
+			PreDown) PRE_DOWN+=( "$value" ); continue ;;
+			PostUp) POST_UP+=( "$value" ); continue ;;
+			PostDown) POST_DOWN+=( "$value" ); continue ;;
+			SaveConfig) read_bool SAVE_CONFIG "$value"; continue ;;
+			esac
+		fi
+		WG_CONFIG+="$line"$'\n'
+	done < "$CONFIG_FILE"
+	shopt -u nocasematch
+}
+
+read_bool() {
+	case "$2" in
+	true) printf -v "$1" 1 ;;
+	false) printf -v "$1" 0 ;;
+	*) die "\`$2' is neither true nor false"
+	esac
+}
+
+auto_su() {
+	[[ $UID == 0 ]] || exec doas -- "$BASH" -- "$SELF" "${ARGS[@]}"
+}
+
+
+get_real_interface() {
+	local interface diff
+	wg show interfaces >/dev/null
+	[[ -f "/var/run/wireguard/$INTERFACE.name" ]] || return 1
+	interface="$(< "/var/run/wireguard/$INTERFACE.name")"
+	[[ -n $interface && -S "/var/run/wireguard/$interface.sock" ]] || return 1
+	diff=$(( $(stat -f %m "/var/run/wireguard/$interface.sock" 2>/dev/null || echo 200) - $(stat -f %m "/var/run/wireguard/$INTERFACE.name" 2>/dev/null || echo 100) ))
+	[[ $diff -ge 2 || $diff -le -2 ]] && return 1
+	REAL_INTERFACE="$interface"
+	echo "[+] Interface for $INTERFACE is $REAL_INTERFACE" >&2
+	return 0
+}
+
+add_if() {
+	export WG_TUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
+	mkdir -m 0700 -p "/var/run/wireguard/"
+	cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" tun
+	get_real_interface
+}
+
+del_routes() {
+	local todelete=( ) destination gateway netif
+	[[ -n $REAL_INTERFACE ]] || return 0
+	while read -r destination _ _ _ _ netif _; do
+		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
+	done < <(netstat -nr -f inet)
+	for destination in "${todelete[@]}"; do
+		cmd route -q -n delete -inet "$destination" || true
+	done
+	todelete=( )
+	while read -r destination gateway _ netif; do
+		[[ $netif == "$REAL_INTERFACE" || ( $netif == lo* && $gateway == "$REAL_INTERFACE" ) ]] && todelete+=( "$destination" )
+	done < <(netstat -nr -f inet6)
+	for destination in "${todelete[@]}"; do
+		cmd route -q -n delete -inet6 "$destination" || true
+	done
+	for destination in "${ENDPOINTS[@]}"; do
+		if [[ $destination == *:* ]]; then
+			cmd route -q -n delete -inet6 "$destination" || true
+		else
+			cmd route -q -n delete -inet "$destination" || true
+		fi
+	done
+}
+
+del_if() {
+	unset_dns
+	[[ -z $REAL_INTERFACE ]] || cmd rm -f "/var/run/wireguard/$REAL_INTERFACE.sock"
+	cmd rm -f "/var/run/wireguard/$INTERFACE.name"
+}
+
+up_if() {
+	cmd ifconfig "$REAL_INTERFACE" up
+}
+
+add_addr() {
+	local family
+	if [[ $1 == *:* ]]; then
+		family=inet6
+		[[ -n $FIRSTADDR6 ]] || FIRSTADDR6="${1%/*}"
+	else
+		family=inet
+		[[ -n $FIRSTADDR4 ]] || FIRSTADDR4="${1%/*}"
+	fi
+	cmd ifconfig "$REAL_INTERFACE" $family "$1" alias
+}
+
+set_mtu() {
+	local mtu=0 endpoint output family
+	if [[ -n $MTU ]]; then
+		cmd ifconfig "$REAL_INTERFACE" mtu "$MTU"
+		return
+	fi
+	while read -r _ endpoint; do
+		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
+		family=inet
+		[[ ${BASH_REMATCH[1]} == *:* ]] && family=inet6
+		output="$(route -n get "-$family" "${BASH_REMATCH[1]}" || true)"
+		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
+	done < <(wg show "$REAL_INTERFACE" endpoints)
+	if [[ $mtu -eq 0 ]]; then
+		read -r output < <(route -n get default || true) || true
+		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
+	fi
+	[[ $mtu -gt 0 ]] || mtu=1500
+	cmd ifconfig "$REAL_INTERFACE" mtu $(( mtu - 80 ))
+}
+
+
+collect_gateways() {
+	local destination gateway
+
+	GATEWAY4=""
+	while read -r destination gateway _; do
+		[[ $destination == default ]] || continue
+		GATEWAY4="$gateway"
+		break
+	done < <(netstat -nr -f inet)
+
+	GATEWAY6=""
+	while read -r destination gateway _; do
+		[[ $destination == default ]] || continue
+		[[ $gateway == fe80:* ]] && continue
+		GATEWAY6="$gateway"
+		break
+	done < <(netstat -nr -f inet6)
+}
+
+collect_endpoints() {
+	ENDPOINTS=( )
+	while read -r _ endpoint; do
+		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
+		ENDPOINTS+=( "${BASH_REMATCH[1]}" )
+	done < <(wg show "$REAL_INTERFACE" endpoints)
+}
+
+set_endpoint_direct_route() {
+	local old_endpoints endpoint old_gateway4 old_gateway6 remove_all_old=0 added=( )
+	old_endpoints=( "${ENDPOINTS[@]}" )
+	old_gateway4="$GATEWAY4"
+	old_gateway6="$GATEWAY6"
+	collect_gateways
+	collect_endpoints
+
+	[[ $old_gateway4 != "$GATEWAY4" || $old_gateway6 != "$GATEWAY6" ]] && remove_all_old=1
+
+	if [[ $remove_all_old -eq 1 ]]; then
+		for endpoint in "${ENDPOINTS[@]}"; do
+			[[ " ${old_endpoints[*]} " == *" $endpoint "* ]] || old_endpoints+=( "$endpoint" )
+		done
+	fi
+
+	for endpoint in "${old_endpoints[@]}"; do
+		[[ $remove_all_old -eq 0 && " ${ENDPOINTS[*]} " == *" $endpoint "* ]] && continue
+		if [[ $endpoint == *:* && $AUTO_ROUTE6 -eq 1 ]]; then
+			cmd route -q -n delete -inet6 "$endpoint" 2>/dev/null || true
+		elif [[ $AUTO_ROUTE4 -eq 1 ]]; then
+			cmd route -q -n delete -inet "$endpoint" 2>/dev/null || true
+		fi
+	done
+
+	for endpoint in "${ENDPOINTS[@]}"; do
+		if [[ $remove_all_old -eq 0 && " ${old_endpoints[*]} " == *" $endpoint "* ]]; then
+			added+=( "$endpoint" )
+			continue
+		fi
+		if [[ $endpoint == *:* && $AUTO_ROUTE6 -eq 1 ]]; then
+			if [[ -n $GATEWAY6 ]]; then
+				cmd route -q -n add -inet6 "$endpoint" -gateway "$GATEWAY6" || true
+			else
+				# Prevent routing loop
+				cmd route -q -n add -inet6 "$endpoint" ::1 -blackhole || true
+			fi
+			added+=( "$endpoint" )
+		elif [[ $AUTO_ROUTE4 -eq 1 ]]; then
+			if [[ -n $GATEWAY4 ]]; then
+				cmd route -q -n add -inet "$endpoint" -gateway "$GATEWAY4" || true
+			else
+				# Prevent routing loop
+				cmd route -q -n add -inet "$endpoint" 127.0.0.1 -blackhole || true
+			fi
+			added+=( "$endpoint" )
+		fi
+	done
+	ENDPOINTS=( "${added[@]}" )
+}
+
+monitor_daemon() {
+	echo "[+] Backgrounding route monitor" >&2
+	(trap 'del_routes; exit 0' INT TERM EXIT
+	exec >/dev/null 2>&1
+	local event
+	# TODO: this should also check to see if the endpoint actually changes
+	# in response to incoming packets, and then call set_endpoint_direct_route
+	# then too. That function should be able to gracefully cleanup if the
+	# endpoints change.
+	while read -r event; do
+		[[ $event == RTM_* ]] || continue
+		ifconfig "$REAL_INTERFACE" >/dev/null 2>&1 || break
+		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
+		# TODO: set the mtu as well, but only if up
+	done < <(route -n monitor)) & disown
+}
+
+set_dns() {
+	[[ ${#DNS[@]} -gt 0 ]] || return 0
+	# TODO: this is a horrible way of doing it. Has OpenBSD no resolvconf?
+	cmd cp /etc/resolv.conf "/etc/resolv.conf.wg-quick-backup.$INTERFACE"
+	cmd printf 'nameserver %s\n' "${DNS[@]}" > /etc/resolv.conf
+}
+
+unset_dns() {
+	[[ -f "/etc/resolv.conf.wg-quick-backup.$INTERFACE" ]] || return 0
+	cmd mv "/etc/resolv.conf.wg-quick-backup.$INTERFACE" /etc/resolv.conf
+}
+
+add_route() {
+	[[ $TABLE != off ]] || return 0
+	local family ifaceroute
+
+	if [[ $1 == *:* ]]; then
+		family=inet6
+		[[ -n $FIRSTADDR6 ]] || die "Local IPv6 address must be set to have routes"
+		ifaceroute="$FIRSTADDR6"
+	else
+		family=inet
+		[[ -n $FIRSTADDR4 ]] || die "Local IPv4 address must be set to have routes"
+		ifaceroute="$FIRSTADDR4"
+	fi
+
+	if [[ -n $TABLE && $TABLE != auto ]]; then
+		cmd route -q -n add "-$family" -rdomain "$TABLE" "$1" -iface "$ifaceroute"
+	elif [[ $1 == */0 ]]; then
+		if [[ $1 == *:* ]]; then
+			AUTO_ROUTE6=1
+			cmd route -q -n add -inet6 ::/1 -iface "$ifaceroute"
+			cmd route -q -n add -inet6 8000::/1 -iface "$ifaceroute"
+		else
+			AUTO_ROUTE4=1
+			cmd route -q -n add -inet 0.0.0.0/1 -iface "$ifaceroute"
+			cmd route -q -n add -inet 128.0.0.0/1 -iface "$ifaceroute"
+		fi
+	else
+		[[ $(route -n get "-$family" "$1" 2>/dev/null) =~ interface:\ $REAL_INTERFACE$'\n' ]] || cmd route -q -n add "-$family" "$1" -iface "$ifaceroute"
+	fi
+}
+
+set_config() {
+	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG")
+}
+
+save_config() {
+	# TODO: actually save addresses by running ifconfig and dnses too
+	local old_umask new_config current_config address cmd
+	new_config=$'[Interface]\n'
+	for address in "${ADDRESSES[@]}"; do
+		new_config+="Address = $address"$'\n'
+	done
+	for address in "${DNS[@]}"; do
+		new_config+="DNS = $address"$'\n'
+	done
+	[[ -n $MTU ]] && new_config+="MTU = $MTU"$'\n'
+	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
+	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
+	for cmd in "${PRE_UP[@]}"; do
+		new_config+="PreUp = $cmd"$'\n'
+	done
+	for cmd in "${POST_UP[@]}"; do
+		new_config+="PostUp = $cmd"$'\n'
+	done
+	for cmd in "${PRE_DOWN[@]}"; do
+		new_config+="PreDown = $cmd"$'\n'
+	done
+	for cmd in "${POST_DOWN[@]}"; do
+		new_config+="PostDown = $cmd"$'\n'
+	done
+	old_umask="$(umask)"
+	umask 077
+	current_config="$(cmd wg showconf "$REAL_INTERFACE")"
+	trap 'rm -f "$CONFIG_FILE.tmp"; exit' INT TERM EXIT
+	echo "${current_config/\[Interface\]$'\n'/$new_config}" > "$CONFIG_FILE.tmp" || die "Could not write configuration file"
+	sync "$CONFIG_FILE.tmp"
+	mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || die "Could not move configuration file"
+	trap - INT TERM EXIT
+	umask "$old_umask"
+}
+
+execute_hooks() {
+	local hook
+	for hook in "$@"; do
+		hook="${hook//%i/$REAL_INTERFACE}"
+		hook="${hook//%I/$INTERFACE}"
+		echo "[#] $hook" >&2
+		(eval "$hook")
+	done
+}
+
+cmd_usage() {
+	cat >&2 <<-_EOF
+	Usage: $PROGRAM [ up | down | save ] [ CONFIG_FILE | INTERFACE ]
+
+	  CONFIG_FILE is a configuration file, whose filename is the interface name
+	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
+	  configuration found at /etc/wireguard/INTERFACE.conf. It is to be readable
+	  by wg(8)'s \`setconf' sub-command, with the exception of the following additions
+	  to the [Interface] section, which are handled by $PROGRAM:
+
+	  - Address: may be specified one or more times and contains one or more
+	    IP addresses (with an optional CIDR mask) to be set for the interface.
+	  - DNS: an optional DNS server to use while the device is up.
+	  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.
+	  - Table: an optional routing table to which routes will be added; if
+	    unspecified or \`auto', the default table is used. If \`off', no routes
+	    are added.
+	  - PreUp, PostUp, PreDown, PostDown: script snippets which will be executed
+	    by bash(1) at the corresponding phases of the link, most commonly used
+	    to configure DNS. The string \`%i' is expanded to INTERFACE.
+	  - SaveConfig: if set to \`true', the configuration is saved from the current
+	    state of the interface upon shutdown.
+
+	See wg-quick(8) for more info and examples.
+	_EOF
+}
+
+cmd_up() {
+	local i
+	get_real_interface && die "\`$INTERFACE' already exists as \`$REAL_INTERFACE'"
+	trap 'del_if; del_routes; exit' INT TERM EXIT
+	execute_hooks "${PRE_UP[@]}"
+	add_if
+	set_config
+	for i in "${ADDRESSES[@]}"; do
+		add_addr "$i"
+	done
+	set_mtu
+	up_if
+	set_dns
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
+		add_route "$i"
+	done
+	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
+	monitor_daemon
+	execute_hooks "${POST_UP[@]}"
+	trap - INT TERM EXIT
+}
+
+cmd_down() {
+	if ! get_real_interface || [[ " $(wg show interfaces) " != *" $REAL_INTERFACE "* ]]; then
+		die "\`$INTERFACE' is not a WireGuard interface"
+	fi
+	execute_hooks "${PRE_DOWN[@]}"
+	[[ $SAVE_CONFIG -eq 0 ]] || save_config
+	del_if
+	unset_dns
+	execute_hooks "${POST_DOWN[@]}"
+}
+
+cmd_save() {
+	if ! get_real_interface || [[ " $(wg show interfaces) " != *" $REAL_INTERFACE "* ]]; then
+		die "\`$INTERFACE' is not a WireGuard interface"
+	fi
+	save_config
+}
+
+# ~~ function override insertion point ~~
+
+if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
+	cmd_usage
+elif [[ $# -eq 2 && $1 == up ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_up
+elif [[ $# -eq 2 && $1 == down ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_down
+elif [[ $# -eq 2 && $1 == save ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_save
+else
+	cmd_usage
+	exit 1
+fi
+
+exit 0

commit 333363f77c706b79d2e136fa3d0d1133be1d46f5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 21 22:04:37 2018 +0200

    wg-quick: freebsd: add new implementation
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 566cfea..17cf2b8 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -113,20 +113,20 @@ del_routes() {
 		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
 	done < <(netstat -nr -f inet)
 	for destination in "${todelete[@]}"; do
-		cmd route -q delete -inet "$destination" >/dev/null || true
+		cmd route -q -n delete -inet "$destination" >/dev/null || true
 	done
 	todelete=( )
 	while read -r destination gateway _ netif; do
 		[[ $netif == "$REAL_INTERFACE" || ( $netif == lo* && $gateway == "$REAL_INTERFACE" ) ]] && todelete+=( "$destination" )
 	done < <(netstat -nr -f inet6)
 	for destination in "${todelete[@]}"; do
-		cmd route -q delete -inet6 "$destination" >/dev/null || true
+		cmd route -q -n delete -inet6 "$destination" >/dev/null || true
 	done
 	for destination in "${ENDPOINTS[@]}"; do
 		if [[ $destination == *:* ]]; then
-			cmd route -q delete -inet6 "$destination" >/dev/null || true
+			cmd route -q -n delete -inet6 "$destination" >/dev/null || true
 		else
-			cmd route -q delete -inet "$destination" >/dev/null || true
+			cmd route -q -n delete -inet "$destination" >/dev/null || true
 		fi
 	done
 }
@@ -149,6 +149,7 @@ add_addr() {
 }
 
 set_mtu() {
+	# TODO: use better set_mtu algorithm from freebsd.bash
 	local mtu=0 current_mtu=-1 destination netif defaultif
 	if [[ -n $MTU ]]; then
 		cmd ifconfig "$REAL_INTERFACE" mtu "$MTU"
@@ -231,9 +232,9 @@ set_endpoint_direct_route() {
 	for endpoint in "${old_endpoints[@]}"; do
 		[[ $remove_all_old -eq 0 && " ${ENDPOINTS[*]} " == *" $endpoint "* ]] && continue
 		if [[ $endpoint == *:* && $AUTO_ROUTE6 -eq 1 ]]; then
-			cmd route -q delete -inet6 "$endpoint" >/dev/null 2>&1 || true
+			cmd route -q -n delete -inet6 "$endpoint" >/dev/null 2>&1 || true
 		elif [[ $AUTO_ROUTE4 -eq 1 ]]; then
-			cmd route -q delete -inet "$endpoint" >/dev/null 2>&1 || true
+			cmd route -q -n delete -inet "$endpoint" >/dev/null 2>&1 || true
 		fi
 	done
 
@@ -244,18 +245,18 @@ set_endpoint_direct_route() {
 		fi
 		if [[ $endpoint == *:* && $AUTO_ROUTE6 -eq 1 ]]; then
 			if [[ -n $GATEWAY6 ]]; then
-				cmd route -q add -inet6 "$endpoint" -gateway "$GATEWAY6" >/dev/null || true
+				cmd route -q -n add -inet6 "$endpoint" -gateway "$GATEWAY6" >/dev/null || true
 			else
 				# Prevent routing loop
-				cmd route -q add -inet6 "$endpoint" ::1 -blackhole >/dev/null || true
+				cmd route -q -n add -inet6 "$endpoint" ::1 -blackhole >/dev/null || true
 			fi
 			added+=( "$endpoint" )
 		elif [[ $AUTO_ROUTE4 -eq 1 ]]; then
 			if [[ -n $GATEWAY4 ]]; then
-				cmd route -q add -inet "$endpoint" -gateway "$GATEWAY4" >/dev/null || true
+				cmd route -q -n add -inet "$endpoint" -gateway "$GATEWAY4" >/dev/null || true
 			else
 				# Prevent routing loop
-				cmd route -q add -inet "$endpoint" 127.0.0.1 -blackhole >/dev/null || true
+				cmd route -q -n add -inet "$endpoint" 127.0.0.1 -blackhole >/dev/null || true
 			fi
 			added+=( "$endpoint" )
 		fi
@@ -309,16 +310,17 @@ add_route() {
 	if [[ $1 == */0 && ( -z $TABLE || $TABLE == auto ) ]]; then
 		if [[ $1 == *:* ]]; then
 			AUTO_ROUTE6=1
-			cmd route -q add -inet6 ::/1 -interface "$REAL_INTERFACE" >/dev/null
-			cmd route -q add -inet6 8000::/1 -interface "$REAL_INTERFACE" >/dev/null
+			cmd route -q -n add -inet6 ::/1 -interface "$REAL_INTERFACE" >/dev/null
+			cmd route -q -n add -inet6 8000::/1 -interface "$REAL_INTERFACE" >/dev/null
 		else
 			AUTO_ROUTE4=1
-			cmd route -q add -inet 0.0.0.0/1 -interface "$REAL_INTERFACE" >/dev/null
-			cmd route -q add -inet 128.0.0.0/1 -interface "$REAL_INTERFACE" >/dev/null
+			cmd route -q -n add -inet 0.0.0.0/1 -interface "$REAL_INTERFACE" >/dev/null
+			cmd route -q -n add -inet 128.0.0.0/1 -interface "$REAL_INTERFACE" >/dev/null
 		fi
 	else
 		[[ $TABLE == main || $TABLE == auto || -z $TABLE ]] || die "Darwin only supports TABLE=auto|main|off"
-		cmd route -q add "-$family" "$1" -interface "$REAL_INTERFACE" >/dev/null
+		[[ $(route -n get "-$family" "$1" 2>/dev/null) =~ interface:\ $REAL_INTERFACE$'\n' ]] || cmd route -q -n add -$family "$1" -interface "$REAL_INTERFACE" >/dev/null
+
 	fi
 }
 
@@ -327,6 +329,7 @@ set_config() {
 }
 
 save_config() {
+	# TODO: actually save addresses and DNS by running ifconfig and networksetup
 	local old_umask new_config current_config address cmd
 	new_config=$'[Interface]\n'
 	for address in "${ADDRESSES[@]}"; do
@@ -411,7 +414,7 @@ cmd_up() {
 	done
 	set_mtu
 	up_if
-	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips)); do
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
 		add_route "$i"
 	done
 	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
diff --git a/src/wg-quick/freebsd.bash b/src/wg-quick/freebsd.bash
new file mode 100755
index 0000000..6d698e2
--- /dev/null
+++ b/src/wg-quick/freebsd.bash
@@ -0,0 +1,415 @@
+#!/usr/local/bin/bash
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+#
+
+# TODO: Are bash process subsitutions acceptable in FreeBSD, or do they create insecure temporary files?
+
+set -e -o pipefail
+shopt -s extglob
+export LC_ALL=C
+
+SELF="$(readlink -f "${BASH_SOURCE[0]}")"
+export PATH="${SELF%/*}:$PATH"
+
+WG_CONFIG=""
+INTERFACE=""
+ADDRESSES=( )
+MTU=""
+DNS=( )
+TABLE=""
+PRE_UP=( )
+POST_UP=( )
+PRE_DOWN=( )
+POST_DOWN=( )
+SAVE_CONFIG=0
+CONFIG_FILE=""
+PROGRAM="${0##*/}"
+ARGS=( "$@" )
+
+cmd() {
+	echo "[#] $*" >&2
+	"$@"
+}
+
+die() {
+	echo "$PROGRAM: $*" >&2
+	exit 1
+}
+
+parse_options() {
+	local interface_section=0 line key value stripped
+	CONFIG_FILE="$1"
+	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
+	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
+	[[ $CONFIG_FILE =~ (^|/)([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
+	CONFIG_FILE="$(readlink -f "$CONFIG_FILE")"
+	((($(stat -f '0%#p' "$CONFIG_FILE") & $(stat -f '0%#p' "${CONFIG_FILE%/*}") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
+	INTERFACE="${BASH_REMATCH[2]}"
+	shopt -s nocasematch
+	while read -r line || [[ -n $line ]]; do
+		stripped="${line%%\#*}"
+		key="${stripped%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
+		value="${stripped#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
+		[[ $key == "["* ]] && interface_section=0
+		[[ $key == "[Interface]" ]] && interface_section=1
+		if [[ $interface_section -eq 1 ]]; then
+			case "$key" in
+			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
+			MTU) MTU="$value"; continue ;;
+			DNS) DNS+=( ${value//,/ } ); continue ;;
+			Table) TABLE="$value"; continue ;;
+			PreUp) PRE_UP+=( "$value" ); continue ;;
+			PreDown) PRE_DOWN+=( "$value" ); continue ;;
+			PostUp) POST_UP+=( "$value" ); continue ;;
+			PostDown) POST_DOWN+=( "$value" ); continue ;;
+			SaveConfig) read_bool SAVE_CONFIG "$value"; continue ;;
+			esac
+		fi
+		WG_CONFIG+="$line"$'\n'
+	done < "$CONFIG_FILE"
+	shopt -u nocasematch
+}
+
+read_bool() {
+	case "$2" in
+	true) printf -v "$1" 1 ;;
+	false) printf -v "$1" 0 ;;
+	*) die "\`$2' is neither true nor false"
+	esac
+}
+
+auto_su() {
+	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " -- "$BASH" -- "$SELF" "${ARGS[@]}"
+}
+
+add_if() {
+	cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" "$INTERFACE"
+}
+
+del_routes() {
+	local todelete=( ) destination gateway netif
+	while read -r destination _ _ _ _ netif _; do
+		[[ $netif == "$INTERFACE" ]] && todelete+=( "$destination" )
+	done < <(netstat -nr -f inet)
+	for destination in "${todelete[@]}"; do
+		cmd route -q -n delete -inet "$destination" || true
+	done
+	todelete=( )
+	while read -r destination gateway _ netif; do
+		[[ $netif == "$INTERFACE" || ( $netif == lo* && $gateway == "$INTERFACE" ) ]] && todelete+=( "$destination" )
+	done < <(netstat -nr -f inet6)
+	for destination in "${todelete[@]}"; do
+		cmd route -q -n delete -inet6 "$destination" || true
+	done
+	for destination in "${ENDPOINTS[@]}"; do
+		if [[ $destination == *:* ]]; then
+			cmd route -q -n delete -inet6 "$destination" || true
+		else
+			cmd route -q -n delete -inet "$destination" || true
+		fi
+	done
+}
+
+del_if() {
+	[[ $HAVE_SET_DNS -eq 0 ]] || unset_dns
+	cmd rm -f "/var/run/wireguard/$INTERFACE.sock"
+}
+
+up_if() {
+	cmd ifconfig "$INTERFACE" up
+}
+
+add_addr() {
+	local family=inet
+	[[ $1 == *:* ]] && family=inet6
+	cmd ifconfig "$INTERFACE" "$family" "$1" alias
+}
+
+set_mtu() {
+	local mtu=0 endpoint output family
+	if [[ -n $MTU ]]; then
+		cmd ifconfig "$INTERFACE" mtu "$MTU"
+		return
+	fi
+	while read -r _ endpoint; do
+		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
+		family=inet
+		[[ ${BASH_REMATCH[1]} == *:* ]] && family=inet6
+		output="$(route -n get "-$family" "${BASH_REMATCH[1]}" || true)"
+		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
+	done < <(wg show "$INTERFACE" endpoints)
+	if [[ $mtu -eq 0 ]]; then
+		read -r output < <(route -n get default || true) || true
+		[[ $output =~ interface:\ ([^ ]+)$'\n' && $(ifconfig "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
+	fi
+	[[ $mtu -gt 0 ]] || mtu=1500
+	cmd ifconfig "$INTERFACE" mtu $(( mtu - 80 ))
+}
+
+
+collect_gateways() {
+	local destination gateway
+
+	GATEWAY4=""
+	while read -r destination gateway _; do
+		[[ $destination == default ]] || continue
+		GATEWAY4="$gateway"
+		break
+	done < <(netstat -nr -f inet)
+
+	GATEWAY6=""
+	while read -r destination gateway _; do
+		[[ $destination == default ]] || continue
+		[[ $gateway == fe80:* ]] && continue
+		GATEWAY6="$gateway"
+		break
+	done < <(netstat -nr -f inet6)
+}
+
+collect_endpoints() {
+	ENDPOINTS=( )
+	while read -r _ endpoint; do
+		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
+		ENDPOINTS+=( "${BASH_REMATCH[1]}" )
+	done < <(wg show "$INTERFACE" endpoints)
+}
+
+set_endpoint_direct_route() {
+	local old_endpoints endpoint old_gateway4 old_gateway6 remove_all_old=0 added=( )
+	old_endpoints=( "${ENDPOINTS[@]}" )
+	old_gateway4="$GATEWAY4"
+	old_gateway6="$GATEWAY6"
+	collect_gateways
+	collect_endpoints
+
+	[[ $old_gateway4 != "$GATEWAY4" || $old_gateway6 != "$GATEWAY6" ]] && remove_all_old=1
+
+	if [[ $remove_all_old -eq 1 ]]; then
+		for endpoint in "${ENDPOINTS[@]}"; do
+			[[ " ${old_endpoints[*]} " == *" $endpoint "* ]] || old_endpoints+=( "$endpoint" )
+		done
+	fi
+
+	for endpoint in "${old_endpoints[@]}"; do
+		[[ $remove_all_old -eq 0 && " ${ENDPOINTS[*]} " == *" $endpoint "* ]] && continue
+		if [[ $endpoint == *:* && $AUTO_ROUTE6 -eq 1 ]]; then
+			cmd route -q -n delete -inet6 "$endpoint" 2>/dev/null || true
+		elif [[ $AUTO_ROUTE4 -eq 1 ]]; then
+			cmd route -q -n delete -inet "$endpoint" 2>/dev/null || true
+		fi
+	done
+
+	for endpoint in "${ENDPOINTS[@]}"; do
+		if [[ $remove_all_old -eq 0 && " ${old_endpoints[*]} " == *" $endpoint "* ]]; then
+			added+=( "$endpoint" )
+			continue
+		fi
+		if [[ $endpoint == *:* && $AUTO_ROUTE6 -eq 1 ]]; then
+			if [[ -n $GATEWAY6 ]]; then
+				cmd route -q -n add -inet6 "$endpoint" -gateway "$GATEWAY6" || true
+			else
+				# Prevent routing loop
+				cmd route -q -n add -inet6 "$endpoint" ::1 -blackhole || true
+			fi
+			added+=( "$endpoint" )
+		elif [[ $AUTO_ROUTE4 -eq 1 ]]; then
+			if [[ -n $GATEWAY4 ]]; then
+				cmd route -q -n add -inet "$endpoint" -gateway "$GATEWAY4" || true
+			else
+				# Prevent routing loop
+				cmd route -q -n add -inet "$endpoint" 127.0.0.1 -blackhole || true
+			fi
+			added+=( "$endpoint" )
+		fi
+	done
+	ENDPOINTS=( "${added[@]}" )
+}
+
+monitor_daemon() {
+	echo "[+] Backgrounding route monitor" >&2
+	(trap 'del_routes; exit 0' INT TERM EXIT
+	exec >/dev/null 2>&1
+	local event
+	# TODO: this should also check to see if the endpoint actually changes
+	# in response to incoming packets, and then call set_endpoint_direct_route
+	# then too. That function should be able to gracefully cleanup if the
+	# endpoints change.
+	while read -r event; do
+		[[ $event == RTM_* ]] || continue
+		ifconfig "$INTERFACE" >/dev/null 2>&1 || break
+		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
+		# TODO: set the mtu as well, but only if up
+	done < <(route -n monitor)) & disown
+}
+
+HAVE_SET_DNS=0
+set_dns() {
+	[[ ${#DNS[@]} -gt 0 ]] || return 0
+	printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "$INTERFACE" -x
+	HAVE_SET_DNS=1
+}
+
+unset_dns() {
+	[[ ${#DNS[@]} -gt 0 ]] || return 0
+	cmd resolvconf -d "$INTERFACE"
+}
+
+add_route() {
+	[[ $TABLE != off ]] || return 0
+
+	local family=inet
+	[[ $1 == *:* ]] && family=inet6
+
+	if [[ -n $TABLE && $TABLE != auto ]]; then
+		cmd route -q -n add "-$family" -fib "$TABLE" "$1" -interface "$INTERFACE"
+	elif [[ $1 == */0 ]]; then
+		if [[ $1 == *:* ]]; then
+			AUTO_ROUTE6=1
+			cmd route -q -n add -inet6 ::/1 -interface "$INTERFACE"
+			cmd route -q -n add -inet6 8000::/1 -interface "$INTERFACE"
+		else
+			AUTO_ROUTE4=1
+			cmd route -q -n add -inet 0.0.0.0/1 -interface "$INTERFACE"
+			cmd route -q -n add -inet 128.0.0.0/1 -interface "$INTERFACE"
+		fi
+	else
+		[[ $(route -n get "-$family" "$1" 2>/dev/null) =~ interface:\ $INTERFACE$'\n' ]] || cmd route -q -n add "-$family" "$1" -interface "$INTERFACE"
+	fi
+}
+
+set_config() {
+	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG")
+}
+
+save_config() {
+	# TODO: actually save addresses by running ifconfig
+	local old_umask new_config current_config address cmd
+	new_config=$'[Interface]\n'
+	for address in "${ADDRESSES[@]}"; do
+		new_config+="Address = $address"$'\n'
+	done
+	while read -r address; do
+		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
+	done < <(resolvconf -l "$INTERFACE" 2>/dev/null)
+	[[ -n $MTU ]] && new_config+="MTU = $MTU"$'\n'
+	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
+	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
+	for cmd in "${PRE_UP[@]}"; do
+		new_config+="PreUp = $cmd"$'\n'
+	done
+	for cmd in "${POST_UP[@]}"; do
+		new_config+="PostUp = $cmd"$'\n'
+	done
+	for cmd in "${PRE_DOWN[@]}"; do
+		new_config+="PreDown = $cmd"$'\n'
+	done
+	for cmd in "${POST_DOWN[@]}"; do
+		new_config+="PostDown = $cmd"$'\n'
+	done
+	old_umask="$(umask)"
+	umask 077
+	current_config="$(cmd wg showconf "$INTERFACE")"
+	trap 'rm -f "$CONFIG_FILE.tmp"; exit' INT TERM EXIT
+	echo "${current_config/\[Interface\]$'\n'/$new_config}" > "$CONFIG_FILE.tmp" || die "Could not write configuration file"
+	sync "$CONFIG_FILE.tmp"
+	mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || die "Could not move configuration file"
+	trap - INT TERM EXIT
+	umask "$old_umask"
+}
+
+execute_hooks() {
+	local hook
+	for hook in "$@"; do
+		hook="${hook//%i/$INTERFACE}"
+		echo "[#] $hook" >&2
+		(eval "$hook")
+	done
+}
+
+cmd_usage() {
+	cat >&2 <<-_EOF
+	Usage: $PROGRAM [ up | down | save ] [ CONFIG_FILE | INTERFACE ]
+
+	  CONFIG_FILE is a configuration file, whose filename is the interface name
+	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
+	  configuration found at /etc/wireguard/INTERFACE.conf. It is to be readable
+	  by wg(8)'s \`setconf' sub-command, with the exception of the following additions
+	  to the [Interface] section, which are handled by $PROGRAM:
+
+	  - Address: may be specified one or more times and contains one or more
+	    IP addresses (with an optional CIDR mask) to be set for the interface.
+	  - DNS: an optional DNS server to use while the device is up.
+	  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.
+	  - Table: an optional routing table to which routes will be added; if
+	    unspecified or \`auto', the default table is used. If \`off', no routes
+	    are added.
+	  - PreUp, PostUp, PreDown, PostDown: script snippets which will be executed
+	    by bash(1) at the corresponding phases of the link, most commonly used
+	    to configure DNS. The string \`%i' is expanded to INTERFACE.
+	  - SaveConfig: if set to \`true', the configuration is saved from the current
+	    state of the interface upon shutdown.
+
+	See wg-quick(8) for more info and examples.
+	_EOF
+}
+
+cmd_up() {
+	local i
+	[[ -z $(ifconfig "$INTERFACE" 2>/dev/null) ]] || die "\`$INTERFACE' already exists"
+	trap 'del_if; del_routes; exit' INT TERM EXIT
+	execute_hooks "${PRE_UP[@]}"
+	add_if
+	set_config
+	for i in "${ADDRESSES[@]}"; do
+		add_addr "$i"
+	done
+	set_mtu
+	up_if
+	set_dns
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
+		add_route "$i"
+	done
+	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
+	monitor_daemon
+	execute_hooks "${POST_UP[@]}"
+	trap - INT TERM EXIT
+}
+
+cmd_down() {
+	[[ " $(wg show interfaces) " == *" $INTERFACE "* ]] || die "\`$INTERFACE' is not a WireGuard interface"
+	execute_hooks "${PRE_DOWN[@]}"
+	[[ $SAVE_CONFIG -eq 0 ]] || save_config
+	del_if
+	unset_dns
+	execute_hooks "${POST_DOWN[@]}"
+}
+
+cmd_save() {
+	[[ " $(wg show interfaces) " == *" $INTERFACE "* ]] || die "\`$INTERFACE' is not a WireGuard interface"
+	save_config
+}
+
+# ~~ function override insertion point ~~
+
+if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
+	cmd_usage
+elif [[ $# -eq 2 && $1 == up ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_up
+elif [[ $# -eq 2 && $1 == down ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_down
+elif [[ $# -eq 2 && $1 == save ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_save
+else
+	cmd_usage
+	exit 1
+fi
+
+exit 0

commit 52eb6a187cba591bcde884676beb54d68426c946
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 22 16:32:40 2018 +0200

    wg-quick: darwin: do not remove routes when no real interface
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 8387d85..566cfea 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -107,6 +107,7 @@ add_if() {
 }
 
 del_routes() {
+	[[ -n $REAL_INTERFACE ]] || return 0
 	local todelete=( ) destination gateway netif
 	while read -r destination _ _ _ _ netif _; do
 		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )

commit 59dae33e9a7a3d8aa9a4bee49c947cd5aab2ebcf
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 22 15:28:06 2018 +0200

    wg-quick: darwin: rename namefile environment variable
    
    This paves the way for an openbsd implementation.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 1443c76..8387d85 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -100,7 +100,7 @@ get_real_interface() {
 }
 
 add_if() {
-	export WG_DARWIN_UTUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
+	export WG_TUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
 	mkdir -m 0700 -p "/var/run/wireguard/"
 	cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" utun
 	get_real_interface

commit 9d52a812c8fcadfcec8870bf0ea5c8e10f240f8c
Author: Filippo Valsorda <hi@filippo.io>
Date:   Mon May 21 00:10:54 2018 -0400

    wg: fix OpenBSD build
    
    License: MIT
    Signed-off-by: Filippo Valsorda <valsorda@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/containers.h b/src/containers.h
index a23da1c..455d998 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -9,9 +9,9 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <time.h>
+#include <sys/socket.h>
 #include <net/if.h>
 #include <netinet/in.h>
-#include <sys/socket.h>
 
 #include "../uapi/wireguard.h"
 
diff --git a/src/ipc.c b/src/ipc.c
index cdb152b..e29a939 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -12,6 +12,7 @@
 #include "mnlg.h"
 #endif
 #include <netinet/in.h>
+#include <sys/socket.h>
 #include <net/if.h>
 #include <errno.h>
 #include <stdbool.h>
@@ -26,7 +27,6 @@
 #include <signal.h>
 #include <netdb.h>
 #include <limits.h>
-#include <sys/socket.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
diff --git a/src/show.c b/src/show.c
index 1b8712f..415489b 100644
--- a/src/show.c
+++ b/src/show.c
@@ -6,6 +6,7 @@
 #include <arpa/inet.h>
 #include <inttypes.h>
 #include <netinet/in.h>
+#include <sys/socket.h>
 #include <net/if.h>
 #include <stdbool.h>
 #include <stddef.h>
diff --git a/src/showconf.c b/src/showconf.c
index 390273a..313ad23 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -5,6 +5,7 @@
 
 #include <arpa/inet.h>
 #include <netinet/in.h>
+#include <sys/socket.h>
 #include <net/if.h>
 #include <stddef.h>
 #include <stdio.h>

commit 550119bb08262cd8ab60d48e0610dbe109f7531d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 22 01:08:51 2018 +0200

    ncat-client-server: do not always call sudo and use env bash
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/ncat-client-server/client-quick.sh b/contrib/ncat-client-server/client-quick.sh
index 25ff615..8ef8f70 100755
--- a/contrib/ncat-client-server/client-quick.sh
+++ b/contrib/ncat-client-server/client-quick.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 # SPDX-License-Identifier: GPL-2.0
 #
 # Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
@@ -19,7 +19,8 @@ IFS=: read -r status server_pubkey server_port internal_ip <&7
 [[ $status == OK ]] || exit 1
 
 echo "[+] Writing config file."
-sudo sh -c 'umask 077; mkdir -p /etc/wireguard; cat > /etc/wireguard/demo.conf' <<_EOF
+[[ $UID -eq 0 ]] || sudo=sudo
+$sudo sh -c 'umask 077; mkdir -p /etc/wireguard; cat > /etc/wireguard/demo.conf' <<_EOF
 [Interface]
 PrivateKey = $privatekey
 Address = $internal_ip/24

commit a8654606c2636824c9e8ac3f0cfd1bf944c8eb24
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 18 19:51:33 2018 +0200

    wg: fix errno propagation and messages
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 3f23d1d..cdb152b 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -185,7 +185,7 @@ static int userspace_get_wireguard_interfaces(struct inflatable_buffer *buffer)
 
 	dir = opendir(SOCK_PATH);
 	if (!dir)
-		return errno == ENOENT ? 0 : errno;
+		return errno == ENOENT ? 0 : -errno;
 	while ((ent = readdir(dir))) {
 		len = strlen(ent->d_name);
 		if (len <= strlen(SOCK_SUFFIX))
@@ -964,7 +964,6 @@ char *ipc_list_devices(void)
 cleanup:
 	errno = -ret;
 	if (errno) {
-		perror("Error when trying to get a list of WireGuard interfaces");
 		free(buffer.buffer);
 		return NULL;
 	}
diff --git a/src/set.c b/src/set.c
index b3f57ef..d44fed9 100644
--- a/src/set.c
+++ b/src/set.c
@@ -29,7 +29,7 @@ int set_main(int argc, char *argv[])
 	device->name[IFNAMSIZ - 1] = '\0';
 
 	if (ipc_set_device(device) != 0) {
-		perror("Unable to set device");
+		perror("Unable to modify interface");
 		goto cleanup;
 	}
 
diff --git a/src/setconf.c b/src/setconf.c
index f146a48..012c245 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -51,7 +51,7 @@ int setconf_main(int argc, char *argv[])
 	device->name[IFNAMSIZ - 1] = '\0';
 
 	if (ipc_set_device(device) != 0) {
-		perror("Unable to set device");
+		perror("Unable to modify interface");
 		goto cleanup;
 	}
 
diff --git a/src/show.c b/src/show.c
index 3fd6a67..1b8712f 100644
--- a/src/show.c
+++ b/src/show.c
@@ -390,7 +390,7 @@ int show_main(int argc, char *argv[])
 		char *interfaces = ipc_list_devices(), *interface;
 
 		if (!interfaces) {
-			perror("Unable to get devices");
+			perror("Unable to list interfaces");
 			return 1;
 		}
 		interface = interfaces;
@@ -398,7 +398,7 @@ int show_main(int argc, char *argv[])
 			struct wgdevice *device = NULL;
 
 			if (ipc_get_device(&device, interface) < 0) {
-				perror("Unable to get device");
+				perror("Unable to access interface");
 				continue;
 			}
 			if (argc == 3) {
@@ -424,7 +424,7 @@ int show_main(int argc, char *argv[])
 		}
 		interfaces = ipc_list_devices();
 		if (!interfaces) {
-			perror("Unable to get devices");
+			perror("Unable to list interfaces");
 			return 1;
 		}
 		interface = interfaces;
@@ -437,7 +437,7 @@ int show_main(int argc, char *argv[])
 		struct wgdevice *device = NULL;
 
 		if (ipc_get_device(&device, argv[1]) < 0) {
-			perror("Unable to get device");
+			perror("Unable to access interface");
 			return 1;
 		}
 		if (argc == 3) {
diff --git a/src/showconf.c b/src/showconf.c
index fa3fd2d..390273a 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -32,7 +32,7 @@ int showconf_main(int argc, char *argv[])
 	}
 
 	if (ipc_get_device(&device, argv[1])) {
-		perror("Unable to get device");
+		perror("Unable to access interface");
 		goto cleanup;
 	}
 

commit 434bc616b2e4f5b927e4e8393b10a9c9c7e0dbd8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu May 17 19:29:48 2018 +0200

    wg-quick: darwin: simpler inclusion check
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index d084191..1443c76 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -207,7 +207,7 @@ collect_new_service_dns() {
 	done; } < <(networksetup -listallnetworkservices)
 
 	for service in "${!SERVICE_DNS[@]}"; do
-		[[ ${found_services["$service"]} == 1 ]] || unset SERVICE_DNS["$service"]
+		[[ -n ${found_services["$service"]} ]] || unset SERVICE_DNS["$service"]
 	done
 }
 

commit 986feba2ee6a5ecaf5d91394670947e1b60726c9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu May 17 04:58:27 2018 +0200

    wg-quick: darwin: reorder functions
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index c611877..d084191 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -159,7 +159,7 @@ set_mtu() {
 			break
 		fi
 	done < <(netstat -nr -f inet)
-	[[ -n $defaultif &&  $(ifconfig "$defaultif") =~ mtu\ ([0-9]+) ]] && mtu="${BASH_REMATCH[1]}"
+	[[ -n $defaultif && $(ifconfig "$defaultif") =~ mtu\ ([0-9]+) ]] && mtu="${BASH_REMATCH[1]}"
 	[[ $mtu -gt 0 ]] || mtu=1500
 	mtu=$(( mtu - 80 ))
 	[[ $(ifconfig "$REAL_INTERFACE") =~ mtu\ ([0-9]+) ]] && current_mtu="${BASH_REMATCH[1]}"
@@ -193,6 +193,24 @@ collect_endpoints() {
 	done < <(wg show "$REAL_INTERFACE" endpoints)
 }
 
+declare -A SERVICE_DNS
+collect_new_service_dns() {
+	local service get_response
+	local -A found_services
+	{ read -r _ && while read -r service; do
+		[[ $service == "*"* ]] && service="${service:1}"
+		found_services["$service"]=1
+		[[ -n ${SERVICE_DNS["$service"]} ]] && continue
+		get_response="$(cmd networksetup -getdnsservers "$service")"
+		[[ $get_response == *" "* ]] && get_response="Empty"
+		[[ -n $get_response ]] && SERVICE_DNS["$service"]="$get_response"
+	done; } < <(networksetup -listallnetworkservices)
+
+	for service in "${!SERVICE_DNS[@]}"; do
+		[[ ${found_services["$service"]} == 1 ]] || unset SERVICE_DNS["$service"]
+	done
+}
+
 set_endpoint_direct_route() {
 	local old_endpoints endpoint old_gateway4 old_gateway6 remove_all_old=0 added=( )
 	old_endpoints=( "${ENDPOINTS[@]}" )
@@ -244,24 +262,6 @@ set_endpoint_direct_route() {
 	ENDPOINTS=( "${added[@]}" )
 }
 
-declare -A SERVICE_DNS
-collect_new_service_dns() {
-	local service get_response
-	local -A found_services
-	{ read -r _ && while read -r service; do
-		[[ $service == "*"* ]] && service="${service:1}"
-		found_services["$service"]=1
-		[[ -n ${SERVICE_DNS["$service"]} ]] && continue
-		get_response="$(cmd networksetup -getdnsservers "$service")"
-		[[ $get_response == *" "* ]] && get_response="Empty"
-		[[ -n $get_response ]] && SERVICE_DNS["$service"]="$get_response"
-	done; } < <(networksetup -listallnetworkservices)
-
-	for service in "${!SERVICE_DNS[@]}"; do
-		[[ ${found_services["$service"]} == 1 ]] || unset SERVICE_DNS["$service"]
-	done
-}
-
 set_dns() {
 	collect_new_service_dns
 	local service response

commit 80ff1f8ded233b646982b82cb3ccc0e7a6fffc11
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu May 17 04:50:18 2018 +0200

    wg-quick: darwin: networksetup does not like missing stdio
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 0edf2fe..c611877 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -284,7 +284,7 @@ del_dns() {
 monitor_daemon() {
 	echo "[+] Backgrounding route monitor" >&2
 	(trap 'del_routes; del_dns; exit 0' INT TERM EXIT
-	exec 1>&- 2>&-
+	exec >/dev/null 2>&1
 	local event
 	# TODO: this should also check to see if the endpoint actually changes
 	# in response to incoming packets, and then call set_endpoint_direct_route

commit 884f7c50cea1b7830d3726f18af5f9b774705718
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu May 17 04:07:11 2018 +0200

    wg-quick: darwin: avoid routing loop if no default
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index dfdd54e..0edf2fe 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -211,9 +211,9 @@ set_endpoint_direct_route() {
 
 	for endpoint in "${old_endpoints[@]}"; do
 		[[ $remove_all_old -eq 0 && " ${ENDPOINTS[*]} " == *" $endpoint "* ]] && continue
-		if [[ $endpoint == *:* ]]; then
+		if [[ $endpoint == *:* && $AUTO_ROUTE6 -eq 1 ]]; then
 			cmd route -q delete -inet6 "$endpoint" >/dev/null 2>&1 || true
-		else
+		elif [[ $AUTO_ROUTE4 -eq 1 ]]; then
 			cmd route -q delete -inet "$endpoint" >/dev/null 2>&1 || true
 		fi
 	done
@@ -223,11 +223,21 @@ set_endpoint_direct_route() {
 			added+=( "$endpoint" )
 			continue
 		fi
-		if [[ $endpoint == *:* && -n $GATEWAY6 ]]; then
-			cmd route -q add -inet6 "$endpoint" -gateway "$GATEWAY6" >/dev/null || true
+		if [[ $endpoint == *:* && $AUTO_ROUTE6 -eq 1 ]]; then
+			if [[ -n $GATEWAY6 ]]; then
+				cmd route -q add -inet6 "$endpoint" -gateway "$GATEWAY6" >/dev/null || true
+			else
+				# Prevent routing loop
+				cmd route -q add -inet6 "$endpoint" ::1 -blackhole >/dev/null || true
+			fi
 			added+=( "$endpoint" )
-		elif [[ -n $GATEWAY4 ]]; then
-			cmd route -q add -inet "$endpoint" -gateway "$GATEWAY4" >/dev/null || true
+		elif [[ $AUTO_ROUTE4 -eq 1 ]]; then
+			if [[ -n $GATEWAY4 ]]; then
+				cmd route -q add -inet "$endpoint" -gateway "$GATEWAY4" >/dev/null || true
+			else
+				# Prevent routing loop
+				cmd route -q add -inet "$endpoint" 127.0.0.1 -blackhole >/dev/null || true
+			fi
 			added+=( "$endpoint" )
 		fi
 	done

commit 0d9f30246d50cc3aa9418b682ca36e25e4a66430
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu May 17 03:26:51 2018 +0200

    wg-quick: darwin: sometimes there are no network services
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 581954c..dfdd54e 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -236,10 +236,9 @@ set_endpoint_direct_route() {
 
 declare -A SERVICE_DNS
 collect_new_service_dns() {
-	# TODO: switch to scutil for all DNS modification
 	local service get_response
 	local -A found_services
-	{ read -r _; while read -r service; do
+	{ read -r _ && while read -r service; do
 		[[ $service == "*"* ]] && service="${service:1}"
 		found_services["$service"]=1
 		[[ -n ${SERVICE_DNS["$service"]} ]] && continue

commit fe9bc71e40a134ba37c7ff0cafda9f22b1fc3c63
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 16 19:19:48 2018 +0200

    wg-quick: use invoking shell in auto rooting
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 0eef3d9..581954c 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -9,6 +9,7 @@ shopt -s extglob
 export LC_ALL=C
 
 SELF="${BASH_SOURCE[0]}"
+[[ $SELF == */* ]] || SELF="./$SELF"
 SELF="$(cd "${SELF%/*}" && pwd -P)/${SELF##*/}"
 export PATH="${SELF%/*}:$PATH"
 
@@ -82,7 +83,7 @@ read_bool() {
 }
 
 auto_su() {
-	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$SELF" "${ARGS[@]}"
+	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " -- "$BASH" -- "$SELF" "${ARGS[@]}"
 }
 
 get_real_interface() {
diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 9139e7f..3f1976b 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -79,7 +79,7 @@ read_bool() {
 }
 
 auto_su() {
-	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$SELF" "${ARGS[@]}"
+	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " -- "$BASH" -- "$SELF" "${ARGS[@]}"
 }
 
 add_if() {

commit 6c407ae27b820310fb382fea9623b45fab50f0e5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 16 04:12:02 2018 +0200

    wg-quick: add intentionally undocumented userspace implementation knob
    
    This knob might disappear at some point, and we don't want to encourage
    its use, so it's not being documented, but this should help with
    development of new implementations.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 4a3240c..0eef3d9 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -101,7 +101,7 @@ get_real_interface() {
 add_if() {
 	export WG_DARWIN_UTUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
 	mkdir -m 0700 -p "/var/run/wireguard/"
-	cmd wireguard-go utun
+	cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" utun
 	get_real_interface
 }
 
diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index 38ccad2..9139e7f 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -86,9 +86,9 @@ add_if() {
 	local ret
 	if ! cmd ip link add "$INTERFACE" type wireguard; then
 		ret=$?
-		[[ -e /sys/module/wireguard ]] || ! command -v wireguard-go >/dev/null && return $ret
+		[[ -e /sys/module/wireguard ]] || ! command -v "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" >/dev/null && exit $ret
 		echo "[!] Missing WireGuard kernel module. Falling back to slow userspace implementation."
-		cmd wireguard-go "$INTERFACE"
+		cmd "${WG_QUICK_USERSPACE_IMPLEMENTATION:-wireguard-go}" "$INTERFACE"
 	fi
 }
 

commit 4502350512f01ddaee8c4e6366bfbd0fedb994b3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 16 04:15:05 2018 +0200

    wg-quick: darwin: use bash from environment and require bash 4+
    
    For properly configured Homebrew installations /usr/local/bin should be
    before /bin, so this should still work. This allows the script to be
    used in more than one setting.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index ba1e49b..4a3240c 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -1,11 +1,9 @@
-#!/usr/local/bin/bash
+#!/usr/bin/env bash
 # SPDX-License-Identifier: GPL-2.0
 #
 # Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
-# The shebang is in /usr/local because this requires bash 4.
-
 set -e -o pipefail
 shopt -s extglob
 export LC_ALL=C
@@ -29,6 +27,18 @@ CONFIG_FILE=""
 PROGRAM="${0##*/}"
 ARGS=( "$@" )
 
+cmd() {
+	echo "[#] $*" >&2
+	"$@"
+}
+
+die() {
+	echo "$PROGRAM: $*" >&2
+	exit 1
+}
+
+[[ ${BASH_VERSINFO[0]} -ge 4 ]] || die "Version mismatch: bash ${BASH_VERSINFO[0]} detected, when bash 4+ required"
+
 parse_options() {
 	local interface_section=0 line key value stripped
 	CONFIG_FILE="$1"
@@ -71,16 +81,6 @@ read_bool() {
 	esac
 }
 
-cmd() {
-	echo "[#] $*" >&2
-	"$@"
-}
-
-die() {
-	echo "$PROGRAM: $*" >&2
-	exit 1
-}
-
 auto_su() {
 	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$SELF" "${ARGS[@]}"
 }
diff --git a/src/wg-quick/linux.bash b/src/wg-quick/linux.bash
index cd66b4d..38ccad2 100755
--- a/src/wg-quick/linux.bash
+++ b/src/wg-quick/linux.bash
@@ -26,6 +26,16 @@ CONFIG_FILE=""
 PROGRAM="${0##*/}"
 ARGS=( "$@" )
 
+cmd() {
+	echo "[#] $*" >&2
+	"$@"
+}
+
+die() {
+	echo "$PROGRAM: $*" >&2
+	exit 1
+}
+
 parse_options() {
 	local interface_section=0 line key value stripped
 	CONFIG_FILE="$1"
@@ -68,16 +78,6 @@ read_bool() {
 	esac
 }
 
-cmd() {
-	echo "[#] $*" >&2
-	"$@"
-}
-
-die() {
-	echo "$PROGRAM: $*" >&2
-	exit 1
-}
-
 auto_su() {
 	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$SELF" "${ARGS[@]}"
 }

commit 699777da8ce8289992c3cf536ef8467439026201
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 16 03:09:33 2018 +0200

    wg-quick: darwin: restore DNS on down
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 5c25961..ba1e49b 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -233,30 +233,42 @@ set_endpoint_direct_route() {
 	ENDPOINTS=( "${added[@]}" )
 }
 
-set_dns() {
-	# TODO: this should use scutil and be slightly more clever. But for now
-	# we simply overwrite any _manually set_ DNS servers for all network
-	# services. This means we get into trouble if the user doesn't actually
-	# want DNS via DHCP when setting this back to "empty". Because macOS is
-	# so horrible to deal with here, we'll simply wait for irate users to
-	# provide a patch themselves.
-	local service response
+declare -A SERVICE_DNS
+collect_new_service_dns() {
+	# TODO: switch to scutil for all DNS modification
+	local service get_response
+	local -A found_services
 	{ read -r _; while read -r service; do
 		[[ $service == "*"* ]] && service="${service:1}"
+		found_services["$service"]=1
+		[[ -n ${SERVICE_DNS["$service"]} ]] && continue
+		get_response="$(cmd networksetup -getdnsservers "$service")"
+		[[ $get_response == *" "* ]] && get_response="Empty"
+		[[ -n $get_response ]] && SERVICE_DNS["$service"]="$get_response"
+	done; } < <(networksetup -listallnetworkservices)
+
+	for service in "${!SERVICE_DNS[@]}"; do
+		[[ ${found_services["$service"]} == 1 ]] || unset SERVICE_DNS["$service"]
+	done
+}
+
+set_dns() {
+	collect_new_service_dns
+	local service response
+	for service in "${!SERVICE_DNS[@]}"; do
 		while read -r response; do
 			[[ $response == *Error* ]] && echo "$response" >&2
 		done < <(cmd networksetup -setdnsservers "$service" "${DNS[@]}")
-	done; } < <(networksetup -listallnetworkservices)
+	done
 }
 
 del_dns() {
 	local service response
-	{ read -r _; while read -r service; do
-		[[ $service == "*"* ]] && service="${service:1}"
+	for service in "${!SERVICE_DNS[@]}"; do
 		while read -r response; do
 			[[ $response == *Error* ]] && echo "$response" >&2
-		done < <(cmd networksetup -setdnsservers "$service" Empty)
-	done; } < <(networksetup -listallnetworkservices)
+		done < <(cmd networksetup -setdnsservers "$service" ${SERVICE_DNS["$service"]} || true)
+	done
 }
 
 monitor_daemon() {

commit 9c18c70da65fe0de72719f32518d515b3843d303
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 16 02:17:33 2018 +0200

    wg-quick: darwin: bash correctness
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index ca7e901..5c25961 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -204,12 +204,12 @@ set_endpoint_direct_route() {
 
 	if [[ $remove_all_old -eq 1 ]]; then
 		for endpoint in "${ENDPOINTS[@]}"; do
-			[[ " ${old_endpoints[*]} " == *"$endpoint"* ]] || old_endpoints+=( "$endpoint" )
+			[[ " ${old_endpoints[*]} " == *" $endpoint "* ]] || old_endpoints+=( "$endpoint" )
 		done
 	fi
 
 	for endpoint in "${old_endpoints[@]}"; do
-		[[ $remove_all_old -eq 0 && " ${ENDPOINTS[*]} " == *"$endpoint"* ]] && continue
+		[[ $remove_all_old -eq 0 && " ${ENDPOINTS[*]} " == *" $endpoint "* ]] && continue
 		if [[ $endpoint == *:* ]]; then
 			cmd route -q delete -inet6 "$endpoint" >/dev/null 2>&1 || true
 		else
@@ -218,7 +218,7 @@ set_endpoint_direct_route() {
 	done
 
 	for endpoint in "${ENDPOINTS[@]}"; do
-		if [[ $remove_all_old -eq 0 && " ${old_endpoints[*]} " == *"$endpoint"* ]]; then
+		if [[ $remove_all_old -eq 0 && " ${old_endpoints[*]} " == *" $endpoint "* ]]; then
 			added+=( "$endpoint" )
 			continue
 		fi
@@ -240,9 +240,7 @@ set_dns() {
 	# want DNS via DHCP when setting this back to "empty". Because macOS is
 	# so horrible to deal with here, we'll simply wait for irate users to
 	# provide a patch themselves.
-
 	local service response
-
 	{ read -r _; while read -r service; do
 		[[ $service == "*"* ]] && service="${service:1}"
 		while read -r response; do
@@ -252,6 +250,7 @@ set_dns() {
 }
 
 del_dns() {
+	local service response
 	{ read -r _; while read -r service; do
 		[[ $service == "*"* ]] && service="${service:1}"
 		while read -r response; do

commit f64f0cc7401e98a0203d13e85f8361eafd3da011
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 15 23:12:15 2018 +0200

    wg-quick: darwin: remove v6 routes after shutdown
    
    This works around a Darwin kernel bug regarding interface removal.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index 0c28085..ca7e901 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -106,7 +106,7 @@ add_if() {
 }
 
 del_routes() {
-	local todelete=( ) destination netif
+	local todelete=( ) destination gateway netif
 	while read -r destination _ _ _ _ netif _; do
 		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
 	done < <(netstat -nr -f inet)
@@ -114,8 +114,8 @@ del_routes() {
 		cmd route -q delete -inet "$destination" >/dev/null || true
 	done
 	todelete=( )
-	while read -r destination _ _ netif; do
-		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
+	while read -r destination gateway _ netif; do
+		[[ $netif == "$REAL_INTERFACE" || ( $netif == lo* && $gateway == "$REAL_INTERFACE" ) ]] && todelete+=( "$destination" )
 	done < <(netstat -nr -f inet6)
 	for destination in "${todelete[@]}"; do
 		cmd route -q delete -inet6 "$destination" >/dev/null || true

commit cfa4203be73ab554739199668f61da50ff2becaf
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 15 20:05:48 2018 +0200

    wg-quick: darwin: ensure socket directory exists
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
index c4fc8f1..0c28085 100755
--- a/src/wg-quick/darwin.bash
+++ b/src/wg-quick/darwin.bash
@@ -100,12 +100,8 @@ get_real_interface() {
 
 add_if() {
 	export WG_DARWIN_UTUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
+	mkdir -m 0700 -p "/var/run/wireguard/"
 	cmd wireguard-go utun
-	local i
-	for i in {1..30}; do
-		[[ -f "/var/run/wireguard/$INTERFACE.name" ]] && break
-		sleep 0.1
-	done
 	get_real_interface
 }
 

commit 19990e293724b1073d5379192b960f8112ef6ee8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 15 21:48:41 2018 +0200

    dns-hatchet: update paths
    
    Suggested-by: Martin Hauke <mardnh@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/dns-hatchet/apply.sh b/contrib/dns-hatchet/apply.sh
index 11e5bed..35460d1 100755
--- a/contrib/dns-hatchet/apply.sh
+++ b/contrib/dns-hatchet/apply.sh
@@ -6,4 +6,4 @@
 ME="$(readlink -f "$(dirname "$(readlink -f "$0")")")"
 TOOLS="$ME/../../../src/tools"
 
-sed -i "/~~ function override insertion point ~~/r $ME/hatchet.bash" "$TOOLS/wg-quick.bash"
+sed -i "/~~ function override insertion point ~~/r $ME/hatchet.bash" "$TOOLS/wg-quick/linux.bash"

commit 2f34f3efe7dc720d86c107eabf5ce6e09d93c2e8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 15 02:26:55 2018 +0200

    ncat-client-server: add wg-quick variant
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/ncat-client-server/client-quick.sh b/contrib/ncat-client-server/client-quick.sh
new file mode 100755
index 0000000..25ff615
--- /dev/null
+++ b/contrib/ncat-client-server/client-quick.sh
@@ -0,0 +1,34 @@
+#!/bin/bash
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
+set -e
+
+echo "[!] Warning: This server is for testing purposes only. You may not use this server for abusive or illegal purposes."
+
+echo "[+] Generating private key."
+privatekey="$(wg genkey)"
+
+echo "[+] Sending public key to server."
+exec 7<>/dev/tcp/demo.wireguard.com/42912
+wg pubkey <<<"$privatekey" >&7
+
+echo "[+] Parsing server response."
+IFS=: read -r status server_pubkey server_port internal_ip <&7
+[[ $status == OK ]] || exit 1
+
+echo "[+] Writing config file."
+sudo sh -c 'umask 077; mkdir -p /etc/wireguard; cat > /etc/wireguard/demo.conf' <<_EOF
+[Interface]
+PrivateKey = $privatekey
+Address = $internal_ip/24
+DNS = 8.8.8.8, 8.8.4.4, 1.1.1.1, 1.0.0.1
+
+[Peer]
+PublicKey = $server_pubkey
+Endpoint = demo.wireguard.com:$server_port
+AllowedIPs = 0.0.0.0/0
+_EOF
+
+echo "[+] Success. Run \`wg-quick up demo\` to turn on the tunnel to the demo server and \`wg-quick down demo\` to turn it off."
diff --git a/contrib/ncat-client-server/client.sh b/contrib/ncat-client-server/client.sh
index 9ad9180..7994f18 100755
--- a/contrib/ncat-client-server/client.sh
+++ b/contrib/ncat-client-server/client.sh
@@ -5,15 +5,14 @@
 
 set -e
 [[ $UID == 0 ]] || { echo "You must be root to run this."; exit 1; }
-umask 077
-trap 'rm -f /tmp/wg_private_key' EXIT INT TERM
 exec 3<>/dev/tcp/demo.wireguard.com/42912
-wg genkey | tee /tmp/wg_private_key | wg pubkey >&3
+privatekey="$(wg genkey)"
+wg pubkey <<<"$privatekey" >&3
 IFS=: read -r status server_pubkey server_port internal_ip <&3
 [[ $status == OK ]]
 ip link del dev wg0 2>/dev/null || true
 ip link add dev wg0 type wireguard
-wg set wg0 private-key /tmp/wg_private_key peer "$server_pubkey" allowed-ips 0.0.0.0/0 endpoint "demo.wireguard.com:$server_port" persistent-keepalive 25
+wg set wg0 private-key <(echo "$privatekey") peer "$server_pubkey" allowed-ips 0.0.0.0/0 endpoint "demo.wireguard.com:$server_port" persistent-keepalive 25
 ip address add "$internal_ip"/24 dev wg0
 ip link set up dev wg0
 if [ "$1" == "default-route" ]; then

commit a5412d10562840a079b955dae4cfb334ae22daf4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 14 22:28:53 2018 +0200

    wg-quick: add darwin implementation
    
    It's pretty rough and leaves much to be desired, but it works.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/darwin.bash b/src/wg-quick/darwin.bash
new file mode 100755
index 0000000..c4fc8f1
--- /dev/null
+++ b/src/wg-quick/darwin.bash
@@ -0,0 +1,444 @@
+#!/usr/local/bin/bash
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+#
+
+# The shebang is in /usr/local because this requires bash 4.
+
+set -e -o pipefail
+shopt -s extglob
+export LC_ALL=C
+
+SELF="${BASH_SOURCE[0]}"
+SELF="$(cd "${SELF%/*}" && pwd -P)/${SELF##*/}"
+export PATH="${SELF%/*}:$PATH"
+
+WG_CONFIG=""
+INTERFACE=""
+ADDRESSES=( )
+MTU=""
+DNS=( )
+TABLE=""
+PRE_UP=( )
+POST_UP=( )
+PRE_DOWN=( )
+POST_DOWN=( )
+SAVE_CONFIG=0
+CONFIG_FILE=""
+PROGRAM="${0##*/}"
+ARGS=( "$@" )
+
+parse_options() {
+	local interface_section=0 line key value stripped
+	CONFIG_FILE="$1"
+	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
+	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
+	[[ $CONFIG_FILE =~ (^|/)([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
+	CONFIG_FILE="$(cd "${CONFIG_FILE%/*}" && pwd -P)/${CONFIG_FILE##*/}"
+	((($(stat -f '0%#p' "$CONFIG_FILE") & $(stat -f '0%#p' "${CONFIG_FILE%/*}") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
+	INTERFACE="${BASH_REMATCH[2]}"
+	shopt -s nocasematch
+	while read -r line || [[ -n $line ]]; do
+		stripped="${line%%\#*}"
+		key="${stripped%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
+		value="${stripped#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
+		[[ $key == "["* ]] && interface_section=0
+		[[ $key == "[Interface]" ]] && interface_section=1
+		if [[ $interface_section -eq 1 ]]; then
+			case "$key" in
+			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
+			MTU) MTU="$value"; continue ;;
+			DNS) DNS+=( ${value//,/ } ); continue ;;
+			Table) TABLE="$value"; continue ;;
+			PreUp) PRE_UP+=( "$value" ); continue ;;
+			PreDown) PRE_DOWN+=( "$value" ); continue ;;
+			PostUp) POST_UP+=( "$value" ); continue ;;
+			PostDown) POST_DOWN+=( "$value" ); continue ;;
+			SaveConfig) read_bool SAVE_CONFIG "$value"; continue ;;
+			esac
+		fi
+		WG_CONFIG+="$line"$'\n'
+	done < "$CONFIG_FILE"
+	shopt -u nocasematch
+}
+
+read_bool() {
+	case "$2" in
+	true) printf -v "$1" 1 ;;
+	false) printf -v "$1" 0 ;;
+	*) die "\`$2' is neither true nor false"
+	esac
+}
+
+cmd() {
+	echo "[#] $*" >&2
+	"$@"
+}
+
+die() {
+	echo "$PROGRAM: $*" >&2
+	exit 1
+}
+
+auto_su() {
+	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$SELF" "${ARGS[@]}"
+}
+
+get_real_interface() {
+	local interface diff
+	wg show interfaces >/dev/null
+	[[ -f "/var/run/wireguard/$INTERFACE.name" ]] || return 1
+	interface="$(< "/var/run/wireguard/$INTERFACE.name")"
+	[[ -n $interface && -S "/var/run/wireguard/$interface.sock" ]] || return 1
+	diff=$(( $(stat -f %m "/var/run/wireguard/$interface.sock" 2>/dev/null || echo 200) - $(stat -f %m "/var/run/wireguard/$INTERFACE.name" 2>/dev/null || echo 100) ))
+	[[ $diff -ge 2 || $diff -le -2 ]] && return 1
+	REAL_INTERFACE="$interface"
+	echo "[+] Interface for $INTERFACE is $REAL_INTERFACE" >&2
+	return 0
+}
+
+add_if() {
+	export WG_DARWIN_UTUN_NAME_FILE="/var/run/wireguard/$INTERFACE.name"
+	cmd wireguard-go utun
+	local i
+	for i in {1..30}; do
+		[[ -f "/var/run/wireguard/$INTERFACE.name" ]] && break
+		sleep 0.1
+	done
+	get_real_interface
+}
+
+del_routes() {
+	local todelete=( ) destination netif
+	while read -r destination _ _ _ _ netif _; do
+		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
+	done < <(netstat -nr -f inet)
+	for destination in "${todelete[@]}"; do
+		cmd route -q delete -inet "$destination" >/dev/null || true
+	done
+	todelete=( )
+	while read -r destination _ _ netif; do
+		[[ $netif == "$REAL_INTERFACE" ]] && todelete+=( "$destination" )
+	done < <(netstat -nr -f inet6)
+	for destination in "${todelete[@]}"; do
+		cmd route -q delete -inet6 "$destination" >/dev/null || true
+	done
+	for destination in "${ENDPOINTS[@]}"; do
+		if [[ $destination == *:* ]]; then
+			cmd route -q delete -inet6 "$destination" >/dev/null || true
+		else
+			cmd route -q delete -inet "$destination" >/dev/null || true
+		fi
+	done
+}
+
+del_if() {
+	[[ -z $REAL_INTERFACE ]] || cmd rm -f "/var/run/wireguard/$REAL_INTERFACE.sock"
+	cmd rm -f "/var/run/wireguard/$INTERFACE.name"
+}
+
+up_if() {
+	cmd ifconfig "$REAL_INTERFACE" up
+}
+
+add_addr() {
+	if [[ $1 == *:* ]]; then
+		cmd ifconfig "$REAL_INTERFACE" inet6 "$1"
+	else
+		cmd ifconfig "$REAL_INTERFACE" inet "$1" "${1%%/*}"
+	fi
+}
+
+set_mtu() {
+	local mtu=0 current_mtu=-1 destination netif defaultif
+	if [[ -n $MTU ]]; then
+		cmd ifconfig "$REAL_INTERFACE" mtu "$MTU"
+		return
+	fi
+	while read -r destination _ _ _ _ netif _; do
+		if [[ $destination == default ]]; then
+			defaultif="$netif"
+			break
+		fi
+	done < <(netstat -nr -f inet)
+	[[ -n $defaultif &&  $(ifconfig "$defaultif") =~ mtu\ ([0-9]+) ]] && mtu="${BASH_REMATCH[1]}"
+	[[ $mtu -gt 0 ]] || mtu=1500
+	mtu=$(( mtu - 80 ))
+	[[ $(ifconfig "$REAL_INTERFACE") =~ mtu\ ([0-9]+) ]] && current_mtu="${BASH_REMATCH[1]}"
+	[[ $mtu -eq $current_mtu ]] || cmd ifconfig "$REAL_INTERFACE" mtu "$mtu"
+}
+
+collect_gateways() {
+	local destination gateway
+
+	GATEWAY4=""
+	while read -r destination gateway _; do
+		[[ $destination == default ]] || continue
+		GATEWAY4="$gateway"
+		break
+	done < <(netstat -nr -f inet)
+
+	GATEWAY6=""
+	while read -r destination gateway _; do
+		[[ $destination == default ]] || continue
+		[[ $gateway == fe80:* ]] && continue
+		GATEWAY6="$gateway"
+		break
+	done < <(netstat -nr -f inet6)
+}
+
+collect_endpoints() {
+	ENDPOINTS=( )
+	while read -r _ endpoint; do
+		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
+		ENDPOINTS+=( "${BASH_REMATCH[1]}" )
+	done < <(wg show "$REAL_INTERFACE" endpoints)
+}
+
+set_endpoint_direct_route() {
+	local old_endpoints endpoint old_gateway4 old_gateway6 remove_all_old=0 added=( )
+	old_endpoints=( "${ENDPOINTS[@]}" )
+	old_gateway4="$GATEWAY4"
+	old_gateway6="$GATEWAY6"
+	collect_gateways
+	collect_endpoints
+
+	[[ $old_gateway4 != "$GATEWAY4" || $old_gateway6 != "$GATEWAY6" ]] && remove_all_old=1
+
+	if [[ $remove_all_old -eq 1 ]]; then
+		for endpoint in "${ENDPOINTS[@]}"; do
+			[[ " ${old_endpoints[*]} " == *"$endpoint"* ]] || old_endpoints+=( "$endpoint" )
+		done
+	fi
+
+	for endpoint in "${old_endpoints[@]}"; do
+		[[ $remove_all_old -eq 0 && " ${ENDPOINTS[*]} " == *"$endpoint"* ]] && continue
+		if [[ $endpoint == *:* ]]; then
+			cmd route -q delete -inet6 "$endpoint" >/dev/null 2>&1 || true
+		else
+			cmd route -q delete -inet "$endpoint" >/dev/null 2>&1 || true
+		fi
+	done
+
+	for endpoint in "${ENDPOINTS[@]}"; do
+		if [[ $remove_all_old -eq 0 && " ${old_endpoints[*]} " == *"$endpoint"* ]]; then
+			added+=( "$endpoint" )
+			continue
+		fi
+		if [[ $endpoint == *:* && -n $GATEWAY6 ]]; then
+			cmd route -q add -inet6 "$endpoint" -gateway "$GATEWAY6" >/dev/null || true
+			added+=( "$endpoint" )
+		elif [[ -n $GATEWAY4 ]]; then
+			cmd route -q add -inet "$endpoint" -gateway "$GATEWAY4" >/dev/null || true
+			added+=( "$endpoint" )
+		fi
+	done
+	ENDPOINTS=( "${added[@]}" )
+}
+
+set_dns() {
+	# TODO: this should use scutil and be slightly more clever. But for now
+	# we simply overwrite any _manually set_ DNS servers for all network
+	# services. This means we get into trouble if the user doesn't actually
+	# want DNS via DHCP when setting this back to "empty". Because macOS is
+	# so horrible to deal with here, we'll simply wait for irate users to
+	# provide a patch themselves.
+
+	local service response
+
+	{ read -r _; while read -r service; do
+		[[ $service == "*"* ]] && service="${service:1}"
+		while read -r response; do
+			[[ $response == *Error* ]] && echo "$response" >&2
+		done < <(cmd networksetup -setdnsservers "$service" "${DNS[@]}")
+	done; } < <(networksetup -listallnetworkservices)
+}
+
+del_dns() {
+	{ read -r _; while read -r service; do
+		[[ $service == "*"* ]] && service="${service:1}"
+		while read -r response; do
+			[[ $response == *Error* ]] && echo "$response" >&2
+		done < <(cmd networksetup -setdnsservers "$service" Empty)
+	done; } < <(networksetup -listallnetworkservices)
+}
+
+monitor_daemon() {
+	echo "[+] Backgrounding route monitor" >&2
+	(trap 'del_routes; del_dns; exit 0' INT TERM EXIT
+	exec 1>&- 2>&-
+	local event
+	# TODO: this should also check to see if the endpoint actually changes
+	# in response to incoming packets, and then call set_endpoint_direct_route
+	# then too. That function should be able to gracefully cleanup if the
+	# endpoints change.
+	while read -r event; do
+		[[ $event == RTM_* ]] || continue
+		ifconfig "$REAL_INTERFACE" >/dev/null 2>&1 || break
+		[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
+		[[ -z $MTU ]] && set_mtu
+		[[ ${#DNS[@]} -gt 0 ]] && set_dns
+	done < <(route -n monitor)) & disown
+}
+
+add_route() {
+	[[ $TABLE != off ]] || return 0
+
+	local family=inet
+	[[ $1 == *:* ]] && family=inet6
+
+	if [[ $1 == */0 && ( -z $TABLE || $TABLE == auto ) ]]; then
+		if [[ $1 == *:* ]]; then
+			AUTO_ROUTE6=1
+			cmd route -q add -inet6 ::/1 -interface "$REAL_INTERFACE" >/dev/null
+			cmd route -q add -inet6 8000::/1 -interface "$REAL_INTERFACE" >/dev/null
+		else
+			AUTO_ROUTE4=1
+			cmd route -q add -inet 0.0.0.0/1 -interface "$REAL_INTERFACE" >/dev/null
+			cmd route -q add -inet 128.0.0.0/1 -interface "$REAL_INTERFACE" >/dev/null
+		fi
+	else
+		[[ $TABLE == main || $TABLE == auto || -z $TABLE ]] || die "Darwin only supports TABLE=auto|main|off"
+		cmd route -q add "-$family" "$1" -interface "$REAL_INTERFACE" >/dev/null
+	fi
+}
+
+set_config() {
+	cmd wg setconf "$REAL_INTERFACE" <(echo "$WG_CONFIG")
+}
+
+save_config() {
+	local old_umask new_config current_config address cmd
+	new_config=$'[Interface]\n'
+	for address in "${ADDRESSES[@]}"; do
+		new_config+="Address = $address"$'\n'
+	done
+	for address in "${DNS[@]}"; do
+		new_config+="DNS = $address"$'\n'
+	done
+	[[ -n $MTU ]] && new_config+="MTU = $MTU"$'\n'
+	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
+	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
+	for cmd in "${PRE_UP[@]}"; do
+		new_config+="PreUp = $cmd"$'\n'
+	done
+	for cmd in "${POST_UP[@]}"; do
+		new_config+="PostUp = $cmd"$'\n'
+	done
+	for cmd in "${PRE_DOWN[@]}"; do
+		new_config+="PreDown = $cmd"$'\n'
+	done
+	for cmd in "${POST_DOWN[@]}"; do
+		new_config+="PostDown = $cmd"$'\n'
+	done
+	old_umask="$(umask)"
+	umask 077
+	current_config="$(cmd wg showconf "$REAL_INTERFACE")"
+	trap 'rm -f "$CONFIG_FILE.tmp"; exit' INT TERM EXIT
+	echo "${current_config/\[Interface\]$'\n'/$new_config}" > "$CONFIG_FILE.tmp" || die "Could not write configuration file"
+	sync "$CONFIG_FILE.tmp"
+	mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || die "Could not move configuration file"
+	trap - INT TERM EXIT
+	umask "$old_umask"
+}
+
+execute_hooks() {
+	local hook
+	for hook in "$@"; do
+		hook="${hook//%i/$REAL_INTERFACE}"
+		hook="${hook//%I/$INTERFACE}"
+		echo "[#] $hook" >&2
+		(eval "$hook")
+	done
+}
+
+cmd_usage() {
+	cat >&2 <<-_EOF
+	Usage: $PROGRAM [ up | down | save ] [ CONFIG_FILE | INTERFACE ]
+
+	  CONFIG_FILE is a configuration file, whose filename is the interface name
+	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
+	  configuration found at /etc/wireguard/INTERFACE.conf. It is to be readable
+	  by wg(8)'s \`setconf' sub-command, with the exception of the following additions
+	  to the [Interface] section, which are handled by $PROGRAM:
+
+	  - Address: may be specified one or more times and contains one or more
+	    IP addresses (with an optional CIDR mask) to be set for the interface.
+	  - DNS: an optional DNS server to use while the device is up.
+	  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.
+	  - Table: an optional routing table to which routes will be added; if
+	    unspecified or \`auto', the default table is used. If \`off', no routes
+	    are added. Besides \`auto' and \`off', only \`main' is supported on
+	    this platform.
+	  - PreUp, PostUp, PreDown, PostDown: script snippets which will be executed
+	    by bash(1) at the corresponding phases of the link, most commonly used
+	    to configure DNS. The string \`%i' is expanded to INTERFACE.
+	  - SaveConfig: if set to \`true', the configuration is saved from the current
+	    state of the interface upon shutdown.
+
+	See wg-quick(8) for more info and examples.
+	_EOF
+}
+
+cmd_up() {
+	local i
+	get_real_interface && die "\`$INTERFACE' already exists as \`$REAL_INTERFACE'"
+	trap 'del_if; del_routes; exit' INT TERM EXIT
+	execute_hooks "${PRE_UP[@]}"
+	add_if
+	set_config
+	for i in "${ADDRESSES[@]}"; do
+		add_addr "$i"
+	done
+	set_mtu
+	up_if
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$REAL_INTERFACE" allowed-ips)); do
+		add_route "$i"
+	done
+	[[ $AUTO_ROUTE4 -eq 1 || $AUTO_ROUTE6 -eq 1 ]] && set_endpoint_direct_route
+	[[ ${#DNS[@]} -gt 0 ]] && set_dns
+	monitor_daemon
+	execute_hooks "${POST_UP[@]}"
+	trap - INT TERM EXIT
+}
+
+cmd_down() {
+	if ! get_real_interface || [[ " $(wg show interfaces) " != *" $REAL_INTERFACE "* ]]; then
+		die "\`$INTERFACE' is not a WireGuard interface"
+	fi
+	execute_hooks "${PRE_DOWN[@]}"
+	[[ $SAVE_CONFIG -eq 0 ]] || save_config
+	del_if
+	execute_hooks "${POST_DOWN[@]}"
+}
+
+cmd_save() {
+	if ! get_real_interface || [[ " $(wg show interfaces) " != *" $REAL_INTERFACE "* ]]; then
+		die "\`$INTERFACE' is not a WireGuard interface"
+	fi
+	save_config
+}
+
+# ~~ function override insertion point ~~
+
+if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
+	cmd_usage
+elif [[ $# -eq 2 && $1 == up ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_up
+elif [[ $# -eq 2 && $1 == down ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_down
+elif [[ $# -eq 2 && $1 == save ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_save
+else
+	cmd_usage
+	exit 1
+fi
+
+exit 0

commit 5d9433d73ff2f7fa62249c2fcdbff7d9db0a3772
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 14 19:23:17 2018 +0200

    wg-quick: add wg symlink
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/wg b/src/wg-quick/wg
new file mode 120000
index 0000000..d454d14
--- /dev/null
+++ b/src/wg-quick/wg
@@ -0,0 +1 @@
+../wg
\ No newline at end of file

commit a563ba2cf9a82e2ca1e459439a0e654a4bde4154
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 14 18:20:13 2018 +0200

    wg-quick: add android implementation
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick/android.c b/src/wg-quick/android.c
new file mode 100644
index 0000000..25f8f5f
--- /dev/null
+++ b/src/wg-quick/android.c
@@ -0,0 +1,666 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * This is a shell script written in C. It very intentionally still functions like
+ * a shell script, calling out to external executables such as ip(8).
+ */
+
+#define _GNU_SOURCE
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <string.h>
+#include <strings.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <time.h>
+#include <unistd.h>
+#include <errno.h>
+#include <regex.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <sys/param.h>
+
+#ifndef WG_CONFIG_SEARCH_PATHS
+#define WG_CONFIG_SEARCH_PATHS "/data/misc/wireguard /data/data/com.wireguard.android/files"
+#endif
+
+#define _printf_(x, y) __attribute__((format(printf, x, y)))
+#define _cleanup_(x) __attribute__((cleanup(x)))
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
+
+static bool is_exiting = false;
+
+static void *xmalloc(size_t size)
+{
+	void *ret = malloc(size);
+	if (ret)
+		return ret;
+	perror("Error: malloc");
+	exit(errno);
+}
+
+static void *xstrdup(const char *str)
+{
+	char *ret = strdup(str);
+	if (ret)
+		return ret;
+	perror("Error: strdup");
+	exit(errno);
+}
+
+static void xregcomp(regex_t *preg, const char *regex, int cflags)
+{
+	if (regcomp(preg, regex, cflags)) {
+		fprintf(stderr, "Error: Regex compilation error\n");
+		exit(EBADR);
+	}
+}
+
+static char *concat(char *first, ...)
+{
+	va_list args;
+	size_t len = 0;
+	char *ret;
+
+	va_start(args, first);
+	for (char *i = first; i; i = va_arg(args, char *))
+		len += strlen(i);
+	va_end(args);
+
+	ret = xmalloc(len + 1);
+	ret[0] = '\0';
+
+	va_start(args, first);
+	for (char *i = first; i; i = va_arg(args, char *))
+		strcat(ret, i);
+	va_end(args);
+
+	return ret;
+}
+
+static char *concat_and_free(char *orig, const char *delim, const char *new_line)
+{
+	char *ret;
+
+	if (!orig)
+		ret = xstrdup(new_line);
+	else
+		ret = concat(orig, delim, new_line, NULL);
+	free(orig);
+	return ret;
+}
+
+struct command_buffer {
+	char *line;
+	size_t len;
+	FILE *stream;
+};
+
+static void free_command_buffer(struct command_buffer *c)
+{
+	if (!c)
+		return;
+	if (c->stream)
+		pclose(c->stream);
+	free(c->line);
+}
+
+static void freep(void *p)
+{
+	free(*(void **)p);
+}
+static void fclosep(FILE **f)
+{
+	if (*f)
+		fclose(*f);
+}
+#define _cleanup_free_ _cleanup_(freep)
+#define _cleanup_fclose_ _cleanup_(fclosep)
+
+#define DEFINE_CMD(name) _cleanup_(free_command_buffer) struct command_buffer name = { 0 };
+
+static char *vcmd_ret(struct command_buffer *c, const char *cmd_fmt, va_list args)
+{
+	_cleanup_free_ char *cmd = NULL;
+
+	if (!c->stream && !cmd_fmt)
+		return NULL;
+	if (c->stream && cmd_fmt)
+		pclose(c->stream);
+
+	if (cmd_fmt) {
+		if (vasprintf(&cmd, cmd_fmt, args) < 0) {
+			perror("Error: vasprintf");
+			exit(errno);
+		}
+
+		c->stream = popen(cmd, "r");
+		if (!c->stream) {
+			perror("Error: popen");
+			exit(errno);
+		}
+	}
+	errno = 0;
+	if (getline(&c->line, &c->len, c->stream) < 0) {
+		if (errno) {
+			perror("Error: getline");
+			exit(errno);
+		}
+		return NULL;
+	}
+	return c->line;
+}
+
+_printf_(1, 2) static void cmd(const char *cmd_fmt, ...)
+{
+	_cleanup_free_ char *cmd = NULL;
+	va_list args;
+	int ret;
+
+	va_start(args, cmd_fmt);
+	if (vasprintf(&cmd, cmd_fmt, args) < 0) {
+		perror("Error: vasprintf");
+		exit(errno);
+	}
+	va_end(args);
+
+	printf("[#] %s\n", cmd);
+	ret = system(cmd);
+
+	if (ret < 0)
+		ret = ESRCH;
+	else if (ret > 0)
+		ret = WIFEXITED(ret) ? WEXITSTATUS(ret) : EIO;
+
+	if (ret && !is_exiting)
+		exit(ret);
+}
+
+_printf_(2, 3) static char *cmd_ret(struct command_buffer *c, const char *cmd_fmt, ...)
+{
+	va_list args;
+	char *ret;
+
+	va_start(args, cmd_fmt);
+	ret = vcmd_ret(c, cmd_fmt, args);
+	va_end(args);
+	return ret;
+}
+
+_printf_(1, 2) static void cndc(const char *cmd_fmt, ...)
+{
+	DEFINE_CMD(c);
+	int error_code;
+	char *ret;
+	va_list args;
+	_cleanup_free_ char *ndc_fmt = concat("ndc ", cmd_fmt, NULL);
+
+	va_start(args, cmd_fmt);
+	printf("[#] ");
+	vprintf(ndc_fmt, args);
+	printf("\n");
+	va_end(args);
+
+	va_start(args, cmd_fmt);
+	ret = vcmd_ret(&c, ndc_fmt, args);
+	va_end(args);
+
+	if (!ret) {
+		fprintf(stderr, "Error: could not call ndc\n");
+		exit(ENOSYS);
+	}
+
+	error_code = atoi(ret);
+	if (error_code >= 400 && error_code < 600) {
+		fprintf(stderr, "Error: %s\n", ret);
+		exit(ENONET);
+	}
+}
+
+static void auto_su(int argc, char *argv[])
+{
+	char *args[argc + 4];
+
+	if (!getuid())
+		return;
+
+	args[0] = "su";
+	args[1] = "-p";
+	args[2] = "-c";
+	memcpy(&args[3], argv, argc * sizeof(*args));
+	args[argc + 3] = NULL;
+
+	printf("[$] su -p -c ");
+	for (int i = 0; i < argc; ++i)
+		printf("%s%c", argv[i], i == argc - 1 ? '\n' : ' ');
+
+	execvp("su", args);
+	exit(errno);
+}
+
+static void add_if(const char *iface)
+{
+	cmd("ip link add %s type wireguard", iface);
+}
+
+static void del_if(const char *iface)
+{
+	DEFINE_CMD(c);
+	regex_t reg;
+	regmatch_t matches[2];
+	char *netid = NULL;
+	_cleanup_free_ char *regex = concat("0xc([0-9a-f]+)/0xcffff lookup ", iface, NULL);
+
+	xregcomp(&reg, regex, REG_EXTENDED);
+
+	cmd("ip link del %s", iface);
+	for (char *ret = cmd_ret(&c, "ip rule show"); ret; ret = cmd_ret(&c, NULL)) {
+		if (!regexec(&reg, ret, ARRAY_SIZE(matches), matches, 0)) {
+			ret[matches[1].rm_eo] = '\0';
+			netid = &ret[matches[1].rm_so];
+			break;
+		}
+	}
+
+	if (netid)
+		cndc("network destroy %lu", strtoul(netid, NULL, 16));
+}
+
+static void up_if(unsigned int *netid, const char *iface)
+{
+	srandom(time(NULL) ^ getpid()); /* Not real randomness. */
+
+	while (*netid < 4096)
+		*netid = random() & 0xfffe;
+
+	cmd("wg set %s fwmark 0x20000", iface);
+	cndc("interface setcfg %s up", iface);
+	cndc("network create %u vpn 1 1", *netid);
+	cndc("network interface add %u %s", *netid, iface);
+	cndc("network users add %u 0-99999", *netid);
+}
+
+static void set_dnses(unsigned int netid, const char *dnses)
+{
+	size_t len = strlen(dnses);
+	if (len > (1<<16))
+		return;
+	_cleanup_free_ char *mutable = xstrdup(dnses);
+	_cleanup_free_ char *arglist = xmalloc(len * 4 + 1);
+	_cleanup_free_ char *arg = xmalloc(len + 4);
+
+	if (!len)
+		return;
+	arglist[0] = '\0';
+
+	for (char *dns = strtok(mutable, ", \t\n"); dns; dns = strtok(NULL, ", \t\n")) {
+		if (strchr(dns, '\'') || strchr(dns, '\\'))
+			continue;
+		snprintf(arg, len + 3, "'%s' ", dns);
+		strncat(arglist, arg, len * 4 - 1);
+	}
+	if (!strlen(arglist))
+		return;
+	cndc("resolver setnetdns %u '' %s", netid, arglist);
+}
+
+static void add_addr(const char *iface, const char *addr)
+{
+	if (strchr(addr, ':')) {
+		cndc("interface ipv6 %s enable", iface);
+		cmd("ip -6 addr add '%s' dev %s", addr, iface);
+	} else {
+		_cleanup_free_ char *mut_addr = strdup(addr);
+		char *slash = strchr(mut_addr, '/');
+		unsigned char mask = 32;
+
+		if (slash) {
+			*slash = '\0';
+			mask = atoi(slash + 1);
+		}
+		cndc("interface setcfg %s '%s' %u", iface, mut_addr, mask);
+	}
+}
+
+static void set_addr(const char *iface, const char *addrs)
+{
+	_cleanup_free_ char *mutable = xstrdup(addrs);
+
+	for (char *addr = strtok(mutable, ", \t\n"); addr; addr = strtok(NULL, ", \t\n")) {
+		if (strchr(addr, '\'') || strchr(addr, '\\'))
+			continue;
+		add_addr(iface, addr);
+	}
+}
+
+static int get_route_mtu(const char *endpoint)
+{
+	DEFINE_CMD(c_route);
+	DEFINE_CMD(c_dev);
+	regmatch_t matches[2];
+	regex_t regex_mtu, regex_dev;
+	char *route, *mtu, *dev;
+
+	xregcomp(&regex_mtu, "mtu ([0-9]+)", REG_EXTENDED);
+	xregcomp(&regex_dev, "dev ([^ ]+)", REG_EXTENDED);
+
+	if (strcmp(endpoint, "default"))
+		route = cmd_ret(&c_route, "ip -o route get %s", endpoint);
+	else
+		route = cmd_ret(&c_route, "ip -o route show %s", endpoint);
+	if (!route)
+		return -1;
+
+	if (!regexec(&regex_mtu, route, ARRAY_SIZE(matches), matches, 0)) {
+		route[matches[1].rm_eo] = '\0';
+		mtu = &route[matches[1].rm_so];
+	} else if (!regexec(&regex_dev, route, ARRAY_SIZE(matches), matches, 0)) {
+		route[matches[1].rm_eo] = '\0';
+		dev = &route[matches[1].rm_so];
+		route = cmd_ret(&c_dev, "ip -o link show dev %s", dev);
+		if (!route)
+			return -1;
+		if (regexec(&regex_mtu, route, ARRAY_SIZE(matches), matches, 0))
+			return -1;
+		route[matches[1].rm_eo] = '\0';
+		mtu = &route[matches[1].rm_so];
+	} else
+		return -1;
+	return atoi(mtu);
+}
+
+static void set_mtu(const char *iface, unsigned int mtu)
+{
+	DEFINE_CMD(c_endpoints);
+	regex_t regex_endpoint;
+	regmatch_t matches[2];
+	int endpoint_mtu, next_mtu;
+
+	if (mtu) {
+		cndc("interface setmtu %s %u", iface, mtu);
+		return;
+	}
+
+	xregcomp(&regex_endpoint, "^\\[?([a-z0-9:.]+)\\]?:[0-9]+$", REG_EXTENDED);
+
+	endpoint_mtu = get_route_mtu("default");
+	if (endpoint_mtu == -1)
+		endpoint_mtu = 1500;
+
+	for (char *endpoint = cmd_ret(&c_endpoints, "wg show %s endpoints", iface); endpoint; endpoint = cmd_ret(&c_endpoints, NULL)) {
+		if (regexec(&regex_endpoint, endpoint, ARRAY_SIZE(matches), matches, 0))
+			continue;
+		endpoint[matches[1].rm_eo] = '\0';
+		endpoint = &endpoint[matches[1].rm_so];
+
+		next_mtu = get_route_mtu(endpoint);
+		if (next_mtu > 0 && next_mtu < endpoint_mtu)
+			endpoint_mtu = next_mtu;
+	}
+
+	cndc("interface setmtu %s %d", iface, endpoint_mtu - 80);
+}
+
+static void add_route(const char *iface, unsigned int netid, const char *route)
+{
+	cndc("network route add %u %s %s", netid, iface, route);
+}
+
+static void set_routes(const char *iface, unsigned int netid)
+{
+	DEFINE_CMD(c);
+
+	for (char *allowedips = cmd_ret(&c, "wg show %s allowed-ips", iface); allowedips; allowedips = cmd_ret(&c, NULL)) {
+		char *start = strchr(allowedips, '\t');
+
+		if (!start)
+			continue;
+		++start;
+		for (char *allowedip = strtok(start, " \n"); allowedip; allowedip = strtok(NULL, " \n"))
+			add_route(iface, netid, allowedip);
+	}
+}
+
+static void set_config(const char *iface, const char *config)
+{
+	FILE *config_writer;
+	_cleanup_free_ char *cmd = concat("wg setconf ", iface, " /proc/self/fd/0", NULL);
+	int ret;
+
+	printf("[#] %s\n", cmd);
+
+	config_writer = popen(cmd, "w");
+	if (!config_writer) {
+		perror("Error: popen");
+		exit(errno);
+	}
+	if (fputs(config, config_writer) < 0) {
+		perror("Error: fputs");
+		exit(errno);
+	}
+	ret = pclose(config_writer);
+	if (ret)
+		exit(WIFEXITED(ret) ? WEXITSTATUS(ret) : EIO);
+}
+
+static void broadcast_change(void)
+{
+	const char *pkg = getenv("CALLING_PACKAGE");
+
+	if (!pkg || strcmp(pkg, "com.wireguard.android"))
+		cmd("am broadcast -a com.wireguard.android.WGQUICK_CHANGE com.wireguard.android");
+}
+
+static void print_search_paths(FILE *file, const char *prefix)
+{
+	_cleanup_free_ char *paths = strdup(WG_CONFIG_SEARCH_PATHS);
+
+	for (char *path = strtok(paths, " "); path; path = strtok(NULL, " "))
+		fprintf(file, "%s%s\n", prefix, path);
+}
+
+static void cmd_usage(const char *program)
+{
+	printf( "Usage: %s [ up | down ] [ CONFIG_FILE | INTERFACE ]\n"
+		"\n"
+		"  CONFIG_FILE is a configuration file, whose filename is the interface name\n"
+		"  followed by `.conf'. Otherwise, INTERFACE is an interface name, with\n"
+		"  configuration found at:\n\n", program);
+	print_search_paths(stdout, "  - ");
+	printf( "\n  It is to be readable by wg(8)'s `setconf' sub-command, with the exception\n"
+		"  of the following additions to the [Interface] section, which are handled by\n"
+		"  this program:\n\n"
+		"  - Address: may be specified one or more times and contains one or more\n"
+		"    IP addresses (with an optional CIDR mask) to be set for the interface.\n"
+		"  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.\n"
+		"  - DNS: an optional DNS server to use while the device is up.\n\n"
+		"  See wg-quick(8) for more info and examples.\n");
+}
+
+static char *cleanup_iface = NULL;
+
+static void cmd_up_cleanup(void)
+{
+	is_exiting = true;
+	if (cleanup_iface)
+		del_if(cleanup_iface);
+	free(cleanup_iface);
+}
+
+static void cmd_up(const char *iface, const char *config, unsigned int mtu, const char *addrs, const char *dnses)
+{
+	DEFINE_CMD(c);
+	unsigned int netid = 0;
+
+	if (cmd_ret(&c, "ip link show dev %s 2>/dev/null", iface)) {
+		fprintf(stderr, "Error: %s already exists\n", iface);
+		exit(EEXIST);
+	}
+
+	cleanup_iface = xstrdup(iface);
+	atexit(cmd_up_cleanup);
+
+	add_if(iface);
+	set_config(iface, config);
+	set_addr(iface, addrs);
+	up_if(&netid, iface);
+	set_dnses(netid, dnses);
+	set_routes(iface, netid);
+	set_mtu(iface, mtu);
+	broadcast_change();
+
+	free(cleanup_iface);
+	cleanup_iface = NULL;
+	exit(EXIT_SUCCESS);
+}
+
+static void cmd_down(const char *iface)
+{
+	DEFINE_CMD(c);
+	bool found = false;
+
+	char *ifaces = cmd_ret(&c, "wg show interfaces");
+	if (ifaces) {
+		for (char *eiface = strtok(ifaces, " \n"); eiface; eiface = strtok(NULL, " \n")) {
+			if (!strcmp(iface, eiface)) {
+				found = true;
+				break;
+			}
+		}
+	}
+	if (!found) {
+		fprintf(stderr, "Error: %s is not a WireGuard interface\n", iface);
+		exit(EMEDIUMTYPE);
+	}
+
+	del_if(iface);
+	broadcast_change();
+	exit(EXIT_SUCCESS);
+}
+
+static void parse_options(char **iface, char **config, unsigned int *mtu, char **addrs, char **dnses, const char *arg)
+{
+	_cleanup_fclose_ FILE *file = NULL;
+	_cleanup_free_ char *line = NULL;
+	_cleanup_free_ char *filename = NULL;
+	_cleanup_free_ char *paths = strdup(WG_CONFIG_SEARCH_PATHS);
+	regex_t regex_iface, regex_conf;
+	regmatch_t matches[2];
+	struct stat sbuf;
+	size_t n = 0;
+	bool in_interface_section = false;
+
+	*iface = *config = *addrs = *dnses = NULL;
+	*mtu = 0;
+
+	xregcomp(&regex_iface, "^[a-zA-Z0-9_=+.-]{1,15}$", REG_EXTENDED | REG_NOSUB);
+	xregcomp(&regex_conf, "/?([a-zA-Z0-9_=+.-]{1,15})\\.conf$", REG_EXTENDED);
+
+	if (!regexec(&regex_iface, arg, 0, NULL, 0)) {
+		for (char *path = strtok(paths, " "); path; path = strtok(NULL, " ")) {
+			free(filename);
+			if (asprintf(&filename, "%s/%s.conf", path, arg) < 0) {
+				perror("Error: asprintf");
+				exit(errno);
+			}
+			file = fopen(filename, "r");
+			if (file)
+				break;
+		}
+		if (!file) {
+			fprintf(stderr, "Error: Unable to find configuration file for `%s' in:\n", arg);
+			print_search_paths(stderr, "- ");
+			exit(errno);
+		}
+	} else {
+		filename = xstrdup(arg);
+		file = fopen(filename, "r");
+		if (!file) {
+			fprintf(stderr, "Error: Unable to find configuration file at `%s'\n", filename);
+			exit(errno);
+		}
+	}
+
+	if (regexec(&regex_conf, filename, ARRAY_SIZE(matches), matches, 0)) {
+		fprintf(stderr, "Error: The config file must be a valid interface name, followed by .conf\n");
+		exit(EINVAL);
+	}
+
+	if (fstat(fileno(file), &sbuf) < 0) {
+		perror("Error: fstat");
+		exit(errno);
+	}
+	if (sbuf.st_mode & 0007)
+		fprintf(stderr, "Warning: `%s' is world accessible\n", filename);
+
+	filename[matches[1].rm_eo] = 0;
+	*iface = xstrdup(&filename[matches[1].rm_so]);
+
+	while (getline(&line, &n, file) >= 0) {
+		size_t len = strlen(line), j = 0;
+		if (len > (1<<16))
+			return;
+		_cleanup_free_ char *clean = xmalloc(len + 1);
+
+		for (size_t i = 0; i < len; ++i) {
+			if (!isspace(line[i]))
+				clean[j++] = line[i];
+		}
+		clean[j] = '\0';
+
+		if (clean[0] == '[')
+			in_interface_section = false;
+		if (!strcasecmp(clean, "[Interface]"))
+			in_interface_section = true;
+		if (in_interface_section) {
+			if (!strncasecmp(clean, "Address=", 8) && j > 8) {
+				*addrs = concat_and_free(*addrs, ",", clean + 8);
+				continue;
+			} else if (!strncasecmp(clean, "DNS=", 4) && j > 4) {
+				*dnses = concat_and_free(*dnses, ",", clean + 4);
+				continue;
+			} else if (!strncasecmp(clean, "MTU=", 4) && j > 4) {
+				*mtu = atoi(clean + 4);
+				continue;
+			}
+		}
+		*config = concat_and_free(*config, "", line);
+	}
+
+	if (!*iface)
+		*iface = xstrdup("");
+	if (!*config)
+		*config = xstrdup("");
+	if (!*addrs)
+		*addrs = xstrdup("");
+	if (!*dnses)
+		*dnses = xstrdup("");
+}
+
+int main(int argc, char *argv[])
+{
+	_cleanup_free_ char *iface = NULL;
+	_cleanup_free_ char *config = NULL;
+	_cleanup_free_ char *addrs = NULL;
+	_cleanup_free_ char *dnses = NULL;
+	unsigned int mtu;
+
+	if (argc == 2 && (!strcmp(argv[1], "help") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "-h")))
+		cmd_usage(argv[0]);
+	else if (argc == 3 && !strcmp(argv[1], "up")) {
+		auto_su(argc, argv);
+		parse_options(&iface, &config, &mtu, &addrs, &dnses, argv[2]);
+		cmd_up(iface, config, mtu, addrs, dnses);
+	} else if (argc == 3 && !strcmp(argv[1], "down")) {
+		auto_su(argc, argv);
+		parse_options(&iface, &config, &mtu, &addrs, &dnses, argv[2]);
+		cmd_down(iface);
+	} else {
+		cmd_usage(argv[0]);
+		return 1;
+	}
+	return 0;
+}

commit 08c78a65af1de710ff98d1a99510d049dbb7edfb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 14 18:14:55 2018 +0200

    wg: reorganize for multiplatform wg-quick
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 72296aa..241293f 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -35,6 +35,8 @@ WITH_SYSTEMDUNITS := yes
 endif
 endif
 
+PLATFORM ?= $(shell uname -s | tr '[:upper:]' '[:lower:]')
+
 CFLAGS ?= -O3
 CFLAGS += -std=gnu11 -D_GNU_SOURCE
 CFLAGS += -Wall -Wextra
@@ -43,7 +45,7 @@ CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
 ifeq ($(DEBUG_TOOLS),y)
 CFLAGS += -g
 endif
-ifeq ($(shell uname -s),Linux)
+ifeq ($(PLATFORM),linux)
 LIBMNL_CFLAGS := $(shell $(PKG_CONFIG) --cflags libmnl 2>/dev/null)
 LIBMNL_LDLIBS := $(shell $(PKG_CONFIG) --libs libmnl 2>/dev/null || echo -lmnl)
 CFLAGS += $(LIBMNL_CFLAGS)
@@ -72,17 +74,17 @@ endif
 
 install: wg
 	@install -v -d "$(DESTDIR)$(BINDIR)" && install -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"
-	@install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -m 0644 -v wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
+	@install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -m 0644 -v man/wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
 	@[ "$(WITH_BASHCOMPLETION)" = "yes" ] || exit 0; \
 	install -v -d "$(DESTDIR)$(BASHCOMPDIR)" && install -m 0644 -v completion/wg.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg"
 	@[ "$(WITH_WGQUICK)" = "yes" ] || exit 0; \
-	install -m 0755 -v wg-quick.bash "$(DESTDIR)$(BINDIR)/wg-quick" && install -m 0700 -v -d "$(DESTDIR)$(SYSCONFDIR)/wireguard"
+	install -m 0755 -v wg-quick/$(PLATFORM).bash "$(DESTDIR)$(BINDIR)/wg-quick" && install -m 0700 -v -d "$(DESTDIR)$(SYSCONFDIR)/wireguard"
 	@[ "$(WITH_WGQUICK)" = "yes" ] || exit 0; \
-	install -m 0644 -v wg-quick.8 "$(DESTDIR)$(MANDIR)/man8/wg-quick.8"
+	install -m 0644 -v man/wg-quick.8 "$(DESTDIR)$(MANDIR)/man8/wg-quick.8"
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_BASHCOMPLETION)" = "yes" ] || exit 0; \
 	install -m 0644 -v completion/wg-quick.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg-quick"
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_SYSTEMDUNITS)" = "yes" ] || exit 0; \
-	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -m 0644 -v wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
+	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -m 0644 -v systemd/wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
 
 help:
 	@cat INSTALL
diff --git a/src/wg-quick.8 b/src/man/wg-quick.8
similarity index 100%
rename from src/wg-quick.8
rename to src/man/wg-quick.8
diff --git a/src/wg.8 b/src/man/wg.8
similarity index 100%
rename from src/wg.8
rename to src/man/wg.8
diff --git a/src/wg-quick@.service b/src/systemd/wg-quick@.service
similarity index 73%
rename from src/wg-quick@.service
rename to src/systemd/wg-quick@.service
index ce6d70a..da5d787 100644
--- a/src/wg-quick@.service
+++ b/src/systemd/wg-quick@.service
@@ -6,8 +6,8 @@ Documentation=man:wg-quick(8)
 Documentation=man:wg(8)
 Documentation=https://www.wireguard.com/
 Documentation=https://www.wireguard.com/quickstart/
-Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/wg-quick.8
-Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/wg.8
+Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/man/wg-quick.8
+Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/man/wg.8
 
 [Service]
 Type=oneshot
diff --git a/src/wg-quick.bash b/src/wg-quick/linux.bash
similarity index 100%
rename from src/wg-quick.bash
rename to src/wg-quick/linux.bash

commit 0b64881c7ac934f3ef8e9c74b815357fbe981ccb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat May 5 03:54:55 2018 +0200

    wg-quick: preliminary support for go implementation
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index f8c1ce7..cd66b4d 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -83,7 +83,13 @@ auto_su() {
 }
 
 add_if() {
-	cmd ip link add "$INTERFACE" type wireguard
+	local ret
+	if ! cmd ip link add "$INTERFACE" type wireguard; then
+		ret=$?
+		[[ -e /sys/module/wireguard ]] || ! command -v wireguard-go >/dev/null && return $ret
+		echo "[!] Missing WireGuard kernel module. Falling back to slow userspace implementation."
+		cmd wireguard-go "$INTERFACE"
+	fi
 }
 
 del_if() {

commit f8a990763a1439732b8ea4f2a39f7cee6633949a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu May 3 19:07:55 2018 +0200

    embeddable-wg-library: zero attribute padding
    
    See: http://git.netfilter.org/libmnl/commit/?id=37c876b55a2c00424ccda5a300ab5fdec1d88b22
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index a713567..16ddd9a 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -358,11 +358,15 @@ static void mnl_attr_put(struct nlmsghdr *nlh, uint16_t type, size_t len,
 {
 	struct nlattr *attr = mnl_nlmsg_get_payload_tail(nlh);
 	uint16_t payload_len = MNL_ALIGN(sizeof(struct nlattr)) + len;
+	int pad;
 
 	attr->nla_type = type;
 	attr->nla_len = payload_len;
 	memcpy(mnl_attr_get_payload(attr), data, len);
 	nlh->nlmsg_len += MNL_ALIGN(payload_len);
+	pad = MNL_ALIGN(len) - len;
+	if (pad > 0)
+		memset(mnl_attr_get_payload(attr) + len, 0, pad);
 }
 
 static void mnl_attr_put_u16(struct nlmsghdr *nlh, uint16_t type, uint16_t data)

commit f36209f588209e68e5dd5402b058a2e6bae50513
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 2 01:27:41 2018 +0200

    keygen-html: add zip file example
    
    A little bit more JavaScript for easy copy&pasting.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
index 45efec7..d9365e0 100644
--- a/contrib/keygen-html/keygen.html
+++ b/contrib/keygen-html/keygen.html
@@ -7,7 +7,9 @@
 
 function sendPubkeyToServer(pubkey, username, password)
 {
-	alert("Sending " + username + ":" + password + " to server for new pubkey " + pubkey + "...");
+	var node = document.createElement("li");
+	node.innerText = "Sending " + username + ":" + password + " to server for new pubkey " + pubkey + "...";
+	document.body.appendChild(node);
 
 	// send info to server
 
@@ -38,8 +40,12 @@ function downloadNewConfiguration()
 	config.push("AllowedIPs = " + serverResponse.allowedIPs.join(", "));
 	config.push("Endpoint = " + serverResponse.endpoint);
 	config.push("");
-	config = config.join("\n");
+	return config.join("\n");
+}
 
+function giveOneConfigurationToUser()
+{
+	var config = downloadNewConfiguration();
 	var blob = new Blob([config], { type: "text/plain" });
 	var a = document.createElement("a");
 	a.download = "demo0.conf";
@@ -49,6 +55,124 @@ function downloadNewConfiguration()
 	a.click();
 	document.body.removeChild(a);
 }
+
+function putU32(b, n)
+{
+	b.push(n & 0xff, (n >>> 8) & 0xff, (n >>> 16) & 0xff, (n >>> 24) & 0xff);
+}
+
+function putU16(b, n)
+{
+	b.push(n & 0xff, (n >>> 8) & 0xff);
+}
+
+function putBytes(b, a)
+{
+	for (var i = 0; i < a.length; ++i)
+		b.push(a[i] & 0xff);
+}
+
+function encodeString(s)
+{
+	var utf8 = unescape(encodeURIComponent(s));
+	var b = new Uint8Array(utf8.length);
+	for (var i = 0; i < utf8.length; ++i)
+		b[i] = utf8.charCodeAt(i);
+	return b;
+}
+
+function crc32(b)
+{
+	if (!crc32.table) {
+		crc32.table = [];
+		for (var c = 0, n = 0; n < 256; c = ++n) {
+			for (var k = 0; k < 8; ++k)
+				c = ((c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1));
+			crc32.table[n] = c;
+		}
+	}
+	var crc = -1;
+	for (var i = 0; i < b.length; ++i)
+		crc = (crc >>> 8) ^ crc32.table[(crc ^ b[i]) & 0xff];
+	return (crc ^ (-1)) >>> 0;
+}
+
+function createZipFile(files)
+{
+	var b = [];
+	var cd = [];
+	var offset = 0;
+
+	for (var i = 0; i < files.length; ++i) {
+		var name = encodeString(files[i].name);
+		var contents = encodeString(files[i].contents);
+		var crc = crc32(contents);
+
+		putU32(b, 0x04034b50); /* signature */
+		putU16(b, 20); /* version needed */
+		putU16(b, 0); /* flags */
+		putU16(b, 0); /* compression method */
+		putU16(b, 0); /* mtime */
+		putU16(b, 0); /* mdate */
+		putU32(b, crc); /* crc32 */
+		putU32(b, contents.length); /* compressed size */
+		putU32(b, contents.length); /* uncompressed size */
+		putU16(b, name.length); /* file name length */
+		putU16(b, 0); /* extra field length */
+		putBytes(b, name);
+		putBytes(b, contents);
+
+		putU32(cd, 0x02014b50); /* signature */
+		putU16(cd, 0); /* version made */
+		putU16(cd, 20); /* version needed */
+		putU16(cd, 0); /* flags */
+		putU16(cd, 0); /* compression method */
+		putU16(cd, 0); /* mtime */
+		putU16(cd, 0); /* mdate */
+		putU32(cd, crc); /* crc32 */
+		putU32(cd, contents.length); /* compressed size */
+		putU32(cd, contents.length); /* uncompressed size */
+		putU16(cd, name.length); /* file name length */
+		putU16(cd, 0); /* extra field length */
+		putU16(cd, 0); /* file comment length */
+		putU16(cd, 0); /* disk number start */
+		putU16(cd, 0); /* internal file attributes */
+		putU32(cd, 32); /* external file attributes - 'archive' bit set (32) */
+		putU32(cd, offset); /* relative offset of local header */
+		putBytes(cd, name); /* file name */
+
+		offset += 30 + contents.length + name.length
+	}
+	putBytes(b, cd); /* central directory */
+	putU32(b, 0x06054b50); /* end of central directory signature */
+	putU16(b, 0); /* number of this disk */
+	putU16(b, 0); /* number of disk with central directory start */
+	putU16(b, files.length); /* number of entries on disk */
+	putU16(b, files.length); /* number of entries */
+	putU32(b, cd.length); /* length of central directory */
+	putU32(b, offset); /* offset to start of central directory */
+	putU16(b, 0); /* zip comment size */
+	return Uint8Array.from(b);
+}
+
+function giveMultipleConfigurationsToUser()
+{
+	var zipFile = createZipFile([
+		{ name: "demo0.conf", contents: downloadNewConfiguration() },
+		{ name: "demo1.conf", contents: downloadNewConfiguration() },
+		{ name: "demo2.conf", contents: downloadNewConfiguration() }
+	]);
+	var blob = new Blob([zipFile], { type: "application/zip" });
+	var a = document.createElement("a");
+	a.download = "demo-configs.zip";
+	a.href = URL.createObjectURL(blob);
+	a.style.display = "none";
+	document.body.appendChild(a);
+	a.click();
+	document.body.removeChild(a);
+}
+
 </script>
 
-<a href="javascript:downloadNewConfiguration()">Download a WireGuard configuration file</a>
+<p><a href="javascript:giveOneConfigurationToUser()">Download a WireGuard configuration file</a></p>
+<p><a href="javascript:giveMultipleConfigurationsToUser()">Download several WireGuard configuration files</a></p>

commit 81879fe34648d1aba618df5a065591538d1492c2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 14 02:34:28 2018 +0200

    wg-quick: account for specified fwmark in auto routing mode
    
    If we're doing automatic routing with default routes, but the config has
    also specified an explicit fwmark, then use that explicit fwmark, even
    if it's conflicting, since the administrator has explicitly opted into
    using it. Also, when shutting down the interface, we only now remove the
    fancy rules if we're in automatic routing mode with default routes.
    
    Suggested-by: Luis Ressel <aranea@aixah.de>
    Reported-by: Saeid Akbari <saeidscorp@yahoo.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 2a0abe0..f8c1ce7 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -87,20 +87,17 @@ add_if() {
 }
 
 del_if() {
-	local fwmark
+	local table
 	[[ $HAVE_SET_DNS -eq 0 ]] || unset_dns
-	fwmark="$(wg show "$INTERFACE" fwmark)"
-	DEFAULT_TABLE=0
-	[[ $fwmark != off ]] && DEFAULT_TABLE=$(( fwmark ))
-	if [[ $DEFAULT_TABLE -ne 0 ]]; then
-		while [[ $(ip -4 rule show) == *"lookup $DEFAULT_TABLE"* ]]; do
-			cmd ip -4 rule delete table $DEFAULT_TABLE
+	if [[ -z $TABLE || $TABLE == auto ]] && get_fwmark table && [[ $(wg show "$INTERFACE" allowed-ips) =~ /0(\ |$'\n'|$) ]]; then
+		while [[ $(ip -4 rule show) == *"lookup $table"* ]]; do
+			cmd ip -4 rule delete table $table
 		done
 		while [[ $(ip -4 rule show) == *"from all lookup main suppress_prefixlength 0"* ]]; do
 			cmd ip -4 rule delete table main suppress_prefixlength 0
 		done
-		while [[ $(ip -6 rule show) == *"lookup $DEFAULT_TABLE"* ]]; do
-			cmd ip -6 rule delete table $DEFAULT_TABLE
+		while [[ $(ip -6 rule show) == *"lookup $table"* ]]; do
+			cmd ip -6 rule delete table $table
 		done
 		while [[ $(ip -6 rule show) == *"from all lookup main suppress_prefixlength 0"* ]]; do
 			cmd ip -6 rule delete table main suppress_prefixlength 0
@@ -169,21 +166,28 @@ add_route() {
 	fi
 }
 
-DEFAULT_TABLE=
+get_fwmark() {
+	local fwmark
+	fwmark="$(wg show "$INTERFACE" fwmark)" || return 1
+	[[ -n $fwmark && $fwmark != off ]] || return 1
+	printf -v "$1" "%d" "$fwmark"
+	return 0
+}
+
 add_default() {
-	if [[ -z $DEFAULT_TABLE ]]; then
-		DEFAULT_TABLE=51820
-		while [[ -n $(ip -4 route show table $DEFAULT_TABLE) || -n $(ip -6 route show table $DEFAULT_TABLE) ]]; do
-			((DEFAULT_TABLE++))
+	local table proto key value
+	if ! get_fwmark table; then
+		table=51820
+		while [[ -n $(ip -4 route show table $table) || -n $(ip -6 route show table $table) ]]; do
+			((table++))
 		done
+		cmd wg set "$INTERFACE" fwmark $table
 	fi
-	local proto=-4
+	proto=-4
 	[[ $1 == *:* ]] && proto=-6
-	cmd wg set "$INTERFACE" fwmark $DEFAULT_TABLE
-	cmd ip $proto route add "$1" dev "$INTERFACE" table $DEFAULT_TABLE
-	cmd ip $proto rule add not fwmark $DEFAULT_TABLE table $DEFAULT_TABLE
+	cmd ip $proto route add "$1" dev "$INTERFACE" table $table
+	cmd ip $proto rule add not fwmark $table table $table
 	cmd ip $proto rule add table main suppress_prefixlength 0
-	local key value
 	while read -r key _ value; do
 		[[ $value -eq 1 ]] && sysctl -q "$key=2"
 	done < <(sysctl -a -r '^net\.ipv4.conf\.[^ .=]+\.rp_filter$')

commit cd19f54970c544907d231c0e68568a45b471442c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Apr 4 10:53:20 2018 -0400

    wg-quick.8: fix typo
    
    Reported-by: Mike Pechkin <mike.pechkin@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index ceffb0d..5e27d10 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -209,7 +209,7 @@ in the filename:
 
 \fB    # wg-quick up /path/to/wgnet0.conf\fP
 
-For convienence, if only an interface name is supplied, it automatically chooses a path in
+For convenience, if only an interface name is supplied, it automatically chooses a path in
 `/etc/wireguard/':
 
 \fB    # wg-quick up wgnet0\fP

commit 81b7e4863c43f3b2c3972a5789815af56f9c473b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Mar 4 19:03:54 2018 +0100

    wg-quick: hide errors on save
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 27bd4c7..2a0abe0 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -203,7 +203,7 @@ save_config() {
 	done
 	while read -r address; do
 		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
-	done < <(resolvconf -l "$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null || cat "/etc/resolvconf/run/interface/$(resolvconf_iface_prefix)$INTERFACE")
+	done < <(resolvconf -l "$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null || cat "/etc/resolvconf/run/interface/$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null)
 	[[ -n $MTU && $(ip link show dev "$INTERFACE") =~ mtu\ ([0-9]+) ]] && new_config+="MTU = ${BASH_REMATCH[1]}"$'\n'
 	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'

commit d4421aea8907f15bd1b504c0377624bda752381a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 28 00:17:43 2018 +0100

    contrib: add extract-handshakes kprobe example
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/.gitignore b/.gitignore
index 83768f6..4f9e9fc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -20,3 +20,4 @@ src/tests/qemu/distfiles/
 *.nam
 *.til
 *.pro.user
+.cache.mk
diff --git a/contrib/extract-handshakes/.gitignore b/contrib/extract-handshakes/.gitignore
new file mode 100644
index 0000000..4196119
--- /dev/null
+++ b/contrib/extract-handshakes/.gitignore
@@ -0,0 +1,3 @@
+offset-finder.o
+offset-finder
+offsets.include
diff --git a/contrib/extract-handshakes/Makefile b/contrib/extract-handshakes/Makefile
new file mode 100644
index 0000000..36e951e
--- /dev/null
+++ b/contrib/extract-handshakes/Makefile
@@ -0,0 +1,28 @@
+ifeq ($(KERNELRELEASE),)
+KERNELDIR ?= /lib/modules/$(shell uname -r)/build
+PWD := $(shell pwd)
+CFLAGS ?= -O3 -march=native
+CFLAGS += -Wall -pedantic -std=gnu11
+
+offsets.include: offset-finder
+	./$^ > $@
+
+offset-finder: offset-finder.c offset-finder.o
+	$(CC) $(CFLAGS) $(CPPFLAGS) -o $@ $^
+
+offset-finder.o: offset-finder.c
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@
+	objcopy -j '.rodata*' $@ $@
+
+clean:
+	rm -f offset-finder offsets.include
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) clean
+
+.PHONY: clean
+else
+offset-finder-m := offset-finder.o
+oldsrc := $(src)
+src := $(src)/../../../src
+include $(src)/compat/Kbuild.include
+src := $(oldsrc)
+endif
diff --git a/contrib/extract-handshakes/README b/contrib/extract-handshakes/README
new file mode 100644
index 0000000..1d030fa
--- /dev/null
+++ b/contrib/extract-handshakes/README
@@ -0,0 +1,20 @@
+Handshake Extractor
+===================
+
+This will extract private keys from outgoing handshake sessions, prior
+to them being sent, via kprobes. It exports the bare minimum to be
+able to then decrypt all packets in the handshake and in the subsequent
+transport data session.
+
+Build:
+
+    $ make
+
+Run (as root):
+
+    # ./extract-handshakes.sh
+    New handshake session:
+      LOCAL_STATIC_PRIVATE_KEY = QChaGDXeH3eQsbFAhueUNWFdq9KfpF3yl+eITjZbXEk=
+      REMOTE_STATIC_PUBLIC_KEY = HzgTY6aWXtuSyW/PUquZtg8LB/DyMwEXGkPiEmdSsUU=
+      LOCAL_EPHEMERAL_PRIVATE_KEY = UNGdRHuKDeqbFvmiV5FD4wP7a8PqI6v3Xnnz6Jc6NXQ=
+      PRESHARED_KEY = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
diff --git a/contrib/extract-handshakes/extract-handshakes.sh b/contrib/extract-handshakes/extract-handshakes.sh
new file mode 100755
index 0000000..16ed630
--- /dev/null
+++ b/contrib/extract-handshakes/extract-handshakes.sh
@@ -0,0 +1,80 @@
+#!/bin/bash
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2017-2018 Peter Wu <peter@lekensteyn.nl>. All Rights Reserved.
+
+set -e
+
+ME_DIR="${BASH_SOURCE[0]}"
+ME_DIR="${ME_DIR%/*}"
+source "$ME_DIR/offsets.include" || { echo "Did you forget to run make?" >&2; exit 1; }
+
+case "$(uname -m)" in
+	x86_64) ARGUMENT_REGISTER="%si" ;;
+	i386|i686) ARGUMENT_REGISTER="%dx" ;;
+	aarch64) ARGUMENT_REGISTER="%x1" ;;
+	arm) ARGUMENT_REGISTER="%r1" ;;
+	*) echo "ERROR: Unknown architecture" >&2; exit 1 ;;
+esac
+
+ARGS=( )
+REGEX=".*: idxadd: .*"
+for key in "${!OFFSETS[@]}"; do
+	values="${OFFSETS[$key]}"
+	values=( ${values//,/ } )
+	for i in {0..3}; do
+		value="$ARGUMENT_REGISTER"
+		for indirection in "${values[@]:1}"; do
+			value="+$indirection($value)"
+		done
+		value="+$((i * 8 + values[0]))($value)"
+		ARGS+=( "${key,,}$i=$value:x64" )
+		REGEX="$REGEX ${key,,}$i=0x([0-9a-f]+)"
+	done
+done
+
+turn_off() {
+	set +e
+	[[ -f /sys/kernel/debug/tracing/events/wireguard/idxadd/enable ]] || exit
+	echo 0 > /sys/kernel/debug/tracing/events/wireguard/idxadd/enable
+	echo "-:wireguard/idxadd" >> /sys/kernel/debug/tracing/kprobe_events
+	exit
+}
+
+trap turn_off INT TERM EXIT
+echo "p:wireguard/idxadd index_hashtable_insert ${ARGS[*]}" >> /sys/kernel/debug/tracing/kprobe_events
+echo 1 > /sys/kernel/debug/tracing/events/wireguard/idxadd/enable
+
+unpack_u64() {
+	local i expanded="$1"
+	if [[ $ENDIAN == big ]]; then
+		printf -v expanded "%.*s$expanded" $((16 - ${#expanded})) 0000000000000000
+		for i in {0..7}; do
+			echo -n "\\x${expanded:(i * 2):2}"
+		done
+	elif [[ $ENDIAN == little ]]; then
+		(( ${#expanded} % 2 == 1 )) && expanded="0$expanded"
+		expanded="${expanded}0000000000000000"
+		for i in {0..7}; do
+			echo -n "\\x${expanded:((7 - i) * 2):2}"
+		done
+	else
+		echo "ERROR: Unable to determine endian" >&2
+		exit 1
+	fi
+}
+
+while read -r line; do
+	[[ $line =~ $REGEX ]] || continue
+	echo "New handshake session:"
+	j=1
+	for key in "${!OFFSETS[@]}"; do
+		bytes=""
+		for i in {0..3}; do
+			bytes="$bytes$(unpack_u64 "${BASH_REMATCH[j]}")"
+			((++j))
+		done
+		echo "  $key = $(printf "$bytes" | base64)"
+	done
+done < /sys/kernel/debug/tracing/trace_pipe
diff --git a/contrib/extract-handshakes/offset-finder.c b/contrib/extract-handshakes/offset-finder.c
new file mode 100644
index 0000000..d0bc69c
--- /dev/null
+++ b/contrib/extract-handshakes/offset-finder.c
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+struct def {
+	const char *name;
+	unsigned long offset;
+	unsigned long indirection_offset;
+};
+extern const struct def defs[];
+
+#ifdef __KERNEL__
+#include "../../../src/noise.h"
+
+const struct def defs[] = {
+	{ "LOCAL_STATIC_PRIVATE_KEY", offsetof(struct noise_static_identity, static_private), offsetof(struct noise_handshake, static_identity) },
+	{ "LOCAL_EPHEMERAL_PRIVATE_KEY", offsetof(struct noise_handshake, ephemeral_private), -1 },
+	{ "REMOTE_STATIC_PUBLIC_KEY", offsetof(struct noise_handshake, remote_static), -1 },
+	{ "PRESHARED_KEY", offsetof(struct noise_handshake, preshared_key), -1 },
+	{ NULL, 0 }
+};
+#else
+#include <stdio.h>
+int main(int argc, char *argv[])
+{
+	puts("declare -A OFFSETS=(");
+	for (const struct def *def = defs; def->name; ++def) {
+		printf("\t[%s]=%ld", def->name, def->offset);
+		if (def->indirection_offset != -1)
+			printf(",%ld", def->indirection_offset);
+		putchar('\n');
+	}
+	puts(")");
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	puts("ENDIAN=big");
+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	puts("ENDIAN=little");
+#else
+#error "Unsupported endianness"
+#endif
+	return 0;
+}
+#endif

commit e6ce5fd38612b0f06e61945bceac6132b084b96e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 28 19:46:28 2018 +0100

    wg-quick: if resolvconf/run/iface exists, use it
    
    Some older broken resolvconfs don't support resolvconf -l, but do have a
    file in a standard location, so use it.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index e93fb80..27bd4c7 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -203,7 +203,7 @@ save_config() {
 	done
 	while read -r address; do
 		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
-	done < <(resolvconf -l "$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null)
+	done < <(resolvconf -l "$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null || cat "/etc/resolvconf/run/interface/$(resolvconf_iface_prefix)$INTERFACE")
 	[[ -n $MTU && $(ip link show dev "$INTERFACE") =~ mtu\ ([0-9]+) ]] && new_config+="MTU = ${BASH_REMATCH[1]}"$'\n'
 	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'

commit 99264cb88f6752ee4c07121f6ed1120544d32e5f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 28 19:24:31 2018 +0100

    wg-quick: if resolvconf/interface-order exists, use it
    
    Some older broken resolvconf implementations ignore -m, but do have an
    interface-order list. It's better to use this list dynamically, in case
    it changes, or in case it's not used by the OS's resolvconf
    implementation, such as in the case of systemd or openresolv.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index af72f7d..e93fb80 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -136,16 +136,25 @@ set_mtu() {
 	cmd ip link set mtu $(( mtu - 80 )) dev "$INTERFACE"
 }
 
+resolvconf_iface_prefix() {
+	[[ -f /etc/resolvconf/interface-order ]] || return 0
+	local iface
+	while read -r iface; do
+		[[ $iface =~ ^([A-Za-z0-9-]+)\*$ ]] || continue
+		echo "${BASH_REMATCH[1]}." && return 0
+	done < /etc/resolvconf/interface-order
+}
+
 HAVE_SET_DNS=0
 set_dns() {
 	[[ ${#DNS[@]} -gt 0 ]] || return 0
-	printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "tun.$INTERFACE" -m 0 -x
+	printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "$(resolvconf_iface_prefix)$INTERFACE" -m 0 -x
 	HAVE_SET_DNS=1
 }
 
 unset_dns() {
 	[[ ${#DNS[@]} -gt 0 ]] || return 0
-	cmd resolvconf -d "tun.$INTERFACE"
+	cmd resolvconf -d "$(resolvconf_iface_prefix)$INTERFACE"
 }
 
 add_route() {
@@ -194,7 +203,7 @@ save_config() {
 	done
 	while read -r address; do
 		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
-	done < <(resolvconf -l "tun.$INTERFACE" 2>/dev/null)
+	done < <(resolvconf -l "$(resolvconf_iface_prefix)$INTERFACE" 2>/dev/null)
 	[[ -n $MTU && $(ip link show dev "$INTERFACE") =~ mtu\ ([0-9]+) ]] && new_config+="MTU = ${BASH_REMATCH[1]}"$'\n'
 	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'

commit 45749674659abd66ece4348d3ba2a3d769ca77b5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Feb 27 00:49:16 2018 +0100

    global: in gnu code, use un-underscored asm
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 2195040..b030853 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -46,7 +46,7 @@ typedef int64_t s64;
 static noinline void memzero_explicit(void *s, size_t count)
 {
 	memset(s, 0, count);
-	__asm__ __volatile__("": :"r"(s) :"memory");
+	asm volatile("": :"r"(s) :"memory");
 }
 
 #ifdef __SIZEOF_INT128__
diff --git a/src/encoding.c b/src/encoding.c
index a8bfd24..cb1b123 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -113,7 +113,7 @@ bool key_is_zero(const uint8_t key[static WG_KEY_LEN])
 
 	for (unsigned int i = 0; i < WG_KEY_LEN; ++i) {
 		acc |= key[i];
-		__asm__ ("" : "=r" (acc) : "0" (acc));
+		asm("" : "=r" (acc) : "0" (acc));
 	}
 	return 1 & ((acc - 1) >> 8);
 }

commit 3314030d5732bceeaaa6d9f0a8748a04692ff35b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Mar 1 02:14:50 2018 +0100

    Revert "contrib: keygen-html: rewrite in pure javascript"
    
    This reverts commit e5203543a674453ce1e0cbbcb234d3308762fe65.
    
    As swanky as it is to have a really short file, it's hard to justify and
    makes me nervous.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/Makefile b/contrib/keygen-html/Makefile
new file mode 100644
index 0000000..a3acec0
--- /dev/null
+++ b/contrib/keygen-html/Makefile
@@ -0,0 +1,6 @@
+curve25519_generate.js: src/curve25519_generate.c src/glue.js
+	emcc -O2 --memory-init-file 0 --closure 1 --post-js src/glue.js -s 'EXTRA_EXPORTED_RUNTIME_METHODS=["Pointer_stringify"]' -o $@ src/curve25519_generate.c
+clean:
+	rm -f curve25519_generate.js
+all: curve25519_generate.js
+.PHONY: clean all
diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
index 694e1ff..45efec7 100644
--- a/contrib/keygen-html/keygen.html
+++ b/contrib/keygen-html/keygen.html
@@ -1,4 +1,4 @@
-<script src="wireguard.js"></script>
+<script src="curve25519_generate.js" onError='document.write("<h3>Did you forget to run \"make\" to compile curve25519_generate.js?</h3><!--");'></script>
 <script>
 /* SPDX-License-Identifier: GPL-2.0
  *
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
new file mode 100644
index 0000000..fc47575
--- /dev/null
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -0,0 +1,97 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include <emscripten.h>
+
+typedef unsigned long long  u64;
+typedef unsigned int u32;
+typedef unsigned char u8;
+typedef u32 __le32;
+
+enum { CURVE25519_POINT_SIZE = 32 };
+
+#ifndef __always_inline
+#define __always_inline __inline __attribute__((__always_inline__))
+#endif
+#ifndef noinline
+#define noinline __attribute__((noinline))
+#endif
+#ifndef __aligned
+#define __aligned(x) __attribute__((aligned(x)))
+#endif
+#ifndef __force
+#define __force
+#endif
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define le32_to_cpup(a) (*(a))
+#else
+#define le32_to_cpup(a) __builtin_bswap32(*(a))
+#endif
+
+#define memset(a, b, c) __builtin_memset(a, b, c)
+#define memcpy(a, b, c) __builtin_memcpy(a, b, c)
+#define memmove(a, b, c) __builtin_memmove(a, b, c)
+/* We don't even attempt to deal with this in javascript. */
+#define memzero_explicit(a, b)
+
+static __always_inline void normalize_secret(u8 secret[CURVE25519_POINT_SIZE])
+{
+	secret[0] &= 248;
+	secret[31] &= 127;
+	secret[31] |= 64;
+}
+
+#include "../../../../src/crypto/curve25519-fiat32.h"
+
+EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(u8 public[static 32], const u8 private[static 32])
+{
+	static const u8 basepoint[32] = { 9 };
+
+	curve25519_generic(public, private, basepoint);
+}
+
+EMSCRIPTEN_KEEPALIVE void curve25519_generate_private(u8 private[static 32])
+{
+	int i;
+
+	EM_ASM({
+		/* Same trick as libsodium */
+		var getRandomValue = function() {
+			var buf = new Uint32Array(1);
+			window.crypto.getRandomValues(buf);
+			return buf[0] >>> 0;
+		};
+		Module.getRandomValue = getRandomValue;
+	});
+	
+	for (i = 0; i < 32; ++i)
+		private[i] = EM_ASM_INT_V({ return Module.getRandomValue(); });
+	normalize_secret(private);
+}
+
+static inline void encode_base64(char dest[4], const u8 src[3])
+{
+	const u8 input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
+
+	for (unsigned int i = 0; i < 4; ++i)
+		dest[i] = input[i] + 'A'
+			  + (((25 - input[i]) >> 8) & 6)
+			  - (((51 - input[i]) >> 8) & 75)
+			  - (((61 - input[i]) >> 8) & 15)
+			  + (((62 - input[i]) >> 8) & 3);
+
+}
+
+EMSCRIPTEN_KEEPALIVE void key_to_base64(char base64[static 45], const u8 key[static 32])
+{
+	unsigned int i;
+
+	for (i = 0; i < 32 / 3; ++i)
+		encode_base64(&base64[i * 4], &key[i * 3]);
+	encode_base64(&base64[i * 4], (const u8[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
+	base64[45 - 2] = '=';
+	base64[45 - 1] = '\0';
+}
diff --git a/contrib/keygen-html/src/glue.js b/contrib/keygen-html/src/glue.js
new file mode 100644
index 0000000..981e533
--- /dev/null
+++ b/contrib/keygen-html/src/glue.js
@@ -0,0 +1,25 @@
+/*! SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+window["WireGuard"] = {
+	"generateKeypair": function() {
+		var privateKey = Module["_malloc"](32);
+		var publicKey = Module["_malloc"](32);
+		Module["_curve25519_generate_private"](privateKey);
+		Module["_curve25519_generate_public"](publicKey, privateKey);
+		var privateBase64 = Module["_malloc"](45);
+		var publicBase64 = Module["_malloc"](45);
+		Module["_key_to_base64"](privateBase64, privateKey);
+		Module["_key_to_base64"](publicBase64, publicKey);
+		Module["_free"](privateKey);
+		Module["_free"](publicKey);
+		var keypair = {
+			publicKey: Module["Pointer_stringify"](publicBase64),
+			privateKey: Module["Pointer_stringify"](privateBase64)
+		};
+		Module["_free"](privateBase64);
+		Module["_free"](publicBase64);
+		return keypair;
+	}
+};
diff --git a/contrib/keygen-html/wireguard.js b/contrib/keygen-html/wireguard.js
deleted file mode 100644
index b77dec8..0000000
--- a/contrib/keygen-html/wireguard.js
+++ /dev/null
@@ -1,186 +0,0 @@
-/*! SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-
-(function() {
-	function gf(init) {
-		var r = new Float64Array(16);
-		if (init) {
-			for (var i = 0; i < init.length; ++i)
-				r[i] = init[i];
-		}
-		return r;
-	}
-
-	function pack(o, n) {
-		var b, m = gf(), t = gf();
-		for (var i = 0; i < 16; ++i)
-			t[i] = n[i];
-		carry(t);
-		carry(t);
-		carry(t);
-		for (var j = 0; j < 2; ++j) {
-			m[0] = t[0] - 0xffed;
-			for (var i = 1; i < 15; ++i) {
-				m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
-				m[i - 1] &= 0xffff;
-			}
-			m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
-			b = (m[15] >> 16) & 1;
-			m[14] &= 0xffff;
-			cswap(t, m, 1 - b);
-		}
-		for (var i = 0; i < 16; ++i) {
-			o[2 * i] = t[i] & 0xff;
-			o[2 * i + 1] = t[i] >> 8;
-		}
-	}
-
-	function carry(o) {
-		var c;
-		for (var i = 0; i < 16; ++i) {
-			o[i] += 65536;
-			c = Math.floor(o[i] / 65536);
-			o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);
-			o[i] -= (c * 65536);
-		}
-	}
-
-	function cswap(p, q, b) {
-		var t, c = ~(b - 1);
-		for (var i = 0; i < 16; ++i) {
-			t = c & (p[i] ^ q[i]);
-			p[i] ^= t;
-			q[i] ^= t;
-		}
-	}
-
-	function add(o, a, b) {
-		for (var i = 0; i < 16; ++i)
-			o[i] = (a[i] + b[i]) | 0;
-	}
-
-	function subtract(o, a, b) {
-		for (var i = 0; i < 16; ++i)
-			o[i] = (a[i] - b[i]) | 0;
-	}
-
-	function multmod(o, a, b) {
-		var t = new Float64Array(31);
-		for (var i = 0; i < 16; ++i) {
-			for (var j = 0; j < 16; ++j)
-				t[i + j] += a[i] * b[j];
-		}
-		for (var i = 0; i < 15; ++i)
-			t[i] += 38 * t[i + 16];
-		for (var i = 0; i < 16; ++i)
-			o[i] = t[i];
-		carry(o);
-		carry(o);
-	}
-
-	function invert(o, i) {
-		var c = gf();
-		for (var a = 0; a < 16; ++a)
-			c[a] = i[a];
-		for (var a = 253; a >= 0; --a) {
-			multmod(c, c, c);
-			if (a !== 2 && a !== 4)
-				multmod(c, c, i);
-		}
-		for (var a = 0; a < 16; ++a)
-			o[a] = c[a];
-	}
-
-	function normalizeKey(z) {
-		z[31] = (z[31] & 127) | 64;
-		z[0] &= 248;
-	}
-
-	function generatePublicKey(privateKey) {
-		var r, z = new Uint8Array(32);
-		var a = gf([1]),
-			b = gf([9]),
-			c = gf(),
-			d = gf([1]),
-			e = gf(),
-			f = gf(),
-			_121665 = gf([0xdb41, 1]),
-			_9 = gf([9]);
-		for (var i = 0; i < 32; ++i)
-			z[i] = privateKey[i];
-		normalizeKey(z);
-		for (var i = 254; i >= 0; --i) {
-			r = (z[i >>> 3] >>> (i & 7)) & 1;
-			cswap(a, b, r);
-			cswap(c, d, r);
-			add(e, a, c);
-			subtract(a, a, c);
-			add(c, b, d);
-			subtract(b, b, d);
-			multmod(d, e, e);
-			multmod(f, a, a);
-			multmod(a, c, a);
-			multmod(c, b, e);
-			add(e, a, c);
-			subtract(a, a, c);
-			multmod(b, a, a);
-			subtract(c, d, f);
-			multmod(a, c, _121665);
-			add(a, a, d);
-			multmod(c, c, a);
-			multmod(a, d, f);
-			multmod(d, b, _9);
-			multmod(b, e, e);
-			cswap(a, b, r);
-			cswap(c, d, r);
-		}
-		invert(c, c);
-		multmod(a, a, c);
-		pack(z, a);
-		return z;
-	}
-
-	function generatePresharedKey() {
-		var privateKey = new Uint8Array(32);
-		window.crypto.getRandomValues(privateKey);
-		return privateKey;
-	}
-
-	function generatePrivateKey() {
-		var privateKey = generatePresharedKey();
-		normalizeKey(privateKey);
-		return privateKey;
-	}
-
-	function encodeBase64(dest, src) {
-		var input = Uint8Array.from([(src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63]);
-		for (var i = 0; i < 4; ++i)
-			dest[i] = input[i] + 65 +
-			(((25 - input[i]) >> 8) & 6) -
-			(((51 - input[i]) >> 8) & 75) -
-			(((61 - input[i]) >> 8) & 15) +
-			(((62 - input[i]) >> 8) & 3);
-	}
-
-	function keyToBase64(key) {
-		var i, base64 = new Uint8Array(44);
-		for (i = 0; i < 32 / 3; ++i)
-			encodeBase64(base64.subarray(i * 4), key.subarray(i * 3));
-		encodeBase64(base64.subarray(i * 4), Uint8Array.from([key[i * 3 + 0], key[i * 3 + 1], 0]));
-		base64[43] = 61;
-		return String.fromCharCode.apply(null, base64);
-	}
-
-	window["WireGuard"] = {
-		"generateKeypair": function() {
-			var privateKey = generatePrivateKey();
-			var publicKey = generatePublicKey(privateKey);
-			return {
-				publicKey: keyToBase64(publicKey),
-				privateKey: keyToBase64(privateKey)
-			};
-		}
-	};
-})();

commit 3749b29b1f28b7658930411edfde23ded1f63d4e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Feb 23 05:29:54 2018 +0100

    contrib: keygen-html: rewrite in pure javascript
    
    Emscripten is too cumbersome. This code here is much slower, but it's
    shorter and simpler.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/Makefile b/contrib/keygen-html/Makefile
deleted file mode 100644
index a3acec0..0000000
--- a/contrib/keygen-html/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-curve25519_generate.js: src/curve25519_generate.c src/glue.js
-	emcc -O2 --memory-init-file 0 --closure 1 --post-js src/glue.js -s 'EXTRA_EXPORTED_RUNTIME_METHODS=["Pointer_stringify"]' -o $@ src/curve25519_generate.c
-clean:
-	rm -f curve25519_generate.js
-all: curve25519_generate.js
-.PHONY: clean all
diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
index 45efec7..694e1ff 100644
--- a/contrib/keygen-html/keygen.html
+++ b/contrib/keygen-html/keygen.html
@@ -1,4 +1,4 @@
-<script src="curve25519_generate.js" onError='document.write("<h3>Did you forget to run \"make\" to compile curve25519_generate.js?</h3><!--");'></script>
+<script src="wireguard.js"></script>
 <script>
 /* SPDX-License-Identifier: GPL-2.0
  *
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
deleted file mode 100644
index fc47575..0000000
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-
-#include <emscripten.h>
-
-typedef unsigned long long  u64;
-typedef unsigned int u32;
-typedef unsigned char u8;
-typedef u32 __le32;
-
-enum { CURVE25519_POINT_SIZE = 32 };
-
-#ifndef __always_inline
-#define __always_inline __inline __attribute__((__always_inline__))
-#endif
-#ifndef noinline
-#define noinline __attribute__((noinline))
-#endif
-#ifndef __aligned
-#define __aligned(x) __attribute__((aligned(x)))
-#endif
-#ifndef __force
-#define __force
-#endif
-
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-#define le32_to_cpup(a) (*(a))
-#else
-#define le32_to_cpup(a) __builtin_bswap32(*(a))
-#endif
-
-#define memset(a, b, c) __builtin_memset(a, b, c)
-#define memcpy(a, b, c) __builtin_memcpy(a, b, c)
-#define memmove(a, b, c) __builtin_memmove(a, b, c)
-/* We don't even attempt to deal with this in javascript. */
-#define memzero_explicit(a, b)
-
-static __always_inline void normalize_secret(u8 secret[CURVE25519_POINT_SIZE])
-{
-	secret[0] &= 248;
-	secret[31] &= 127;
-	secret[31] |= 64;
-}
-
-#include "../../../../src/crypto/curve25519-fiat32.h"
-
-EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(u8 public[static 32], const u8 private[static 32])
-{
-	static const u8 basepoint[32] = { 9 };
-
-	curve25519_generic(public, private, basepoint);
-}
-
-EMSCRIPTEN_KEEPALIVE void curve25519_generate_private(u8 private[static 32])
-{
-	int i;
-
-	EM_ASM({
-		/* Same trick as libsodium */
-		var getRandomValue = function() {
-			var buf = new Uint32Array(1);
-			window.crypto.getRandomValues(buf);
-			return buf[0] >>> 0;
-		};
-		Module.getRandomValue = getRandomValue;
-	});
-	
-	for (i = 0; i < 32; ++i)
-		private[i] = EM_ASM_INT_V({ return Module.getRandomValue(); });
-	normalize_secret(private);
-}
-
-static inline void encode_base64(char dest[4], const u8 src[3])
-{
-	const u8 input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
-
-	for (unsigned int i = 0; i < 4; ++i)
-		dest[i] = input[i] + 'A'
-			  + (((25 - input[i]) >> 8) & 6)
-			  - (((51 - input[i]) >> 8) & 75)
-			  - (((61 - input[i]) >> 8) & 15)
-			  + (((62 - input[i]) >> 8) & 3);
-
-}
-
-EMSCRIPTEN_KEEPALIVE void key_to_base64(char base64[static 45], const u8 key[static 32])
-{
-	unsigned int i;
-
-	for (i = 0; i < 32 / 3; ++i)
-		encode_base64(&base64[i * 4], &key[i * 3]);
-	encode_base64(&base64[i * 4], (const u8[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
-	base64[45 - 2] = '=';
-	base64[45 - 1] = '\0';
-}
diff --git a/contrib/keygen-html/src/glue.js b/contrib/keygen-html/src/glue.js
deleted file mode 100644
index 981e533..0000000
--- a/contrib/keygen-html/src/glue.js
+++ /dev/null
@@ -1,25 +0,0 @@
-/*! SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-window["WireGuard"] = {
-	"generateKeypair": function() {
-		var privateKey = Module["_malloc"](32);
-		var publicKey = Module["_malloc"](32);
-		Module["_curve25519_generate_private"](privateKey);
-		Module["_curve25519_generate_public"](publicKey, privateKey);
-		var privateBase64 = Module["_malloc"](45);
-		var publicBase64 = Module["_malloc"](45);
-		Module["_key_to_base64"](privateBase64, privateKey);
-		Module["_key_to_base64"](publicBase64, publicKey);
-		Module["_free"](privateKey);
-		Module["_free"](publicKey);
-		var keypair = {
-			publicKey: Module["Pointer_stringify"](publicBase64),
-			privateKey: Module["Pointer_stringify"](privateBase64)
-		};
-		Module["_free"](privateBase64);
-		Module["_free"](publicBase64);
-		return keypair;
-	}
-};
diff --git a/contrib/keygen-html/wireguard.js b/contrib/keygen-html/wireguard.js
new file mode 100644
index 0000000..b77dec8
--- /dev/null
+++ b/contrib/keygen-html/wireguard.js
@@ -0,0 +1,186 @@
+/*! SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+(function() {
+	function gf(init) {
+		var r = new Float64Array(16);
+		if (init) {
+			for (var i = 0; i < init.length; ++i)
+				r[i] = init[i];
+		}
+		return r;
+	}
+
+	function pack(o, n) {
+		var b, m = gf(), t = gf();
+		for (var i = 0; i < 16; ++i)
+			t[i] = n[i];
+		carry(t);
+		carry(t);
+		carry(t);
+		for (var j = 0; j < 2; ++j) {
+			m[0] = t[0] - 0xffed;
+			for (var i = 1; i < 15; ++i) {
+				m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
+				m[i - 1] &= 0xffff;
+			}
+			m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
+			b = (m[15] >> 16) & 1;
+			m[14] &= 0xffff;
+			cswap(t, m, 1 - b);
+		}
+		for (var i = 0; i < 16; ++i) {
+			o[2 * i] = t[i] & 0xff;
+			o[2 * i + 1] = t[i] >> 8;
+		}
+	}
+
+	function carry(o) {
+		var c;
+		for (var i = 0; i < 16; ++i) {
+			o[i] += 65536;
+			c = Math.floor(o[i] / 65536);
+			o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);
+			o[i] -= (c * 65536);
+		}
+	}
+
+	function cswap(p, q, b) {
+		var t, c = ~(b - 1);
+		for (var i = 0; i < 16; ++i) {
+			t = c & (p[i] ^ q[i]);
+			p[i] ^= t;
+			q[i] ^= t;
+		}
+	}
+
+	function add(o, a, b) {
+		for (var i = 0; i < 16; ++i)
+			o[i] = (a[i] + b[i]) | 0;
+	}
+
+	function subtract(o, a, b) {
+		for (var i = 0; i < 16; ++i)
+			o[i] = (a[i] - b[i]) | 0;
+	}
+
+	function multmod(o, a, b) {
+		var t = new Float64Array(31);
+		for (var i = 0; i < 16; ++i) {
+			for (var j = 0; j < 16; ++j)
+				t[i + j] += a[i] * b[j];
+		}
+		for (var i = 0; i < 15; ++i)
+			t[i] += 38 * t[i + 16];
+		for (var i = 0; i < 16; ++i)
+			o[i] = t[i];
+		carry(o);
+		carry(o);
+	}
+
+	function invert(o, i) {
+		var c = gf();
+		for (var a = 0; a < 16; ++a)
+			c[a] = i[a];
+		for (var a = 253; a >= 0; --a) {
+			multmod(c, c, c);
+			if (a !== 2 && a !== 4)
+				multmod(c, c, i);
+		}
+		for (var a = 0; a < 16; ++a)
+			o[a] = c[a];
+	}
+
+	function normalizeKey(z) {
+		z[31] = (z[31] & 127) | 64;
+		z[0] &= 248;
+	}
+
+	function generatePublicKey(privateKey) {
+		var r, z = new Uint8Array(32);
+		var a = gf([1]),
+			b = gf([9]),
+			c = gf(),
+			d = gf([1]),
+			e = gf(),
+			f = gf(),
+			_121665 = gf([0xdb41, 1]),
+			_9 = gf([9]);
+		for (var i = 0; i < 32; ++i)
+			z[i] = privateKey[i];
+		normalizeKey(z);
+		for (var i = 254; i >= 0; --i) {
+			r = (z[i >>> 3] >>> (i & 7)) & 1;
+			cswap(a, b, r);
+			cswap(c, d, r);
+			add(e, a, c);
+			subtract(a, a, c);
+			add(c, b, d);
+			subtract(b, b, d);
+			multmod(d, e, e);
+			multmod(f, a, a);
+			multmod(a, c, a);
+			multmod(c, b, e);
+			add(e, a, c);
+			subtract(a, a, c);
+			multmod(b, a, a);
+			subtract(c, d, f);
+			multmod(a, c, _121665);
+			add(a, a, d);
+			multmod(c, c, a);
+			multmod(a, d, f);
+			multmod(d, b, _9);
+			multmod(b, e, e);
+			cswap(a, b, r);
+			cswap(c, d, r);
+		}
+		invert(c, c);
+		multmod(a, a, c);
+		pack(z, a);
+		return z;
+	}
+
+	function generatePresharedKey() {
+		var privateKey = new Uint8Array(32);
+		window.crypto.getRandomValues(privateKey);
+		return privateKey;
+	}
+
+	function generatePrivateKey() {
+		var privateKey = generatePresharedKey();
+		normalizeKey(privateKey);
+		return privateKey;
+	}
+
+	function encodeBase64(dest, src) {
+		var input = Uint8Array.from([(src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63]);
+		for (var i = 0; i < 4; ++i)
+			dest[i] = input[i] + 65 +
+			(((25 - input[i]) >> 8) & 6) -
+			(((51 - input[i]) >> 8) & 75) -
+			(((61 - input[i]) >> 8) & 15) +
+			(((62 - input[i]) >> 8) & 3);
+	}
+
+	function keyToBase64(key) {
+		var i, base64 = new Uint8Array(44);
+		for (i = 0; i < 32 / 3; ++i)
+			encodeBase64(base64.subarray(i * 4), key.subarray(i * 3));
+		encodeBase64(base64.subarray(i * 4), Uint8Array.from([key[i * 3 + 0], key[i * 3 + 1], 0]));
+		base64[43] = 61;
+		return String.fromCharCode.apply(null, base64);
+	}
+
+	window["WireGuard"] = {
+		"generateKeypair": function() {
+			var privateKey = generatePrivateKey();
+			var publicKey = generatePublicKey(privateKey);
+			return {
+				publicKey: keyToBase64(publicKey),
+				privateKey: keyToBase64(privateKey)
+			};
+		}
+	};
+})();

commit 0e6fe9a5486ca02b5ef6d629645e434429663196
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 21 19:19:50 2018 +0100

    contrib: embedded-wg-library: add key generation functions
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/test.c b/contrib/embeddable-wg-library/test.c
index aad24de..8d4aae3 100644
--- a/contrib/embeddable-wg-library/test.c
+++ b/contrib/embeddable-wg-library/test.c
@@ -50,9 +50,11 @@ int main(int argc, char *argv[])
 		.first_peer = &new_peer,
 		.last_peer = &new_peer
 	};
+	wg_key temp_private_key;
 
-	wg_key_from_base64(new_device.private_key, "SFLKy56SOiFoAvQDSCBRrH/nyYonuAQnyr/JTQRPDlU=");
-	wg_key_from_base64(new_peer.public_key, "aNoLvvCfgbtTf4f2Eb/CWVNvIc5AJt/4C4pKrxMUZlM=");
+	wg_generate_private_key(temp_private_key);
+	wg_generate_public_key(new_peer.public_key, temp_private_key);
+	wg_generate_private_key(new_device.private_key);
 
 	if (wg_add_device(new_device.name) < 0) {
 		perror("Unable to add device");
diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index 692d285..a713567 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -19,6 +19,8 @@
 #include <sys/socket.h>
 #include <time.h>
 #include <unistd.h>
+#include <fcntl.h>
+#include <assert.h>
 
 #include "wireguard.h"
 
@@ -1575,3 +1577,199 @@ int wg_key_from_base64(wg_key key, const wg_key_b64_string base64)
 out:
 	return -errno;
 }
+
+typedef int64_t fe[16];
+
+static __attribute__((noinline)) void memzero_explicit(void *s, size_t count)
+{
+	memset(s, 0, count);
+	__asm__ __volatile__("": :"r"(s) :"memory");
+}
+
+static void carry(fe o)
+{
+	int i;
+	int64_t c;
+
+	for (i = 0; i < 16; ++i) {
+		o[i] += (1LL << 16);
+		c = o[i] >> 16;
+		o[(i + 1) * (i < 15)] += c - 1 + 37 * (c - 1) * (i == 15);
+		o[i] -= c << 16;
+	}
+
+	memzero_explicit(&c, sizeof(c));
+}
+
+static void cswap(fe p, fe q, int b)
+{
+	int i;
+	int64_t t, c = ~(b - 1);
+
+	for (i = 0; i < 16; ++i) {
+		t = c & (p[i] ^ q[i]);
+		p[i] ^= t;
+		q[i] ^= t;
+	}
+
+	memzero_explicit(&t, sizeof(t));
+	memzero_explicit(&c, sizeof(c));
+	memzero_explicit(&b, sizeof(b));
+}
+
+static void pack(uint8_t *o, const fe n)
+{
+	int i, j, b;
+	fe m, t;
+
+	memcpy(t, n, sizeof(t));
+	carry(t);
+	carry(t);
+	carry(t);
+	for (j = 0; j < 2; ++j) {
+		m[0] = t[0] - 0xffed;
+		for (i = 1; i < 15; ++i) {
+			m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
+			m[i - 1] &= 0xffff;
+		}
+		m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
+		b = (m[15] >> 16) & 1;
+		m[14] &= 0xffff;
+		cswap(t, m, 1 - b);
+	}
+	for (i = 0; i < 16; ++i) {
+		o[2 * i] = t[i] & 0xff;
+		o[2 * i + 1] = t[i] >> 8;
+	}
+
+	memzero_explicit(m, sizeof(m));
+	memzero_explicit(t, sizeof(t));
+	memzero_explicit(&b, sizeof(b));
+}
+
+static void add(fe o, const fe a, const fe b)
+{
+	int i;
+
+	for (i = 0; i < 16; ++i)
+		o[i] = a[i] + b[i];
+}
+
+static void subtract(fe o, const fe a, const fe b)
+{
+	int i;
+
+	for (i = 0; i < 16; ++i)
+		o[i] = a[i] - b[i];
+}
+
+static void multmod(fe o, const fe a, const fe b)
+{
+	int i, j;
+	int64_t t[31] = { 0 };
+
+	for (i = 0; i < 16; ++i) {
+		for (j = 0; j < 16; ++j)
+			t[i + j] += a[i] * b[j];
+	}
+	for (i = 0; i < 15; ++i)
+		t[i] += 38 * t[i + 16];
+	memcpy(o, t, sizeof(fe));
+	carry(o);
+	carry(o);
+
+	memzero_explicit(t, sizeof(t));
+}
+
+static void invert(fe o, const fe i)
+{
+	fe c;
+	int a;
+
+	memcpy(c, i, sizeof(c));
+	for (a = 253; a >= 0; --a) {
+		multmod(c, c, c);
+		if (a != 2 && a != 4)
+			multmod(c, c, i);
+	}
+	memcpy(o, c, sizeof(fe));
+
+	memzero_explicit(c, sizeof(c));
+}
+
+static void normalize_key(uint8_t *z)
+{
+	z[31] = (z[31] & 127) | 64;
+	z[0] &= 248;
+}
+
+void wg_generate_public_key(wg_key public_key, const wg_key private_key)
+{
+	int i, r;
+	uint8_t z[32];
+	fe a = { 1 }, b = { 9 }, c = { 0 }, d = { 1 }, e, f;
+
+	memcpy(z, private_key, sizeof(z));
+	normalize_key(z);
+
+	for (i = 254; i >= 0; --i) {
+		r = (z[i >> 3] >> (i & 7)) & 1;
+		cswap(a, b, r);
+		cswap(c, d, r);
+		add(e, a, c);
+		subtract(a, a, c);
+		add(c, b, d);
+		subtract(b, b, d);
+		multmod(d, e, e);
+		multmod(f, a, a);
+		multmod(a, c, a);
+		multmod(c, b, e);
+		add(e, a, c);
+		subtract(a, a, c);
+		multmod(b, a, a);
+		subtract(c, d, f);
+		multmod(a, c, (const fe){ 0xdb41, 1 });
+		add(a, a, d);
+		multmod(c, c, a);
+		multmod(a, d, f);
+		multmod(d, b, (const fe){ 9 });
+		multmod(b, e, e);
+		cswap(a, b, r);
+		cswap(c, d, r);
+	}
+	invert(c, c);
+	multmod(a, a, c);
+	pack(public_key, a);
+
+	memzero_explicit(&r, sizeof(r));
+	memzero_explicit(z, sizeof(z));
+	memzero_explicit(a, sizeof(a));
+	memzero_explicit(b, sizeof(b));
+	memzero_explicit(c, sizeof(c));
+	memzero_explicit(d, sizeof(d));
+	memzero_explicit(e, sizeof(e));
+	memzero_explicit(f, sizeof(f));
+}
+
+void wg_generate_private_key(wg_key private_key)
+{
+	wg_generate_preshared_key(private_key);
+	normalize_key(private_key);
+}
+
+void wg_generate_preshared_key(wg_key preshared_key)
+{
+	ssize_t ret;
+	int fd;
+
+#if defined(__NR_getrandom)
+	ret = syscall(__NR_getrandom, preshared_key, sizeof(wg_key), 0);
+	if (ret == sizeof(wg_key))
+		return;
+#endif
+	fd = open("/dev/urandom", O_RDONLY);
+	assert(fd >= 0);
+	ret = read(fd, preshared_key, sizeof(wg_key));
+	close(fd);
+	assert(ret == sizeof(wg_key));
+}
diff --git a/contrib/embeddable-wg-library/wireguard.h b/contrib/embeddable-wg-library/wireguard.h
index 350de7d..53d9d5d 100644
--- a/contrib/embeddable-wg-library/wireguard.h
+++ b/contrib/embeddable-wg-library/wireguard.h
@@ -90,5 +90,8 @@ char *wg_list_device_names(void); /* first\0second\0third\0forth\0last\0\0 */
 void wg_key_to_base64(wg_key_b64_string base64, const wg_key key);
 int wg_key_from_base64(wg_key key, const wg_key_b64_string base64);
 bool wg_key_is_zero(const wg_key key);
+void wg_generate_public_key(wg_key public_key, const wg_key private_key);
+void wg_generate_private_key(wg_key private_key);
+void wg_generate_preshared_key(wg_key preshared_key);
 
 #endif

commit 295c9ff274f489b3eaec8c4e342938eef864f769
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 21 02:53:06 2018 +0100

    contrib: embedded-wg-library: add ability to add and del interfaces
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/test.c b/contrib/embeddable-wg-library/test.c
index b738481..aad24de 100644
--- a/contrib/embeddable-wg-library/test.c
+++ b/contrib/embeddable-wg-library/test.c
@@ -8,7 +8,7 @@
 #include <string.h>
 #include <stdlib.h>
 
-int main(int argc, char *argv[])
+void list_devices(void)
 {
 	char *device_names, *device_name;
 	size_t len;
@@ -16,7 +16,7 @@ int main(int argc, char *argv[])
 	device_names = wg_list_device_names();
 	if (!device_names) {
 		perror("Unable to get device names");
-		return 1;
+		exit(1);
 	}
 	wg_for_each_device_name(device_names, device_name, len) {
 		wg_device *device;
@@ -36,5 +36,40 @@ int main(int argc, char *argv[])
 		wg_free_device(device);
 	}
 	free(device_names);
+}
+
+int main(int argc, char *argv[])
+{
+	wg_peer new_peer = {
+		.flags = WGPEER_HAS_PUBLIC_KEY | WGPEER_REPLACE_ALLOWEDIPS
+	};
+	wg_device new_device = {
+		.name = "wgtest0",
+		.listen_port = 1234,
+		.flags = WGDEVICE_HAS_PRIVATE_KEY | WGDEVICE_HAS_LISTEN_PORT,
+		.first_peer = &new_peer,
+		.last_peer = &new_peer
+	};
+
+	wg_key_from_base64(new_device.private_key, "SFLKy56SOiFoAvQDSCBRrH/nyYonuAQnyr/JTQRPDlU=");
+	wg_key_from_base64(new_peer.public_key, "aNoLvvCfgbtTf4f2Eb/CWVNvIc5AJt/4C4pKrxMUZlM=");
+
+	if (wg_add_device(new_device.name) < 0) {
+		perror("Unable to add device");
+		exit(1);
+	}
+
+	if (wg_set_device(&new_device) < 0) {
+		perror("Unable to set device");
+		exit(1);
+	}
+
+	list_devices();
+
+	if (wg_del_device(new_device.name) < 0) {
+		perror("Unable to delete device");
+		exit(1);
+	}
+
 	return 0;
 }
diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
index a7b25de..692d285 100644
--- a/contrib/embeddable-wg-library/wireguard.c
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -910,7 +910,7 @@ static int parse_linkinfo(const struct nlattr *attr, void *data)
 {
 	struct inflatable_buffer *buffer = data;
 
-	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp("wireguard", mnl_attr_get_str(attr)))
+	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp(WG_GENL_NAME, mnl_attr_get_str(attr)))
 		buffer->good = true;
 	return MNL_CB_OK;
 }
@@ -1006,6 +1006,65 @@ cleanup:
 	return ret;
 }
 
+static int add_del_iface(const char *ifname, bool add)
+{
+	struct mnl_socket *nl = NULL;
+	char *rtnl_buffer;
+	ssize_t len;
+	int ret;
+	struct nlmsghdr *nlh;
+	struct ifinfomsg *ifm;
+	struct nlattr *nest;
+
+	rtnl_buffer = calloc(MNL_SOCKET_BUFFER_SIZE, 1);
+	if (!rtnl_buffer) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	nl = mnl_socket_open(NETLINK_ROUTE);
+	if (!nl) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	nlh = mnl_nlmsg_put_header(rtnl_buffer);
+	nlh->nlmsg_type = add ? RTM_NEWLINK : RTM_DELLINK;
+	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | (add ? NLM_F_CREATE | NLM_F_EXCL : 0);
+	nlh->nlmsg_seq = time(NULL);
+	ifm = mnl_nlmsg_put_extra_header(nlh, sizeof(*ifm));
+	ifm->ifi_family = AF_UNSPEC;
+	mnl_attr_put_strz(nlh, IFLA_IFNAME, ifname);
+	nest = mnl_attr_nest_start(nlh, IFLA_LINKINFO);
+	mnl_attr_put_strz(nlh, IFLA_INFO_KIND, WG_GENL_NAME);
+	mnl_attr_nest_end(nlh, nest);
+
+	if (mnl_socket_sendto(nl, rtnl_buffer, nlh->nlmsg_len) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+	if ((len = mnl_socket_recvfrom(nl, rtnl_buffer, MNL_SOCKET_BUFFER_SIZE)) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+	if (mnl_cb_run(rtnl_buffer, len, nlh->nlmsg_seq, mnl_socket_get_portid(nl), NULL, NULL) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+	ret = 0;
+
+cleanup:
+	free(rtnl_buffer);
+	if (nl)
+		mnl_socket_close(nl);
+	return ret;
+}
+
 int wg_set_device(wg_device *dev)
 {
 	int ret = 0;
@@ -1424,6 +1483,16 @@ err:
 	return buffer.buffer;
 }
 
+int wg_add_device(const char *device_name)
+{
+	return add_del_iface(device_name, true);
+}
+
+int wg_del_device(const char *device_name)
+{
+	return add_del_iface(device_name, false);
+}
+
 void wg_free_device(wg_device *dev)
 {
 	wg_peer *peer, *np;
diff --git a/contrib/embeddable-wg-library/wireguard.h b/contrib/embeddable-wg-library/wireguard.h
index 514ede1..350de7d 100644
--- a/contrib/embeddable-wg-library/wireguard.h
+++ b/contrib/embeddable-wg-library/wireguard.h
@@ -83,6 +83,8 @@ typedef struct wg_device {
 
 int wg_set_device(wg_device *dev);
 int wg_get_device(wg_device **dev, const char *device_name);
+int wg_add_device(const char *device_name);
+int wg_del_device(const char *device_name);
 void wg_free_device(wg_device *dev);
 char *wg_list_device_names(void); /* first\0second\0third\0forth\0last\0\0 */
 void wg_key_to_base64(wg_key_b64_string base64, const wg_key key);

commit d29e0bad7d5e80a7e289000a5fa1ae57c1955ba6
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Feb 17 19:39:26 2018 +0100

    wg: fixup errno handling
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/containers.h b/src/containers.h
index 8294ec7..a23da1c 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -78,7 +78,6 @@ struct wgdevice {
 
 #define for_each_wgpeer(__dev, __peer) for ((__peer) = (__dev)->first_peer; (__peer); (__peer) = (__peer)->next_peer)
 #define for_each_wgallowedip(__peer, __allowedip) for ((__allowedip) = (__peer)->first_allowedip; (__allowedip); (__allowedip) = (__allowedip)->next_allowedip)
-#define max(a, b) ((a) > (b) ? (a) : (b))
 
 static inline void free_wgdevice(struct wgdevice *dev)
 {
diff --git a/src/ipc.c b/src/ipc.c
index edc8e8f..3f23d1d 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -48,7 +48,6 @@
 #define SOCKET_BUFFER_SIZE 8192
 #endif
 
-
 struct inflatable_buffer {
 	char *buffer;
 	char *next;
@@ -57,6 +56,7 @@ struct inflatable_buffer {
 	size_t pos;
 };
 
+#define max(a, b) ((a) > (b) ? (a) : (b))
 static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 {
 	size_t len, expand_to;
@@ -111,7 +111,7 @@ static FILE *userspace_interface_file(const char *interface)
 	int fd = -1, ret;
 	FILE *f = NULL;
 
-	ret = -EINVAL;
+	errno = EINVAL;
 	if (strchr(interface, '/'))
 		goto out;
 	ret = snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, interface);
@@ -120,7 +120,7 @@ static FILE *userspace_interface_file(const char *interface)
 	ret = stat(addr.sun_path, &sbuf);
 	if (ret < 0)
 		goto out;
-	ret = -EBADF;
+	errno = EBADF;
 	if (!S_ISSOCK(sbuf.st_mode))
 		goto out;
 
@@ -135,12 +135,13 @@ static FILE *userspace_interface_file(const char *interface)
 		goto out;
 	}
 	f = fdopen(fd, "r+");
-	if (!f)
-		ret = -errno;
+	if (f)
+		errno = 0;
 out:
-	if (ret && fd >= 0)
-		close(fd);
+	ret = -errno;
 	if (ret) {
+		if (fd >= 0)
+			close(fd);
 		errno = -ret;
 		return NULL;
 	}

commit ca5d2708e08d1c24e92639895199c3e835eb54d5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Feb 17 19:30:05 2018 +0100

    wg: FreeBSD doesn't have EAI_NODATA
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 93c39fa..b07aa46 100644
--- a/src/config.c
+++ b/src/config.c
@@ -224,8 +224,21 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 		if (!ret)
 			break;
 		timeout = timeout * 3 / 2;
-		/* The set of return codes that are "permanent failures". All other possibilities are potentially transient. */
-		if (ret == EAI_NONAME || ret == EAI_FAIL || ret == EAI_NODATA || timeout >= 90000000) {
+		/* The set of return codes that are "permanent failures". All other possibilities are potentially transient.
+		 *
+		 * This is according to https://sourceware.org/glibc/wiki/NameResolver which states:
+		 *	"From the perspective of the application that calls getaddrinfo() it perhaps
+		 *	 doesn't matter that much since EAI_FAIL, EAI_NONAME and EAI_NODATA are all
+		 *	 permanent failure codes and the causes are all permanent failures in the
+		 *	 sense that there is no point in retrying later."
+		 *
+		 * So this is what we do, except FreeBSD removed EAI_NODATA some time ago, so that's conditional.
+		 */
+		if (ret == EAI_NONAME || ret == EAI_FAIL ||
+			#ifdef EAI_NODATA
+				ret == EAI_NODATA ||
+			#endif
+				timeout >= 90000000) {
 			free(mutable);
 			fprintf(stderr, "%s: `%s'\n", ret == EAI_SYSTEM ? strerror(errno) : gai_strerror(ret), value);
 			return false;

commit 5ecc49a62fd354f01b351258ee5cdb89dd6f62dd
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Feb 17 18:58:31 2018 +0100

    wg: do not collide types with libc clashes
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 664cd80..2195040 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -8,12 +8,18 @@
 #include <stdint.h>
 #include <string.h>
 
-typedef uint64_t u64;
-typedef uint32_t u32;
+#ifdef __linux__
+#include <linux/types.h>
+typedef __u64 u64;
+typedef __u32 u32;
+typedef __u8 u8;
+typedef __s64 s64;
+#else
+typedef uint64_t u64, __le64;
+typedef uint32_t u32, __le32;
 typedef uint8_t u8;
 typedef int64_t s64;
-typedef u64 __le64;
-typedef u32 __le32;
+#endif
 #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 #define le64_to_cpup(a) __builtin_bswap64(*(a))
 #define le32_to_cpup(a) __builtin_bswap32(*(a))

commit 2f42abeb562930cb393521dd6cbe69f350d2b89a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Feb 15 13:50:12 2018 +0100

    contrib: add embeddable wireguard library
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/embeddable-wg-library/.gitignore b/contrib/embeddable-wg-library/.gitignore
new file mode 100644
index 0000000..9daeafb
--- /dev/null
+++ b/contrib/embeddable-wg-library/.gitignore
@@ -0,0 +1 @@
+test
diff --git a/contrib/embeddable-wg-library/Makefile b/contrib/embeddable-wg-library/Makefile
new file mode 100644
index 0000000..63d7631
--- /dev/null
+++ b/contrib/embeddable-wg-library/Makefile
@@ -0,0 +1,7 @@
+CFLAGS += -Wall
+
+test: test.c wireguard.c wireguard.h
+
+clean:
+	rm -f test
+.PHONY: clean
diff --git a/contrib/embeddable-wg-library/README b/contrib/embeddable-wg-library/README
new file mode 100644
index 0000000..453dc8e
--- /dev/null
+++ b/contrib/embeddable-wg-library/README
@@ -0,0 +1,23 @@
+Embeddable WireGuard C Library
+==============================
+
+This is a mini single-file library, meant to be embedded directly into the
+source code of your program. It is *not* meant to be built as a shared
+library.
+
+
+Usage
+-----
+
+Copy wireguard.c and wireguard.h into your project. They should build with
+any C89 compiler. There are no dependencies except libc.
+
+Please see the set of simple functions in wireguard.h for information on
+how to use, as well as the example code in test.c.
+
+
+License
+-------
+
+Because this uses code from libmnl, wireguard.c and wireguard.h are licensed
+under the LGPL-2.1+.
diff --git a/contrib/embeddable-wg-library/test.c b/contrib/embeddable-wg-library/test.c
new file mode 100644
index 0000000..b738481
--- /dev/null
+++ b/contrib/embeddable-wg-library/test.c
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: LGPL-2.1+
+ *
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#include "wireguard.h"
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+int main(int argc, char *argv[])
+{
+	char *device_names, *device_name;
+	size_t len;
+
+	device_names = wg_list_device_names();
+	if (!device_names) {
+		perror("Unable to get device names");
+		return 1;
+	}
+	wg_for_each_device_name(device_names, device_name, len) {
+		wg_device *device;
+		wg_peer *peer;
+		wg_key_b64_string key;
+
+		if (wg_get_device(&device, device_name) < 0) {
+			perror("Unable to get device");
+			continue;
+		}
+		wg_key_to_base64(key, device->public_key);
+		printf("%s has public key %s\n", device_name, key);
+		wg_for_each_peer(device, peer) {
+			wg_key_to_base64(key, peer->public_key);
+			printf(" - peer %s\n", key);
+		}
+		wg_free_device(device);
+	}
+	free(device_names);
+	return 0;
+}
diff --git a/contrib/embeddable-wg-library/wireguard.c b/contrib/embeddable-wg-library/wireguard.c
new file mode 100644
index 0000000..a7b25de
--- /dev/null
+++ b/contrib/embeddable-wg-library/wireguard.c
@@ -0,0 +1,1508 @@
+/* SPDX-License-Identifier: LGPL-2.1+
+ *
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2008-2012 Pablo Neira Ayuso <pablo@netfilter.org>.
+ */
+
+#define _GNU_SOURCE
+
+#include <errno.h>
+#include <linux/genetlink.h>
+#include <linux/if_link.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <netinet/in.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <time.h>
+#include <unistd.h>
+
+#include "wireguard.h"
+
+/* wireguard.h netlink uapi: */
+
+#define WG_GENL_NAME "wireguard"
+#define WG_GENL_VERSION 1
+
+enum wg_cmd {
+	WG_CMD_GET_DEVICE,
+	WG_CMD_SET_DEVICE,
+	__WG_CMD_MAX
+};
+
+enum wgdevice_flag {
+	WGDEVICE_F_REPLACE_PEERS = 1U << 0
+};
+enum wgdevice_attribute {
+	WGDEVICE_A_UNSPEC,
+	WGDEVICE_A_IFINDEX,
+	WGDEVICE_A_IFNAME,
+	WGDEVICE_A_PRIVATE_KEY,
+	WGDEVICE_A_PUBLIC_KEY,
+	WGDEVICE_A_FLAGS,
+	WGDEVICE_A_LISTEN_PORT,
+	WGDEVICE_A_FWMARK,
+	WGDEVICE_A_PEERS,
+	__WGDEVICE_A_LAST
+};
+
+enum wgpeer_flag {
+	WGPEER_F_REMOVE_ME = 1U << 0,
+	WGPEER_F_REPLACE_ALLOWEDIPS = 1U << 1
+};
+enum wgpeer_attribute {
+	WGPEER_A_UNSPEC,
+	WGPEER_A_PUBLIC_KEY,
+	WGPEER_A_PRESHARED_KEY,
+	WGPEER_A_FLAGS,
+	WGPEER_A_ENDPOINT,
+	WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL,
+	WGPEER_A_LAST_HANDSHAKE_TIME,
+	WGPEER_A_RX_BYTES,
+	WGPEER_A_TX_BYTES,
+	WGPEER_A_ALLOWEDIPS,
+	__WGPEER_A_LAST
+};
+
+enum wgallowedip_attribute {
+	WGALLOWEDIP_A_UNSPEC,
+	WGALLOWEDIP_A_FAMILY,
+	WGALLOWEDIP_A_IPADDR,
+	WGALLOWEDIP_A_CIDR_MASK,
+	__WGALLOWEDIP_A_LAST
+};
+
+/* libmnl mini library: */
+
+#define MNL_SOCKET_AUTOPID 0
+#define MNL_SOCKET_BUFFER_SIZE (sysconf(_SC_PAGESIZE) < 8192L ? sysconf(_SC_PAGESIZE) : 8192L)
+#define MNL_ALIGNTO 4
+#define MNL_ALIGN(len) (((len)+MNL_ALIGNTO-1) & ~(MNL_ALIGNTO-1))
+#define MNL_NLMSG_HDRLEN MNL_ALIGN(sizeof(struct nlmsghdr))
+#define MNL_ATTR_HDRLEN MNL_ALIGN(sizeof(struct nlattr))
+
+enum mnl_attr_data_type {
+        MNL_TYPE_UNSPEC,
+        MNL_TYPE_U8,
+        MNL_TYPE_U16,
+        MNL_TYPE_U32,
+        MNL_TYPE_U64,
+        MNL_TYPE_STRING,
+        MNL_TYPE_FLAG,
+        MNL_TYPE_MSECS,
+        MNL_TYPE_NESTED,
+        MNL_TYPE_NESTED_COMPAT,
+        MNL_TYPE_NUL_STRING,
+        MNL_TYPE_BINARY,
+        MNL_TYPE_MAX,
+};
+
+#define mnl_attr_for_each(attr, nlh, offset) \
+        for ((attr) = mnl_nlmsg_get_payload_offset((nlh), (offset)); \
+             mnl_attr_ok((attr), (char *)mnl_nlmsg_get_payload_tail(nlh) - (char *)(attr)); \
+             (attr) = mnl_attr_next(attr))
+
+#define mnl_attr_for_each_nested(attr, nest) \
+        for ((attr) = mnl_attr_get_payload(nest); \
+             mnl_attr_ok((attr), (char *)mnl_attr_get_payload(nest) + mnl_attr_get_payload_len(nest) - (char *)(attr)); \
+             (attr) = mnl_attr_next(attr))
+
+#define mnl_attr_for_each_payload(payload, payload_size) \
+        for ((attr) = (payload); \
+             mnl_attr_ok((attr), (char *)(payload) + payload_size - (char *)(attr)); \
+             (attr) = mnl_attr_next(attr))
+
+#define MNL_CB_ERROR            -1
+#define MNL_CB_STOP              0
+#define MNL_CB_OK                1
+
+typedef int (*mnl_attr_cb_t)(const struct nlattr *attr, void *data);
+typedef int (*mnl_cb_t)(const struct nlmsghdr *nlh, void *data);
+
+#ifndef MNL_ARRAY_SIZE
+#define MNL_ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))
+#endif
+
+static size_t mnl_nlmsg_size(size_t len)
+{
+	return len + MNL_NLMSG_HDRLEN;
+}
+
+static struct nlmsghdr *mnl_nlmsg_put_header(void *buf)
+{
+	int len = MNL_ALIGN(sizeof(struct nlmsghdr));
+	struct nlmsghdr *nlh = buf;
+
+	memset(buf, 0, len);
+	nlh->nlmsg_len = len;
+	return nlh;
+}
+
+static void *mnl_nlmsg_put_extra_header(struct nlmsghdr *nlh, size_t size)
+{
+	char *ptr = (char *)nlh + nlh->nlmsg_len;
+	size_t len = MNL_ALIGN(size);
+	nlh->nlmsg_len += len;
+	memset(ptr, 0, len);
+	return ptr;
+}
+
+static void *mnl_nlmsg_get_payload(const struct nlmsghdr *nlh)
+{
+	return (void *)nlh + MNL_NLMSG_HDRLEN;
+}
+
+static void *mnl_nlmsg_get_payload_offset(const struct nlmsghdr *nlh, size_t offset)
+{
+	return (void *)nlh + MNL_NLMSG_HDRLEN + MNL_ALIGN(offset);
+}
+
+
+static bool mnl_nlmsg_ok(const struct nlmsghdr *nlh, int len)
+{
+	return len >= (int)sizeof(struct nlmsghdr) &&
+	       nlh->nlmsg_len >= sizeof(struct nlmsghdr) &&
+	       (int)nlh->nlmsg_len <= len;
+}
+
+static struct nlmsghdr *mnl_nlmsg_next(const struct nlmsghdr *nlh, int *len)
+{
+	*len -= MNL_ALIGN(nlh->nlmsg_len);
+	return (struct nlmsghdr *)((void *)nlh + MNL_ALIGN(nlh->nlmsg_len));
+}
+
+static void *mnl_nlmsg_get_payload_tail(const struct nlmsghdr *nlh)
+{
+	return (void *)nlh + MNL_ALIGN(nlh->nlmsg_len);
+}
+
+static bool mnl_nlmsg_seq_ok(const struct nlmsghdr *nlh, unsigned int seq)
+{
+	return nlh->nlmsg_seq && seq ? nlh->nlmsg_seq == seq : true;
+}
+
+static bool mnl_nlmsg_portid_ok(const struct nlmsghdr *nlh, unsigned int portid)
+{
+	return nlh->nlmsg_pid && portid ? nlh->nlmsg_pid == portid : true;
+}
+
+static uint16_t mnl_attr_get_type(const struct nlattr *attr)
+{
+	return attr->nla_type & NLA_TYPE_MASK;
+}
+
+static uint16_t mnl_attr_get_payload_len(const struct nlattr *attr)
+{
+	return attr->nla_len - MNL_ATTR_HDRLEN;
+}
+
+static void *mnl_attr_get_payload(const struct nlattr *attr)
+{
+	return (void *)attr + MNL_ATTR_HDRLEN;
+}
+
+static bool mnl_attr_ok(const struct nlattr *attr, int len)
+{
+	return len >= (int)sizeof(struct nlattr) &&
+	       attr->nla_len >= sizeof(struct nlattr) &&
+	       (int)attr->nla_len <= len;
+}
+
+static struct nlattr *mnl_attr_next(const struct nlattr *attr)
+{
+	return (struct nlattr *)((void *)attr + MNL_ALIGN(attr->nla_len));
+}
+
+static int mnl_attr_type_valid(const struct nlattr *attr, uint16_t max)
+{
+	if (mnl_attr_get_type(attr) > max) {
+		errno = EOPNOTSUPP;
+		return -1;
+	}
+	return 1;
+}
+
+static int __mnl_attr_validate(const struct nlattr *attr,
+			       enum mnl_attr_data_type type, size_t exp_len)
+{
+	uint16_t attr_len = mnl_attr_get_payload_len(attr);
+	const char *attr_data = mnl_attr_get_payload(attr);
+
+	if (attr_len < exp_len) {
+		errno = ERANGE;
+		return -1;
+	}
+	switch(type) {
+	case MNL_TYPE_FLAG:
+		if (attr_len > 0) {
+			errno = ERANGE;
+			return -1;
+		}
+		break;
+	case MNL_TYPE_NUL_STRING:
+		if (attr_len == 0) {
+			errno = ERANGE;
+			return -1;
+		}
+		if (attr_data[attr_len-1] != '\0') {
+			errno = EINVAL;
+			return -1;
+		}
+		break;
+	case MNL_TYPE_STRING:
+		if (attr_len == 0) {
+			errno = ERANGE;
+			return -1;
+		}
+		break;
+	case MNL_TYPE_NESTED:
+
+		if (attr_len == 0)
+			break;
+
+		if (attr_len < MNL_ATTR_HDRLEN) {
+			errno = ERANGE;
+			return -1;
+		}
+		break;
+	default:
+
+		break;
+	}
+	if (exp_len && attr_len > exp_len) {
+		errno = ERANGE;
+		return -1;
+	}
+	return 0;
+}
+
+static const size_t mnl_attr_data_type_len[MNL_TYPE_MAX] = {
+	[MNL_TYPE_U8]		= sizeof(uint8_t),
+	[MNL_TYPE_U16]		= sizeof(uint16_t),
+	[MNL_TYPE_U32]		= sizeof(uint32_t),
+	[MNL_TYPE_U64]		= sizeof(uint64_t),
+	[MNL_TYPE_MSECS]	= sizeof(uint64_t),
+};
+
+static int mnl_attr_validate(const struct nlattr *attr, enum mnl_attr_data_type type)
+{
+	int exp_len;
+
+	if (type >= MNL_TYPE_MAX) {
+		errno = EINVAL;
+		return -1;
+	}
+	exp_len = mnl_attr_data_type_len[type];
+	return __mnl_attr_validate(attr, type, exp_len);
+}
+
+static int mnl_attr_parse(const struct nlmsghdr *nlh, unsigned int offset,
+			  mnl_attr_cb_t cb, void *data)
+{
+	int ret = MNL_CB_OK;
+	const struct nlattr *attr;
+
+	mnl_attr_for_each(attr, nlh, offset)
+		if ((ret = cb(attr, data)) <= MNL_CB_STOP)
+			return ret;
+	return ret;
+}
+
+static int mnl_attr_parse_nested(const struct nlattr *nested, mnl_attr_cb_t cb,
+				 void *data)
+{
+	int ret = MNL_CB_OK;
+	const struct nlattr *attr;
+
+	mnl_attr_for_each_nested(attr, nested)
+		if ((ret = cb(attr, data)) <= MNL_CB_STOP)
+			return ret;
+	return ret;
+}
+
+static uint8_t mnl_attr_get_u8(const struct nlattr *attr)
+{
+	return *((uint8_t *)mnl_attr_get_payload(attr));
+}
+
+static uint16_t mnl_attr_get_u16(const struct nlattr *attr)
+{
+	return *((uint16_t *)mnl_attr_get_payload(attr));
+}
+
+static uint32_t mnl_attr_get_u32(const struct nlattr *attr)
+{
+	return *((uint32_t *)mnl_attr_get_payload(attr));
+}
+
+
+static uint64_t mnl_attr_get_u64(const struct nlattr *attr)
+{
+	uint64_t tmp;
+	memcpy(&tmp, mnl_attr_get_payload(attr), sizeof(tmp));
+	return tmp;
+}
+
+static const char *mnl_attr_get_str(const struct nlattr *attr)
+{
+	return mnl_attr_get_payload(attr);
+}
+
+static void mnl_attr_put(struct nlmsghdr *nlh, uint16_t type, size_t len,
+			 const void *data)
+{
+	struct nlattr *attr = mnl_nlmsg_get_payload_tail(nlh);
+	uint16_t payload_len = MNL_ALIGN(sizeof(struct nlattr)) + len;
+
+	attr->nla_type = type;
+	attr->nla_len = payload_len;
+	memcpy(mnl_attr_get_payload(attr), data, len);
+	nlh->nlmsg_len += MNL_ALIGN(payload_len);
+}
+
+static void mnl_attr_put_u16(struct nlmsghdr *nlh, uint16_t type, uint16_t data)
+{
+	mnl_attr_put(nlh, type, sizeof(uint16_t), &data);
+}
+
+static void mnl_attr_put_u32(struct nlmsghdr *nlh, uint16_t type, uint32_t data)
+{
+	mnl_attr_put(nlh, type, sizeof(uint32_t), &data);
+}
+
+static void mnl_attr_put_strz(struct nlmsghdr *nlh, uint16_t type, const char *data)
+{
+	mnl_attr_put(nlh, type, strlen(data)+1, data);
+}
+
+static struct nlattr *mnl_attr_nest_start(struct nlmsghdr *nlh, uint16_t type)
+{
+	struct nlattr *start = mnl_nlmsg_get_payload_tail(nlh);
+
+	start->nla_type = NLA_F_NESTED | type;
+	nlh->nlmsg_len += MNL_ALIGN(sizeof(struct nlattr));
+	return start;
+}
+
+static bool mnl_attr_put_check(struct nlmsghdr *nlh, size_t buflen,
+			       uint16_t type, size_t len, const void *data)
+{
+	if (nlh->nlmsg_len + MNL_ATTR_HDRLEN + MNL_ALIGN(len) > buflen)
+		return false;
+	mnl_attr_put(nlh, type, len, data);
+	return true;
+}
+
+static bool mnl_attr_put_u8_check(struct nlmsghdr *nlh, size_t buflen,
+				  uint16_t type, uint8_t data)
+{
+	return mnl_attr_put_check(nlh, buflen, type, sizeof(uint8_t), &data);
+}
+
+
+static bool mnl_attr_put_u16_check(struct nlmsghdr *nlh, size_t buflen,
+				   uint16_t type, uint16_t data)
+{
+	return mnl_attr_put_check(nlh, buflen, type, sizeof(uint16_t), &data);
+}
+
+
+static bool mnl_attr_put_u32_check(struct nlmsghdr *nlh, size_t buflen,
+				   uint16_t type, uint32_t data)
+{
+	return mnl_attr_put_check(nlh, buflen, type, sizeof(uint32_t), &data);
+}
+
+static struct nlattr *mnl_attr_nest_start_check(struct nlmsghdr *nlh, size_t buflen,
+						uint16_t type)
+{
+	if (nlh->nlmsg_len + MNL_ATTR_HDRLEN > buflen)
+		return NULL;
+	return mnl_attr_nest_start(nlh, type);
+}
+
+static void mnl_attr_nest_end(struct nlmsghdr *nlh, struct nlattr *start)
+{
+	start->nla_len = mnl_nlmsg_get_payload_tail(nlh) - (void *)start;
+}
+
+static void mnl_attr_nest_cancel(struct nlmsghdr *nlh, struct nlattr *start)
+{
+	nlh->nlmsg_len -= mnl_nlmsg_get_payload_tail(nlh) - (void *)start;
+}
+
+static int mnl_cb_noop(const struct nlmsghdr *nlh, void *data)
+{
+	return MNL_CB_OK;
+}
+
+static int mnl_cb_error(const struct nlmsghdr *nlh, void *data)
+{
+	const struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);
+
+	if (nlh->nlmsg_len < mnl_nlmsg_size(sizeof(struct nlmsgerr))) {
+		errno = EBADMSG;
+		return MNL_CB_ERROR;
+	}
+
+	if (err->error < 0)
+		errno = -err->error;
+	else
+		errno = err->error;
+
+	return err->error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+}
+
+static int mnl_cb_stop(const struct nlmsghdr *nlh, void *data)
+{
+	return MNL_CB_STOP;
+}
+
+static const mnl_cb_t default_cb_array[NLMSG_MIN_TYPE] = {
+	[NLMSG_NOOP]	= mnl_cb_noop,
+	[NLMSG_ERROR]	= mnl_cb_error,
+	[NLMSG_DONE]	= mnl_cb_stop,
+	[NLMSG_OVERRUN]	= mnl_cb_noop,
+};
+
+static int __mnl_cb_run(const void *buf, size_t numbytes,
+			unsigned int seq, unsigned int portid,
+			mnl_cb_t cb_data, void *data,
+			const mnl_cb_t *cb_ctl_array,
+			unsigned int cb_ctl_array_len)
+{
+	int ret = MNL_CB_OK, len = numbytes;
+	const struct nlmsghdr *nlh = buf;
+
+	while (mnl_nlmsg_ok(nlh, len)) {
+
+		if (!mnl_nlmsg_portid_ok(nlh, portid)) {
+			errno = ESRCH;
+			return -1;
+		}
+
+		if (!mnl_nlmsg_seq_ok(nlh, seq)) {
+			errno = EPROTO;
+			return -1;
+		}
+
+
+		if (nlh->nlmsg_flags & NLM_F_DUMP_INTR) {
+			errno = EINTR;
+			return -1;
+		}
+
+
+		if (nlh->nlmsg_type >= NLMSG_MIN_TYPE) {
+			if (cb_data){
+				ret = cb_data(nlh, data);
+				if (ret <= MNL_CB_STOP)
+					goto out;
+			}
+		} else if (nlh->nlmsg_type < cb_ctl_array_len) {
+			if (cb_ctl_array && cb_ctl_array[nlh->nlmsg_type]) {
+				ret = cb_ctl_array[nlh->nlmsg_type](nlh, data);
+				if (ret <= MNL_CB_STOP)
+					goto out;
+			}
+		} else if (default_cb_array[nlh->nlmsg_type]) {
+			ret = default_cb_array[nlh->nlmsg_type](nlh, data);
+			if (ret <= MNL_CB_STOP)
+				goto out;
+		}
+		nlh = mnl_nlmsg_next(nlh, &len);
+	}
+out:
+	return ret;
+}
+
+static int mnl_cb_run2(const void *buf, size_t numbytes, unsigned int seq,
+		       unsigned int portid, mnl_cb_t cb_data, void *data,
+		       const mnl_cb_t *cb_ctl_array, unsigned int cb_ctl_array_len)
+{
+	return __mnl_cb_run(buf, numbytes, seq, portid, cb_data, data,
+			    cb_ctl_array, cb_ctl_array_len);
+}
+
+static int mnl_cb_run(const void *buf, size_t numbytes, unsigned int seq,
+		      unsigned int portid, mnl_cb_t cb_data, void *data)
+{
+	return __mnl_cb_run(buf, numbytes, seq, portid, cb_data, data, NULL, 0);
+}
+
+struct mnl_socket {
+	int 			fd;
+	struct sockaddr_nl	addr;
+};
+
+static unsigned int mnl_socket_get_portid(const struct mnl_socket *nl)
+{
+	return nl->addr.nl_pid;
+}
+
+static struct mnl_socket *__mnl_socket_open(int bus, int flags)
+{
+	struct mnl_socket *nl;
+
+	nl = calloc(1, sizeof(struct mnl_socket));
+	if (nl == NULL)
+		return NULL;
+
+	nl->fd = socket(AF_NETLINK, SOCK_RAW | flags, bus);
+	if (nl->fd == -1) {
+		free(nl);
+		return NULL;
+	}
+
+	return nl;
+}
+
+static struct mnl_socket *mnl_socket_open(int bus)
+{
+	return __mnl_socket_open(bus, 0);
+}
+
+
+static int mnl_socket_bind(struct mnl_socket *nl, unsigned int groups, pid_t pid)
+{
+	int ret;
+	socklen_t addr_len;
+
+	nl->addr.nl_family = AF_NETLINK;
+	nl->addr.nl_groups = groups;
+	nl->addr.nl_pid = pid;
+
+	ret = bind(nl->fd, (struct sockaddr *) &nl->addr, sizeof (nl->addr));
+	if (ret < 0)
+		return ret;
+
+	addr_len = sizeof(nl->addr);
+	ret = getsockname(nl->fd, (struct sockaddr *) &nl->addr, &addr_len);
+	if (ret < 0)
+		return ret;
+
+	if (addr_len != sizeof(nl->addr)) {
+		errno = EINVAL;
+		return -1;
+	}
+	if (nl->addr.nl_family != AF_NETLINK) {
+		errno = EINVAL;
+		return -1;
+	}
+	return 0;
+}
+
+
+static ssize_t mnl_socket_sendto(const struct mnl_socket *nl, const void *buf,
+				 size_t len)
+{
+	static const struct sockaddr_nl snl = {
+		.nl_family = AF_NETLINK
+	};
+	return sendto(nl->fd, buf, len, 0,
+		      (struct sockaddr *) &snl, sizeof(snl));
+}
+
+
+static ssize_t mnl_socket_recvfrom(const struct mnl_socket *nl, void *buf,
+				   size_t bufsiz)
+{
+	ssize_t ret;
+	struct sockaddr_nl addr;
+	struct iovec iov = {
+		.iov_base	= buf,
+		.iov_len	= bufsiz,
+	};
+	struct msghdr msg = {
+		.msg_name	= &addr,
+		.msg_namelen	= sizeof(struct sockaddr_nl),
+		.msg_iov	= &iov,
+		.msg_iovlen	= 1,
+		.msg_control	= NULL,
+		.msg_controllen	= 0,
+		.msg_flags	= 0,
+	};
+	ret = recvmsg(nl->fd, &msg, 0);
+	if (ret == -1)
+		return ret;
+
+	if (msg.msg_flags & MSG_TRUNC) {
+		errno = ENOSPC;
+		return -1;
+	}
+	if (msg.msg_namelen != sizeof(struct sockaddr_nl)) {
+		errno = EINVAL;
+		return -1;
+	}
+	return ret;
+}
+
+static int mnl_socket_close(struct mnl_socket *nl)
+{
+	int ret = close(nl->fd);
+	free(nl);
+	return ret;
+}
+
+/* mnlg mini library: */
+
+struct mnlg_socket {
+	struct mnl_socket *nl;
+	char *buf;
+	uint16_t id;
+	uint8_t version;
+	unsigned int seq;
+	unsigned int portid;
+};
+
+static struct nlmsghdr *__mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
+					   uint16_t flags, uint16_t id,
+					   uint8_t version)
+{
+	struct nlmsghdr *nlh;
+	struct genlmsghdr *genl;
+
+	nlh = mnl_nlmsg_put_header(nlg->buf);
+	nlh->nlmsg_type	= id;
+	nlh->nlmsg_flags = flags;
+	nlg->seq = time(NULL);
+	nlh->nlmsg_seq = nlg->seq;
+
+	genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
+	genl->cmd = cmd;
+	genl->version = version;
+
+	return nlh;
+}
+
+static struct nlmsghdr *mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
+					 uint16_t flags)
+{
+	return __mnlg_msg_prepare(nlg, cmd, flags, nlg->id, nlg->version);
+}
+
+static int mnlg_socket_send(struct mnlg_socket *nlg, const struct nlmsghdr *nlh)
+{
+	return mnl_socket_sendto(nlg->nl, nlh, nlh->nlmsg_len);
+}
+
+static int mnlg_cb_noop(const struct nlmsghdr *nlh, void *data)
+{
+	(void)nlh;
+	(void)data;
+	return MNL_CB_OK;
+}
+
+static int mnlg_cb_error(const struct nlmsghdr *nlh, void *data)
+{
+	const struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);
+	(void)data;
+
+	if (nlh->nlmsg_len < mnl_nlmsg_size(sizeof(struct nlmsgerr))) {
+		errno = EBADMSG;
+		return MNL_CB_ERROR;
+	}
+	/* Netlink subsystems returns the errno value with different signess */
+	if (err->error < 0)
+		errno = -err->error;
+	else
+		errno = err->error;
+
+	return err->error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+}
+
+static int mnlg_cb_stop(const struct nlmsghdr *nlh, void *data)
+{
+	(void)data;
+	if (nlh->nlmsg_flags & NLM_F_MULTI && nlh->nlmsg_len == mnl_nlmsg_size(sizeof(int))) {
+		int error = *(int *)mnl_nlmsg_get_payload(nlh);
+		/* Netlink subsystems returns the errno value with different signess */
+		if (error < 0)
+			errno = -error;
+		else
+			errno = error;
+
+		return error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+	}
+	return MNL_CB_STOP;
+}
+
+static const mnl_cb_t mnlg_cb_array[] = {
+	[NLMSG_NOOP]	= mnlg_cb_noop,
+	[NLMSG_ERROR]	= mnlg_cb_error,
+	[NLMSG_DONE]	= mnlg_cb_stop,
+	[NLMSG_OVERRUN]	= mnlg_cb_noop,
+};
+
+static int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data)
+{
+	int err;
+
+	do {
+		err = mnl_socket_recvfrom(nlg->nl, nlg->buf,
+					  MNL_SOCKET_BUFFER_SIZE);
+		if (err <= 0)
+			break;
+		err = mnl_cb_run2(nlg->buf, err, nlg->seq, nlg->portid,
+				  data_cb, data, mnlg_cb_array, MNL_ARRAY_SIZE(mnlg_cb_array));
+	} while (err > 0);
+
+	return err;
+}
+
+static int get_family_id_attr_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
+		return MNL_CB_ERROR;
+
+	if (type == CTRL_ATTR_FAMILY_ID &&
+	    mnl_attr_validate(attr, MNL_TYPE_U16) < 0)
+		return MNL_CB_ERROR;
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static int get_family_id_cb(const struct nlmsghdr *nlh, void *data)
+{
+	uint16_t *p_id = data;
+	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
+
+	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_family_id_attr_cb, tb);
+	if (!tb[CTRL_ATTR_FAMILY_ID])
+		return MNL_CB_ERROR;
+	*p_id = mnl_attr_get_u16(tb[CTRL_ATTR_FAMILY_ID]);
+	return MNL_CB_OK;
+}
+
+static struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t version)
+{
+	struct mnlg_socket *nlg;
+	struct nlmsghdr *nlh;
+	int err;
+
+	nlg = malloc(sizeof(*nlg));
+	if (!nlg)
+		return NULL;
+
+	err = -ENOMEM;
+	nlg->buf = malloc(MNL_SOCKET_BUFFER_SIZE);
+	if (!nlg->buf)
+		goto err_buf_alloc;
+
+	nlg->nl = mnl_socket_open(NETLINK_GENERIC);
+	if (!nlg->nl) {
+		err = -errno;
+		goto err_mnl_socket_open;
+	}
+
+	if (mnl_socket_bind(nlg->nl, 0, MNL_SOCKET_AUTOPID) < 0) {
+		err = -errno;
+		goto err_mnl_socket_bind;
+	}
+
+	nlg->portid = mnl_socket_get_portid(nlg->nl);
+
+	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
+				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
+	mnl_attr_put_strz(nlh, CTRL_ATTR_FAMILY_NAME, family_name);
+
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		err = -errno;
+		goto err_mnlg_socket_send;
+	}
+
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, get_family_id_cb, &nlg->id) < 0) {
+		errno = errno == ENOENT ? EPROTONOSUPPORT : errno;
+		err = errno ? -errno : -ENOSYS;
+		goto err_mnlg_socket_recv_run;
+	}
+
+	nlg->version = version;
+	errno = 0;
+	return nlg;
+
+err_mnlg_socket_recv_run:
+err_mnlg_socket_send:
+err_mnl_socket_bind:
+	mnl_socket_close(nlg->nl);
+err_mnl_socket_open:
+	free(nlg->buf);
+err_buf_alloc:
+	free(nlg);
+	errno = -err;
+	return NULL;
+}
+
+static void mnlg_socket_close(struct mnlg_socket *nlg)
+{
+	mnl_socket_close(nlg->nl);
+	free(nlg->buf);
+	free(nlg);
+}
+
+/* wireguard-specific parts: */
+
+struct inflatable_buffer {
+	char *buffer;
+	char *next;
+	bool good;
+	size_t len;
+	size_t pos;
+};
+
+#define max(a, b) ((a) > (b) ? (a) : (b))
+
+static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
+{
+	size_t len, expand_to;
+	char *new_buffer;
+
+	if (!buffer->good || !buffer->next) {
+		free(buffer->next);
+		buffer->good = false;
+		return 0;
+	}
+
+	len = strlen(buffer->next) + 1;
+
+	if (len == 1) {
+		free(buffer->next);
+		buffer->good = false;
+		return 0;
+	}
+
+	if (buffer->len - buffer->pos <= len) {
+		expand_to = max(buffer->len * 2, buffer->len + len + 1);
+		new_buffer = realloc(buffer->buffer, expand_to);
+		if (!new_buffer) {
+			free(buffer->next);
+			buffer->good = false;
+			return -errno;
+		}
+		memset(&new_buffer[buffer->len], 0, expand_to - buffer->len);
+		buffer->buffer = new_buffer;
+		buffer->len = expand_to;
+	}
+	memcpy(&buffer->buffer[buffer->pos], buffer->next, len);
+	free(buffer->next);
+	buffer->good = false;
+	buffer->pos += len;
+	return 0;
+}
+
+static void warn_unrecognized(const char *which)
+{
+	static bool once = false;
+	if (once)
+		return;
+	once = true;
+	fprintf(stderr, "Warning: one or more unrecognized %s attributes\n", which);
+}
+
+static int parse_linkinfo(const struct nlattr *attr, void *data)
+{
+	struct inflatable_buffer *buffer = data;
+
+	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp("wireguard", mnl_attr_get_str(attr)))
+		buffer->good = true;
+	return MNL_CB_OK;
+}
+
+static int parse_infomsg(const struct nlattr *attr, void *data)
+{
+	struct inflatable_buffer *buffer = data;
+
+	if (mnl_attr_get_type(attr) == IFLA_LINKINFO)
+		return mnl_attr_parse_nested(attr, parse_linkinfo, data);
+	else if (mnl_attr_get_type(attr) == IFLA_IFNAME)
+		buffer->next = strdup(mnl_attr_get_str(attr));
+	return MNL_CB_OK;
+}
+
+static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
+{
+	struct inflatable_buffer *buffer = data;
+	int ret;
+
+	buffer->good = false;
+	buffer->next = NULL;
+	ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, data);
+	if (ret != MNL_CB_OK)
+		return ret;
+	ret = add_next_to_inflatable_buffer(buffer);
+	if (ret < 0)
+		return ret;
+	if (nlh->nlmsg_type != NLMSG_DONE)
+		return MNL_CB_OK + 1;
+	return MNL_CB_OK;
+}
+
+static int fetch_device_names(struct inflatable_buffer *buffer)
+{
+	struct mnl_socket *nl = NULL;
+	char *rtnl_buffer = NULL;
+	size_t message_len;
+	unsigned int portid, seq;
+	ssize_t len;
+	int ret = 0;
+	struct nlmsghdr *nlh;
+	struct ifinfomsg *ifm;
+
+	ret = -ENOMEM;
+	rtnl_buffer = calloc(MNL_SOCKET_BUFFER_SIZE, 1);
+	if (!rtnl_buffer)
+		goto cleanup;
+
+	nl = mnl_socket_open(NETLINK_ROUTE);
+	if (!nl) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	seq = time(NULL);
+	portid = mnl_socket_get_portid(nl);
+	nlh = mnl_nlmsg_put_header(rtnl_buffer);
+	nlh->nlmsg_type = RTM_GETLINK;
+	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP;
+	nlh->nlmsg_seq = seq;
+	ifm = mnl_nlmsg_put_extra_header(nlh, sizeof(*ifm));
+	ifm->ifi_family = AF_UNSPEC;
+	message_len = nlh->nlmsg_len;
+
+	if (mnl_socket_sendto(nl, rtnl_buffer, message_len) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+another:
+	if ((len = mnl_socket_recvfrom(nl, rtnl_buffer, MNL_SOCKET_BUFFER_SIZE)) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, buffer)) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+	if (len == MNL_CB_OK + 1)
+		goto another;
+	ret = 0;
+
+cleanup:
+	free(rtnl_buffer);
+	if (nl)
+		mnl_socket_close(nl);
+	return ret;
+}
+
+int wg_set_device(wg_device *dev)
+{
+	int ret = 0;
+	size_t i, j;
+	wg_peer *peer = NULL;
+	wg_allowedip *allowedip = NULL;
+	struct nlattr *peers_nest, *peer_nest, *allowedips_nest, *allowedip_nest;
+	struct nlmsghdr *nlh;
+	struct mnlg_socket *nlg;
+
+	nlg = mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
+	if (!nlg)
+		return -errno;
+
+again:
+	nlh = mnlg_msg_prepare(nlg, WG_CMD_SET_DEVICE, NLM_F_REQUEST | NLM_F_ACK);
+	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, dev->name);
+
+	if (!peer) {
+		uint32_t flags = 0;
+
+		if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY)
+			mnl_attr_put(nlh, WGDEVICE_A_PRIVATE_KEY, sizeof(dev->private_key), dev->private_key);
+		if (dev->flags & WGDEVICE_HAS_LISTEN_PORT)
+			mnl_attr_put_u16(nlh, WGDEVICE_A_LISTEN_PORT, dev->listen_port);
+		if (dev->flags & WGDEVICE_HAS_FWMARK)
+			mnl_attr_put_u32(nlh, WGDEVICE_A_FWMARK, dev->fwmark);
+		if (dev->flags & WGDEVICE_REPLACE_PEERS)
+			flags |= WGDEVICE_F_REPLACE_PEERS;
+		if (flags)
+			mnl_attr_put_u32(nlh, WGDEVICE_A_FLAGS, flags);
+	}
+	if (!dev->first_peer)
+		goto send;
+	peers_nest = peer_nest = allowedips_nest = allowedip_nest = NULL;
+	peers_nest = mnl_attr_nest_start(nlh, WGDEVICE_A_PEERS);
+	for (i = 0, peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
+		uint32_t flags = 0;
+
+		peer_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, i++);
+		if (!peer_nest)
+			goto toobig_peers;
+		if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PUBLIC_KEY, sizeof(peer->public_key), peer->public_key))
+			goto toobig_peers;
+		if (peer->flags & WGPEER_REMOVE_ME)
+			flags |= WGPEER_F_REMOVE_ME;
+		if (!allowedip) {
+			if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
+				flags |= WGPEER_F_REPLACE_ALLOWEDIPS;
+			if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
+				if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PRESHARED_KEY, sizeof(peer->preshared_key), peer->preshared_key))
+					goto toobig_peers;
+			}
+			if (peer->endpoint.addr.sa_family == AF_INET) {
+				if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr4), &peer->endpoint.addr4))
+					goto toobig_peers;
+			} else if (peer->endpoint.addr.sa_family == AF_INET6) {
+				if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr6), &peer->endpoint.addr6))
+					goto toobig_peers;
+			}
+			if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL) {
+				if (!mnl_attr_put_u16_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL, peer->persistent_keepalive_interval))
+					goto toobig_peers;
+			}
+		}
+		if (flags) {
+			if (!mnl_attr_put_u32_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_FLAGS, flags))
+				goto toobig_peers;
+		}
+		if (peer->first_allowedip) {
+			if (!allowedip)
+				allowedip = peer->first_allowedip;
+			allowedips_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ALLOWEDIPS);
+			if (!allowedips_nest)
+				goto toobig_allowedips;
+			for (j = 0; allowedip; allowedip = allowedip->next_allowedip) {
+				allowedip_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, j++);
+				if (!allowedip_nest)
+					goto toobig_allowedips;
+				if (!mnl_attr_put_u16_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_FAMILY, allowedip->family))
+					goto toobig_allowedips;
+				if (allowedip->family == AF_INET) {
+					if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip4), &allowedip->ip4))
+						goto toobig_allowedips;
+				} else if (allowedip->family == AF_INET6) {
+					if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip6), &allowedip->ip6))
+						goto toobig_allowedips;
+				}
+				if (!mnl_attr_put_u8_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_CIDR_MASK, allowedip->cidr))
+					goto toobig_allowedips;
+				mnl_attr_nest_end(nlh, allowedip_nest);
+				allowedip_nest = NULL;
+			}
+			mnl_attr_nest_end(nlh, allowedips_nest);
+			allowedips_nest = NULL;
+		}
+
+		mnl_attr_nest_end(nlh, peer_nest);
+		peer_nest = NULL;
+	}
+	mnl_attr_nest_end(nlh, peers_nest);
+	peers_nest = NULL;
+	goto send;
+toobig_allowedips:
+	if (allowedip_nest)
+		mnl_attr_nest_cancel(nlh, allowedip_nest);
+	if (allowedips_nest)
+		mnl_attr_nest_end(nlh, allowedips_nest);
+	mnl_attr_nest_end(nlh, peer_nest);
+	mnl_attr_nest_end(nlh, peers_nest);
+	goto send;
+toobig_peers:
+	if (peer_nest)
+		mnl_attr_nest_cancel(nlh, peer_nest);
+	mnl_attr_nest_end(nlh, peers_nest);
+	goto send;
+send:
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		ret = -errno;
+		goto out;
+	}
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, NULL, NULL) < 0) {
+		ret = errno ? -errno : -EINVAL;
+		goto out;
+	}
+	if (peer)
+		goto again;
+
+out:
+	mnlg_socket_close(nlg);
+	errno = -ret;
+	return ret;
+}
+
+static int parse_allowedip(const struct nlattr *attr, void *data)
+{
+	wg_allowedip *allowedip = data;
+
+	switch (mnl_attr_get_type(attr)) {
+	case WGALLOWEDIP_A_UNSPEC:
+		break;
+	case WGALLOWEDIP_A_FAMILY:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
+			allowedip->family = mnl_attr_get_u16(attr);
+		break;
+	case WGALLOWEDIP_A_IPADDR:
+		if (mnl_attr_get_payload_len(attr) == sizeof(allowedip->ip4))
+			memcpy(&allowedip->ip4, mnl_attr_get_payload(attr), sizeof(allowedip->ip4));
+		else if (mnl_attr_get_payload_len(attr) == sizeof(allowedip->ip6))
+			memcpy(&allowedip->ip6, mnl_attr_get_payload(attr), sizeof(allowedip->ip6));
+		break;
+	case WGALLOWEDIP_A_CIDR_MASK:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U8))
+			allowedip->cidr = mnl_attr_get_u8(attr);
+		break;
+	default:
+		warn_unrecognized("netlink");
+	}
+
+	return MNL_CB_OK;
+}
+
+static int parse_allowedips(const struct nlattr *attr, void *data)
+{
+	wg_peer *peer = data;
+	wg_allowedip *new_allowedip = calloc(1, sizeof(wg_allowedip));
+	int ret;
+
+	if (!new_allowedip)
+		return MNL_CB_ERROR;
+	if (!peer->first_allowedip)
+		peer->first_allowedip = peer->last_allowedip = new_allowedip;
+	else {
+		peer->last_allowedip->next_allowedip = new_allowedip;
+		peer->last_allowedip = new_allowedip;
+	}
+	ret = mnl_attr_parse_nested(attr, parse_allowedip, new_allowedip);
+	if (!ret)
+		return ret;
+	if (!((new_allowedip->family == AF_INET && new_allowedip->cidr <= 32) || (new_allowedip->family == AF_INET6 && new_allowedip->cidr <= 128))) {
+		errno = EAFNOSUPPORT;
+		return MNL_CB_ERROR;
+	}
+	return MNL_CB_OK;
+}
+
+bool wg_key_is_zero(const wg_key key)
+{
+	volatile uint8_t acc = 0;
+	unsigned int i;
+
+	for (i = 0; i < sizeof(wg_key); ++i) {
+		acc |= key[i];
+		__asm__ ("" : "=r" (acc) : "0" (acc));
+	}
+	return 1 & ((acc - 1) >> 8);
+}
+
+static int parse_peer(const struct nlattr *attr, void *data)
+{
+	wg_peer *peer = data;
+
+	switch (mnl_attr_get_type(attr)) {
+	case WGPEER_A_UNSPEC:
+		break;
+	case WGPEER_A_PUBLIC_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->public_key)) {
+			memcpy(peer->public_key, mnl_attr_get_payload(attr), sizeof(peer->public_key));
+			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
+		}
+		break;
+	case WGPEER_A_PRESHARED_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->preshared_key)) {
+			memcpy(peer->preshared_key, mnl_attr_get_payload(attr), sizeof(peer->preshared_key));
+			if (!wg_key_is_zero(peer->preshared_key))
+				peer->flags |= WGPEER_HAS_PRESHARED_KEY;
+		}
+		break;
+	case WGPEER_A_ENDPOINT: {
+		struct sockaddr *addr;
+
+		if (mnl_attr_get_payload_len(attr) < sizeof(*addr))
+			break;
+		addr = mnl_attr_get_payload(attr);
+		if (addr->sa_family == AF_INET && mnl_attr_get_payload_len(attr) == sizeof(peer->endpoint.addr4))
+			memcpy(&peer->endpoint.addr4, addr, sizeof(peer->endpoint.addr4));
+		else if (addr->sa_family == AF_INET6 && mnl_attr_get_payload_len(attr) == sizeof(peer->endpoint.addr6))
+			memcpy(&peer->endpoint.addr6, addr, sizeof(peer->endpoint.addr6));
+		break;
+	}
+	case WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
+			peer->persistent_keepalive_interval = mnl_attr_get_u16(attr);
+		break;
+	case WGPEER_A_LAST_HANDSHAKE_TIME:
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->last_handshake_time))
+			memcpy(&peer->last_handshake_time, mnl_attr_get_payload(attr), sizeof(peer->last_handshake_time));
+		break;
+	case WGPEER_A_RX_BYTES:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
+			peer->rx_bytes = mnl_attr_get_u64(attr);
+		break;
+	case WGPEER_A_TX_BYTES:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
+			peer->tx_bytes = mnl_attr_get_u64(attr);
+		break;
+	case WGPEER_A_ALLOWEDIPS:
+		return mnl_attr_parse_nested(attr, parse_allowedips, peer);
+	default:
+		warn_unrecognized("netlink");
+	}
+
+	return MNL_CB_OK;
+}
+
+static int parse_peers(const struct nlattr *attr, void *data)
+{
+	wg_device *device = data;
+	wg_peer *new_peer = calloc(1, sizeof(wg_peer));
+	int ret;
+
+	if (!new_peer)
+		return MNL_CB_ERROR;
+	if (!device->first_peer)
+		device->first_peer = device->last_peer = new_peer;
+	else {
+		device->last_peer->next_peer = new_peer;
+		device->last_peer = new_peer;
+	}
+	ret = mnl_attr_parse_nested(attr, parse_peer, new_peer);
+	if (!ret)
+		return ret;
+	if (!(new_peer->flags & WGPEER_HAS_PUBLIC_KEY)) {
+		errno = ENXIO;
+		return MNL_CB_ERROR;
+	}
+	return MNL_CB_OK;
+}
+
+static int parse_device(const struct nlattr *attr, void *data)
+{
+	wg_device *device = data;
+
+	switch (mnl_attr_get_type(attr)) {
+	case WGDEVICE_A_UNSPEC:
+		break;
+	case WGDEVICE_A_IFINDEX:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
+			device->ifindex = mnl_attr_get_u32(attr);
+		break;
+	case WGDEVICE_A_IFNAME:
+		if (!mnl_attr_validate(attr, MNL_TYPE_STRING)) {
+			strncpy(device->name, mnl_attr_get_str(attr), sizeof(device->name) - 1);
+			device->name[sizeof(device->name) - 1] = '\0';
+		}
+		break;
+	case WGDEVICE_A_PRIVATE_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(device->private_key)) {
+			memcpy(device->private_key, mnl_attr_get_payload(attr), sizeof(device->private_key));
+			device->flags |= WGDEVICE_HAS_PRIVATE_KEY;
+		}
+		break;
+	case WGDEVICE_A_PUBLIC_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(device->public_key)) {
+			memcpy(device->public_key, mnl_attr_get_payload(attr), sizeof(device->public_key));
+			device->flags |= WGDEVICE_HAS_PUBLIC_KEY;
+		}
+		break;
+	case WGDEVICE_A_LISTEN_PORT:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
+			device->listen_port = mnl_attr_get_u16(attr);
+		break;
+	case WGDEVICE_A_FWMARK:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
+			device->fwmark = mnl_attr_get_u32(attr);
+		break;
+	case WGDEVICE_A_PEERS:
+		return mnl_attr_parse_nested(attr, parse_peers, device);
+	default:
+		warn_unrecognized("netlink");
+	}
+
+	return MNL_CB_OK;
+}
+
+static int read_device_cb(const struct nlmsghdr *nlh, void *data)
+{
+	return mnl_attr_parse(nlh, sizeof(struct genlmsghdr), parse_device, data);
+}
+
+static void coalesce_peers(wg_device *device)
+{
+	wg_peer *old_next_peer, *peer = device->first_peer;
+
+	while (peer && peer->next_peer) {
+		if (memcmp(peer->public_key, peer->next_peer->public_key, sizeof(wg_key))) {
+			peer = peer->next_peer;
+			continue;
+		}
+		if (!peer->first_allowedip) {
+			peer->first_allowedip = peer->next_peer->first_allowedip;
+			peer->last_allowedip = peer->next_peer->last_allowedip;
+		} else {
+			peer->last_allowedip->next_allowedip = peer->next_peer->first_allowedip;
+			peer->last_allowedip = peer->next_peer->last_allowedip;
+		}
+		old_next_peer = peer->next_peer;
+		peer->next_peer = old_next_peer->next_peer;
+		free(old_next_peer);
+	}
+}
+
+int wg_get_device(wg_device **device, const char *device_name)
+{
+	int ret = 0;
+	struct nlmsghdr *nlh;
+	struct mnlg_socket *nlg;
+
+try_again:
+	*device = calloc(1, sizeof(wg_device));
+	if (!*device)
+		return -errno;
+
+	nlg = mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
+	if (!nlg) {
+		wg_free_device(*device);
+		*device = NULL;
+		return -errno;
+	}
+
+	nlh = mnlg_msg_prepare(nlg, WG_CMD_GET_DEVICE, NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP);
+	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, device_name);
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		ret = -errno;
+		goto out;
+	}
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, read_device_cb, *device) < 0) {
+		ret = errno ? -errno : -EINVAL;
+		goto out;
+	}
+	coalesce_peers(*device);
+
+out:
+	if (nlg)
+		mnlg_socket_close(nlg);
+	if (ret) {
+		wg_free_device(*device);
+		if (ret == -EINTR)
+			goto try_again;
+		*device = NULL;
+	}
+	errno = -ret;
+	return ret;
+}
+
+/* first\0second\0third\0forth\0last\0\0 */
+char *wg_list_device_names(void)
+{
+	struct inflatable_buffer buffer = { .len = MNL_SOCKET_BUFFER_SIZE };
+	int ret;
+
+	ret = -ENOMEM;
+	buffer.buffer = calloc(1, buffer.len);
+	if (!buffer.buffer)
+		goto err;
+
+	ret = fetch_device_names(&buffer);
+err:
+	errno = -ret;
+	if (errno) {
+		free(buffer.buffer);
+		return NULL;
+	}
+	return buffer.buffer;
+}
+
+void wg_free_device(wg_device *dev)
+{
+	wg_peer *peer, *np;
+	wg_allowedip *allowedip, *na;
+
+	if (!dev)
+		return;
+	for (peer = dev->first_peer, np = peer ? peer->next_peer : NULL; peer; peer = np, np = peer ? peer->next_peer : NULL) {
+		for (allowedip = peer->first_allowedip, na = allowedip ? allowedip->next_allowedip : NULL; allowedip; allowedip = na, na = allowedip ? allowedip->next_allowedip : NULL)
+			free(allowedip);
+		free(peer);
+	}
+	free(dev);
+}
+
+static void encode_base64(char dest[4], const uint8_t src[3])
+{
+	const uint8_t input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
+	unsigned int i;
+
+	for (i = 0; i < 4; ++i)
+		dest[i] = input[i] + 'A'
+			  + (((25 - input[i]) >> 8) & 6)
+			  - (((51 - input[i]) >> 8) & 75)
+			  - (((61 - input[i]) >> 8) & 15)
+			  + (((62 - input[i]) >> 8) & 3);
+
+}
+
+void wg_key_to_base64(wg_key_b64_string base64, const wg_key key)
+{
+	unsigned int i;
+
+	for (i = 0; i < 32 / 3; ++i)
+		encode_base64(&base64[i * 4], &key[i * 3]);
+	encode_base64(&base64[i * 4], (const uint8_t[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
+	base64[sizeof(wg_key_b64_string) - 2] = '=';
+	base64[sizeof(wg_key_b64_string) - 1] = '\0';
+}
+
+static int decode_base64(const char src[4])
+{
+	int val = 0;
+	unsigned int i;
+
+	for (i = 0; i < 4; ++i)
+		val |= (-1
+			    + ((((('A' - 1) - src[i]) & (src[i] - ('Z' + 1))) >> 8) & (src[i] - 64))
+			    + ((((('a' - 1) - src[i]) & (src[i] - ('z' + 1))) >> 8) & (src[i] - 70))
+			    + ((((('0' - 1) - src[i]) & (src[i] - ('9' + 1))) >> 8) & (src[i] + 5))
+			    + ((((('+' - 1) - src[i]) & (src[i] - ('+' + 1))) >> 8) & 63)
+			    + ((((('/' - 1) - src[i]) & (src[i] - ('/' + 1))) >> 8) & 64)
+			) << (18 - 6 * i);
+	return val;
+}
+
+int wg_key_from_base64(wg_key key, const wg_key_b64_string base64)
+{
+	unsigned int i;
+	int val;
+
+	errno = EINVAL;
+	if (strlen(base64) != sizeof(wg_key_b64_string) - 1 || base64[sizeof(wg_key_b64_string) - 2] != '=')
+		goto out;
+
+	for (i = 0; i < 32 / 3; ++i) {
+		val = decode_base64(&base64[i * 4]);
+		if (val < 0)
+			goto out;
+		key[i * 3 + 0] = (val >> 16) & 0xff;
+		key[i * 3 + 1] = (val >> 8) & 0xff;
+		key[i * 3 + 2] = val & 0xff;
+	}
+	val = decode_base64((const char[]){ base64[i * 4 + 0], base64[i * 4 + 1], base64[i * 4 + 2], 'A' });
+	if (val < 0 || val & 0xff)
+		goto out;
+	key[i * 3 + 0] = (val >> 16) & 0xff;
+	key[i * 3 + 1] = (val >> 8) & 0xff;
+	errno = 0;
+out:
+	return -errno;
+}
diff --git a/contrib/embeddable-wg-library/wireguard.h b/contrib/embeddable-wg-library/wireguard.h
new file mode 100644
index 0000000..514ede1
--- /dev/null
+++ b/contrib/embeddable-wg-library/wireguard.h
@@ -0,0 +1,92 @@
+/* SPDX-License-Identifier: LGPL-2.1+
+ *
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+
+#ifndef WIREGUARD_H
+#define WIREGUARD_H
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <time.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+typedef uint8_t wg_key[32];
+typedef char wg_key_b64_string[((sizeof(wg_key) + 2) / 3) * 4 + 1];
+
+typedef struct wg_allowedip {
+	uint16_t family;
+	union {
+		struct in_addr ip4;
+		struct in6_addr ip6;
+	};
+	uint8_t cidr;
+	struct wg_allowedip *next_allowedip;
+} wg_allowedip;
+
+enum wg_peer_flags {
+	WGPEER_REMOVE_ME = 1U << 0,
+	WGPEER_REPLACE_ALLOWEDIPS = 1U << 1,
+	WGPEER_HAS_PUBLIC_KEY = 1U << 2,
+	WGPEER_HAS_PRESHARED_KEY = 1U << 3,
+	WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL = 1U << 4
+};
+
+typedef struct wg_peer {
+	enum wg_peer_flags flags;
+
+	wg_key public_key;
+	wg_key preshared_key;
+
+	union {
+		struct sockaddr addr;
+		struct sockaddr_in addr4;
+		struct sockaddr_in6 addr6;
+	} endpoint;
+
+	struct timespec last_handshake_time;
+	uint64_t rx_bytes, tx_bytes;
+	uint16_t persistent_keepalive_interval;
+
+	struct wg_allowedip *first_allowedip, *last_allowedip;
+	struct wg_peer *next_peer;
+} wg_peer;
+
+enum wg_device_flags {
+	WGDEVICE_REPLACE_PEERS = 1U << 0,
+	WGDEVICE_HAS_PRIVATE_KEY = 1U << 1,
+	WGDEVICE_HAS_PUBLIC_KEY = 1U << 2,
+	WGDEVICE_HAS_LISTEN_PORT = 1U << 3,
+	WGDEVICE_HAS_FWMARK = 1U << 4
+};
+
+typedef struct wg_device {
+	char name[IFNAMSIZ];
+	uint32_t ifindex;
+
+	enum wg_device_flags flags;
+
+	wg_key public_key;
+	wg_key private_key;
+
+	uint32_t fwmark;
+	uint16_t listen_port;
+
+	struct wg_peer *first_peer, *last_peer;
+} wg_device;
+
+#define wg_for_each_device_name(__names, __name, __len) for ((__name) = (__names), (__len) = 0; ((__len) = strlen(__name)); (__name) += (__len) + 1)
+#define wg_for_each_peer(__dev, __peer) for ((__peer) = (__dev)->first_peer; (__peer); (__peer) = (__peer)->next_peer)
+#define wg_for_each_allowedip(__peer, __allowedip) for ((__allowedip) = (__peer)->first_allowedip; (__allowedip); (__allowedip) = (__allowedip)->next_allowedip)
+
+int wg_set_device(wg_device *dev);
+int wg_get_device(wg_device **dev, const char *device_name);
+void wg_free_device(wg_device *dev);
+char *wg_list_device_names(void); /* first\0second\0third\0forth\0last\0\0 */
+void wg_key_to_base64(wg_key_b64_string base64, const wg_key key);
+int wg_key_from_base64(wg_key key, const wg_key_b64_string base64);
+bool wg_key_is_zero(const wg_key key);
+
+#endif

commit 186df55998c4476d6113ea0053f873ada9a6e293
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Feb 17 05:54:48 2018 +0100

    wg(8): clarify phrasing
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg.8 b/src/wg.8
index ebfb7f6..49dc15b 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -143,9 +143,9 @@ and may be omitted. This option adds an additional layer of symmetric-key
 cryptography to be mixed into the already existing public-key cryptography,
 for post-quantum resistance.
 .IP \(bu
-AllowedIPs \(em a comma-separated list of ip (v4 or v6) addresses with
-CIDR masks from which this peer is allowed to send incoming traffic and
-to which outgoing traffic for this peer is directed. The catch-all
+AllowedIPs \(em a comma-separated list of IP (v4 or v6) addresses with
+CIDR masks from which incoming traffic for this peer is allowed and to
+which outgoing traffic for this peer is directed. The catch-all
 \fI0.0.0.0/0\fP may be specified for matching all IPv4 addresses, and
 \fI::/0\fP may be specified for matching all IPv6 addresses. May be specified
 multiple times. Required.

commit 437116f238d30f1b9d7b19d8d4364ed937817dff
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Feb 16 20:10:25 2018 +0100

    wg: allow in-line comments
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/reresolve-dns/reresolve-dns.sh b/contrib/reresolve-dns/reresolve-dns.sh
index 7f913ab..5b9394b 100755
--- a/contrib/reresolve-dns/reresolve-dns.sh
+++ b/contrib/reresolve-dns/reresolve-dns.sh
@@ -29,8 +29,9 @@ reset_peer_section() {
 
 reset_peer_section
 while read -r line || [[ -n $line ]]; do
-	key="${line%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
-	value="${line#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
+	stripped="${line%%\#*}"
+	key="${stripped%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
+	value="${stripped#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
 	[[ $key == "["* ]] && { process_peer; reset_peer_section; }
 	[[ $key == "[Peer]" ]] && PEER_SECTION=1
 	if [[ $PEER_SECTION -eq 1 ]]; then
diff --git a/src/config.c b/src/config.c
index 0407b36..93c39fa 100644
--- a/src/config.c
+++ b/src/config.c
@@ -417,25 +417,30 @@ error:
 
 bool config_read_line(struct config_ctx *ctx, const char *input)
 {
-	size_t len = strlen(input), cleaned_len = 0;
-	char *line = calloc(len + 1, sizeof(char));
+	size_t len, cleaned_len = 0;
+	char *line, *comment;
 	bool ret = true;
 
+	/* This is what strchrnull is for, but that isn't portable. */
+	comment = strchr(input, COMMENT_CHAR);
+	if (comment)
+		len = comment - input;
+	else
+		len = strlen(input);
+
+	line = calloc(len + 1, sizeof(char));
 	if (!line) {
 		perror("calloc");
 		ret = false;
 		goto out;
 	}
-	if (!len)
-		goto out;
+
 	for (size_t i = 0; i < len; ++i) {
 		if (!isspace(input[i]))
 			line[cleaned_len++] = input[i];
 	}
 	if (!cleaned_len)
 		goto out;
-	if (line[0] == COMMENT_CHAR)
-		goto out;
 	ret = process_line(ctx, line);
 out:
 	free(line);
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 80921bf..af72f7d 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -27,7 +27,7 @@ PROGRAM="${0##*/}"
 ARGS=( "$@" )
 
 parse_options() {
-	local interface_section=0 line key value
+	local interface_section=0 line key value stripped
 	CONFIG_FILE="$1"
 	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
@@ -37,8 +37,9 @@ parse_options() {
 	INTERFACE="${BASH_REMATCH[2]}"
 	shopt -s nocasematch
 	while read -r line || [[ -n $line ]]; do
-		key="${line%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
-		value="${line#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
+		stripped="${line%%\#*}"
+		key="${stripped%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
+		value="${stripped#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
 		[[ $key == "["* ]] && interface_section=0
 		[[ $key == "[Interface]" ]] && interface_section=1
 		if [[ $interface_section -eq 1 ]]; then
diff --git a/src/wg.8 b/src/wg.8
index 612fb4e..ebfb7f6 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -165,8 +165,8 @@ when unspecified, this option is off. Most users will not need this. Optional.
 
 .SH CONFIGURATION FILE FORMAT EXAMPLE
 This example may be used as a model for writing configuration files, following an
-INI-like syntax. Lines that start with a '#' are considered comments and are thus
-ignored.
+INI-like syntax. Characters after and including a '#' are considered comments and
+are thus ignored.
 
     [Interface]
 .br

commit cc8a25e2f6989003dedab548d2146ee0fb76640b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Feb 15 13:12:28 2018 +0100

    external-tests: update go version
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index e9e8da3..a582797 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -40,7 +40,7 @@ func main() {
 	theirPublic, _ := base64.StdEncoding.DecodeString("qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=")
 	preshared, _ := base64.StdEncoding.DecodeString("FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=")
 	cs := noise.NewCipherSuite(noise.DH25519, noise.CipherChaChaPoly, noise.HashBLAKE2s)
-	hs := noise.NewHandshakeState(noise.Config{
+	hs, _ := noise.NewHandshakeState(noise.Config{
 		CipherSuite:           cs,
 		Random:                rand.Reader,
 		Pattern:               noise.HandshakeIK,
@@ -68,7 +68,7 @@ func main() {
 	initiationPacket[2] = 0                                 // Reserved
 	initiationPacket[3] = 0                                 // Reserved
 	binary.LittleEndian.PutUint32(initiationPacket[4:], 28) // Sender index: 28 (arbitrary)
-	initiationPacket, _, _ = hs.WriteMessage(initiationPacket, tai64n)
+	initiationPacket, _, _, _ = hs.WriteMessage(initiationPacket, tai64n)
 	hasher, _ := blake2s.New256(nil)
 	hasher.Write([]byte("mac1----"))
 	hasher.Write(theirPublic)

commit 186272048dbc32e79226ed194b153030d0453f27
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 14 23:21:11 2018 +0100

    wg: normalize strncpy/snprintf usage
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 7223fd7..edc8e8f 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -114,7 +114,7 @@ static FILE *userspace_interface_file(const char *interface)
 	ret = -EINVAL;
 	if (strchr(interface, '/'))
 		goto out;
-	ret = snprintf(addr.sun_path, sizeof(addr.sun_path) - 1, SOCK_PATH "%s" SOCK_SUFFIX, interface);
+	ret = snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, interface);
 	if (ret < 0)
 		goto out;
 	ret = stat(addr.sun_path, &sbuf);
@@ -155,7 +155,7 @@ static bool userspace_has_wireguard_interface(const char *interface)
 
 	if (strchr(interface, '/'))
 		return false;
-	if (snprintf(addr.sun_path, sizeof(addr.sun_path) - 1, SOCK_PATH "%s" SOCK_SUFFIX, interface) < 0)
+	if (snprintf(addr.sun_path, sizeof(addr.sun_path), SOCK_PATH "%s" SOCK_SUFFIX, interface) < 0)
 		return false;
 	if (stat(addr.sun_path, &sbuf) < 0)
 		return false;
@@ -834,8 +834,10 @@ static int parse_device(const struct nlattr *attr, void *data)
 			device->ifindex = mnl_attr_get_u32(attr);
 		break;
 	case WGDEVICE_A_IFNAME:
-		if (!mnl_attr_validate(attr, MNL_TYPE_STRING))
+		if (!mnl_attr_validate(attr, MNL_TYPE_STRING)) {
 			strncpy(device->name, mnl_attr_get_str(attr), sizeof(device->name) - 1);
+			device->name[sizeof(device->name) - 1] = '\0';
+		}
 		break;
 	case WGDEVICE_A_PRIVATE_KEY:
 		if (mnl_attr_get_payload_len(attr) == sizeof(device->private_key)) {
diff --git a/src/set.c b/src/set.c
index 7f9374d..b3f57ef 100644
--- a/src/set.c
+++ b/src/set.c
@@ -26,7 +26,7 @@ int set_main(int argc, char *argv[])
 	if (!device)
 		goto cleanup;
 	strncpy(device->name, argv[1], IFNAMSIZ -  1);
-	device->name[IFNAMSIZ - 1] = 0;
+	device->name[IFNAMSIZ - 1] = '\0';
 
 	if (ipc_set_device(device) != 0) {
 		perror("Unable to set device");
diff --git a/src/setconf.c b/src/setconf.c
index b5b3cfb..f146a48 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -48,7 +48,7 @@ int setconf_main(int argc, char *argv[])
 		goto cleanup;
 	}
 	strncpy(device->name, argv[1], IFNAMSIZ - 1);
-	device->name[IFNAMSIZ - 1] = 0;
+	device->name[IFNAMSIZ - 1] = '\0';
 
 	if (ipc_set_device(device) != 0) {
 		perror("Unable to set device");
diff --git a/src/show.c b/src/show.c
index 0574a78..3fd6a67 100644
--- a/src/show.c
+++ b/src/show.c
@@ -117,10 +117,11 @@ static char *endpoint(const struct sockaddr *addr)
 		addr_len = sizeof(struct sockaddr_in6);
 
 	ret = getnameinfo(addr, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST);
-	if (ret)
+	if (ret) {
 		strncpy(buf, gai_strerror(ret), sizeof(buf) - 1);
-	else
-		snprintf(buf, sizeof(buf) - 1, (addr->sa_family == AF_INET6 && strchr(host, ':')) ? "[%s]:%s" : "%s:%s", host, service);
+		buf[sizeof(buf) - 1] = '\0';
+	} else
+		snprintf(buf, sizeof(buf), (addr->sa_family == AF_INET6 && strchr(host, ':')) ? "[%s]:%s" : "%s:%s", host, service);
 	return buf;
 }
 
@@ -139,15 +140,15 @@ static size_t pretty_time(char *buf, const size_t len, unsigned long long left)
 	seconds = left % 60;
 
 	if (years)
-		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN "year%s" TERMINAL_RESET, offset ? ", " : "", years, years == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN "year%s" TERMINAL_RESET, offset ? ", " : "", years, years == 1 ? "" : "s");
 	if (days)
-		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN  "day%s" TERMINAL_RESET, offset ? ", " : "", days, days == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN  "day%s" TERMINAL_RESET, offset ? ", " : "", days, days == 1 ? "" : "s");
 	if (hours)
-		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN  "hour%s" TERMINAL_RESET, offset ? ", " : "", hours, hours == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN  "hour%s" TERMINAL_RESET, offset ? ", " : "", hours, hours == 1 ? "" : "s");
 	if (minutes)
-		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN "minute%s" TERMINAL_RESET, offset ? ", " : "", minutes, minutes == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN "minute%s" TERMINAL_RESET, offset ? ", " : "", minutes, minutes == 1 ? "" : "s");
 	if (seconds)
-		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN  "second%s" TERMINAL_RESET, offset ? ", " : "", seconds, seconds == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN  "second%s" TERMINAL_RESET, offset ? ", " : "", seconds, seconds == 1 ? "" : "s");
 
 	return offset;
 }
@@ -166,6 +167,7 @@ static char *ago(const struct timespec *t)
 		offset = pretty_time(buf, sizeof(buf), now - t->tv_sec);
 		strncpy(buf + offset, " ago", sizeof(buf) - offset - 1);
 	}
+	buf[sizeof(buf) - 1] = '\0';
 
 	return buf;
 }
@@ -183,15 +185,15 @@ static char *bytes(uint64_t b)
 	static char buf[1024];
 
 	if (b < 1024ULL)
-		snprintf(buf, sizeof(buf) - 1, "%u " TERMINAL_FG_CYAN "B" TERMINAL_RESET, (unsigned int)b);
+		snprintf(buf, sizeof(buf), "%u " TERMINAL_FG_CYAN "B" TERMINAL_RESET, (unsigned int)b);
 	else if (b < 1024ULL * 1024ULL)
-		snprintf(buf, sizeof(buf) - 1, "%.2f " TERMINAL_FG_CYAN "KiB" TERMINAL_RESET, (double)b / 1024);
+		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "KiB" TERMINAL_RESET, (double)b / 1024);
 	else if (b < 1024ULL * 1024ULL * 1024ULL)
-		snprintf(buf, sizeof(buf) - 1, "%.2f " TERMINAL_FG_CYAN "MiB" TERMINAL_RESET, (double)b / (1024 * 1024));
+		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "MiB" TERMINAL_RESET, (double)b / (1024 * 1024));
 	else if (b < 1024ULL * 1024ULL * 1024ULL * 1024ULL)
-		snprintf(buf, sizeof(buf) - 1, "%.2f " TERMINAL_FG_CYAN "GiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024));
+		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "GiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024));
 	else
-		snprintf(buf, sizeof(buf) - 1, "%.2f " TERMINAL_FG_CYAN "TiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024) / 1024);
+		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "TiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024) / 1024);
 
 	return buf;
 }

commit 725258b9e349eaa17bc4234439b8482fba1053e0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Feb 6 12:52:09 2018 +0100

    wg-quick: match from beginning rather than shift right
    
    Before, this meant that it simply took the last 15 characters, instead
    of erroring out when there's more than 15 chars.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index a028b98..80921bf 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -31,10 +31,10 @@ parse_options() {
 	CONFIG_FILE="$1"
 	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
-	[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
+	[[ $CONFIG_FILE =~ (^|/)([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
 	CONFIG_FILE="$(readlink -f "$CONFIG_FILE")"
 	((($(stat -c '0%#a' "$CONFIG_FILE") & $(stat -c '0%#a' "${CONFIG_FILE%/*}") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
-	INTERFACE="${BASH_REMATCH[1]}"
+	INTERFACE="${BASH_REMATCH[2]}"
 	shopt -s nocasematch
 	while read -r line || [[ -n $line ]]; do
 		key="${line%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"

commit 5be1ce2aab2c594c01b51b64a74897aa71236eee
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Feb 5 12:23:10 2018 +0100

    wg: endian.h is not portable
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 901becd..664cd80 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -7,7 +7,6 @@
 
 #include <stdint.h>
 #include <string.h>
-#include <endian.h>
 
 typedef uint64_t u64;
 typedef uint32_t u32;
@@ -15,9 +14,15 @@ typedef uint8_t u8;
 typedef int64_t s64;
 typedef u64 __le64;
 typedef u32 __le32;
-#define le64_to_cpup(a) le64toh(*(a));
-#define le32_to_cpup(a) le32toh(*(a));
-#define cpu_to_le64(a) htole64(a);
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+#define le64_to_cpup(a) __builtin_bswap64(*(a))
+#define le32_to_cpup(a) __builtin_bswap32(*(a))
+#define cpu_to_le64(a) __builtin_bswap64(a)
+#else
+#define le64_to_cpup(a) (*(a))
+#define le32_to_cpup(a) (*(a))
+#define cpu_to_le64(a) (a)
+#endif
 #ifndef __always_inline
 #define __always_inline __inline __attribute__((__always_inline__))
 #endif

commit 7b0fc75a174ac69ee17858ebb723273111efb358
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Feb 2 22:03:11 2018 +0100

    keygen-html: fix up copyright
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index 8b4bbb3..fc47575 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -1,10 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2016 The fiat-crypto Authors.
  * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- *
- * This is a machine-generated formally verified implementation of curve25519 DH from:
- * https://github.com/mit-plv/fiat-crypto
  */
 
 #include <emscripten.h>

commit bee5bbb6f363f97b5e6e855481dc1f6b414f734a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Feb 1 19:15:28 2018 +0100

    curve25519: replace fiat64 with faster hacl64
    
    This reverts commit da4ff396cc5d5e0ff21f9ecbc2f951c048c63fff and adds
    some optimizations to hacl64.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index e7873a6..8b4bbb3 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -48,7 +48,7 @@ static __always_inline void normalize_secret(u8 secret[CURVE25519_POINT_SIZE])
 	secret[31] |= 64;
 }
 
-#include "../../../../src/crypto/curve25519-generic.h"
+#include "../../../../src/crypto/curve25519-fiat32.h"
 
 EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(u8 public[static 32], const u8 private[static 32])
 {
diff --git a/src/curve25519.c b/src/curve25519.c
index 50b95a9..901becd 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -39,11 +39,11 @@ static noinline void memzero_explicit(void *s, size_t count)
 }
 
 #ifdef __SIZEOF_INT128__
-#define CONFIG_ARCH_SUPPORTS_INT128
+#include "../crypto/curve25519-hacl64.h"
+#else
+#include "../crypto/curve25519-fiat32.h"
 #endif
 
-#include "../crypto/curve25519-generic.h"
-
 void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE])
 {
 	static const uint8_t basepoint[CURVE25519_POINT_SIZE] = { 9 };

commit 40ae0e0bbaa03821246e5fbde977da589c70f40b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 31 16:53:59 2018 +0100

    curve25519: replace hacl64 with fiat64
    
    For now, it's faster:
    
    hacl64: 109782 cycles per call
    fiat64: 108984 cycles per call
    
    It's quite possible this commit will be reverted with nice changes from
    INRIA, though.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index 8b4bbb3..e7873a6 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -48,7 +48,7 @@ static __always_inline void normalize_secret(u8 secret[CURVE25519_POINT_SIZE])
 	secret[31] |= 64;
 }
 
-#include "../../../../src/crypto/curve25519-fiat32.h"
+#include "../../../../src/crypto/curve25519-generic.h"
 
 EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(u8 public[static 32], const u8 private[static 32])
 {
diff --git a/src/curve25519.c b/src/curve25519.c
index 0ed4977..50b95a9 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -1,11 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2016-2017 INRIA and Microsoft Corporation.
- * Copyright (C) 2015-2016 The fiat-crypto Authors.
  * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- *
- * This is a machine-generated formally verified implementation of curve25519 DH from:
- * https://github.com/mitls/hacl-star and https://github.com/mit-plv/fiat-crypto
  */
 
 #include "curve25519.h"
@@ -44,11 +39,11 @@ static noinline void memzero_explicit(void *s, size_t count)
 }
 
 #ifdef __SIZEOF_INT128__
-#include "../crypto/curve25519-hacl64.h"
-#else
-#include "../crypto/curve25519-fiat32.h"
+#define CONFIG_ARCH_SUPPORTS_INT128
 #endif
 
+#include "../crypto/curve25519-generic.h"
+
 void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE])
 {
 	static const uint8_t basepoint[CURVE25519_POINT_SIZE] = { 9 };

commit bc3f283148437370f36dcc3843b13f0126688c6b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 31 15:58:17 2018 +0100

    wg: dedup secret normalization
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 061b913..0ed4977 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -35,6 +35,7 @@ typedef u32 __le32;
 #ifndef __force
 #define __force
 #endif
+#define normalize_secret(a) curve25519_normalize_secret(a)
 
 static noinline void memzero_explicit(void *s, size_t count)
 {
@@ -42,13 +43,6 @@ static noinline void memzero_explicit(void *s, size_t count)
 	__asm__ __volatile__("": :"r"(s) :"memory");
 }
 
-static __always_inline void normalize_secret(u8 secret[CURVE25519_POINT_SIZE])
-{
-	secret[0] &= 248;
-	secret[31] &= 127;
-	secret[31] |= 64;
-}
-
 #ifdef __SIZEOF_INT128__
 #include "../crypto/curve25519-hacl64.h"
 #else

commit 1e5d6b9a661750133a1d0dc4729847c9b52ce97a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jan 29 21:40:08 2018 +0100

    wg: fread doesn't change errno
    
    Thus we might be responding to an old errno, which could cause this to
    unnecessarily fail.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 5ab6ece..0407b36 100644
--- a/src/config.c
+++ b/src/config.c
@@ -128,10 +128,6 @@ static bool parse_keyfile(uint8_t key[static WG_KEY_LEN], const char *path)
 	}
 
 	if (fread(dst, WG_KEY_LEN_BASE64 - 1, 1, f) != 1) {
-		if (errno) {
-			perror("fread");
-			goto out;
-		}
 		/* If we're at the end and we didn't read anything, we're /dev/null or an empty file. */
 		if (!ferror(f) && feof(f) && !ftell(f)) {
 			memset(key, 0, WG_KEY_LEN);

commit 17e7c34d38a0384098a72fede843812035343a59
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jan 22 18:11:32 2018 +0100

    contrib: keygen-html: share curve25519 implementation with kernel
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/Makefile b/contrib/keygen-html/Makefile
index 0902275..a3acec0 100644
--- a/contrib/keygen-html/Makefile
+++ b/contrib/keygen-html/Makefile
@@ -1,5 +1,5 @@
 curve25519_generate.js: src/curve25519_generate.c src/glue.js
-	emcc -O2 --memory-init-file 0 --closure 1 --post-js src/glue.js -o $@ src/curve25519_generate.c
+	emcc -O2 --memory-init-file 0 --closure 1 --post-js src/glue.js -s 'EXTRA_EXPORTED_RUNTIME_METHODS=["Pointer_stringify"]' -o $@ src/curve25519_generate.c
 clean:
 	rm -f curve25519_generate.js
 all: curve25519_generate.js
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index c5f86dc..8b4bbb3 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -9,855 +9,55 @@
 
 #include <emscripten.h>
 
+typedef unsigned long long  u64;
+typedef unsigned int u32;
+typedef unsigned char u8;
+typedef u32 __le32;
+
+enum { CURVE25519_POINT_SIZE = 32 };
+
 #ifndef __always_inline
 #define __always_inline __inline __attribute__((__always_inline__))
 #endif
-
+#ifndef noinline
+#define noinline __attribute__((noinline))
+#endif
 #ifndef __aligned
 #define __aligned(x) __attribute__((aligned(x)))
 #endif
+#ifndef __force
+#define __force
+#endif
 
 #if __BYTE_ORDER == __LITTLE_ENDIAN
-#define le32toh(x) (x)
+#define le32_to_cpup(a) (*(a))
 #else
-#define htole32(x) __builtin_bswap32(x)
+#define le32_to_cpup(a) __builtin_bswap32(*(a))
 #endif
 
+#define memset(a, b, c) __builtin_memset(a, b, c)
+#define memcpy(a, b, c) __builtin_memcpy(a, b, c)
+#define memmove(a, b, c) __builtin_memmove(a, b, c)
+/* We don't even attempt to deal with this in javascript. */
+#define memzero_explicit(a, b)
 
-typedef unsigned long long uint64_t;
-typedef unsigned int uint32_t;
-typedef unsigned char uint8_t;
-/* fe means field element. Here the field is \Z/(2^255-19). An element t,
- * entries t[0]...t[9], represents the integer t[0]+2^26 t[1]+2^51 t[2]+2^77
- * t[3]+2^102 t[4]+...+2^230 t[9].
- * fe limbs are bounded by 1.125*2^26,1.125*2^25,1.125*2^26,1.125*2^25,etc.
- * Multiplication and carrying produce fe from fe_loose.
- */
-typedef struct fe { uint32_t v[10]; } fe;
-
-/* fe_loose limbs are bounded by 3.375*2^26,3.375*2^25,3.375*2^26,3.375*2^25,etc.
- * Addition and subtraction produce fe_loose from (fe, fe).
- */
-typedef struct fe_loose { uint32_t v[10]; } fe_loose;
-
-static __always_inline void fe_frombytes_impl(uint32_t h[10], const uint8_t *s)
-{
-	/* Ignores top bit of s. */
-	uint32_t a0 = le32toh(*(uint32_t *)(s));
-	uint32_t a1 = le32toh(*(uint32_t *)(s+4));
-	uint32_t a2 = le32toh(*(uint32_t *)(s+8));
-	uint32_t a3 = le32toh(*(uint32_t *)(s+12));
-	uint32_t a4 = le32toh(*(uint32_t *)(s+16));
-	uint32_t a5 = le32toh(*(uint32_t *)(s+20));
-	uint32_t a6 = le32toh(*(uint32_t *)(s+24));
-	uint32_t a7 = le32toh(*(uint32_t *)(s+28));
-	h[0] = a0&((1<<26)-1);                    /* 26 used, 32-26 left.   26 */
-	h[1] = (a0>>26) | ((a1&((1<<19)-1))<< 6); /* (32-26) + 19 =  6+19 = 25 */
-	h[2] = (a1>>19) | ((a2&((1<<13)-1))<<13); /* (32-19) + 13 = 13+13 = 26 */
-	h[3] = (a2>>13) | ((a3&((1<< 6)-1))<<19); /* (32-13) +  6 = 19+ 6 = 25 */
-	h[4] = (a3>> 6);                          /* (32- 6)              = 26 */
-	h[5] = a4&((1<<25)-1);                    /*                        25 */
-	h[6] = (a4>>25) | ((a5&((1<<19)-1))<< 7); /* (32-25) + 19 =  7+19 = 26 */
-	h[7] = (a5>>19) | ((a6&((1<<12)-1))<<13); /* (32-19) + 12 = 13+12 = 25 */
-	h[8] = (a6>>12) | ((a7&((1<< 6)-1))<<20); /* (32-12) +  6 = 20+ 6 = 26 */
-	h[9] = (a7>> 6)&((1<<25)-1); /*                                     25 */
-}
-
-static __always_inline void fe_frombytes(fe *h, const uint8_t *s)
-{
-	fe_frombytes_impl(h->v, s);
-}
-
-static __always_inline uint8_t /*bool*/ addcarryx_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
-{
-	/* This function extracts 25 bits of result and 1 bit of carry (26 total), so
-	 * a 32-bit intermediate is sufficient.
-	 */
-	uint32_t x = a + b + c;
-	*low = x & ((1 << 25) - 1);
-	return (x >> 25) & 1;
-}
-
-static __always_inline uint8_t /*bool*/ addcarryx_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
-{
-	/* This function extracts 26 bits of result and 1 bit of carry (27 total), so
-	 * a 32-bit intermediate is sufficient.
-	 */
-	uint32_t x = a + b + c;
-	*low = x & ((1 << 26) - 1);
-	return (x >> 26) & 1;
-}
-
-static __always_inline uint8_t /*bool*/ subborrow_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
-{
-	/* This function extracts 25 bits of result and 1 bit of borrow (26 total), so
-	 * a 32-bit intermediate is sufficient.
-	 */
-	uint32_t x = a - b - c;
-	*low = x & ((1 << 25) - 1);
-	return x >> 31;
-}
-
-static __always_inline uint8_t /*bool*/ subborrow_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
-{
-	/* This function extracts 26 bits of result and 1 bit of borrow (27 total), so
-	 * a 32-bit intermediate is sufficient.
-	 */
-	uint32_t x = a - b - c;
-	*low = x & ((1 << 26) - 1);
-	return x >> 31;
-}
-
-static __always_inline uint32_t cmovznz32(uint32_t t, uint32_t z, uint32_t nz)
-{
-	t = -!!t; /* all set if nonzero, 0 if 0 */
-	return (t&nz) | ((~t)&z);
-}
-
-static __always_inline void fe_freeze(uint32_t out[10], const uint32_t in1[10])
-{
-	{ const uint32_t x17 = in1[9];
-	{ const uint32_t x18 = in1[8];
-	{ const uint32_t x16 = in1[7];
-	{ const uint32_t x14 = in1[6];
-	{ const uint32_t x12 = in1[5];
-	{ const uint32_t x10 = in1[4];
-	{ const uint32_t x8 = in1[3];
-	{ const uint32_t x6 = in1[2];
-	{ const uint32_t x4 = in1[1];
-	{ const uint32_t x2 = in1[0];
-	{ uint32_t x20; uint8_t/*bool*/ x21 = subborrow_u26(0x0, x2, 0x3ffffed, &x20);
-	{ uint32_t x23; uint8_t/*bool*/ x24 = subborrow_u25(x21, x4, 0x1ffffff, &x23);
-	{ uint32_t x26; uint8_t/*bool*/ x27 = subborrow_u26(x24, x6, 0x3ffffff, &x26);
-	{ uint32_t x29; uint8_t/*bool*/ x30 = subborrow_u25(x27, x8, 0x1ffffff, &x29);
-	{ uint32_t x32; uint8_t/*bool*/ x33 = subborrow_u26(x30, x10, 0x3ffffff, &x32);
-	{ uint32_t x35; uint8_t/*bool*/ x36 = subborrow_u25(x33, x12, 0x1ffffff, &x35);
-	{ uint32_t x38; uint8_t/*bool*/ x39 = subborrow_u26(x36, x14, 0x3ffffff, &x38);
-	{ uint32_t x41; uint8_t/*bool*/ x42 = subborrow_u25(x39, x16, 0x1ffffff, &x41);
-	{ uint32_t x44; uint8_t/*bool*/ x45 = subborrow_u26(x42, x18, 0x3ffffff, &x44);
-	{ uint32_t x47; uint8_t/*bool*/ x48 = subborrow_u25(x45, x17, 0x1ffffff, &x47);
-	{ uint32_t x49 = cmovznz32(x48, 0x0, 0xffffffff);
-	{ uint32_t x50 = (x49 & 0x3ffffed);
-	{ uint32_t x52; uint8_t/*bool*/ x53 = addcarryx_u26(0x0, x20, x50, &x52);
-	{ uint32_t x54 = (x49 & 0x1ffffff);
-	{ uint32_t x56; uint8_t/*bool*/ x57 = addcarryx_u25(x53, x23, x54, &x56);
-	{ uint32_t x58 = (x49 & 0x3ffffff);
-	{ uint32_t x60; uint8_t/*bool*/ x61 = addcarryx_u26(x57, x26, x58, &x60);
-	{ uint32_t x62 = (x49 & 0x1ffffff);
-	{ uint32_t x64; uint8_t/*bool*/ x65 = addcarryx_u25(x61, x29, x62, &x64);
-	{ uint32_t x66 = (x49 & 0x3ffffff);
-	{ uint32_t x68; uint8_t/*bool*/ x69 = addcarryx_u26(x65, x32, x66, &x68);
-	{ uint32_t x70 = (x49 & 0x1ffffff);
-	{ uint32_t x72; uint8_t/*bool*/ x73 = addcarryx_u25(x69, x35, x70, &x72);
-	{ uint32_t x74 = (x49 & 0x3ffffff);
-	{ uint32_t x76; uint8_t/*bool*/ x77 = addcarryx_u26(x73, x38, x74, &x76);
-	{ uint32_t x78 = (x49 & 0x1ffffff);
-	{ uint32_t x80; uint8_t/*bool*/ x81 = addcarryx_u25(x77, x41, x78, &x80);
-	{ uint32_t x82 = (x49 & 0x3ffffff);
-	{ uint32_t x84; uint8_t/*bool*/ x85 = addcarryx_u26(x81, x44, x82, &x84);
-	{ uint32_t x86 = (x49 & 0x1ffffff);
-	{ uint32_t x88; addcarryx_u25(x85, x47, x86, &x88);
-	out[0] = x52;
-	out[1] = x56;
-	out[2] = x60;
-	out[3] = x64;
-	out[4] = x68;
-	out[5] = x72;
-	out[6] = x76;
-	out[7] = x80;
-	out[8] = x84;
-	out[9] = x88;
-	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
-}
-
-static __always_inline void fe_tobytes(uint8_t s[32], const fe *f)
-{
-	uint32_t h[10];
-	fe_freeze(h, f->v);
-	s[0] = h[0] >> 0;
-	s[1] = h[0] >> 8;
-	s[2] = h[0] >> 16;
-	s[3] = (h[0] >> 24) | (h[1] << 2);
-	s[4] = h[1] >> 6;
-	s[5] = h[1] >> 14;
-	s[6] = (h[1] >> 22) | (h[2] << 3);
-	s[7] = h[2] >> 5;
-	s[8] = h[2] >> 13;
-	s[9] = (h[2] >> 21) | (h[3] << 5);
-	s[10] = h[3] >> 3;
-	s[11] = h[3] >> 11;
-	s[12] = (h[3] >> 19) | (h[4] << 6);
-	s[13] = h[4] >> 2;
-	s[14] = h[4] >> 10;
-	s[15] = h[4] >> 18;
-	s[16] = h[5] >> 0;
-	s[17] = h[5] >> 8;
-	s[18] = h[5] >> 16;
-	s[19] = (h[5] >> 24) | (h[6] << 1);
-	s[20] = h[6] >> 7;
-	s[21] = h[6] >> 15;
-	s[22] = (h[6] >> 23) | (h[7] << 3);
-	s[23] = h[7] >> 5;
-	s[24] = h[7] >> 13;
-	s[25] = (h[7] >> 21) | (h[8] << 4);
-	s[26] = h[8] >> 4;
-	s[27] = h[8] >> 12;
-	s[28] = (h[8] >> 20) | (h[9] << 6);
-	s[29] = h[9] >> 2;
-	s[30] = h[9] >> 10;
-	s[31] = h[9] >> 18;
-}
-
-/* h = f */
-static __always_inline void fe_copy(fe *h, const fe *f)
-{
-	__builtin_memmove(h, f, sizeof(uint32_t) * 10);
-}
-
-static __always_inline void fe_copy_lt(fe_loose *h, const fe *f)
-{
-	__builtin_memmove(h, f, sizeof(uint32_t) * 10);
-}
-
-/* h = 0 */
-static __always_inline void fe_0(fe *h)
-{
-	__builtin_memset(h, 0, sizeof(uint32_t) * 10);
-}
-
-/* h = 1 */
-static __always_inline void fe_1(fe *h)
-{
-	__builtin_memset(h, 0, sizeof(uint32_t) * 10);
-	h->v[0] = 1;
-}
-
-static void fe_add_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
-{
-	{ const uint32_t x20 = in1[9];
-	{ const uint32_t x21 = in1[8];
-	{ const uint32_t x19 = in1[7];
-	{ const uint32_t x17 = in1[6];
-	{ const uint32_t x15 = in1[5];
-	{ const uint32_t x13 = in1[4];
-	{ const uint32_t x11 = in1[3];
-	{ const uint32_t x9 = in1[2];
-	{ const uint32_t x7 = in1[1];
-	{ const uint32_t x5 = in1[0];
-	{ const uint32_t x38 = in2[9];
-	{ const uint32_t x39 = in2[8];
-	{ const uint32_t x37 = in2[7];
-	{ const uint32_t x35 = in2[6];
-	{ const uint32_t x33 = in2[5];
-	{ const uint32_t x31 = in2[4];
-	{ const uint32_t x29 = in2[3];
-	{ const uint32_t x27 = in2[2];
-	{ const uint32_t x25 = in2[1];
-	{ const uint32_t x23 = in2[0];
-	out[0] = (x5 + x23);
-	out[1] = (x7 + x25);
-	out[2] = (x9 + x27);
-	out[3] = (x11 + x29);
-	out[4] = (x13 + x31);
-	out[5] = (x15 + x33);
-	out[6] = (x17 + x35);
-	out[7] = (x19 + x37);
-	out[8] = (x21 + x39);
-	out[9] = (x20 + x38);
-	}}}}}}}}}}}}}}}}}}}}
-}
-
-/* h = f + g
- * Can overlap h with f or g.
- */
-static __always_inline void fe_add(fe_loose *h, const fe *f, const fe *g)
-{
-	fe_add_impl(h->v, f->v, g->v);
-}
-
-static void fe_sub_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
-{
-	{ const uint32_t x20 = in1[9];
-	{ const uint32_t x21 = in1[8];
-	{ const uint32_t x19 = in1[7];
-	{ const uint32_t x17 = in1[6];
-	{ const uint32_t x15 = in1[5];
-	{ const uint32_t x13 = in1[4];
-	{ const uint32_t x11 = in1[3];
-	{ const uint32_t x9 = in1[2];
-	{ const uint32_t x7 = in1[1];
-	{ const uint32_t x5 = in1[0];
-	{ const uint32_t x38 = in2[9];
-	{ const uint32_t x39 = in2[8];
-	{ const uint32_t x37 = in2[7];
-	{ const uint32_t x35 = in2[6];
-	{ const uint32_t x33 = in2[5];
-	{ const uint32_t x31 = in2[4];
-	{ const uint32_t x29 = in2[3];
-	{ const uint32_t x27 = in2[2];
-	{ const uint32_t x25 = in2[1];
-	{ const uint32_t x23 = in2[0];
-	out[0] = ((0x7ffffda + x5) - x23);
-	out[1] = ((0x3fffffe + x7) - x25);
-	out[2] = ((0x7fffffe + x9) - x27);
-	out[3] = ((0x3fffffe + x11) - x29);
-	out[4] = ((0x7fffffe + x13) - x31);
-	out[5] = ((0x3fffffe + x15) - x33);
-	out[6] = ((0x7fffffe + x17) - x35);
-	out[7] = ((0x3fffffe + x19) - x37);
-	out[8] = ((0x7fffffe + x21) - x39);
-	out[9] = ((0x3fffffe + x20) - x38);
-	}}}}}}}}}}}}}}}}}}}}
-}
-
-/* h = f - g
- * Can overlap h with f or g.
- */
-static __always_inline void fe_sub(fe_loose *h, const fe *f, const fe *g)
-{
-	fe_sub_impl(h->v, f->v, g->v);
-}
-
-static void fe_mul_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
-{
-	{ const uint32_t x20 = in1[9];
-	{ const uint32_t x21 = in1[8];
-	{ const uint32_t x19 = in1[7];
-	{ const uint32_t x17 = in1[6];
-	{ const uint32_t x15 = in1[5];
-	{ const uint32_t x13 = in1[4];
-	{ const uint32_t x11 = in1[3];
-	{ const uint32_t x9 = in1[2];
-	{ const uint32_t x7 = in1[1];
-	{ const uint32_t x5 = in1[0];
-	{ const uint32_t x38 = in2[9];
-	{ const uint32_t x39 = in2[8];
-	{ const uint32_t x37 = in2[7];
-	{ const uint32_t x35 = in2[6];
-	{ const uint32_t x33 = in2[5];
-	{ const uint32_t x31 = in2[4];
-	{ const uint32_t x29 = in2[3];
-	{ const uint32_t x27 = in2[2];
-	{ const uint32_t x25 = in2[1];
-	{ const uint32_t x23 = in2[0];
-	{ uint64_t x40 = ((uint64_t)x23 * x5);
-	{ uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));
-	{ uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));
-	{ uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));
-	{ uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));
-	{ uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));
-	{ uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));
-	{ uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));
-	{ uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));
-	{ uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));
-	{ uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));
-	{ uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));
-	{ uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));
-	{ uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));
-	{ uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));
-	{ uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));
-	{ uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));
-	{ uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));
-	{ uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);
-	{ uint64_t x59 = (x48 + (x58 << 0x4));
-	{ uint64_t x60 = (x59 + (x58 << 0x1));
-	{ uint64_t x61 = (x60 + x58);
-	{ uint64_t x62 = (x47 + (x57 << 0x4));
-	{ uint64_t x63 = (x62 + (x57 << 0x1));
-	{ uint64_t x64 = (x63 + x57);
-	{ uint64_t x65 = (x46 + (x56 << 0x4));
-	{ uint64_t x66 = (x65 + (x56 << 0x1));
-	{ uint64_t x67 = (x66 + x56);
-	{ uint64_t x68 = (x45 + (x55 << 0x4));
-	{ uint64_t x69 = (x68 + (x55 << 0x1));
-	{ uint64_t x70 = (x69 + x55);
-	{ uint64_t x71 = (x44 + (x54 << 0x4));
-	{ uint64_t x72 = (x71 + (x54 << 0x1));
-	{ uint64_t x73 = (x72 + x54);
-	{ uint64_t x74 = (x43 + (x53 << 0x4));
-	{ uint64_t x75 = (x74 + (x53 << 0x1));
-	{ uint64_t x76 = (x75 + x53);
-	{ uint64_t x77 = (x42 + (x52 << 0x4));
-	{ uint64_t x78 = (x77 + (x52 << 0x1));
-	{ uint64_t x79 = (x78 + x52);
-	{ uint64_t x80 = (x41 + (x51 << 0x4));
-	{ uint64_t x81 = (x80 + (x51 << 0x1));
-	{ uint64_t x82 = (x81 + x51);
-	{ uint64_t x83 = (x40 + (x50 << 0x4));
-	{ uint64_t x84 = (x83 + (x50 << 0x1));
-	{ uint64_t x85 = (x84 + x50);
-	{ uint64_t x86 = (x85 >> 0x1a);
-	{ uint32_t x87 = ((uint32_t)x85 & 0x3ffffff);
-	{ uint64_t x88 = (x86 + x82);
-	{ uint64_t x89 = (x88 >> 0x19);
-	{ uint32_t x90 = ((uint32_t)x88 & 0x1ffffff);
-	{ uint64_t x91 = (x89 + x79);
-	{ uint64_t x92 = (x91 >> 0x1a);
-	{ uint32_t x93 = ((uint32_t)x91 & 0x3ffffff);
-	{ uint64_t x94 = (x92 + x76);
-	{ uint64_t x95 = (x94 >> 0x19);
-	{ uint32_t x96 = ((uint32_t)x94 & 0x1ffffff);
-	{ uint64_t x97 = (x95 + x73);
-	{ uint64_t x98 = (x97 >> 0x1a);
-	{ uint32_t x99 = ((uint32_t)x97 & 0x3ffffff);
-	{ uint64_t x100 = (x98 + x70);
-	{ uint64_t x101 = (x100 >> 0x19);
-	{ uint32_t x102 = ((uint32_t)x100 & 0x1ffffff);
-	{ uint64_t x103 = (x101 + x67);
-	{ uint64_t x104 = (x103 >> 0x1a);
-	{ uint32_t x105 = ((uint32_t)x103 & 0x3ffffff);
-	{ uint64_t x106 = (x104 + x64);
-	{ uint64_t x107 = (x106 >> 0x19);
-	{ uint32_t x108 = ((uint32_t)x106 & 0x1ffffff);
-	{ uint64_t x109 = (x107 + x61);
-	{ uint64_t x110 = (x109 >> 0x1a);
-	{ uint32_t x111 = ((uint32_t)x109 & 0x3ffffff);
-	{ uint64_t x112 = (x110 + x49);
-	{ uint64_t x113 = (x112 >> 0x19);
-	{ uint32_t x114 = ((uint32_t)x112 & 0x1ffffff);
-	{ uint64_t x115 = (x87 + (0x13 * x113));
-	{ uint32_t x116 = (uint32_t) (x115 >> 0x1a);
-	{ uint32_t x117 = ((uint32_t)x115 & 0x3ffffff);
-	{ uint32_t x118 = (x116 + x90);
-	{ uint32_t x119 = (x118 >> 0x19);
-	{ uint32_t x120 = (x118 & 0x1ffffff);
-	out[0] = x117;
-	out[1] = x120;
-	out[2] = (x119 + x93);
-	out[3] = x96;
-	out[4] = x99;
-	out[5] = x102;
-	out[6] = x105;
-	out[7] = x108;
-	out[8] = x111;
-	out[9] = x114;
-	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
-}
-
-static __always_inline void fe_mul_ttt(fe *h, const fe *f, const fe *g)
-{
-	fe_mul_impl(h->v, f->v, g->v);
-}
-
-static __always_inline void fe_mul_tlt(fe *h, const fe_loose *f, const fe *g)
-{
-	fe_mul_impl(h->v, f->v, g->v);
-}
-
-static __always_inline void fe_mul_tll(fe *h, const fe_loose *f, const fe_loose *g)
-{
-	fe_mul_impl(h->v, f->v, g->v);
-}
-
-static void fe_sqr_impl(uint32_t out[10], const uint32_t in1[10])
-{
-	{ const uint32_t x17 = in1[9];
-	{ const uint32_t x18 = in1[8];
-	{ const uint32_t x16 = in1[7];
-	{ const uint32_t x14 = in1[6];
-	{ const uint32_t x12 = in1[5];
-	{ const uint32_t x10 = in1[4];
-	{ const uint32_t x8 = in1[3];
-	{ const uint32_t x6 = in1[2];
-	{ const uint32_t x4 = in1[1];
-	{ const uint32_t x2 = in1[0];
-	{ uint64_t x19 = ((uint64_t)x2 * x2);
-	{ uint64_t x20 = ((uint64_t)(0x2 * x2) * x4);
-	{ uint64_t x21 = (0x2 * (((uint64_t)x4 * x4) + ((uint64_t)x2 * x6)));
-	{ uint64_t x22 = (0x2 * (((uint64_t)x4 * x6) + ((uint64_t)x2 * x8)));
-	{ uint64_t x23 = ((((uint64_t)x6 * x6) + ((uint64_t)(0x4 * x4) * x8)) + ((uint64_t)(0x2 * x2) * x10));
-	{ uint64_t x24 = (0x2 * ((((uint64_t)x6 * x8) + ((uint64_t)x4 * x10)) + ((uint64_t)x2 * x12)));
-	{ uint64_t x25 = (0x2 * (((((uint64_t)x8 * x8) + ((uint64_t)x6 * x10)) + ((uint64_t)x2 * x14)) + ((uint64_t)(0x2 * x4) * x12)));
-	{ uint64_t x26 = (0x2 * (((((uint64_t)x8 * x10) + ((uint64_t)x6 * x12)) + ((uint64_t)x4 * x14)) + ((uint64_t)x2 * x16)));
-	{ uint64_t x27 = (((uint64_t)x10 * x10) + (0x2 * ((((uint64_t)x6 * x14) + ((uint64_t)x2 * x18)) + (0x2 * (((uint64_t)x4 * x16) + ((uint64_t)x8 * x12))))));
-	{ uint64_t x28 = (0x2 * ((((((uint64_t)x10 * x12) + ((uint64_t)x8 * x14)) + ((uint64_t)x6 * x16)) + ((uint64_t)x4 * x18)) + ((uint64_t)x2 * x17)));
-	{ uint64_t x29 = (0x2 * (((((uint64_t)x12 * x12) + ((uint64_t)x10 * x14)) + ((uint64_t)x6 * x18)) + (0x2 * (((uint64_t)x8 * x16) + ((uint64_t)x4 * x17)))));
-	{ uint64_t x30 = (0x2 * (((((uint64_t)x12 * x14) + ((uint64_t)x10 * x16)) + ((uint64_t)x8 * x18)) + ((uint64_t)x6 * x17)));
-	{ uint64_t x31 = (((uint64_t)x14 * x14) + (0x2 * (((uint64_t)x10 * x18) + (0x2 * (((uint64_t)x12 * x16) + ((uint64_t)x8 * x17))))));
-	{ uint64_t x32 = (0x2 * ((((uint64_t)x14 * x16) + ((uint64_t)x12 * x18)) + ((uint64_t)x10 * x17)));
-	{ uint64_t x33 = (0x2 * ((((uint64_t)x16 * x16) + ((uint64_t)x14 * x18)) + ((uint64_t)(0x2 * x12) * x17)));
-	{ uint64_t x34 = (0x2 * (((uint64_t)x16 * x18) + ((uint64_t)x14 * x17)));
-	{ uint64_t x35 = (((uint64_t)x18 * x18) + ((uint64_t)(0x4 * x16) * x17));
-	{ uint64_t x36 = ((uint64_t)(0x2 * x18) * x17);
-	{ uint64_t x37 = ((uint64_t)(0x2 * x17) * x17);
-	{ uint64_t x38 = (x27 + (x37 << 0x4));
-	{ uint64_t x39 = (x38 + (x37 << 0x1));
-	{ uint64_t x40 = (x39 + x37);
-	{ uint64_t x41 = (x26 + (x36 << 0x4));
-	{ uint64_t x42 = (x41 + (x36 << 0x1));
-	{ uint64_t x43 = (x42 + x36);
-	{ uint64_t x44 = (x25 + (x35 << 0x4));
-	{ uint64_t x45 = (x44 + (x35 << 0x1));
-	{ uint64_t x46 = (x45 + x35);
-	{ uint64_t x47 = (x24 + (x34 << 0x4));
-	{ uint64_t x48 = (x47 + (x34 << 0x1));
-	{ uint64_t x49 = (x48 + x34);
-	{ uint64_t x50 = (x23 + (x33 << 0x4));
-	{ uint64_t x51 = (x50 + (x33 << 0x1));
-	{ uint64_t x52 = (x51 + x33);
-	{ uint64_t x53 = (x22 + (x32 << 0x4));
-	{ uint64_t x54 = (x53 + (x32 << 0x1));
-	{ uint64_t x55 = (x54 + x32);
-	{ uint64_t x56 = (x21 + (x31 << 0x4));
-	{ uint64_t x57 = (x56 + (x31 << 0x1));
-	{ uint64_t x58 = (x57 + x31);
-	{ uint64_t x59 = (x20 + (x30 << 0x4));
-	{ uint64_t x60 = (x59 + (x30 << 0x1));
-	{ uint64_t x61 = (x60 + x30);
-	{ uint64_t x62 = (x19 + (x29 << 0x4));
-	{ uint64_t x63 = (x62 + (x29 << 0x1));
-	{ uint64_t x64 = (x63 + x29);
-	{ uint64_t x65 = (x64 >> 0x1a);
-	{ uint32_t x66 = ((uint32_t)x64 & 0x3ffffff);
-	{ uint64_t x67 = (x65 + x61);
-	{ uint64_t x68 = (x67 >> 0x19);
-	{ uint32_t x69 = ((uint32_t)x67 & 0x1ffffff);
-	{ uint64_t x70 = (x68 + x58);
-	{ uint64_t x71 = (x70 >> 0x1a);
-	{ uint32_t x72 = ((uint32_t)x70 & 0x3ffffff);
-	{ uint64_t x73 = (x71 + x55);
-	{ uint64_t x74 = (x73 >> 0x19);
-	{ uint32_t x75 = ((uint32_t)x73 & 0x1ffffff);
-	{ uint64_t x76 = (x74 + x52);
-	{ uint64_t x77 = (x76 >> 0x1a);
-	{ uint32_t x78 = ((uint32_t)x76 & 0x3ffffff);
-	{ uint64_t x79 = (x77 + x49);
-	{ uint64_t x80 = (x79 >> 0x19);
-	{ uint32_t x81 = ((uint32_t)x79 & 0x1ffffff);
-	{ uint64_t x82 = (x80 + x46);
-	{ uint64_t x83 = (x82 >> 0x1a);
-	{ uint32_t x84 = ((uint32_t)x82 & 0x3ffffff);
-	{ uint64_t x85 = (x83 + x43);
-	{ uint64_t x86 = (x85 >> 0x19);
-	{ uint32_t x87 = ((uint32_t)x85 & 0x1ffffff);
-	{ uint64_t x88 = (x86 + x40);
-	{ uint64_t x89 = (x88 >> 0x1a);
-	{ uint32_t x90 = ((uint32_t)x88 & 0x3ffffff);
-	{ uint64_t x91 = (x89 + x28);
-	{ uint64_t x92 = (x91 >> 0x19);
-	{ uint32_t x93 = ((uint32_t)x91 & 0x1ffffff);
-	{ uint64_t x94 = (x66 + (0x13 * x92));
-	{ uint32_t x95 = (uint32_t) (x94 >> 0x1a);
-	{ uint32_t x96 = ((uint32_t)x94 & 0x3ffffff);
-	{ uint32_t x97 = (x95 + x69);
-	{ uint32_t x98 = (x97 >> 0x19);
-	{ uint32_t x99 = (x97 & 0x1ffffff);
-	out[0] = x96;
-	out[1] = x99;
-	out[2] = (x98 + x72);
-	out[3] = x75;
-	out[4] = x78;
-	out[5] = x81;
-	out[6] = x84;
-	out[7] = x87;
-	out[8] = x90;
-	out[9] = x93;
-	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
-}
-
-static __always_inline void fe_sq_tl(fe *h, const fe_loose *f)
-{
-	fe_sqr_impl(h->v, f->v);
-}
-
-static __always_inline void fe_sq_tt(fe *h, const fe *f)
-{
-	fe_sqr_impl(h->v, f->v);
-}
-
-static __always_inline void fe_loose_invert(fe *out, const fe_loose *z)
-{
-	fe t0;
-	fe t1;
-	fe t2;
-	fe t3;
-	int i;
-
-	fe_sq_tl(&t0, z);
-	fe_sq_tt(&t1, &t0);
-	for (i = 1; i < 2; ++i)
-		fe_sq_tt(&t1, &t1);
-	fe_mul_tlt(&t1, z, &t1);
-	fe_mul_ttt(&t0, &t0, &t1);
-	fe_sq_tt(&t2, &t0);
-	fe_mul_ttt(&t1, &t1, &t2);
-	fe_sq_tt(&t2, &t1);
-	for (i = 1; i < 5; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t1, &t2, &t1);
-	fe_sq_tt(&t2, &t1);
-	for (i = 1; i < 10; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t2, &t2, &t1);
-	fe_sq_tt(&t3, &t2);
-	for (i = 1; i < 20; ++i)
-		fe_sq_tt(&t3, &t3);
-	fe_mul_ttt(&t2, &t3, &t2);
-	fe_sq_tt(&t2, &t2);
-	for (i = 1; i < 10; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t1, &t2, &t1);
-	fe_sq_tt(&t2, &t1);
-	for (i = 1; i < 50; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t2, &t2, &t1);
-	fe_sq_tt(&t3, &t2);
-	for (i = 1; i < 100; ++i)
-		fe_sq_tt(&t3, &t3);
-	fe_mul_ttt(&t2, &t3, &t2);
-	fe_sq_tt(&t2, &t2);
-	for (i = 1; i < 50; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t1, &t2, &t1);
-	fe_sq_tt(&t1, &t1);
-	for (i = 1; i < 5; ++i)
-		fe_sq_tt(&t1, &t1);
-	fe_mul_ttt(out, &t1, &t0);
-}
-
-static __always_inline void fe_invert(fe *out, const fe *z)
-{
-	fe_loose l;
-	fe_copy_lt(&l, z);
-	fe_loose_invert(out, &l);
-}
-
-/* Replace (f,g) with (g,f) if b == 1;
- * replace (f,g) with (f,g) if b == 0.
- *
- * Preconditions: b in {0,1}
- */
-static __always_inline void fe_cswap(fe *f, fe *g, unsigned int b)
-{
-	unsigned i;
-	b = 0-b;
-	for (i = 0; i < 10; i++) {
-		uint32_t x = f->v[i] ^ g->v[i];
-		x &= b;
-		f->v[i] ^= x;
-		g->v[i] ^= x;
-	}
-}
-
-/* NOTE: based on fiat-crypto fe_mul, edited for in2=121666, 0, 0.*/
-static __always_inline void fe_mul_121666_impl(uint32_t out[10], const uint32_t in1[10])
-{
-	{ const uint32_t x20 = in1[9];
-	{ const uint32_t x21 = in1[8];
-	{ const uint32_t x19 = in1[7];
-	{ const uint32_t x17 = in1[6];
-	{ const uint32_t x15 = in1[5];
-	{ const uint32_t x13 = in1[4];
-	{ const uint32_t x11 = in1[3];
-	{ const uint32_t x9 = in1[2];
-	{ const uint32_t x7 = in1[1];
-	{ const uint32_t x5 = in1[0];
-	{ const uint32_t x38 = 0;
-	{ const uint32_t x39 = 0;
-	{ const uint32_t x37 = 0;
-	{ const uint32_t x35 = 0;
-	{ const uint32_t x33 = 0;
-	{ const uint32_t x31 = 0;
-	{ const uint32_t x29 = 0;
-	{ const uint32_t x27 = 0;
-	{ const uint32_t x25 = 0;
-	{ const uint32_t x23 = 121666;
-	{ uint64_t x40 = ((uint64_t)x23 * x5);
-	{ uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));
-	{ uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));
-	{ uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));
-	{ uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));
-	{ uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));
-	{ uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));
-	{ uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));
-	{ uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));
-	{ uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));
-	{ uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));
-	{ uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));
-	{ uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));
-	{ uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));
-	{ uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));
-	{ uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));
-	{ uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));
-	{ uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));
-	{ uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);
-	{ uint64_t x59 = (x48 + (x58 << 0x4));
-	{ uint64_t x60 = (x59 + (x58 << 0x1));
-	{ uint64_t x61 = (x60 + x58);
-	{ uint64_t x62 = (x47 + (x57 << 0x4));
-	{ uint64_t x63 = (x62 + (x57 << 0x1));
-	{ uint64_t x64 = (x63 + x57);
-	{ uint64_t x65 = (x46 + (x56 << 0x4));
-	{ uint64_t x66 = (x65 + (x56 << 0x1));
-	{ uint64_t x67 = (x66 + x56);
-	{ uint64_t x68 = (x45 + (x55 << 0x4));
-	{ uint64_t x69 = (x68 + (x55 << 0x1));
-	{ uint64_t x70 = (x69 + x55);
-	{ uint64_t x71 = (x44 + (x54 << 0x4));
-	{ uint64_t x72 = (x71 + (x54 << 0x1));
-	{ uint64_t x73 = (x72 + x54);
-	{ uint64_t x74 = (x43 + (x53 << 0x4));
-	{ uint64_t x75 = (x74 + (x53 << 0x1));
-	{ uint64_t x76 = (x75 + x53);
-	{ uint64_t x77 = (x42 + (x52 << 0x4));
-	{ uint64_t x78 = (x77 + (x52 << 0x1));
-	{ uint64_t x79 = (x78 + x52);
-	{ uint64_t x80 = (x41 + (x51 << 0x4));
-	{ uint64_t x81 = (x80 + (x51 << 0x1));
-	{ uint64_t x82 = (x81 + x51);
-	{ uint64_t x83 = (x40 + (x50 << 0x4));
-	{ uint64_t x84 = (x83 + (x50 << 0x1));
-	{ uint64_t x85 = (x84 + x50);
-	{ uint64_t x86 = (x85 >> 0x1a);
-	{ uint32_t x87 = ((uint32_t)x85 & 0x3ffffff);
-	{ uint64_t x88 = (x86 + x82);
-	{ uint64_t x89 = (x88 >> 0x19);
-	{ uint32_t x90 = ((uint32_t)x88 & 0x1ffffff);
-	{ uint64_t x91 = (x89 + x79);
-	{ uint64_t x92 = (x91 >> 0x1a);
-	{ uint32_t x93 = ((uint32_t)x91 & 0x3ffffff);
-	{ uint64_t x94 = (x92 + x76);
-	{ uint64_t x95 = (x94 >> 0x19);
-	{ uint32_t x96 = ((uint32_t)x94 & 0x1ffffff);
-	{ uint64_t x97 = (x95 + x73);
-	{ uint64_t x98 = (x97 >> 0x1a);
-	{ uint32_t x99 = ((uint32_t)x97 & 0x3ffffff);
-	{ uint64_t x100 = (x98 + x70);
-	{ uint64_t x101 = (x100 >> 0x19);
-	{ uint32_t x102 = ((uint32_t)x100 & 0x1ffffff);
-	{ uint64_t x103 = (x101 + x67);
-	{ uint64_t x104 = (x103 >> 0x1a);
-	{ uint32_t x105 = ((uint32_t)x103 & 0x3ffffff);
-	{ uint64_t x106 = (x104 + x64);
-	{ uint64_t x107 = (x106 >> 0x19);
-	{ uint32_t x108 = ((uint32_t)x106 & 0x1ffffff);
-	{ uint64_t x109 = (x107 + x61);
-	{ uint64_t x110 = (x109 >> 0x1a);
-	{ uint32_t x111 = ((uint32_t)x109 & 0x3ffffff);
-	{ uint64_t x112 = (x110 + x49);
-	{ uint64_t x113 = (x112 >> 0x19);
-	{ uint32_t x114 = ((uint32_t)x112 & 0x1ffffff);
-	{ uint64_t x115 = (x87 + (0x13 * x113));
-	{ uint32_t x116 = (uint32_t) (x115 >> 0x1a);
-	{ uint32_t x117 = ((uint32_t)x115 & 0x3ffffff);
-	{ uint32_t x118 = (x116 + x90);
-	{ uint32_t x119 = (x118 >> 0x19);
-	{ uint32_t x120 = (x118 & 0x1ffffff);
-	out[0] = x117;
-	out[1] = x120;
-	out[2] = (x119 + x93);
-	out[3] = x96;
-	out[4] = x99;
-	out[5] = x102;
-	out[6] = x105;
-	out[7] = x108;
-	out[8] = x111;
-	out[9] = x114;
-	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
-}
-
-static __always_inline void fe_mul121666(fe *h, const fe_loose *f)
-{
-	fe_mul_121666_impl(h->v, f->v);
-}
-
-static __always_inline void normalize_secret(uint8_t secret[static 32])
+static __always_inline void normalize_secret(u8 secret[CURVE25519_POINT_SIZE])
 {
 	secret[0] &= 248;
 	secret[31] &= 127;
 	secret[31] |= 64;
 }
 
-static void curve25519(uint8_t out[static 32], const uint8_t scalar[static 32], const uint8_t point[static 32])
-{
-	fe x1, x2, z2, x3, z3, tmp0, tmp1;
-	fe_loose x2l, z2l, x3l, tmp0l, tmp1l;
-	unsigned swap = 0;
-	int pos;
-	uint8_t e[32];
-
-	__builtin_memcpy(e, scalar, 32);
-	normalize_secret(e);
-
-	/* The following implementation was transcribed to Coq and proven to
-	 * correspond to unary scalar multiplication in affine coordinates given that
-	 * x1 != 0 is the x coordinate of some point on the curve. It was also checked
-	 * in Coq that doing a ladderstep with x1 = x3 = 0 gives z2' = z3' = 0, and z2
-	 * = z3 = 0 gives z2' = z3' = 0. The statement was quantified over the
-	 * underlying field, so it applies to Curve25519 itself and the quadratic
-	 * twist of Curve25519. It was not proven in Coq that prime-field arithmetic
-	 * correctly simulates extension-field arithmetic on prime-field values.
-	 * The decoding of the byte array representation of e was not considered.
-	 * Specification of Montgomery curves in affine coordinates:
-	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Spec/MontgomeryCurve.v#L27>
-	 * Proof that these form a group that is isomorphic to a Weierstrass curve:
-	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/AffineProofs.v#L35>
-	 * Coq transcription and correctness proof of the loop (where scalarbits=255):
-	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L118>
-	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L278>
-	 * preconditions: 0 <= e < 2^255 (not necessarily e < order), fe_invert(0) = 0
-	 */
-	fe_frombytes(&x1, point);
-	fe_1(&x2);
-	fe_0(&z2);
-	fe_copy(&x3, &x1);
-	fe_1(&z3);
-
-	for (pos = 254; pos >= 0; --pos) {
-		/* loop invariant as of right before the test, for the case where x1 != 0:
-		 *   pos >= -1; if z2 = 0 then x2 is nonzero; if z3 = 0 then x3 is nonzero
-		 *   let r := e >> (pos+1) in the following equalities of projective points:
-		 *   to_xz (r*P)     === if swap then (x3, z3) else (x2, z2)
-		 *   to_xz ((r+1)*P) === if swap then (x2, z2) else (x3, z3)
-		 *   x1 is the nonzero x coordinate of the nonzero point (r*P-(r+1)*P)
-		 */
-		unsigned b = 1 & (e[pos / 8] >> (pos & 7));
-		swap ^= b;
-		fe_cswap(&x2, &x3, swap);
-		fe_cswap(&z2, &z3, swap);
-		swap = b;
-		/* Coq transcription of ladderstep formula (called from transcribed loop):
-		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L89>
-		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L131>
-		 * x1 != 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L217>
-		 * x1  = 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L147>
-		 */
-		fe_sub(&tmp0l, &x3, &z3);
-		fe_sub(&tmp1l, &x2, &z2);
-		fe_add(&x2l, &x2, &z2);
-		fe_add(&z2l, &x3, &z3);
-		fe_mul_tll(&z3, &tmp0l, &x2l);
-		fe_mul_tll(&z2, &z2l, &tmp1l);
-		fe_sq_tl(&tmp0, &tmp1l);
-		fe_sq_tl(&tmp1, &x2l);
-		fe_add(&x3l, &z3, &z2);
-		fe_sub(&z2l, &z3, &z2);
-		fe_mul_ttt(&x2, &tmp1, &tmp0);
-		fe_sub(&tmp1l, &tmp1, &tmp0);
-		fe_sq_tl(&z2, &z2l);
-		fe_mul121666(&z3, &tmp1l);
-		fe_sq_tl(&x3, &x3l);
-		fe_add(&tmp0l, &tmp0, &z3);
-		fe_mul_ttt(&z3, &x1, &z2);
-		fe_mul_tll(&z2, &tmp1l, &tmp0l);
-	}
-	/* here pos=-1, so r=e, so to_xz (e*P) === if swap then (x3, z3) else (x2, z2) */
-	fe_cswap(&x2, &x3, swap);
-	fe_cswap(&z2, &z3, swap);
-
-	fe_invert(&z2, &z2);
-	fe_mul_ttt(&x2, &x2, &z2);
-	fe_tobytes(out, &x2);
-}
+#include "../../../../src/crypto/curve25519-fiat32.h"
 
-EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(uint8_t public[static 32], const uint8_t private[static 32])
+EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(u8 public[static 32], const u8 private[static 32])
 {
-	static const uint8_t basepoint[32] = { 9 };
+	static const u8 basepoint[32] = { 9 };
 
-	curve25519(public, private, basepoint);
+	curve25519_generic(public, private, basepoint);
 }
 
-EMSCRIPTEN_KEEPALIVE void curve25519_generate_private(uint8_t private[static 32])
+EMSCRIPTEN_KEEPALIVE void curve25519_generate_private(u8 private[static 32])
 {
 	int i;
 
@@ -876,9 +76,9 @@ EMSCRIPTEN_KEEPALIVE void curve25519_generate_private(uint8_t private[static 32]
 	normalize_secret(private);
 }
 
-static inline void encode_base64(char dest[4], const uint8_t src[3])
+static inline void encode_base64(char dest[4], const u8 src[3])
 {
-	const uint8_t input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
+	const u8 input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
 
 	for (unsigned int i = 0; i < 4; ++i)
 		dest[i] = input[i] + 'A'
@@ -889,13 +89,13 @@ static inline void encode_base64(char dest[4], const uint8_t src[3])
 
 }
 
-EMSCRIPTEN_KEEPALIVE void key_to_base64(char base64[static 45], const uint8_t key[static 32])
+EMSCRIPTEN_KEEPALIVE void key_to_base64(char base64[static 45], const u8 key[static 32])
 {
 	unsigned int i;
 
 	for (i = 0; i < 32 / 3; ++i)
 		encode_base64(&base64[i * 4], &key[i * 3]);
-	encode_base64(&base64[i * 4], (const uint8_t[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
+	encode_base64(&base64[i * 4], (const u8[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
 	base64[45 - 2] = '=';
 	base64[45 - 1] = '\0';
 }

commit b0d41e8b106d9a36943e5473a8db78131b8c0b6a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jan 22 17:58:44 2018 +0100

    wg: share curve25519 implementations with kernel
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 7f6c9bf..061b913 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -14,1559 +14,45 @@
 #include <string.h>
 #include <endian.h>
 
+typedef uint64_t u64;
+typedef uint32_t u32;
+typedef uint8_t u8;
+typedef int64_t s64;
+typedef u64 __le64;
+typedef u32 __le32;
+#define le64_to_cpup(a) le64toh(*(a));
+#define le32_to_cpup(a) le32toh(*(a));
+#define cpu_to_le64(a) htole64(a);
 #ifndef __always_inline
 #define __always_inline __inline __attribute__((__always_inline__))
 #endif
-
+#ifndef noinline
+#define noinline __attribute__((noinline))
+#endif
 #ifndef __aligned
 #define __aligned(x) __attribute__((aligned(x)))
 #endif
+#ifndef __force
+#define __force
+#endif
 
-#ifdef __SIZEOF_INT128__
-typedef __uint128_t uint128_t;
-
-static __always_inline uint64_t uint64_t_eq_mask(uint64_t x, uint64_t y)
-{
-	x = ~(x ^ y);
-	x &= x << 32;
-	x &= x << 16;
-	x &= x << 8;
-	x &= x << 4;
-	x &= x << 2;
-	x &= x << 1;
-	return ((int64_t)x) >> 63;
-}
-
-static __always_inline uint64_t uint64_t_gte_mask(uint64_t x, uint64_t y)
-{
-	uint64_t low63 = ~((uint64_t)((int64_t)((int64_t)(x & 0x7fffffffffffffffLLU) - (int64_t)(y & 0x7fffffffffffffffLLU)) >> 63));
-	uint64_t high_bit = ~((uint64_t)((int64_t)((int64_t)(x & 0x8000000000000000LLU) - (int64_t)(y & 0x8000000000000000LLU)) >> 63));
-	return low63 & high_bit;
-}
-
-static __always_inline void modulo_carry_top(uint64_t *b)
-{
-	uint64_t b4 = b[4];
-	uint64_t b0 = b[0];
-	uint64_t b4_ = b4 & 0x7ffffffffffffLLU;
-	uint64_t b0_ = b0 + 19 * (b4 >> 51);
-	b[4] = b4_;
-	b[0] = b0_;
-}
-
-static __always_inline void fproduct_copy_from_wide_(uint64_t *output, uint128_t *input)
-{
-	{
-		uint128_t xi = input[0];
-		output[0] = ((uint64_t)(xi));
-	}
-	{
-		uint128_t xi = input[1];
-		output[1] = ((uint64_t)(xi));
-	}
-	{
-		uint128_t xi = input[2];
-		output[2] = ((uint64_t)(xi));
-	}
-	{
-		uint128_t xi = input[3];
-		output[3] = ((uint64_t)(xi));
-	}
-	{
-		uint128_t xi = input[4];
-		output[4] = ((uint64_t)(xi));
-	}
-}
-
-static __always_inline void fproduct_sum_scalar_multiplication_(uint128_t *output, uint64_t *input, uint64_t s)
-{
-	uint32_t i;
-	for (i = 0; i < 5; ++i) {
-		uint128_t xi = output[i];
-		uint64_t yi = input[i];
-		output[i] = ((xi) + (((uint128_t)(yi) * (s))));
-	}
-}
-
-static __always_inline void fproduct_carry_wide_(uint128_t *tmp)
-{
-	uint32_t i;
-	for (i = 0; i < 4; ++i) {
-		uint32_t ctr = i;
-		uint128_t tctr = tmp[ctr];
-		uint128_t tctrp1 = tmp[ctr + 1];
-		uint64_t r0 = ((uint64_t)(tctr)) & 0x7ffffffffffffLLU;
-		uint128_t c = ((tctr) >> (51));
-		tmp[ctr] = ((uint128_t)(r0));
-		tmp[ctr + 1] = ((tctrp1) + (c));
-	}
-}
-
-static __always_inline void fmul_shift_reduce(uint64_t *output)
-{
-	uint64_t tmp = output[4];
-	uint64_t b0;
-	{
-		uint32_t ctr = 5 - 0 - 1;
-		uint64_t z = output[ctr - 1];
-		output[ctr] = z;
-	}
-	{
-		uint32_t ctr = 5 - 1 - 1;
-		uint64_t z = output[ctr - 1];
-		output[ctr] = z;
-	}
-	{
-		uint32_t ctr = 5 - 2 - 1;
-		uint64_t z = output[ctr - 1];
-		output[ctr] = z;
-	}
-	{
-		uint32_t ctr = 5 - 3 - 1;
-		uint64_t z = output[ctr - 1];
-		output[ctr] = z;
-	}
-	output[0] = tmp;
-	b0 = output[0];
-	output[0] = 19 * b0;
-}
-
-static __always_inline void fmul_mul_shift_reduce_(uint128_t *output, uint64_t *input, uint64_t *input21)
-{
-	uint32_t i;
-	uint64_t input2i;
-	{
-		uint64_t input2i = input21[0];
-		fproduct_sum_scalar_multiplication_(output, input, input2i);
-		fmul_shift_reduce(input);
-	}
-	{
-		uint64_t input2i = input21[1];
-		fproduct_sum_scalar_multiplication_(output, input, input2i);
-		fmul_shift_reduce(input);
-	}
-	{
-		uint64_t input2i = input21[2];
-		fproduct_sum_scalar_multiplication_(output, input, input2i);
-		fmul_shift_reduce(input);
-	}
-	{
-		uint64_t input2i = input21[3];
-		fproduct_sum_scalar_multiplication_(output, input, input2i);
-		fmul_shift_reduce(input);
-	}
-	i = 4;
-	input2i = input21[i];
-	fproduct_sum_scalar_multiplication_(output, input, input2i);
-}
-
-static __always_inline void fmul_fmul(uint64_t *output, uint64_t *input, uint64_t *input21)
-{
-	uint64_t tmp[5];
-	memcpy(tmp, input, 5 * sizeof(*input));
-	{
-		uint128_t b4;
-		uint128_t b0;
-		uint128_t b4_;
-		uint128_t b0_;
-		uint64_t i0;
-		uint64_t i1;
-		uint64_t i0_;
-		uint64_t i1_;
-		uint128_t t[5];
-		{
-			uint32_t _i;
-			for (_i = 0; _i < 5; ++_i)
-				t[_i] = ((uint128_t)(0));
-		}
-		fmul_mul_shift_reduce_(t, tmp, input21);
-		fproduct_carry_wide_(t);
-		b4 = t[4];
-		b0 = t[0];
-		b4_ = ((b4) & (((uint128_t)(0x7ffffffffffffLLU))));
-		b0_ = ((b0) + (((uint128_t)(19) * (((uint64_t)(((b4) >> (51))))))));
-		t[4] = b4_;
-		t[0] = b0_;
-		fproduct_copy_from_wide_(output, t);
-		i0 = output[0];
-		i1 = output[1];
-		i0_ = i0 & 0x7ffffffffffffLLU;
-		i1_ = i1 + (i0 >> 51);
-		output[0] = i0_;
-		output[1] = i1_;
-	}
-}
-
-static __always_inline void fsquare_fsquare__(uint128_t *tmp, uint64_t *output)
-{
-	uint64_t r0 = output[0];
-	uint64_t r1 = output[1];
-	uint64_t r2 = output[2];
-	uint64_t r3 = output[3];
-	uint64_t r4 = output[4];
-	uint64_t d0 = r0 * 2;
-	uint64_t d1 = r1 * 2;
-	uint64_t d2 = r2 * 2 * 19;
-	uint64_t d419 = r4 * 19;
-	uint64_t d4 = d419 * 2;
-	uint128_t s0 = ((((((uint128_t)(r0) * (r0))) + (((uint128_t)(d4) * (r1))))) + (((uint128_t)(d2) * (r3))));
-	uint128_t s1 = ((((((uint128_t)(d0) * (r1))) + (((uint128_t)(d4) * (r2))))) + (((uint128_t)(r3 * 19) * (r3))));
-	uint128_t s2 = ((((((uint128_t)(d0) * (r2))) + (((uint128_t)(r1) * (r1))))) + (((uint128_t)(d4) * (r3))));
-	uint128_t s3 = ((((((uint128_t)(d0) * (r3))) + (((uint128_t)(d1) * (r2))))) + (((uint128_t)(r4) * (d419))));
-	uint128_t s4 = ((((((uint128_t)(d0) * (r4))) + (((uint128_t)(d1) * (r3))))) + (((uint128_t)(r2) * (r2))));
-	tmp[0] = s0;
-	tmp[1] = s1;
-	tmp[2] = s2;
-	tmp[3] = s3;
-	tmp[4] = s4;
-}
-
-static __always_inline void fsquare_fsquare_(uint128_t *tmp, uint64_t *output)
-{
-	uint128_t b4;
-	uint128_t b0;
-	uint128_t b4_;
-	uint128_t b0_;
-	uint64_t i0;
-	uint64_t i1;
-	uint64_t i0_;
-	uint64_t i1_;
-	fsquare_fsquare__(tmp, output);
-	fproduct_carry_wide_(tmp);
-	b4 = tmp[4];
-	b0 = tmp[0];
-	b4_ = ((b4) & (((uint128_t)(0x7ffffffffffffLLU))));
-	b0_ = ((b0) + (((uint128_t)(19) * (((uint64_t)(((b4) >> (51))))))));
-	tmp[4] = b4_;
-	tmp[0] = b0_;
-	fproduct_copy_from_wide_(output, tmp);
-	i0 = output[0];
-	i1 = output[1];
-	i0_ = i0 & 0x7ffffffffffffLLU;
-	i1_ = i1 + (i0 >> 51);
-	output[0] = i0_;
-	output[1] = i1_;
-}
-
-static __always_inline void fsquare_fsquare_times_(uint64_t *input, uint128_t *tmp, uint32_t count1)
-{
-	uint32_t i;
-	fsquare_fsquare_(tmp, input);
-	for (i = 1; i < count1; ++i)
-		fsquare_fsquare_(tmp, input);
-}
-
-static __always_inline void fsquare_fsquare_times(uint64_t *output, uint64_t *input, uint32_t count1)
-{
-	uint128_t t[5];
-	{
-		uint32_t _i;
-		for (_i = 0; _i < 5; ++_i)
-			t[_i] = ((uint128_t)(0));
-	}
-	memcpy(output, input, 5 * sizeof(*input));
-	fsquare_fsquare_times_(output, t, count1);
-}
-
-static __always_inline void fsquare_fsquare_times_inplace(uint64_t *output, uint32_t count1)
-{
-	uint128_t t[5];
-	{
-		uint32_t _i;
-		for (_i = 0; _i < 5; ++_i)
-			t[_i] = ((uint128_t)(0));
-	}
-	fsquare_fsquare_times_(output, t, count1);
-}
-
-static __always_inline void crecip_crecip(uint64_t *out, uint64_t *z)
-{
-	uint64_t buf[20] = { 0 };
-	uint64_t *a0 = buf;
-	uint64_t *t00 = buf + 5;
-	uint64_t *b0 = buf + 10;
-	uint64_t *t01;
-	uint64_t *b1;
-	uint64_t *c0;
-	uint64_t *a;
-	uint64_t *t0;
-	uint64_t *b;
-	uint64_t *c;
-	fsquare_fsquare_times(a0, z, 1);
-	fsquare_fsquare_times(t00, a0, 2);
-	fmul_fmul(b0, t00, z);
-	fmul_fmul(a0, b0, a0);
-	fsquare_fsquare_times(t00, a0, 1);
-	fmul_fmul(b0, t00, b0);
-	fsquare_fsquare_times(t00, b0, 5);
-	t01 = buf + 5;
-	b1 = buf + 10;
-	c0 = buf + 15;
-	fmul_fmul(b1, t01, b1);
-	fsquare_fsquare_times(t01, b1, 10);
-	fmul_fmul(c0, t01, b1);
-	fsquare_fsquare_times(t01, c0, 20);
-	fmul_fmul(t01, t01, c0);
-	fsquare_fsquare_times_inplace(t01, 10);
-	fmul_fmul(b1, t01, b1);
-	fsquare_fsquare_times(t01, b1, 50);
-	a = buf;
-	t0 = buf + 5;
-	b = buf + 10;
-	c = buf + 15;
-	fmul_fmul(c, t0, b);
-	fsquare_fsquare_times(t0, c, 100);
-	fmul_fmul(t0, t0, c);
-	fsquare_fsquare_times_inplace(t0, 50);
-	fmul_fmul(t0, t0, b);
-	fsquare_fsquare_times_inplace(t0, 5);
-	fmul_fmul(out, t0, a);
-}
-
-static __always_inline void fsum(uint64_t *a, uint64_t *b)
-{
-	uint32_t i;
-	for (i = 0; i < 5; ++i) {
-		uint64_t xi = a[i];
-		uint64_t yi = b[i];
-		a[i] = xi + yi;
-	}
-}
-
-static __always_inline void fdifference(uint64_t *a, uint64_t *b)
-{
-	uint64_t tmp[5] = { 0 };
-	uint64_t b0;
-	uint64_t b1;
-	uint64_t b2;
-	uint64_t b3;
-	uint64_t b4;
-	memcpy(tmp, b, 5 * sizeof(*b));
-	b0 = tmp[0];
-	b1 = tmp[1];
-	b2 = tmp[2];
-	b3 = tmp[3];
-	b4 = tmp[4];
-	tmp[0] = b0 + 0x3fffffffffff68LLU;
-	tmp[1] = b1 + 0x3ffffffffffff8LLU;
-	tmp[2] = b2 + 0x3ffffffffffff8LLU;
-	tmp[3] = b3 + 0x3ffffffffffff8LLU;
-	tmp[4] = b4 + 0x3ffffffffffff8LLU;
-	{
-		uint64_t xi = a[0];
-		uint64_t yi = tmp[0];
-		a[0] = yi - xi;
-	}
-	{
-		uint64_t xi = a[1];
-		uint64_t yi = tmp[1];
-		a[1] = yi - xi;
-	}
-	{
-		uint64_t xi = a[2];
-		uint64_t yi = tmp[2];
-		a[2] = yi - xi;
-	}
-	{
-		uint64_t xi = a[3];
-		uint64_t yi = tmp[3];
-		a[3] = yi - xi;
-	}
-	{
-		uint64_t xi = a[4];
-		uint64_t yi = tmp[4];
-		a[4] = yi - xi;
-	}
-}
-
-static __always_inline void fscalar(uint64_t *output, uint64_t *b, uint64_t s)
-{
-	uint128_t tmp[5];
-	uint128_t b4;
-	uint128_t b0;
-	uint128_t b4_;
-	uint128_t b0_;
-	{
-		uint64_t xi = b[0];
-		tmp[0] = ((uint128_t)(xi) * (s));
-	}
-	{
-		uint64_t xi = b[1];
-		tmp[1] = ((uint128_t)(xi) * (s));
-	}
-	{
-		uint64_t xi = b[2];
-		tmp[2] = ((uint128_t)(xi) * (s));
-	}
-	{
-		uint64_t xi = b[3];
-		tmp[3] = ((uint128_t)(xi) * (s));
-	}
-	{
-		uint64_t xi = b[4];
-		tmp[4] = ((uint128_t)(xi) * (s));
-	}
-	fproduct_carry_wide_(tmp);
-	b4 = tmp[4];
-	b0 = tmp[0];
-	b4_ = ((b4) & (((uint128_t)(0x7ffffffffffffLLU))));
-	b0_ = ((b0) + (((uint128_t)(19) * (((uint64_t)(((b4) >> (51))))))));
-	tmp[4] = b4_;
-	tmp[0] = b0_;
-	fproduct_copy_from_wide_(output, tmp);
-}
-
-static __always_inline void fmul(uint64_t *output, uint64_t *a, uint64_t *b)
-{
-	fmul_fmul(output, a, b);
-}
-
-static __always_inline void crecip(uint64_t *output, uint64_t *input)
-{
-	crecip_crecip(output, input);
-}
-
-static __always_inline void point_swap_conditional_step(uint64_t *a, uint64_t *b, uint64_t swap1, uint32_t ctr)
-{
-	uint32_t i = ctr - 1;
-	uint64_t ai = a[i];
-	uint64_t bi = b[i];
-	uint64_t x = swap1 & (ai ^ bi);
-	uint64_t ai1 = ai ^ x;
-	uint64_t bi1 = bi ^ x;
-	a[i] = ai1;
-	b[i] = bi1;
-}
-
-static __always_inline void point_swap_conditional_(uint64_t *a, uint64_t *b, uint64_t swap1, uint32_t ctr)
-{
-	uint32_t i;
-	for (i = ctr; i > 0; --i)
-		point_swap_conditional_step(a, b, swap1, i);
-}
-
-static __always_inline void point_swap_conditional(uint64_t *a, uint64_t *b, uint64_t iswap)
-{
-	uint64_t swap1 = 0 - iswap;
-	point_swap_conditional_(a, b, swap1, 5);
-	point_swap_conditional_(a + 5, b + 5, swap1, 5);
-}
-
-static __always_inline void point_copy(uint64_t *output, uint64_t *input)
-{
-	memcpy(output, input, 5 * sizeof(*input));
-	memcpy(output + 5, input + 5, 5 * sizeof(*input));
-}
-
-static __always_inline void addanddouble_fmonty(uint64_t *pp, uint64_t *ppq, uint64_t *p, uint64_t *pq, uint64_t *qmqp)
-{
-	uint64_t *qx = qmqp;
-	uint64_t *x2 = pp;
-	uint64_t *z2 = pp + 5;
-	uint64_t *x3 = ppq;
-	uint64_t *z3 = ppq + 5;
-	uint64_t *x = p;
-	uint64_t *z = p + 5;
-	uint64_t *xprime = pq;
-	uint64_t *zprime = pq + 5;
-	uint64_t buf[40] = { 0 };
-	uint64_t *origx = buf;
-	uint64_t *origxprime0 = buf + 5;
-	uint64_t *xxprime0;
-	uint64_t *zzprime0;
-	uint64_t *origxprime;
-	xxprime0 = buf + 25;
-	zzprime0 = buf + 30;
-	memcpy(origx, x, 5 * sizeof(*x));
-	fsum(x, z);
-	fdifference(z, origx);
-	memcpy(origxprime0, xprime, 5 * sizeof(*xprime));
-	fsum(xprime, zprime);
-	fdifference(zprime, origxprime0);
-	fmul(xxprime0, xprime, z);
-	fmul(zzprime0, x, zprime);
-	origxprime = buf + 5;
-	{
-		uint64_t *xx0;
-		uint64_t *zz0;
-		uint64_t *xxprime;
-		uint64_t *zzprime;
-		uint64_t *zzzprime;
-		xx0 = buf + 15;
-		zz0 = buf + 20;
-		xxprime = buf + 25;
-		zzprime = buf + 30;
-		zzzprime = buf + 35;
-		memcpy(origxprime, xxprime, 5 * sizeof(*xxprime));
-		fsum(xxprime, zzprime);
-		fdifference(zzprime, origxprime);
-		fsquare_fsquare_times(x3, xxprime, 1);
-		fsquare_fsquare_times(zzzprime, zzprime, 1);
-		fmul(z3, zzzprime, qx);
-		fsquare_fsquare_times(xx0, x, 1);
-		fsquare_fsquare_times(zz0, z, 1);
-		{
-			uint64_t *zzz;
-			uint64_t *xx;
-			uint64_t *zz;
-			uint64_t scalar;
-			zzz = buf + 10;
-			xx = buf + 15;
-			zz = buf + 20;
-			fmul(x2, xx, zz);
-			fdifference(zz, xx);
-			scalar = 121665;
-			fscalar(zzz, zz, scalar);
-			fsum(zzz, xx);
-			fmul(z2, zzz, zz);
-		}
-	}
-}
-
-static __always_inline void ladder_smallloop_cmult_small_loop_step(uint64_t *nq, uint64_t *nqpq, uint64_t *nq2, uint64_t *nqpq2, uint64_t *q, uint8_t byt)
-{
-	uint64_t bit0 = (uint64_t)(byt >> 7);
-	uint64_t bit;
-	point_swap_conditional(nq, nqpq, bit0);
-	addanddouble_fmonty(nq2, nqpq2, nq, nqpq, q);
-	bit = (uint64_t)(byt >> 7);
-	point_swap_conditional(nq2, nqpq2, bit);
-}
-
-static __always_inline void ladder_smallloop_cmult_small_loop_double_step(uint64_t *nq, uint64_t *nqpq, uint64_t *nq2, uint64_t *nqpq2, uint64_t *q, uint8_t byt)
-{
-	uint8_t byt1;
-	ladder_smallloop_cmult_small_loop_step(nq, nqpq, nq2, nqpq2, q, byt);
-	byt1 = byt << 1;
-	ladder_smallloop_cmult_small_loop_step(nq2, nqpq2, nq, nqpq, q, byt1);
-}
-
-static __always_inline void ladder_smallloop_cmult_small_loop(uint64_t *nq, uint64_t *nqpq, uint64_t *nq2, uint64_t *nqpq2, uint64_t *q, uint8_t byt, uint32_t i)
-{
-	while (i--) {
-		ladder_smallloop_cmult_small_loop_double_step(nq, nqpq, nq2, nqpq2, q, byt);
-		byt <<= 2;
-	}
-}
-
-static __always_inline void ladder_bigloop_cmult_big_loop(uint8_t *n1, uint64_t *nq, uint64_t *nqpq, uint64_t *nq2, uint64_t *nqpq2, uint64_t *q, uint32_t i)
-{
-	while (i--) {
-		uint8_t byte = n1[i];
-		ladder_smallloop_cmult_small_loop(nq, nqpq, nq2, nqpq2, q, byte, 4);
-	}
-}
-
-static __always_inline void ladder_cmult(uint64_t *result, uint8_t *n1, uint64_t *q)
-{
-	uint64_t point_buf[40] = { 0 };
-	uint64_t *nq = point_buf;
-	uint64_t *nqpq = point_buf + 10;
-	uint64_t *nq2 = point_buf + 20;
-	uint64_t *nqpq2 = point_buf + 30;
-	point_copy(nqpq, q);
-	nq[0] = 1;
-	ladder_bigloop_cmult_big_loop(n1, nq, nqpq, nq2, nqpq2, q, 32);
-	point_copy(result, nq);
-}
-
-static __always_inline void format_fexpand(uint64_t *output, const uint8_t *input)
-{
-	const uint8_t *x00 = input + 6;
-	const uint8_t *x01 = input + 12;
-	const uint8_t *x02 = input + 19;
-	const uint8_t *x0 = input + 24;
-	uint64_t i0, i1, i2, i3, i4, output0, output1, output2, output3, output4;
-	i0 = le64toh(*(uint64_t *)input);
-	i1 = le64toh(*(uint64_t *)x00);
-	i2 = le64toh(*(uint64_t *)x01);
-	i3 = le64toh(*(uint64_t *)x02);
-	i4 = le64toh(*(uint64_t *)x0);
-	output0 = i0 & 0x7ffffffffffffLLU;
-	output1 = i1 >> 3 & 0x7ffffffffffffLLU;
-	output2 = i2 >> 6 & 0x7ffffffffffffLLU;
-	output3 = i3 >> 1 & 0x7ffffffffffffLLU;
-	output4 = i4 >> 12 & 0x7ffffffffffffLLU;
-	output[0] = output0;
-	output[1] = output1;
-	output[2] = output2;
-	output[3] = output3;
-	output[4] = output4;
-}
-
-static __always_inline void format_fcontract_first_carry_pass(uint64_t *input)
-{
-	uint64_t t0 = input[0];
-	uint64_t t1 = input[1];
-	uint64_t t2 = input[2];
-	uint64_t t3 = input[3];
-	uint64_t t4 = input[4];
-	uint64_t t1_ = t1 + (t0 >> 51);
-	uint64_t t0_ = t0 & 0x7ffffffffffffLLU;
-	uint64_t t2_ = t2 + (t1_ >> 51);
-	uint64_t t1__ = t1_ & 0x7ffffffffffffLLU;
-	uint64_t t3_ = t3 + (t2_ >> 51);
-	uint64_t t2__ = t2_ & 0x7ffffffffffffLLU;
-	uint64_t t4_ = t4 + (t3_ >> 51);
-	uint64_t t3__ = t3_ & 0x7ffffffffffffLLU;
-	input[0] = t0_;
-	input[1] = t1__;
-	input[2] = t2__;
-	input[3] = t3__;
-	input[4] = t4_;
-}
-
-static __always_inline void format_fcontract_first_carry_full(uint64_t *input)
-{
-	format_fcontract_first_carry_pass(input);
-	modulo_carry_top(input);
-}
-
-static __always_inline void format_fcontract_second_carry_pass(uint64_t *input)
-{
-	uint64_t t0 = input[0];
-	uint64_t t1 = input[1];
-	uint64_t t2 = input[2];
-	uint64_t t3 = input[3];
-	uint64_t t4 = input[4];
-	uint64_t t1_ = t1 + (t0 >> 51);
-	uint64_t t0_ = t0 & 0x7ffffffffffffLLU;
-	uint64_t t2_ = t2 + (t1_ >> 51);
-	uint64_t t1__ = t1_ & 0x7ffffffffffffLLU;
-	uint64_t t3_ = t3 + (t2_ >> 51);
-	uint64_t t2__ = t2_ & 0x7ffffffffffffLLU;
-	uint64_t t4_ = t4 + (t3_ >> 51);
-	uint64_t t3__ = t3_ & 0x7ffffffffffffLLU;
-	input[0] = t0_;
-	input[1] = t1__;
-	input[2] = t2__;
-	input[3] = t3__;
-	input[4] = t4_;
-}
-
-static __always_inline void format_fcontract_second_carry_full(uint64_t *input)
-{
-	uint64_t i0;
-	uint64_t i1;
-	uint64_t i0_;
-	uint64_t i1_;
-	format_fcontract_second_carry_pass(input);
-	modulo_carry_top(input);
-	i0 = input[0];
-	i1 = input[1];
-	i0_ = i0 & 0x7ffffffffffffLLU;
-	i1_ = i1 + (i0 >> 51);
-	input[0] = i0_;
-	input[1] = i1_;
-}
-
-static __always_inline void format_fcontract_trim(uint64_t *input)
-{
-	uint64_t a0 = input[0];
-	uint64_t a1 = input[1];
-	uint64_t a2 = input[2];
-	uint64_t a3 = input[3];
-	uint64_t a4 = input[4];
-	uint64_t mask0 = uint64_t_gte_mask(a0, 0x7ffffffffffedLLU);
-	uint64_t mask1 = uint64_t_eq_mask(a1, 0x7ffffffffffffLLU);
-	uint64_t mask2 = uint64_t_eq_mask(a2, 0x7ffffffffffffLLU);
-	uint64_t mask3 = uint64_t_eq_mask(a3, 0x7ffffffffffffLLU);
-	uint64_t mask4 = uint64_t_eq_mask(a4, 0x7ffffffffffffLLU);
-	uint64_t mask = (((mask0 & mask1) & mask2) & mask3) & mask4;
-	uint64_t a0_ = a0 - (0x7ffffffffffedLLU & mask);
-	uint64_t a1_ = a1 - (0x7ffffffffffffLLU & mask);
-	uint64_t a2_ = a2 - (0x7ffffffffffffLLU & mask);
-	uint64_t a3_ = a3 - (0x7ffffffffffffLLU & mask);
-	uint64_t a4_ = a4 - (0x7ffffffffffffLLU & mask);
-	input[0] = a0_;
-	input[1] = a1_;
-	input[2] = a2_;
-	input[3] = a3_;
-	input[4] = a4_;
-}
-
-static __always_inline void format_fcontract_store(uint8_t *output, uint64_t *input)
-{
-	uint64_t t0 = input[0];
-	uint64_t t1 = input[1];
-	uint64_t t2 = input[2];
-	uint64_t t3 = input[3];
-	uint64_t t4 = input[4];
-	uint64_t o0 = t1 << 51 | t0;
-	uint64_t o1 = t2 << 38 | t1 >> 13;
-	uint64_t o2 = t3 << 25 | t2 >> 26;
-	uint64_t o3 = t4 << 12 | t3 >> 39;
-	uint8_t *b0 = output;
-	uint8_t *b1 = output + 8;
-	uint8_t *b2 = output + 16;
-	uint8_t *b3 = output + 24;
-	*(uint64_t *)b0 = htole64(o0);
-	*(uint64_t *)b1 = htole64(o1);
-	*(uint64_t *)b2 = htole64(o2);
-	*(uint64_t *)b3 = htole64(o3);
-}
-
-static __always_inline void format_fcontract(uint8_t *output, uint64_t *input)
+static noinline void memzero_explicit(void *s, size_t count)
 {
-	format_fcontract_first_carry_full(input);
-	format_fcontract_second_carry_full(input);
-	format_fcontract_trim(input);
-	format_fcontract_store(output, input);
+	memset(s, 0, count);
+	__asm__ __volatile__("": :"r"(s) :"memory");
 }
 
-static __always_inline void format_scalar_of_point(uint8_t *scalar, uint64_t *point)
+static __always_inline void normalize_secret(u8 secret[CURVE25519_POINT_SIZE])
 {
-	uint64_t *x = point;
-	uint64_t *z = point + 5;
-	uint64_t buf[10] __aligned(32) = { 0 };
-	uint64_t *zmone = buf;
-	uint64_t *sc = buf + 5;
-	crecip(zmone, z);
-	fmul(sc, x, zmone);
-	format_fcontract(scalar, sc);
+	secret[0] &= 248;
+	secret[31] &= 127;
+	secret[31] |= 64;
 }
 
-void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE])
-{
-	uint64_t buf0[10] __aligned(32) = { 0 };
-	uint64_t *x0 = buf0;
-	uint64_t *z = buf0 + 5;
-	uint64_t *q;
-	format_fexpand(x0, basepoint);
-	z[0] = 1;
-	q = buf0;
-	{
-		uint8_t e[32] __aligned(32) = { 0 };
-		uint8_t *scalar;
-		memcpy(e, secret, 32);
-		curve25519_normalize_secret(e);
-		scalar = e;
-		{
-			uint64_t buf[15] = { 0 };
-			uint64_t *nq = buf;
-			uint64_t *x = nq;
-			x[0] = 1;
-			ladder_cmult(nq, scalar, q);
-			format_scalar_of_point(mypublic, nq);
-		}
-	}
-}
+#ifdef __SIZEOF_INT128__
+#include "../crypto/curve25519-hacl64.h"
 #else
-/* fe means field element. Here the field is \Z/(2^255-19). An element t,
- * entries t[0]...t[9], represents the integer t[0]+2^26 t[1]+2^51 t[2]+2^77
- * t[3]+2^102 t[4]+...+2^230 t[9].
- * fe limbs are bounded by 1.125*2^26,1.125*2^25,1.125*2^26,1.125*2^25,etc.
- * Multiplication and carrying produce fe from fe_loose.
- */
-typedef struct fe { uint32_t v[10]; } fe;
-
-/* fe_loose limbs are bounded by 3.375*2^26,3.375*2^25,3.375*2^26,3.375*2^25,etc.
- * Addition and subtraction produce fe_loose from (fe, fe).
- */
-typedef struct fe_loose { uint32_t v[10]; } fe_loose;
-
-static __always_inline void fe_frombytes_impl(uint32_t h[10], const uint8_t *s)
-{
-	/* Ignores top bit of s. */
-	uint32_t a0 = le32toh(*(uint32_t *)(s));
-	uint32_t a1 = le32toh(*(uint32_t *)(s+4));
-	uint32_t a2 = le32toh(*(uint32_t *)(s+8));
-	uint32_t a3 = le32toh(*(uint32_t *)(s+12));
-	uint32_t a4 = le32toh(*(uint32_t *)(s+16));
-	uint32_t a5 = le32toh(*(uint32_t *)(s+20));
-	uint32_t a6 = le32toh(*(uint32_t *)(s+24));
-	uint32_t a7 = le32toh(*(uint32_t *)(s+28));
-	h[0] = a0&((1<<26)-1);                    /* 26 used, 32-26 left.   26 */
-	h[1] = (a0>>26) | ((a1&((1<<19)-1))<< 6); /* (32-26) + 19 =  6+19 = 25 */
-	h[2] = (a1>>19) | ((a2&((1<<13)-1))<<13); /* (32-19) + 13 = 13+13 = 26 */
-	h[3] = (a2>>13) | ((a3&((1<< 6)-1))<<19); /* (32-13) +  6 = 19+ 6 = 25 */
-	h[4] = (a3>> 6);                          /* (32- 6)              = 26 */
-	h[5] = a4&((1<<25)-1);                    /*                        25 */
-	h[6] = (a4>>25) | ((a5&((1<<19)-1))<< 7); /* (32-25) + 19 =  7+19 = 26 */
-	h[7] = (a5>>19) | ((a6&((1<<12)-1))<<13); /* (32-19) + 12 = 13+12 = 25 */
-	h[8] = (a6>>12) | ((a7&((1<< 6)-1))<<20); /* (32-12) +  6 = 20+ 6 = 26 */
-	h[9] = (a7>> 6)&((1<<25)-1); /*                                     25 */
-}
-
-static __always_inline void fe_frombytes(fe *h, const uint8_t *s)
-{
-	fe_frombytes_impl(h->v, s);
-}
-
-static __always_inline uint8_t /*bool*/ addcarryx_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
-{
-	/* This function extracts 25 bits of result and 1 bit of carry (26 total), so
-	 * a 32-bit intermediate is sufficient.
-	 */
-	uint32_t x = a + b + c;
-	*low = x & ((1 << 25) - 1);
-	return (x >> 25) & 1;
-}
-
-static __always_inline uint8_t /*bool*/ addcarryx_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
-{
-	/* This function extracts 26 bits of result and 1 bit of carry (27 total), so
-	 * a 32-bit intermediate is sufficient.
-	 */
-	uint32_t x = a + b + c;
-	*low = x & ((1 << 26) - 1);
-	return (x >> 26) & 1;
-}
-
-static __always_inline uint8_t /*bool*/ subborrow_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
-{
-	/* This function extracts 25 bits of result and 1 bit of borrow (26 total), so
-	 * a 32-bit intermediate is sufficient.
-	 */
-	uint32_t x = a - b - c;
-	*low = x & ((1 << 25) - 1);
-	return x >> 31;
-}
-
-static __always_inline uint8_t /*bool*/ subborrow_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
-{
-	/* This function extracts 26 bits of result and 1 bit of borrow (27 total), so
-	 * a 32-bit intermediate is sufficient.
-	 */
-	uint32_t x = a - b - c;
-	*low = x & ((1 << 26) - 1);
-	return x >> 31;
-}
-
-static __always_inline uint32_t cmovznz32(uint32_t t, uint32_t z, uint32_t nz)
-{
-	t = -!!t; /* all set if nonzero, 0 if 0 */
-	return (t&nz) | ((~t)&z);
-}
-
-static __always_inline void fe_freeze(uint32_t out[10], const uint32_t in1[10])
-{
-	{ const uint32_t x17 = in1[9];
-	{ const uint32_t x18 = in1[8];
-	{ const uint32_t x16 = in1[7];
-	{ const uint32_t x14 = in1[6];
-	{ const uint32_t x12 = in1[5];
-	{ const uint32_t x10 = in1[4];
-	{ const uint32_t x8 = in1[3];
-	{ const uint32_t x6 = in1[2];
-	{ const uint32_t x4 = in1[1];
-	{ const uint32_t x2 = in1[0];
-	{ uint32_t x20; uint8_t/*bool*/ x21 = subborrow_u26(0x0, x2, 0x3ffffed, &x20);
-	{ uint32_t x23; uint8_t/*bool*/ x24 = subborrow_u25(x21, x4, 0x1ffffff, &x23);
-	{ uint32_t x26; uint8_t/*bool*/ x27 = subborrow_u26(x24, x6, 0x3ffffff, &x26);
-	{ uint32_t x29; uint8_t/*bool*/ x30 = subborrow_u25(x27, x8, 0x1ffffff, &x29);
-	{ uint32_t x32; uint8_t/*bool*/ x33 = subborrow_u26(x30, x10, 0x3ffffff, &x32);
-	{ uint32_t x35; uint8_t/*bool*/ x36 = subborrow_u25(x33, x12, 0x1ffffff, &x35);
-	{ uint32_t x38; uint8_t/*bool*/ x39 = subborrow_u26(x36, x14, 0x3ffffff, &x38);
-	{ uint32_t x41; uint8_t/*bool*/ x42 = subborrow_u25(x39, x16, 0x1ffffff, &x41);
-	{ uint32_t x44; uint8_t/*bool*/ x45 = subborrow_u26(x42, x18, 0x3ffffff, &x44);
-	{ uint32_t x47; uint8_t/*bool*/ x48 = subborrow_u25(x45, x17, 0x1ffffff, &x47);
-	{ uint32_t x49 = cmovznz32(x48, 0x0, 0xffffffff);
-	{ uint32_t x50 = (x49 & 0x3ffffed);
-	{ uint32_t x52; uint8_t/*bool*/ x53 = addcarryx_u26(0x0, x20, x50, &x52);
-	{ uint32_t x54 = (x49 & 0x1ffffff);
-	{ uint32_t x56; uint8_t/*bool*/ x57 = addcarryx_u25(x53, x23, x54, &x56);
-	{ uint32_t x58 = (x49 & 0x3ffffff);
-	{ uint32_t x60; uint8_t/*bool*/ x61 = addcarryx_u26(x57, x26, x58, &x60);
-	{ uint32_t x62 = (x49 & 0x1ffffff);
-	{ uint32_t x64; uint8_t/*bool*/ x65 = addcarryx_u25(x61, x29, x62, &x64);
-	{ uint32_t x66 = (x49 & 0x3ffffff);
-	{ uint32_t x68; uint8_t/*bool*/ x69 = addcarryx_u26(x65, x32, x66, &x68);
-	{ uint32_t x70 = (x49 & 0x1ffffff);
-	{ uint32_t x72; uint8_t/*bool*/ x73 = addcarryx_u25(x69, x35, x70, &x72);
-	{ uint32_t x74 = (x49 & 0x3ffffff);
-	{ uint32_t x76; uint8_t/*bool*/ x77 = addcarryx_u26(x73, x38, x74, &x76);
-	{ uint32_t x78 = (x49 & 0x1ffffff);
-	{ uint32_t x80; uint8_t/*bool*/ x81 = addcarryx_u25(x77, x41, x78, &x80);
-	{ uint32_t x82 = (x49 & 0x3ffffff);
-	{ uint32_t x84; uint8_t/*bool*/ x85 = addcarryx_u26(x81, x44, x82, &x84);
-	{ uint32_t x86 = (x49 & 0x1ffffff);
-	{ uint32_t x88; addcarryx_u25(x85, x47, x86, &x88);
-	out[0] = x52;
-	out[1] = x56;
-	out[2] = x60;
-	out[3] = x64;
-	out[4] = x68;
-	out[5] = x72;
-	out[6] = x76;
-	out[7] = x80;
-	out[8] = x84;
-	out[9] = x88;
-	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
-}
-
-static __always_inline void fe_tobytes(uint8_t s[32], const fe *f)
-{
-	uint32_t h[10];
-	fe_freeze(h, f->v);
-	s[0] = h[0] >> 0;
-	s[1] = h[0] >> 8;
-	s[2] = h[0] >> 16;
-	s[3] = (h[0] >> 24) | (h[1] << 2);
-	s[4] = h[1] >> 6;
-	s[5] = h[1] >> 14;
-	s[6] = (h[1] >> 22) | (h[2] << 3);
-	s[7] = h[2] >> 5;
-	s[8] = h[2] >> 13;
-	s[9] = (h[2] >> 21) | (h[3] << 5);
-	s[10] = h[3] >> 3;
-	s[11] = h[3] >> 11;
-	s[12] = (h[3] >> 19) | (h[4] << 6);
-	s[13] = h[4] >> 2;
-	s[14] = h[4] >> 10;
-	s[15] = h[4] >> 18;
-	s[16] = h[5] >> 0;
-	s[17] = h[5] >> 8;
-	s[18] = h[5] >> 16;
-	s[19] = (h[5] >> 24) | (h[6] << 1);
-	s[20] = h[6] >> 7;
-	s[21] = h[6] >> 15;
-	s[22] = (h[6] >> 23) | (h[7] << 3);
-	s[23] = h[7] >> 5;
-	s[24] = h[7] >> 13;
-	s[25] = (h[7] >> 21) | (h[8] << 4);
-	s[26] = h[8] >> 4;
-	s[27] = h[8] >> 12;
-	s[28] = (h[8] >> 20) | (h[9] << 6);
-	s[29] = h[9] >> 2;
-	s[30] = h[9] >> 10;
-	s[31] = h[9] >> 18;
-}
-
-/* h = f */
-static __always_inline void fe_copy(fe *h, const fe *f)
-{
-	memmove(h, f, sizeof(uint32_t) * 10);
-}
-
-static __always_inline void fe_copy_lt(fe_loose *h, const fe *f)
-{
-	memmove(h, f, sizeof(uint32_t) * 10);
-}
-
-/* h = 0 */
-static __always_inline void fe_0(fe *h)
-{
-	memset(h, 0, sizeof(uint32_t) * 10);
-}
-
-/* h = 1 */
-static __always_inline void fe_1(fe *h)
-{
-	memset(h, 0, sizeof(uint32_t) * 10);
-	h->v[0] = 1;
-}
-
-static void fe_add_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
-{
-	{ const uint32_t x20 = in1[9];
-	{ const uint32_t x21 = in1[8];
-	{ const uint32_t x19 = in1[7];
-	{ const uint32_t x17 = in1[6];
-	{ const uint32_t x15 = in1[5];
-	{ const uint32_t x13 = in1[4];
-	{ const uint32_t x11 = in1[3];
-	{ const uint32_t x9 = in1[2];
-	{ const uint32_t x7 = in1[1];
-	{ const uint32_t x5 = in1[0];
-	{ const uint32_t x38 = in2[9];
-	{ const uint32_t x39 = in2[8];
-	{ const uint32_t x37 = in2[7];
-	{ const uint32_t x35 = in2[6];
-	{ const uint32_t x33 = in2[5];
-	{ const uint32_t x31 = in2[4];
-	{ const uint32_t x29 = in2[3];
-	{ const uint32_t x27 = in2[2];
-	{ const uint32_t x25 = in2[1];
-	{ const uint32_t x23 = in2[0];
-	out[0] = (x5 + x23);
-	out[1] = (x7 + x25);
-	out[2] = (x9 + x27);
-	out[3] = (x11 + x29);
-	out[4] = (x13 + x31);
-	out[5] = (x15 + x33);
-	out[6] = (x17 + x35);
-	out[7] = (x19 + x37);
-	out[8] = (x21 + x39);
-	out[9] = (x20 + x38);
-	}}}}}}}}}}}}}}}}}}}}
-}
-
-/* h = f + g
- * Can overlap h with f or g.
- */
-static __always_inline void fe_add(fe_loose *h, const fe *f, const fe *g)
-{
-	fe_add_impl(h->v, f->v, g->v);
-}
-
-static void fe_sub_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
-{
-	{ const uint32_t x20 = in1[9];
-	{ const uint32_t x21 = in1[8];
-	{ const uint32_t x19 = in1[7];
-	{ const uint32_t x17 = in1[6];
-	{ const uint32_t x15 = in1[5];
-	{ const uint32_t x13 = in1[4];
-	{ const uint32_t x11 = in1[3];
-	{ const uint32_t x9 = in1[2];
-	{ const uint32_t x7 = in1[1];
-	{ const uint32_t x5 = in1[0];
-	{ const uint32_t x38 = in2[9];
-	{ const uint32_t x39 = in2[8];
-	{ const uint32_t x37 = in2[7];
-	{ const uint32_t x35 = in2[6];
-	{ const uint32_t x33 = in2[5];
-	{ const uint32_t x31 = in2[4];
-	{ const uint32_t x29 = in2[3];
-	{ const uint32_t x27 = in2[2];
-	{ const uint32_t x25 = in2[1];
-	{ const uint32_t x23 = in2[0];
-	out[0] = ((0x7ffffda + x5) - x23);
-	out[1] = ((0x3fffffe + x7) - x25);
-	out[2] = ((0x7fffffe + x9) - x27);
-	out[3] = ((0x3fffffe + x11) - x29);
-	out[4] = ((0x7fffffe + x13) - x31);
-	out[5] = ((0x3fffffe + x15) - x33);
-	out[6] = ((0x7fffffe + x17) - x35);
-	out[7] = ((0x3fffffe + x19) - x37);
-	out[8] = ((0x7fffffe + x21) - x39);
-	out[9] = ((0x3fffffe + x20) - x38);
-	}}}}}}}}}}}}}}}}}}}}
-}
-
-/* h = f - g
- * Can overlap h with f or g.
- */
-static __always_inline void fe_sub(fe_loose *h, const fe *f, const fe *g)
-{
-	fe_sub_impl(h->v, f->v, g->v);
-}
-
-static void fe_mul_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
-{
-	{ const uint32_t x20 = in1[9];
-	{ const uint32_t x21 = in1[8];
-	{ const uint32_t x19 = in1[7];
-	{ const uint32_t x17 = in1[6];
-	{ const uint32_t x15 = in1[5];
-	{ const uint32_t x13 = in1[4];
-	{ const uint32_t x11 = in1[3];
-	{ const uint32_t x9 = in1[2];
-	{ const uint32_t x7 = in1[1];
-	{ const uint32_t x5 = in1[0];
-	{ const uint32_t x38 = in2[9];
-	{ const uint32_t x39 = in2[8];
-	{ const uint32_t x37 = in2[7];
-	{ const uint32_t x35 = in2[6];
-	{ const uint32_t x33 = in2[5];
-	{ const uint32_t x31 = in2[4];
-	{ const uint32_t x29 = in2[3];
-	{ const uint32_t x27 = in2[2];
-	{ const uint32_t x25 = in2[1];
-	{ const uint32_t x23 = in2[0];
-	{ uint64_t x40 = ((uint64_t)x23 * x5);
-	{ uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));
-	{ uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));
-	{ uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));
-	{ uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));
-	{ uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));
-	{ uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));
-	{ uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));
-	{ uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));
-	{ uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));
-	{ uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));
-	{ uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));
-	{ uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));
-	{ uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));
-	{ uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));
-	{ uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));
-	{ uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));
-	{ uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));
-	{ uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);
-	{ uint64_t x59 = (x48 + (x58 << 0x4));
-	{ uint64_t x60 = (x59 + (x58 << 0x1));
-	{ uint64_t x61 = (x60 + x58);
-	{ uint64_t x62 = (x47 + (x57 << 0x4));
-	{ uint64_t x63 = (x62 + (x57 << 0x1));
-	{ uint64_t x64 = (x63 + x57);
-	{ uint64_t x65 = (x46 + (x56 << 0x4));
-	{ uint64_t x66 = (x65 + (x56 << 0x1));
-	{ uint64_t x67 = (x66 + x56);
-	{ uint64_t x68 = (x45 + (x55 << 0x4));
-	{ uint64_t x69 = (x68 + (x55 << 0x1));
-	{ uint64_t x70 = (x69 + x55);
-	{ uint64_t x71 = (x44 + (x54 << 0x4));
-	{ uint64_t x72 = (x71 + (x54 << 0x1));
-	{ uint64_t x73 = (x72 + x54);
-	{ uint64_t x74 = (x43 + (x53 << 0x4));
-	{ uint64_t x75 = (x74 + (x53 << 0x1));
-	{ uint64_t x76 = (x75 + x53);
-	{ uint64_t x77 = (x42 + (x52 << 0x4));
-	{ uint64_t x78 = (x77 + (x52 << 0x1));
-	{ uint64_t x79 = (x78 + x52);
-	{ uint64_t x80 = (x41 + (x51 << 0x4));
-	{ uint64_t x81 = (x80 + (x51 << 0x1));
-	{ uint64_t x82 = (x81 + x51);
-	{ uint64_t x83 = (x40 + (x50 << 0x4));
-	{ uint64_t x84 = (x83 + (x50 << 0x1));
-	{ uint64_t x85 = (x84 + x50);
-	{ uint64_t x86 = (x85 >> 0x1a);
-	{ uint32_t x87 = ((uint32_t)x85 & 0x3ffffff);
-	{ uint64_t x88 = (x86 + x82);
-	{ uint64_t x89 = (x88 >> 0x19);
-	{ uint32_t x90 = ((uint32_t)x88 & 0x1ffffff);
-	{ uint64_t x91 = (x89 + x79);
-	{ uint64_t x92 = (x91 >> 0x1a);
-	{ uint32_t x93 = ((uint32_t)x91 & 0x3ffffff);
-	{ uint64_t x94 = (x92 + x76);
-	{ uint64_t x95 = (x94 >> 0x19);
-	{ uint32_t x96 = ((uint32_t)x94 & 0x1ffffff);
-	{ uint64_t x97 = (x95 + x73);
-	{ uint64_t x98 = (x97 >> 0x1a);
-	{ uint32_t x99 = ((uint32_t)x97 & 0x3ffffff);
-	{ uint64_t x100 = (x98 + x70);
-	{ uint64_t x101 = (x100 >> 0x19);
-	{ uint32_t x102 = ((uint32_t)x100 & 0x1ffffff);
-	{ uint64_t x103 = (x101 + x67);
-	{ uint64_t x104 = (x103 >> 0x1a);
-	{ uint32_t x105 = ((uint32_t)x103 & 0x3ffffff);
-	{ uint64_t x106 = (x104 + x64);
-	{ uint64_t x107 = (x106 >> 0x19);
-	{ uint32_t x108 = ((uint32_t)x106 & 0x1ffffff);
-	{ uint64_t x109 = (x107 + x61);
-	{ uint64_t x110 = (x109 >> 0x1a);
-	{ uint32_t x111 = ((uint32_t)x109 & 0x3ffffff);
-	{ uint64_t x112 = (x110 + x49);
-	{ uint64_t x113 = (x112 >> 0x19);
-	{ uint32_t x114 = ((uint32_t)x112 & 0x1ffffff);
-	{ uint64_t x115 = (x87 + (0x13 * x113));
-	{ uint32_t x116 = (uint32_t) (x115 >> 0x1a);
-	{ uint32_t x117 = ((uint32_t)x115 & 0x3ffffff);
-	{ uint32_t x118 = (x116 + x90);
-	{ uint32_t x119 = (x118 >> 0x19);
-	{ uint32_t x120 = (x118 & 0x1ffffff);
-	out[0] = x117;
-	out[1] = x120;
-	out[2] = (x119 + x93);
-	out[3] = x96;
-	out[4] = x99;
-	out[5] = x102;
-	out[6] = x105;
-	out[7] = x108;
-	out[8] = x111;
-	out[9] = x114;
-	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
-}
-
-static __always_inline void fe_mul_ttt(fe *h, const fe *f, const fe *g)
-{
-	fe_mul_impl(h->v, f->v, g->v);
-}
-
-static __always_inline void fe_mul_tlt(fe *h, const fe_loose *f, const fe *g)
-{
-	fe_mul_impl(h->v, f->v, g->v);
-}
-
-static __always_inline void fe_mul_tll(fe *h, const fe_loose *f, const fe_loose *g)
-{
-	fe_mul_impl(h->v, f->v, g->v);
-}
-
-static void fe_sqr_impl(uint32_t out[10], const uint32_t in1[10])
-{
-	{ const uint32_t x17 = in1[9];
-	{ const uint32_t x18 = in1[8];
-	{ const uint32_t x16 = in1[7];
-	{ const uint32_t x14 = in1[6];
-	{ const uint32_t x12 = in1[5];
-	{ const uint32_t x10 = in1[4];
-	{ const uint32_t x8 = in1[3];
-	{ const uint32_t x6 = in1[2];
-	{ const uint32_t x4 = in1[1];
-	{ const uint32_t x2 = in1[0];
-	{ uint64_t x19 = ((uint64_t)x2 * x2);
-	{ uint64_t x20 = ((uint64_t)(0x2 * x2) * x4);
-	{ uint64_t x21 = (0x2 * (((uint64_t)x4 * x4) + ((uint64_t)x2 * x6)));
-	{ uint64_t x22 = (0x2 * (((uint64_t)x4 * x6) + ((uint64_t)x2 * x8)));
-	{ uint64_t x23 = ((((uint64_t)x6 * x6) + ((uint64_t)(0x4 * x4) * x8)) + ((uint64_t)(0x2 * x2) * x10));
-	{ uint64_t x24 = (0x2 * ((((uint64_t)x6 * x8) + ((uint64_t)x4 * x10)) + ((uint64_t)x2 * x12)));
-	{ uint64_t x25 = (0x2 * (((((uint64_t)x8 * x8) + ((uint64_t)x6 * x10)) + ((uint64_t)x2 * x14)) + ((uint64_t)(0x2 * x4) * x12)));
-	{ uint64_t x26 = (0x2 * (((((uint64_t)x8 * x10) + ((uint64_t)x6 * x12)) + ((uint64_t)x4 * x14)) + ((uint64_t)x2 * x16)));
-	{ uint64_t x27 = (((uint64_t)x10 * x10) + (0x2 * ((((uint64_t)x6 * x14) + ((uint64_t)x2 * x18)) + (0x2 * (((uint64_t)x4 * x16) + ((uint64_t)x8 * x12))))));
-	{ uint64_t x28 = (0x2 * ((((((uint64_t)x10 * x12) + ((uint64_t)x8 * x14)) + ((uint64_t)x6 * x16)) + ((uint64_t)x4 * x18)) + ((uint64_t)x2 * x17)));
-	{ uint64_t x29 = (0x2 * (((((uint64_t)x12 * x12) + ((uint64_t)x10 * x14)) + ((uint64_t)x6 * x18)) + (0x2 * (((uint64_t)x8 * x16) + ((uint64_t)x4 * x17)))));
-	{ uint64_t x30 = (0x2 * (((((uint64_t)x12 * x14) + ((uint64_t)x10 * x16)) + ((uint64_t)x8 * x18)) + ((uint64_t)x6 * x17)));
-	{ uint64_t x31 = (((uint64_t)x14 * x14) + (0x2 * (((uint64_t)x10 * x18) + (0x2 * (((uint64_t)x12 * x16) + ((uint64_t)x8 * x17))))));
-	{ uint64_t x32 = (0x2 * ((((uint64_t)x14 * x16) + ((uint64_t)x12 * x18)) + ((uint64_t)x10 * x17)));
-	{ uint64_t x33 = (0x2 * ((((uint64_t)x16 * x16) + ((uint64_t)x14 * x18)) + ((uint64_t)(0x2 * x12) * x17)));
-	{ uint64_t x34 = (0x2 * (((uint64_t)x16 * x18) + ((uint64_t)x14 * x17)));
-	{ uint64_t x35 = (((uint64_t)x18 * x18) + ((uint64_t)(0x4 * x16) * x17));
-	{ uint64_t x36 = ((uint64_t)(0x2 * x18) * x17);
-	{ uint64_t x37 = ((uint64_t)(0x2 * x17) * x17);
-	{ uint64_t x38 = (x27 + (x37 << 0x4));
-	{ uint64_t x39 = (x38 + (x37 << 0x1));
-	{ uint64_t x40 = (x39 + x37);
-	{ uint64_t x41 = (x26 + (x36 << 0x4));
-	{ uint64_t x42 = (x41 + (x36 << 0x1));
-	{ uint64_t x43 = (x42 + x36);
-	{ uint64_t x44 = (x25 + (x35 << 0x4));
-	{ uint64_t x45 = (x44 + (x35 << 0x1));
-	{ uint64_t x46 = (x45 + x35);
-	{ uint64_t x47 = (x24 + (x34 << 0x4));
-	{ uint64_t x48 = (x47 + (x34 << 0x1));
-	{ uint64_t x49 = (x48 + x34);
-	{ uint64_t x50 = (x23 + (x33 << 0x4));
-	{ uint64_t x51 = (x50 + (x33 << 0x1));
-	{ uint64_t x52 = (x51 + x33);
-	{ uint64_t x53 = (x22 + (x32 << 0x4));
-	{ uint64_t x54 = (x53 + (x32 << 0x1));
-	{ uint64_t x55 = (x54 + x32);
-	{ uint64_t x56 = (x21 + (x31 << 0x4));
-	{ uint64_t x57 = (x56 + (x31 << 0x1));
-	{ uint64_t x58 = (x57 + x31);
-	{ uint64_t x59 = (x20 + (x30 << 0x4));
-	{ uint64_t x60 = (x59 + (x30 << 0x1));
-	{ uint64_t x61 = (x60 + x30);
-	{ uint64_t x62 = (x19 + (x29 << 0x4));
-	{ uint64_t x63 = (x62 + (x29 << 0x1));
-	{ uint64_t x64 = (x63 + x29);
-	{ uint64_t x65 = (x64 >> 0x1a);
-	{ uint32_t x66 = ((uint32_t)x64 & 0x3ffffff);
-	{ uint64_t x67 = (x65 + x61);
-	{ uint64_t x68 = (x67 >> 0x19);
-	{ uint32_t x69 = ((uint32_t)x67 & 0x1ffffff);
-	{ uint64_t x70 = (x68 + x58);
-	{ uint64_t x71 = (x70 >> 0x1a);
-	{ uint32_t x72 = ((uint32_t)x70 & 0x3ffffff);
-	{ uint64_t x73 = (x71 + x55);
-	{ uint64_t x74 = (x73 >> 0x19);
-	{ uint32_t x75 = ((uint32_t)x73 & 0x1ffffff);
-	{ uint64_t x76 = (x74 + x52);
-	{ uint64_t x77 = (x76 >> 0x1a);
-	{ uint32_t x78 = ((uint32_t)x76 & 0x3ffffff);
-	{ uint64_t x79 = (x77 + x49);
-	{ uint64_t x80 = (x79 >> 0x19);
-	{ uint32_t x81 = ((uint32_t)x79 & 0x1ffffff);
-	{ uint64_t x82 = (x80 + x46);
-	{ uint64_t x83 = (x82 >> 0x1a);
-	{ uint32_t x84 = ((uint32_t)x82 & 0x3ffffff);
-	{ uint64_t x85 = (x83 + x43);
-	{ uint64_t x86 = (x85 >> 0x19);
-	{ uint32_t x87 = ((uint32_t)x85 & 0x1ffffff);
-	{ uint64_t x88 = (x86 + x40);
-	{ uint64_t x89 = (x88 >> 0x1a);
-	{ uint32_t x90 = ((uint32_t)x88 & 0x3ffffff);
-	{ uint64_t x91 = (x89 + x28);
-	{ uint64_t x92 = (x91 >> 0x19);
-	{ uint32_t x93 = ((uint32_t)x91 & 0x1ffffff);
-	{ uint64_t x94 = (x66 + (0x13 * x92));
-	{ uint32_t x95 = (uint32_t) (x94 >> 0x1a);
-	{ uint32_t x96 = ((uint32_t)x94 & 0x3ffffff);
-	{ uint32_t x97 = (x95 + x69);
-	{ uint32_t x98 = (x97 >> 0x19);
-	{ uint32_t x99 = (x97 & 0x1ffffff);
-	out[0] = x96;
-	out[1] = x99;
-	out[2] = (x98 + x72);
-	out[3] = x75;
-	out[4] = x78;
-	out[5] = x81;
-	out[6] = x84;
-	out[7] = x87;
-	out[8] = x90;
-	out[9] = x93;
-	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
-}
-
-static __always_inline void fe_sq_tl(fe *h, const fe_loose *f)
-{
-	fe_sqr_impl(h->v, f->v);
-}
-
-static __always_inline void fe_sq_tt(fe *h, const fe *f)
-{
-	fe_sqr_impl(h->v, f->v);
-}
-
-static __always_inline void fe_loose_invert(fe *out, const fe_loose *z)
-{
-	fe t0;
-	fe t1;
-	fe t2;
-	fe t3;
-	int i;
-
-	fe_sq_tl(&t0, z);
-	fe_sq_tt(&t1, &t0);
-	for (i = 1; i < 2; ++i)
-		fe_sq_tt(&t1, &t1);
-	fe_mul_tlt(&t1, z, &t1);
-	fe_mul_ttt(&t0, &t0, &t1);
-	fe_sq_tt(&t2, &t0);
-	fe_mul_ttt(&t1, &t1, &t2);
-	fe_sq_tt(&t2, &t1);
-	for (i = 1; i < 5; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t1, &t2, &t1);
-	fe_sq_tt(&t2, &t1);
-	for (i = 1; i < 10; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t2, &t2, &t1);
-	fe_sq_tt(&t3, &t2);
-	for (i = 1; i < 20; ++i)
-		fe_sq_tt(&t3, &t3);
-	fe_mul_ttt(&t2, &t3, &t2);
-	fe_sq_tt(&t2, &t2);
-	for (i = 1; i < 10; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t1, &t2, &t1);
-	fe_sq_tt(&t2, &t1);
-	for (i = 1; i < 50; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t2, &t2, &t1);
-	fe_sq_tt(&t3, &t2);
-	for (i = 1; i < 100; ++i)
-		fe_sq_tt(&t3, &t3);
-	fe_mul_ttt(&t2, &t3, &t2);
-	fe_sq_tt(&t2, &t2);
-	for (i = 1; i < 50; ++i)
-		fe_sq_tt(&t2, &t2);
-	fe_mul_ttt(&t1, &t2, &t1);
-	fe_sq_tt(&t1, &t1);
-	for (i = 1; i < 5; ++i)
-		fe_sq_tt(&t1, &t1);
-	fe_mul_ttt(out, &t1, &t0);
-}
-
-static __always_inline void fe_invert(fe *out, const fe *z)
-{
-	fe_loose l;
-	fe_copy_lt(&l, z);
-	fe_loose_invert(out, &l);
-}
-
-/* Replace (f,g) with (g,f) if b == 1;
- * replace (f,g) with (f,g) if b == 0.
- *
- * Preconditions: b in {0,1}
- */
-static __always_inline void fe_cswap(fe *f, fe *g, unsigned int b)
-{
-	unsigned i;
-	b = 0-b;
-	for (i = 0; i < 10; i++) {
-		uint32_t x = f->v[i] ^ g->v[i];
-		x &= b;
-		f->v[i] ^= x;
-		g->v[i] ^= x;
-	}
-}
-
-/* NOTE: based on fiat-crypto fe_mul, edited for in2=121666, 0, 0.*/
-static __always_inline void fe_mul_121666_impl(uint32_t out[10], const uint32_t in1[10])
-{
-	{ const uint32_t x20 = in1[9];
-	{ const uint32_t x21 = in1[8];
-	{ const uint32_t x19 = in1[7];
-	{ const uint32_t x17 = in1[6];
-	{ const uint32_t x15 = in1[5];
-	{ const uint32_t x13 = in1[4];
-	{ const uint32_t x11 = in1[3];
-	{ const uint32_t x9 = in1[2];
-	{ const uint32_t x7 = in1[1];
-	{ const uint32_t x5 = in1[0];
-	{ const uint32_t x38 = 0;
-	{ const uint32_t x39 = 0;
-	{ const uint32_t x37 = 0;
-	{ const uint32_t x35 = 0;
-	{ const uint32_t x33 = 0;
-	{ const uint32_t x31 = 0;
-	{ const uint32_t x29 = 0;
-	{ const uint32_t x27 = 0;
-	{ const uint32_t x25 = 0;
-	{ const uint32_t x23 = 121666;
-	{ uint64_t x40 = ((uint64_t)x23 * x5);
-	{ uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));
-	{ uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));
-	{ uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));
-	{ uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));
-	{ uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));
-	{ uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));
-	{ uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));
-	{ uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));
-	{ uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));
-	{ uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));
-	{ uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));
-	{ uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));
-	{ uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));
-	{ uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));
-	{ uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));
-	{ uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));
-	{ uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));
-	{ uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);
-	{ uint64_t x59 = (x48 + (x58 << 0x4));
-	{ uint64_t x60 = (x59 + (x58 << 0x1));
-	{ uint64_t x61 = (x60 + x58);
-	{ uint64_t x62 = (x47 + (x57 << 0x4));
-	{ uint64_t x63 = (x62 + (x57 << 0x1));
-	{ uint64_t x64 = (x63 + x57);
-	{ uint64_t x65 = (x46 + (x56 << 0x4));
-	{ uint64_t x66 = (x65 + (x56 << 0x1));
-	{ uint64_t x67 = (x66 + x56);
-	{ uint64_t x68 = (x45 + (x55 << 0x4));
-	{ uint64_t x69 = (x68 + (x55 << 0x1));
-	{ uint64_t x70 = (x69 + x55);
-	{ uint64_t x71 = (x44 + (x54 << 0x4));
-	{ uint64_t x72 = (x71 + (x54 << 0x1));
-	{ uint64_t x73 = (x72 + x54);
-	{ uint64_t x74 = (x43 + (x53 << 0x4));
-	{ uint64_t x75 = (x74 + (x53 << 0x1));
-	{ uint64_t x76 = (x75 + x53);
-	{ uint64_t x77 = (x42 + (x52 << 0x4));
-	{ uint64_t x78 = (x77 + (x52 << 0x1));
-	{ uint64_t x79 = (x78 + x52);
-	{ uint64_t x80 = (x41 + (x51 << 0x4));
-	{ uint64_t x81 = (x80 + (x51 << 0x1));
-	{ uint64_t x82 = (x81 + x51);
-	{ uint64_t x83 = (x40 + (x50 << 0x4));
-	{ uint64_t x84 = (x83 + (x50 << 0x1));
-	{ uint64_t x85 = (x84 + x50);
-	{ uint64_t x86 = (x85 >> 0x1a);
-	{ uint32_t x87 = ((uint32_t)x85 & 0x3ffffff);
-	{ uint64_t x88 = (x86 + x82);
-	{ uint64_t x89 = (x88 >> 0x19);
-	{ uint32_t x90 = ((uint32_t)x88 & 0x1ffffff);
-	{ uint64_t x91 = (x89 + x79);
-	{ uint64_t x92 = (x91 >> 0x1a);
-	{ uint32_t x93 = ((uint32_t)x91 & 0x3ffffff);
-	{ uint64_t x94 = (x92 + x76);
-	{ uint64_t x95 = (x94 >> 0x19);
-	{ uint32_t x96 = ((uint32_t)x94 & 0x1ffffff);
-	{ uint64_t x97 = (x95 + x73);
-	{ uint64_t x98 = (x97 >> 0x1a);
-	{ uint32_t x99 = ((uint32_t)x97 & 0x3ffffff);
-	{ uint64_t x100 = (x98 + x70);
-	{ uint64_t x101 = (x100 >> 0x19);
-	{ uint32_t x102 = ((uint32_t)x100 & 0x1ffffff);
-	{ uint64_t x103 = (x101 + x67);
-	{ uint64_t x104 = (x103 >> 0x1a);
-	{ uint32_t x105 = ((uint32_t)x103 & 0x3ffffff);
-	{ uint64_t x106 = (x104 + x64);
-	{ uint64_t x107 = (x106 >> 0x19);
-	{ uint32_t x108 = ((uint32_t)x106 & 0x1ffffff);
-	{ uint64_t x109 = (x107 + x61);
-	{ uint64_t x110 = (x109 >> 0x1a);
-	{ uint32_t x111 = ((uint32_t)x109 & 0x3ffffff);
-	{ uint64_t x112 = (x110 + x49);
-	{ uint64_t x113 = (x112 >> 0x19);
-	{ uint32_t x114 = ((uint32_t)x112 & 0x1ffffff);
-	{ uint64_t x115 = (x87 + (0x13 * x113));
-	{ uint32_t x116 = (uint32_t) (x115 >> 0x1a);
-	{ uint32_t x117 = ((uint32_t)x115 & 0x3ffffff);
-	{ uint32_t x118 = (x116 + x90);
-	{ uint32_t x119 = (x118 >> 0x19);
-	{ uint32_t x120 = (x118 & 0x1ffffff);
-	out[0] = x117;
-	out[1] = x120;
-	out[2] = (x119 + x93);
-	out[3] = x96;
-	out[4] = x99;
-	out[5] = x102;
-	out[6] = x105;
-	out[7] = x108;
-	out[8] = x111;
-	out[9] = x114;
-	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
-}
-
-static __always_inline void fe_mul121666(fe *h, const fe_loose *f)
-{
-	fe_mul_121666_impl(h->v, f->v);
-}
-
-void curve25519(uint8_t out[static CURVE25519_POINT_SIZE], const uint8_t scalar[static CURVE25519_POINT_SIZE], const uint8_t point[static CURVE25519_POINT_SIZE])
-{
-	fe x1, x2, z2, x3, z3, tmp0, tmp1;
-	fe_loose x2l, z2l, x3l, tmp0l, tmp1l;
-	unsigned swap = 0;
-	int pos;
-	uint8_t e[32];
-
-	memcpy(e, scalar, 32);
-	curve25519_normalize_secret(e);
-
-	/* The following implementation was transcribed to Coq and proven to
-	 * correspond to unary scalar multiplication in affine coordinates given that
-	 * x1 != 0 is the x coordinate of some point on the curve. It was also checked
-	 * in Coq that doing a ladderstep with x1 = x3 = 0 gives z2' = z3' = 0, and z2
-	 * = z3 = 0 gives z2' = z3' = 0. The statement was quantified over the
-	 * underlying field, so it applies to Curve25519 itself and the quadratic
-	 * twist of Curve25519. It was not proven in Coq that prime-field arithmetic
-	 * correctly simulates extension-field arithmetic on prime-field values.
-	 * The decoding of the byte array representation of e was not considered.
-	 * Specification of Montgomery curves in affine coordinates:
-	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Spec/MontgomeryCurve.v#L27>
-	 * Proof that these form a group that is isomorphic to a Weierstrass curve:
-	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/AffineProofs.v#L35>
-	 * Coq transcription and correctness proof of the loop (where scalarbits=255):
-	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L118>
-	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L278>
-	 * preconditions: 0 <= e < 2^255 (not necessarily e < order), fe_invert(0) = 0
-	 */
-	fe_frombytes(&x1, point);
-	fe_1(&x2);
-	fe_0(&z2);
-	fe_copy(&x3, &x1);
-	fe_1(&z3);
-
-	for (pos = 254; pos >= 0; --pos) {
-		/* loop invariant as of right before the test, for the case where x1 != 0:
-		 *   pos >= -1; if z2 = 0 then x2 is nonzero; if z3 = 0 then x3 is nonzero
-		 *   let r := e >> (pos+1) in the following equalities of projective points:
-		 *   to_xz (r*P)     === if swap then (x3, z3) else (x2, z2)
-		 *   to_xz ((r+1)*P) === if swap then (x2, z2) else (x3, z3)
-		 *   x1 is the nonzero x coordinate of the nonzero point (r*P-(r+1)*P)
-		 */
-		unsigned b = 1 & (e[pos / 8] >> (pos & 7));
-		swap ^= b;
-		fe_cswap(&x2, &x3, swap);
-		fe_cswap(&z2, &z3, swap);
-		swap = b;
-		/* Coq transcription of ladderstep formula (called from transcribed loop):
-		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L89>
-		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L131>
-		 * x1 != 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L217>
-		 * x1  = 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L147>
-		 */
-		fe_sub(&tmp0l, &x3, &z3);
-		fe_sub(&tmp1l, &x2, &z2);
-		fe_add(&x2l, &x2, &z2);
-		fe_add(&z2l, &x3, &z3);
-		fe_mul_tll(&z3, &tmp0l, &x2l);
-		fe_mul_tll(&z2, &z2l, &tmp1l);
-		fe_sq_tl(&tmp0, &tmp1l);
-		fe_sq_tl(&tmp1, &x2l);
-		fe_add(&x3l, &z3, &z2);
-		fe_sub(&z2l, &z3, &z2);
-		fe_mul_ttt(&x2, &tmp1, &tmp0);
-		fe_sub(&tmp1l, &tmp1, &tmp0);
-		fe_sq_tl(&z2, &z2l);
-		fe_mul121666(&z3, &tmp1l);
-		fe_sq_tl(&x3, &x3l);
-		fe_add(&tmp0l, &tmp0, &z3);
-		fe_mul_ttt(&z3, &x1, &z2);
-		fe_mul_tll(&z2, &tmp1l, &tmp0l);
-	}
-	/* here pos=-1, so r=e, so to_xz (e*P) === if swap then (x3, z3) else (x2, z2) */
-	fe_cswap(&x2, &x3, swap);
-	fe_cswap(&z2, &z3, swap);
-
-	fe_invert(&z2, &z2);
-	fe_mul_ttt(&x2, &x2, &z2);
-	fe_tobytes(out, &x2);
-}
+#include "../crypto/curve25519-fiat32.h"
 #endif
 
 void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE])
@@ -1575,3 +61,8 @@ void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const
 
 	curve25519(pub, secret, basepoint);
 }
+
+void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE])
+{
+	curve25519_generic(mypublic, secret, basepoint);
+}

commit 5306604aa59a6cf14e574c6d402657adbf59c7f0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 18 18:41:45 2018 +0100

    curve25519-fiat32: uninline certain functions
    
    While this has a negative performance impact on x86_64, it has a
    positive performance impact on smaller machines, which is where we're
    actually using this code. For example, an A53:
    
    Before: fiat32: 228605 cycles per call
    After: fiat32: 188307 cycles per call
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index 1633275..c5f86dc 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -232,7 +232,7 @@ static __always_inline void fe_1(fe *h)
 	h->v[0] = 1;
 }
 
-static __always_inline void fe_add_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+static void fe_add_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
 {
 	{ const uint32_t x20 = in1[9];
 	{ const uint32_t x21 = in1[8];
@@ -275,7 +275,7 @@ static __always_inline void fe_add(fe_loose *h, const fe *f, const fe *g)
 	fe_add_impl(h->v, f->v, g->v);
 }
 
-static __always_inline void fe_sub_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+static void fe_sub_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
 {
 	{ const uint32_t x20 = in1[9];
 	{ const uint32_t x21 = in1[8];
@@ -318,7 +318,7 @@ static __always_inline void fe_sub(fe_loose *h, const fe *f, const fe *g)
 	fe_sub_impl(h->v, f->v, g->v);
 }
 
-static __always_inline void fe_mul_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+static void fe_mul_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
 {
 	{ const uint32_t x20 = in1[9];
 	{ const uint32_t x21 = in1[8];
@@ -449,7 +449,7 @@ static __always_inline void fe_mul_tll(fe *h, const fe_loose *f, const fe_loose
 	fe_mul_impl(h->v, f->v, g->v);
 }
 
-static __always_inline void fe_sqr_impl(uint32_t out[10], const uint32_t in1[10])
+static void fe_sqr_impl(uint32_t out[10], const uint32_t in1[10])
 {
 	{ const uint32_t x17 = in1[9];
 	{ const uint32_t x18 = in1[8];
diff --git a/src/curve25519.c b/src/curve25519.c
index ee7df84..7f6c9bf 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -957,7 +957,7 @@ static __always_inline void fe_1(fe *h)
 	h->v[0] = 1;
 }
 
-static __always_inline void fe_add_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+static void fe_add_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
 {
 	{ const uint32_t x20 = in1[9];
 	{ const uint32_t x21 = in1[8];
@@ -1000,7 +1000,7 @@ static __always_inline void fe_add(fe_loose *h, const fe *f, const fe *g)
 	fe_add_impl(h->v, f->v, g->v);
 }
 
-static __always_inline void fe_sub_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+static void fe_sub_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
 {
 	{ const uint32_t x20 = in1[9];
 	{ const uint32_t x21 = in1[8];
@@ -1043,7 +1043,7 @@ static __always_inline void fe_sub(fe_loose *h, const fe *f, const fe *g)
 	fe_sub_impl(h->v, f->v, g->v);
 }
 
-static __always_inline void fe_mul_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+static void fe_mul_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
 {
 	{ const uint32_t x20 = in1[9];
 	{ const uint32_t x21 = in1[8];
@@ -1174,7 +1174,7 @@ static __always_inline void fe_mul_tll(fe *h, const fe_loose *f, const fe_loose
 	fe_mul_impl(h->v, f->v, g->v);
 }
 
-static __always_inline void fe_sqr_impl(uint32_t out[10], const uint32_t in1[10])
+static void fe_sqr_impl(uint32_t out[10], const uint32_t in1[10])
 {
 	{ const uint32_t x17 = in1[9];
 	{ const uint32_t x18 = in1[8];

commit d68293b8a3ca95b672a545aa6bc22413e6178f22
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 18 11:50:49 2018 +0100

    contrib: keygen-html: update curve25519 implementation
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index 20d3f91..1633275 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -1,869 +1,853 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2008 Google Inc. All Rights Reserved.
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2016 The fiat-crypto Authors.
+ * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * This is a machine-generated formally verified implementation of curve25519 DH from:
+ * https://github.com/mit-plv/fiat-crypto
  */
 
 #include <emscripten.h>
 
+#ifndef __always_inline
+#define __always_inline __inline __attribute__((__always_inline__))
+#endif
+
+#ifndef __aligned
+#define __aligned(x) __attribute__((aligned(x)))
+#endif
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define le32toh(x) (x)
+#else
+#define htole32(x) __builtin_bswap32(x)
+#endif
+
+
 typedef unsigned long long uint64_t;
-typedef long long int64_t;
-typedef int int32_t;
 typedef unsigned int uint32_t;
 typedef unsigned char uint8_t;
-typedef int64_t limb;
+/* fe means field element. Here the field is \Z/(2^255-19). An element t,
+ * entries t[0]...t[9], represents the integer t[0]+2^26 t[1]+2^51 t[2]+2^77
+ * t[3]+2^102 t[4]+...+2^230 t[9].
+ * fe limbs are bounded by 1.125*2^26,1.125*2^25,1.125*2^26,1.125*2^25,etc.
+ * Multiplication and carrying produce fe from fe_loose.
+ */
+typedef struct fe { uint32_t v[10]; } fe;
 
-/* Field element representation:
- *
- * Field elements are written as an array of signed, 64-bit limbs, least
- * significant first. The value of the field element is:
- *   x[0] + 2^26x[1] + x^51x[2] + 2^102x[3] + ...
- *
- * i.e. the limbs are 26, 25, 26, 25, ... bits wide.
+/* fe_loose limbs are bounded by 3.375*2^26,3.375*2^25,3.375*2^26,3.375*2^25,etc.
+ * Addition and subtraction produce fe_loose from (fe, fe).
  */
+typedef struct fe_loose { uint32_t v[10]; } fe_loose;
 
-/* Sum two numbers: output += in */
-static void fsum(limb *output, const limb *in)
+static __always_inline void fe_frombytes_impl(uint32_t h[10], const uint8_t *s)
 {
-	unsigned int i;
-
-	for (i = 0; i < 10; i += 2) {
-		output[0 + i] = output[0 + i] + in[0 + i];
-		output[1 + i] = output[1 + i] + in[1 + i];
-	}
+	/* Ignores top bit of s. */
+	uint32_t a0 = le32toh(*(uint32_t *)(s));
+	uint32_t a1 = le32toh(*(uint32_t *)(s+4));
+	uint32_t a2 = le32toh(*(uint32_t *)(s+8));
+	uint32_t a3 = le32toh(*(uint32_t *)(s+12));
+	uint32_t a4 = le32toh(*(uint32_t *)(s+16));
+	uint32_t a5 = le32toh(*(uint32_t *)(s+20));
+	uint32_t a6 = le32toh(*(uint32_t *)(s+24));
+	uint32_t a7 = le32toh(*(uint32_t *)(s+28));
+	h[0] = a0&((1<<26)-1);                    /* 26 used, 32-26 left.   26 */
+	h[1] = (a0>>26) | ((a1&((1<<19)-1))<< 6); /* (32-26) + 19 =  6+19 = 25 */
+	h[2] = (a1>>19) | ((a2&((1<<13)-1))<<13); /* (32-19) + 13 = 13+13 = 26 */
+	h[3] = (a2>>13) | ((a3&((1<< 6)-1))<<19); /* (32-13) +  6 = 19+ 6 = 25 */
+	h[4] = (a3>> 6);                          /* (32- 6)              = 26 */
+	h[5] = a4&((1<<25)-1);                    /*                        25 */
+	h[6] = (a4>>25) | ((a5&((1<<19)-1))<< 7); /* (32-25) + 19 =  7+19 = 26 */
+	h[7] = (a5>>19) | ((a6&((1<<12)-1))<<13); /* (32-19) + 12 = 13+12 = 25 */
+	h[8] = (a6>>12) | ((a7&((1<< 6)-1))<<20); /* (32-12) +  6 = 20+ 6 = 26 */
+	h[9] = (a7>> 6)&((1<<25)-1); /*                                     25 */
 }
 
-/* Find the difference of two numbers: output = in - output
- * (note the order of the arguments!).
- */
-static void fdifference(limb *output, const limb *in)
+static __always_inline void fe_frombytes(fe *h, const uint8_t *s)
 {
-	unsigned int i;
-
-	for (i = 0; i < 10; ++i) {
-		output[i] = in[i] - output[i];
-	}
+	fe_frombytes_impl(h->v, s);
 }
 
-/* Multiply a number by a scalar: output = in * scalar */
-static void fscalar_product(limb *output, const limb *in, const limb scalar)
+static __always_inline uint8_t /*bool*/ addcarryx_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
 {
-	unsigned int i;
-
-	for (i = 0; i < 10; ++i) {
-		output[i] = in[i] * scalar;
-	}
+	/* This function extracts 25 bits of result and 1 bit of carry (26 total), so
+	 * a 32-bit intermediate is sufficient.
+	 */
+	uint32_t x = a + b + c;
+	*low = x & ((1 << 25) - 1);
+	return (x >> 25) & 1;
 }
 
-/* Multiply two numbers: output = in2 * in
- *
- * output must be distinct to both inputs. The inputs are reduced coefficient
- * form, the output is not.
- *
- * output[x] <= 14 * the largest product of the input limbs.
- */
-static void fproduct(limb *output, const limb *in2, const limb *in)
-{
-	output[0] =	   ((limb) ((int32_t) in2[0])) * ((int32_t) in[0]);
-	output[1] =	   ((limb) ((int32_t) in2[0])) * ((int32_t) in[1]) +
-						((limb) ((int32_t) in2[1])) * ((int32_t) in[0]);
-	output[2] =  2 *  ((limb) ((int32_t) in2[1])) * ((int32_t) in[1]) +
-						((limb) ((int32_t) in2[0])) * ((int32_t) in[2]) +
-						((limb) ((int32_t) in2[2])) * ((int32_t) in[0]);
-	output[3] =	   ((limb) ((int32_t) in2[1])) * ((int32_t) in[2]) +
-						((limb) ((int32_t) in2[2])) * ((int32_t) in[1]) +
-						((limb) ((int32_t) in2[0])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in2[3])) * ((int32_t) in[0]);
-	output[4] =	   ((limb) ((int32_t) in2[2])) * ((int32_t) in[2]) +
-					   2 * (((limb) ((int32_t) in2[1])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in2[3])) * ((int32_t) in[1])) +
-						((limb) ((int32_t) in2[0])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in2[4])) * ((int32_t) in[0]);
-	output[5] =	   ((limb) ((int32_t) in2[2])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in2[3])) * ((int32_t) in[2]) +
-						((limb) ((int32_t) in2[1])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in2[4])) * ((int32_t) in[1]) +
-						((limb) ((int32_t) in2[0])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in2[5])) * ((int32_t) in[0]);
-	output[6] =  2 * (((limb) ((int32_t) in2[3])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in2[1])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in2[5])) * ((int32_t) in[1])) +
-						((limb) ((int32_t) in2[2])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in2[4])) * ((int32_t) in[2]) +
-						((limb) ((int32_t) in2[0])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in2[6])) * ((int32_t) in[0]);
-	output[7] =	   ((limb) ((int32_t) in2[3])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in2[4])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in2[2])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in2[5])) * ((int32_t) in[2]) +
-						((limb) ((int32_t) in2[1])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in2[6])) * ((int32_t) in[1]) +
-						((limb) ((int32_t) in2[0])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in2[7])) * ((int32_t) in[0]);
-	output[8] =	   ((limb) ((int32_t) in2[4])) * ((int32_t) in[4]) +
-					   2 * (((limb) ((int32_t) in2[3])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in2[5])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in2[1])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in2[7])) * ((int32_t) in[1])) +
-						((limb) ((int32_t) in2[2])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in2[6])) * ((int32_t) in[2]) +
-						((limb) ((int32_t) in2[0])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in2[8])) * ((int32_t) in[0]);
-	output[9] =	   ((limb) ((int32_t) in2[4])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in2[5])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in2[3])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in2[6])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in2[2])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in2[7])) * ((int32_t) in[2]) +
-						((limb) ((int32_t) in2[1])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in2[8])) * ((int32_t) in[1]) +
-						((limb) ((int32_t) in2[0])) * ((int32_t) in[9]) +
-						((limb) ((int32_t) in2[9])) * ((int32_t) in[0]);
-	output[10] = 2 * (((limb) ((int32_t) in2[5])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in2[3])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in2[7])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in2[1])) * ((int32_t) in[9]) +
-						((limb) ((int32_t) in2[9])) * ((int32_t) in[1])) +
-						((limb) ((int32_t) in2[4])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in2[6])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in2[2])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in2[8])) * ((int32_t) in[2]);
-	output[11] =	  ((limb) ((int32_t) in2[5])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in2[6])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in2[4])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in2[7])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in2[3])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in2[8])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in2[2])) * ((int32_t) in[9]) +
-						((limb) ((int32_t) in2[9])) * ((int32_t) in[2]);
-	output[12] =	  ((limb) ((int32_t) in2[6])) * ((int32_t) in[6]) +
-					   2 * (((limb) ((int32_t) in2[5])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in2[7])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in2[3])) * ((int32_t) in[9]) +
-						((limb) ((int32_t) in2[9])) * ((int32_t) in[3])) +
-						((limb) ((int32_t) in2[4])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in2[8])) * ((int32_t) in[4]);
-	output[13] =	  ((limb) ((int32_t) in2[6])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in2[7])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in2[5])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in2[8])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in2[4])) * ((int32_t) in[9]) +
-						((limb) ((int32_t) in2[9])) * ((int32_t) in[4]);
-	output[14] = 2 * (((limb) ((int32_t) in2[7])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in2[5])) * ((int32_t) in[9]) +
-						((limb) ((int32_t) in2[9])) * ((int32_t) in[5])) +
-						((limb) ((int32_t) in2[6])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in2[8])) * ((int32_t) in[6]);
-	output[15] =	  ((limb) ((int32_t) in2[7])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in2[8])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in2[6])) * ((int32_t) in[9]) +
-						((limb) ((int32_t) in2[9])) * ((int32_t) in[6]);
-	output[16] =	  ((limb) ((int32_t) in2[8])) * ((int32_t) in[8]) +
-					   2 * (((limb) ((int32_t) in2[7])) * ((int32_t) in[9]) +
-						((limb) ((int32_t) in2[9])) * ((int32_t) in[7]));
-	output[17] =	  ((limb) ((int32_t) in2[8])) * ((int32_t) in[9]) +
-						((limb) ((int32_t) in2[9])) * ((int32_t) in[8]);
-	output[18] = 2 *  ((limb) ((int32_t) in2[9])) * ((int32_t) in[9]);
-}
-
-/* Reduce a long form to a short form by taking the input mod 2^255 - 19.
- *
- * On entry: |output[i]| < 14*2^54
- * On exit: |output[0..8]| < 280*2^54
- */
-static void freduce_degree(limb *output)
+static __always_inline uint8_t /*bool*/ addcarryx_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
 {
-	/* Each of these shifts and adds ends up multiplying the value by 19.
-	 *
-	 * For output[0..8], the absolute entry value is < 14*2^54 and we add, at
-	 * most, 19*14*2^54 thus, on exit, |output[0..8]| < 280*2^54.
+	/* This function extracts 26 bits of result and 1 bit of carry (27 total), so
+	 * a 32-bit intermediate is sufficient.
 	 */
-	output[8] += output[18] << 4;
-	output[8] += output[18] << 1;
-	output[8] += output[18];
-	output[7] += output[17] << 4;
-	output[7] += output[17] << 1;
-	output[7] += output[17];
-	output[6] += output[16] << 4;
-	output[6] += output[16] << 1;
-	output[6] += output[16];
-	output[5] += output[15] << 4;
-	output[5] += output[15] << 1;
-	output[5] += output[15];
-	output[4] += output[14] << 4;
-	output[4] += output[14] << 1;
-	output[4] += output[14];
-	output[3] += output[13] << 4;
-	output[3] += output[13] << 1;
-	output[3] += output[13];
-	output[2] += output[12] << 4;
-	output[2] += output[12] << 1;
-	output[2] += output[12];
-	output[1] += output[11] << 4;
-	output[1] += output[11] << 1;
-	output[1] += output[11];
-	output[0] += output[10] << 4;
-	output[0] += output[10] << 1;
-	output[0] += output[10];
-}
-
-#if (-1 & 3) != 3
-#error "This code only works on a two's complement system"
-#endif
+	uint32_t x = a + b + c;
+	*low = x & ((1 << 26) - 1);
+	return (x >> 26) & 1;
+}
 
-/* return v / 2^26, using only shifts and adds.
- *
- * On entry: v can take any value.
- */
-static inline limb div_by_2_26(const limb v)
+static __always_inline uint8_t /*bool*/ subborrow_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
 {
-	/* High word of v; no shift needed. */
-	const uint32_t highword = (uint32_t) (((uint64_t) v) >> 32);
-	/* Set to all 1s if v was negative; else set to 0s. */
-	const int32_t sign = ((int32_t) highword) >> 31;
-	/* Set to 0x3ffffff if v was negative; else set to 0. */
-	const int32_t roundoff = ((uint32_t) sign) >> 6;
-	/* Should return v / (1<<26) */
-	return (v + roundoff) >> 26;
+	/* This function extracts 25 bits of result and 1 bit of borrow (26 total), so
+	 * a 32-bit intermediate is sufficient.
+	 */
+	uint32_t x = a - b - c;
+	*low = x & ((1 << 25) - 1);
+	return x >> 31;
 }
 
-/* return v / (2^25), using only shifts and adds.
- *
- * On entry: v can take any value.
- */
-static inline limb div_by_2_25(const limb v)
+static __always_inline uint8_t /*bool*/ subborrow_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
 {
-	/* High word of v; no shift needed*/
-	const uint32_t highword = (uint32_t) (((uint64_t) v) >> 32);
-	/* Set to all 1s if v was negative; else set to 0s. */
-	const int32_t sign = ((int32_t) highword) >> 31;
-	/* Set to 0x1ffffff if v was negative; else set to 0. */
-	const int32_t roundoff = ((uint32_t) sign) >> 7;
-	/* Should return v / (1<<25) */
-	return (v + roundoff) >> 25;
+	/* This function extracts 26 bits of result and 1 bit of borrow (27 total), so
+	 * a 32-bit intermediate is sufficient.
+	 */
+	uint32_t x = a - b - c;
+	*low = x & ((1 << 26) - 1);
+	return x >> 31;
 }
 
-/* Reduce all coefficients of the short form input so that |x| < 2^26.
- *
- * On entry: |output[i]| < 280*2^54
- */
-static void freduce_coefficients(limb *output)
+static __always_inline uint32_t cmovznz32(uint32_t t, uint32_t z, uint32_t nz)
 {
-	unsigned int i;
-
-	output[10] = 0;
+	t = -!!t; /* all set if nonzero, 0 if 0 */
+	return (t&nz) | ((~t)&z);
+}
 
-	for (i = 0; i < 10; i += 2) {
-		limb over = div_by_2_26(output[i]);
-		/* The entry condition (that |output[i]| < 280*2^54) means that over is, at
-		 * most, 280*2^28 in the first iteration of this loop. This is added to the
-		 * next limb and we can approximate the resulting bound of that limb by
-		 * 281*2^54.
-		 */
-		output[i] -= over << 26;
-		output[i+1] += over;
-
-		/* For the first iteration, |output[i+1]| < 281*2^54, thus |over| <
-		 * 281*2^29. When this is added to the next limb, the resulting bound can
-		 * be approximated as 281*2^54.
-		 *
-		 * For subsequent iterations of the loop, 281*2^54 remains a conservative
-		 * bound and no overflow occurs.
-		 */
-		over = div_by_2_25(output[i+1]);
-		output[i+1] -= over << 25;
-		output[i+2] += over;
-	}
-	/* Now |output[10]| < 281*2^29 and all other coefficients are reduced. */
-	output[0] += output[10] << 4;
-	output[0] += output[10] << 1;
-	output[0] += output[10];
+static __always_inline void fe_freeze(uint32_t out[10], const uint32_t in1[10])
+{
+	{ const uint32_t x17 = in1[9];
+	{ const uint32_t x18 = in1[8];
+	{ const uint32_t x16 = in1[7];
+	{ const uint32_t x14 = in1[6];
+	{ const uint32_t x12 = in1[5];
+	{ const uint32_t x10 = in1[4];
+	{ const uint32_t x8 = in1[3];
+	{ const uint32_t x6 = in1[2];
+	{ const uint32_t x4 = in1[1];
+	{ const uint32_t x2 = in1[0];
+	{ uint32_t x20; uint8_t/*bool*/ x21 = subborrow_u26(0x0, x2, 0x3ffffed, &x20);
+	{ uint32_t x23; uint8_t/*bool*/ x24 = subborrow_u25(x21, x4, 0x1ffffff, &x23);
+	{ uint32_t x26; uint8_t/*bool*/ x27 = subborrow_u26(x24, x6, 0x3ffffff, &x26);
+	{ uint32_t x29; uint8_t/*bool*/ x30 = subborrow_u25(x27, x8, 0x1ffffff, &x29);
+	{ uint32_t x32; uint8_t/*bool*/ x33 = subborrow_u26(x30, x10, 0x3ffffff, &x32);
+	{ uint32_t x35; uint8_t/*bool*/ x36 = subborrow_u25(x33, x12, 0x1ffffff, &x35);
+	{ uint32_t x38; uint8_t/*bool*/ x39 = subborrow_u26(x36, x14, 0x3ffffff, &x38);
+	{ uint32_t x41; uint8_t/*bool*/ x42 = subborrow_u25(x39, x16, 0x1ffffff, &x41);
+	{ uint32_t x44; uint8_t/*bool*/ x45 = subborrow_u26(x42, x18, 0x3ffffff, &x44);
+	{ uint32_t x47; uint8_t/*bool*/ x48 = subborrow_u25(x45, x17, 0x1ffffff, &x47);
+	{ uint32_t x49 = cmovznz32(x48, 0x0, 0xffffffff);
+	{ uint32_t x50 = (x49 & 0x3ffffed);
+	{ uint32_t x52; uint8_t/*bool*/ x53 = addcarryx_u26(0x0, x20, x50, &x52);
+	{ uint32_t x54 = (x49 & 0x1ffffff);
+	{ uint32_t x56; uint8_t/*bool*/ x57 = addcarryx_u25(x53, x23, x54, &x56);
+	{ uint32_t x58 = (x49 & 0x3ffffff);
+	{ uint32_t x60; uint8_t/*bool*/ x61 = addcarryx_u26(x57, x26, x58, &x60);
+	{ uint32_t x62 = (x49 & 0x1ffffff);
+	{ uint32_t x64; uint8_t/*bool*/ x65 = addcarryx_u25(x61, x29, x62, &x64);
+	{ uint32_t x66 = (x49 & 0x3ffffff);
+	{ uint32_t x68; uint8_t/*bool*/ x69 = addcarryx_u26(x65, x32, x66, &x68);
+	{ uint32_t x70 = (x49 & 0x1ffffff);
+	{ uint32_t x72; uint8_t/*bool*/ x73 = addcarryx_u25(x69, x35, x70, &x72);
+	{ uint32_t x74 = (x49 & 0x3ffffff);
+	{ uint32_t x76; uint8_t/*bool*/ x77 = addcarryx_u26(x73, x38, x74, &x76);
+	{ uint32_t x78 = (x49 & 0x1ffffff);
+	{ uint32_t x80; uint8_t/*bool*/ x81 = addcarryx_u25(x77, x41, x78, &x80);
+	{ uint32_t x82 = (x49 & 0x3ffffff);
+	{ uint32_t x84; uint8_t/*bool*/ x85 = addcarryx_u26(x81, x44, x82, &x84);
+	{ uint32_t x86 = (x49 & 0x1ffffff);
+	{ uint32_t x88; addcarryx_u25(x85, x47, x86, &x88);
+	out[0] = x52;
+	out[1] = x56;
+	out[2] = x60;
+	out[3] = x64;
+	out[4] = x68;
+	out[5] = x72;
+	out[6] = x76;
+	out[7] = x80;
+	out[8] = x84;
+	out[9] = x88;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
 
-	output[10] = 0;
+static __always_inline void fe_tobytes(uint8_t s[32], const fe *f)
+{
+	uint32_t h[10];
+	fe_freeze(h, f->v);
+	s[0] = h[0] >> 0;
+	s[1] = h[0] >> 8;
+	s[2] = h[0] >> 16;
+	s[3] = (h[0] >> 24) | (h[1] << 2);
+	s[4] = h[1] >> 6;
+	s[5] = h[1] >> 14;
+	s[6] = (h[1] >> 22) | (h[2] << 3);
+	s[7] = h[2] >> 5;
+	s[8] = h[2] >> 13;
+	s[9] = (h[2] >> 21) | (h[3] << 5);
+	s[10] = h[3] >> 3;
+	s[11] = h[3] >> 11;
+	s[12] = (h[3] >> 19) | (h[4] << 6);
+	s[13] = h[4] >> 2;
+	s[14] = h[4] >> 10;
+	s[15] = h[4] >> 18;
+	s[16] = h[5] >> 0;
+	s[17] = h[5] >> 8;
+	s[18] = h[5] >> 16;
+	s[19] = (h[5] >> 24) | (h[6] << 1);
+	s[20] = h[6] >> 7;
+	s[21] = h[6] >> 15;
+	s[22] = (h[6] >> 23) | (h[7] << 3);
+	s[23] = h[7] >> 5;
+	s[24] = h[7] >> 13;
+	s[25] = (h[7] >> 21) | (h[8] << 4);
+	s[26] = h[8] >> 4;
+	s[27] = h[8] >> 12;
+	s[28] = (h[8] >> 20) | (h[9] << 6);
+	s[29] = h[9] >> 2;
+	s[30] = h[9] >> 10;
+	s[31] = h[9] >> 18;
+}
 
-	/* Now output[1..9] are reduced, and |output[0]| < 2^26 + 19*281*2^29
-	 * So |over| will be no more than 2^16.
-	 */
-	{
-		limb over = div_by_2_26(output[0]);
+/* h = f */
+static __always_inline void fe_copy(fe *h, const fe *f)
+{
+	__builtin_memmove(h, f, sizeof(uint32_t) * 10);
+}
 
-		output[0] -= over << 26;
-		output[1] += over;
-	}
+static __always_inline void fe_copy_lt(fe_loose *h, const fe *f)
+{
+	__builtin_memmove(h, f, sizeof(uint32_t) * 10);
+}
 
-	/* Now output[0,2..9] are reduced, and |output[1]| < 2^25 + 2^16 < 2^26. The
-	 * bound on |output[1]| is sufficient to meet our needs.
-	 */
+/* h = 0 */
+static __always_inline void fe_0(fe *h)
+{
+	__builtin_memset(h, 0, sizeof(uint32_t) * 10);
 }
 
-/* A helpful wrapper around fproduct: output = in * in2.
- *
- * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27.
- *
- * output must be distinct to both inputs. The output is reduced degree
- * (indeed, one need only provide storage for 10 limbs) and |output[i]| < 2^26.
- */
-static void fmul(limb *output, const limb *in, const limb *in2)
+/* h = 1 */
+static __always_inline void fe_1(fe *h)
 {
-	limb t[19];
+	__builtin_memset(h, 0, sizeof(uint32_t) * 10);
+	h->v[0] = 1;
+}
 
-	fproduct(t, in, in2);
-	/* |t[i]| < 14*2^54 */
-	freduce_degree(t);
-	freduce_coefficients(t);
-	/* |t[i]| < 2^26 */
-	__builtin_memcpy(output, t, sizeof(limb) * 10);
+static __always_inline void fe_add_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+{
+	{ const uint32_t x20 = in1[9];
+	{ const uint32_t x21 = in1[8];
+	{ const uint32_t x19 = in1[7];
+	{ const uint32_t x17 = in1[6];
+	{ const uint32_t x15 = in1[5];
+	{ const uint32_t x13 = in1[4];
+	{ const uint32_t x11 = in1[3];
+	{ const uint32_t x9 = in1[2];
+	{ const uint32_t x7 = in1[1];
+	{ const uint32_t x5 = in1[0];
+	{ const uint32_t x38 = in2[9];
+	{ const uint32_t x39 = in2[8];
+	{ const uint32_t x37 = in2[7];
+	{ const uint32_t x35 = in2[6];
+	{ const uint32_t x33 = in2[5];
+	{ const uint32_t x31 = in2[4];
+	{ const uint32_t x29 = in2[3];
+	{ const uint32_t x27 = in2[2];
+	{ const uint32_t x25 = in2[1];
+	{ const uint32_t x23 = in2[0];
+	out[0] = (x5 + x23);
+	out[1] = (x7 + x25);
+	out[2] = (x9 + x27);
+	out[3] = (x11 + x29);
+	out[4] = (x13 + x31);
+	out[5] = (x15 + x33);
+	out[6] = (x17 + x35);
+	out[7] = (x19 + x37);
+	out[8] = (x21 + x39);
+	out[9] = (x20 + x38);
+	}}}}}}}}}}}}}}}}}}}}
 }
 
-/* Square a number: output = in**2
- *
- * output must be distinct from the input. The inputs are reduced coefficient
- * form, the output is not.
- *
- * output[x] <= 14 * the largest product of the input limbs.
+/* h = f + g
+ * Can overlap h with f or g.
  */
-static void fsquare_inner(limb *output, const limb *in)
-{
-	output[0] =	   ((limb) ((int32_t) in[0])) * ((int32_t) in[0]);
-	output[1] =  2 *  ((limb) ((int32_t) in[0])) * ((int32_t) in[1]);
-	output[2] =  2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[1]) +
-						((limb) ((int32_t) in[0])) * ((int32_t) in[2]));
-	output[3] =  2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[2]) +
-						((limb) ((int32_t) in[0])) * ((int32_t) in[3]));
-	output[4] =	   ((limb) ((int32_t) in[2])) * ((int32_t) in[2]) +
-					   4 *  ((limb) ((int32_t) in[1])) * ((int32_t) in[3]) +
-					   2 *  ((limb) ((int32_t) in[0])) * ((int32_t) in[4]);
-	output[5] =  2 * (((limb) ((int32_t) in[2])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in[1])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in[0])) * ((int32_t) in[5]));
-	output[6] =  2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[3]) +
-						((limb) ((int32_t) in[2])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in[0])) * ((int32_t) in[6]) +
-					   2 *  ((limb) ((int32_t) in[1])) * ((int32_t) in[5]));
-	output[7] =  2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[4]) +
-						((limb) ((int32_t) in[2])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in[1])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in[0])) * ((int32_t) in[7]));
-	output[8] =	   ((limb) ((int32_t) in[4])) * ((int32_t) in[4]) +
-					   2 * (((limb) ((int32_t) in[2])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in[0])) * ((int32_t) in[8]) +
-					   2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in[3])) * ((int32_t) in[5])));
-	output[9] =  2 * (((limb) ((int32_t) in[4])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in[3])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in[2])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in[1])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in[0])) * ((int32_t) in[9]));
-	output[10] = 2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[5]) +
-						((limb) ((int32_t) in[4])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in[2])) * ((int32_t) in[8]) +
-					   2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in[1])) * ((int32_t) in[9])));
-	output[11] = 2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[6]) +
-						((limb) ((int32_t) in[4])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in[3])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in[2])) * ((int32_t) in[9]));
-	output[12] =	  ((limb) ((int32_t) in[6])) * ((int32_t) in[6]) +
-					   2 * (((limb) ((int32_t) in[4])) * ((int32_t) in[8]) +
-					   2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in[3])) * ((int32_t) in[9])));
-	output[13] = 2 * (((limb) ((int32_t) in[6])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in[5])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in[4])) * ((int32_t) in[9]));
-	output[14] = 2 * (((limb) ((int32_t) in[7])) * ((int32_t) in[7]) +
-						((limb) ((int32_t) in[6])) * ((int32_t) in[8]) +
-					   2 *  ((limb) ((int32_t) in[5])) * ((int32_t) in[9]));
-	output[15] = 2 * (((limb) ((int32_t) in[7])) * ((int32_t) in[8]) +
-						((limb) ((int32_t) in[6])) * ((int32_t) in[9]));
-	output[16] =	  ((limb) ((int32_t) in[8])) * ((int32_t) in[8]) +
-					   4 *  ((limb) ((int32_t) in[7])) * ((int32_t) in[9]);
-	output[17] = 2 *  ((limb) ((int32_t) in[8])) * ((int32_t) in[9]);
-	output[18] = 2 *  ((limb) ((int32_t) in[9])) * ((int32_t) in[9]);
-}
-
-/* fsquare sets output = in^2.
- *
- * On entry: The |in| argument is in reduced coefficients form and |in[i]| <
- * 2^27.
- *
- * On exit: The |output| argument is in reduced coefficients form (indeed, one
- * need only provide storage for 10 limbs) and |out[i]| < 2^26.
- */
-static void fsquare(limb *output, const limb *in)
+static __always_inline void fe_add(fe_loose *h, const fe *f, const fe *g)
 {
-	limb t[19];
-
-	fsquare_inner(t, in);
-	/* |t[i]| < 14*2^54 because the largest product of two limbs will be <
-	 * 2^(27+27) and fsquare_inner adds together, at most, 14 of those
-	 * products.
-	 */
-	freduce_degree(t);
-	freduce_coefficients(t);
-	/* |t[i]| < 2^26 */
-	__builtin_memcpy(output, t, sizeof(limb) * 10);
-}
-
-/* Take a little-endian, 32-byte number and expand it into polynomial form */
-static void fexpand(limb *output, const uint8_t *input)
-{
-#define F(n, start, shift, mask) \
-	output[n] = ((((limb) input[start + 0]) | \
-			  ((limb) input[start + 1]) << 8 | \
-			  ((limb) input[start + 2]) << 16 | \
-			  ((limb) input[start + 3]) << 24) >> shift) & mask;
-	F(0, 0, 0, 0x3ffffff);
-	F(1, 3, 2, 0x1ffffff);
-	F(2, 6, 3, 0x3ffffff);
-	F(3, 9, 5, 0x1ffffff);
-	F(4, 12, 6, 0x3ffffff);
-	F(5, 16, 0, 0x1ffffff);
-	F(6, 19, 1, 0x3ffffff);
-	F(7, 22, 3, 0x1ffffff);
-	F(8, 25, 4, 0x3ffffff);
-	F(9, 28, 6, 0x1ffffff);
-#undef F
-}
-
-#if (-32 >> 1) != -16
-#error "This code only works when >> does sign-extension on negative numbers"
-#endif
+	fe_add_impl(h->v, f->v, g->v);
+}
 
-/* int32_t_eq returns 0xffffffff iff a == b and zero otherwise. */
-static int32_t int32_t_eq(int32_t a, int32_t b)
+static __always_inline void fe_sub_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
 {
-	a = ~(a ^ b);
-	a &= a << 16;
-	a &= a << 8;
-	a &= a << 4;
-	a &= a << 2;
-	a &= a << 1;
-	return a >> 31;
+	{ const uint32_t x20 = in1[9];
+	{ const uint32_t x21 = in1[8];
+	{ const uint32_t x19 = in1[7];
+	{ const uint32_t x17 = in1[6];
+	{ const uint32_t x15 = in1[5];
+	{ const uint32_t x13 = in1[4];
+	{ const uint32_t x11 = in1[3];
+	{ const uint32_t x9 = in1[2];
+	{ const uint32_t x7 = in1[1];
+	{ const uint32_t x5 = in1[0];
+	{ const uint32_t x38 = in2[9];
+	{ const uint32_t x39 = in2[8];
+	{ const uint32_t x37 = in2[7];
+	{ const uint32_t x35 = in2[6];
+	{ const uint32_t x33 = in2[5];
+	{ const uint32_t x31 = in2[4];
+	{ const uint32_t x29 = in2[3];
+	{ const uint32_t x27 = in2[2];
+	{ const uint32_t x25 = in2[1];
+	{ const uint32_t x23 = in2[0];
+	out[0] = ((0x7ffffda + x5) - x23);
+	out[1] = ((0x3fffffe + x7) - x25);
+	out[2] = ((0x7fffffe + x9) - x27);
+	out[3] = ((0x3fffffe + x11) - x29);
+	out[4] = ((0x7fffffe + x13) - x31);
+	out[5] = ((0x3fffffe + x15) - x33);
+	out[6] = ((0x7fffffe + x17) - x35);
+	out[7] = ((0x3fffffe + x19) - x37);
+	out[8] = ((0x7fffffe + x21) - x39);
+	out[9] = ((0x3fffffe + x20) - x38);
+	}}}}}}}}}}}}}}}}}}}}
 }
 
-/* int32_t_gte returns 0xffffffff if a >= b and zero otherwise, where a and b are
- * both non-negative.
+/* h = f - g
+ * Can overlap h with f or g.
  */
-static int32_t int32_t_gte(int32_t a, int32_t b)
+static __always_inline void fe_sub(fe_loose *h, const fe *f, const fe *g)
 {
-	a -= b;
-	/* a >= 0 iff a >= b. */
-	return ~(a >> 31);
+	fe_sub_impl(h->v, f->v, g->v);
 }
 
-/* Take a fully reduced polynomial form number and contract it into a
- * little-endian, 32-byte array.
- *
- * On entry: |input_limbs[i]| < 2^26
- */
-static void fcontract(uint8_t *output, limb *input_limbs)
+static __always_inline void fe_mul_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
 {
-	int i;
-	int j;
-	int32_t input[10];
-	int32_t mask;
-
-	/* |input_limbs[i]| < 2^26, so it's valid to convert to an int32_t. */
-	for (i = 0; i < 10; i++) {
-		input[i] = input_limbs[i];
-	}
-
-	for (j = 0; j < 2; ++j) {
-		for (i = 0; i < 9; ++i) {
-			if ((i & 1) == 1) {
-				/* This calculation is a time-invariant way to make input[i]
-				 * non-negative by borrowing from the next-larger limb.
-				 */
-				const int32_t mask = input[i] >> 31;
-				const int32_t carry = -((input[i] & mask) >> 25);
-
-				input[i] = input[i] + (carry << 25);
-				input[i+1] = input[i+1] - carry;
-			} else {
-				const int32_t mask = input[i] >> 31;
-				const int32_t carry = -((input[i] & mask) >> 26);
-
-				input[i] = input[i] + (carry << 26);
-				input[i+1] = input[i+1] - carry;
-			}
-		}
-
-		/* There's no greater limb for input[9] to borrow from, but we can multiply
-		 * by 19 and borrow from input[0], which is valid mod 2^255-19.
-		 */
-		{
-			const int32_t mask = input[9] >> 31;
-			const int32_t carry = -((input[9] & mask) >> 25);
-
-			input[9] = input[9] + (carry << 25);
-			input[0] = input[0] - (carry * 19);
-		}
+	{ const uint32_t x20 = in1[9];
+	{ const uint32_t x21 = in1[8];
+	{ const uint32_t x19 = in1[7];
+	{ const uint32_t x17 = in1[6];
+	{ const uint32_t x15 = in1[5];
+	{ const uint32_t x13 = in1[4];
+	{ const uint32_t x11 = in1[3];
+	{ const uint32_t x9 = in1[2];
+	{ const uint32_t x7 = in1[1];
+	{ const uint32_t x5 = in1[0];
+	{ const uint32_t x38 = in2[9];
+	{ const uint32_t x39 = in2[8];
+	{ const uint32_t x37 = in2[7];
+	{ const uint32_t x35 = in2[6];
+	{ const uint32_t x33 = in2[5];
+	{ const uint32_t x31 = in2[4];
+	{ const uint32_t x29 = in2[3];
+	{ const uint32_t x27 = in2[2];
+	{ const uint32_t x25 = in2[1];
+	{ const uint32_t x23 = in2[0];
+	{ uint64_t x40 = ((uint64_t)x23 * x5);
+	{ uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));
+	{ uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));
+	{ uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));
+	{ uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));
+	{ uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));
+	{ uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));
+	{ uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));
+	{ uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));
+	{ uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));
+	{ uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));
+	{ uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));
+	{ uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));
+	{ uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));
+	{ uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));
+	{ uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));
+	{ uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));
+	{ uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));
+	{ uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);
+	{ uint64_t x59 = (x48 + (x58 << 0x4));
+	{ uint64_t x60 = (x59 + (x58 << 0x1));
+	{ uint64_t x61 = (x60 + x58);
+	{ uint64_t x62 = (x47 + (x57 << 0x4));
+	{ uint64_t x63 = (x62 + (x57 << 0x1));
+	{ uint64_t x64 = (x63 + x57);
+	{ uint64_t x65 = (x46 + (x56 << 0x4));
+	{ uint64_t x66 = (x65 + (x56 << 0x1));
+	{ uint64_t x67 = (x66 + x56);
+	{ uint64_t x68 = (x45 + (x55 << 0x4));
+	{ uint64_t x69 = (x68 + (x55 << 0x1));
+	{ uint64_t x70 = (x69 + x55);
+	{ uint64_t x71 = (x44 + (x54 << 0x4));
+	{ uint64_t x72 = (x71 + (x54 << 0x1));
+	{ uint64_t x73 = (x72 + x54);
+	{ uint64_t x74 = (x43 + (x53 << 0x4));
+	{ uint64_t x75 = (x74 + (x53 << 0x1));
+	{ uint64_t x76 = (x75 + x53);
+	{ uint64_t x77 = (x42 + (x52 << 0x4));
+	{ uint64_t x78 = (x77 + (x52 << 0x1));
+	{ uint64_t x79 = (x78 + x52);
+	{ uint64_t x80 = (x41 + (x51 << 0x4));
+	{ uint64_t x81 = (x80 + (x51 << 0x1));
+	{ uint64_t x82 = (x81 + x51);
+	{ uint64_t x83 = (x40 + (x50 << 0x4));
+	{ uint64_t x84 = (x83 + (x50 << 0x1));
+	{ uint64_t x85 = (x84 + x50);
+	{ uint64_t x86 = (x85 >> 0x1a);
+	{ uint32_t x87 = ((uint32_t)x85 & 0x3ffffff);
+	{ uint64_t x88 = (x86 + x82);
+	{ uint64_t x89 = (x88 >> 0x19);
+	{ uint32_t x90 = ((uint32_t)x88 & 0x1ffffff);
+	{ uint64_t x91 = (x89 + x79);
+	{ uint64_t x92 = (x91 >> 0x1a);
+	{ uint32_t x93 = ((uint32_t)x91 & 0x3ffffff);
+	{ uint64_t x94 = (x92 + x76);
+	{ uint64_t x95 = (x94 >> 0x19);
+	{ uint32_t x96 = ((uint32_t)x94 & 0x1ffffff);
+	{ uint64_t x97 = (x95 + x73);
+	{ uint64_t x98 = (x97 >> 0x1a);
+	{ uint32_t x99 = ((uint32_t)x97 & 0x3ffffff);
+	{ uint64_t x100 = (x98 + x70);
+	{ uint64_t x101 = (x100 >> 0x19);
+	{ uint32_t x102 = ((uint32_t)x100 & 0x1ffffff);
+	{ uint64_t x103 = (x101 + x67);
+	{ uint64_t x104 = (x103 >> 0x1a);
+	{ uint32_t x105 = ((uint32_t)x103 & 0x3ffffff);
+	{ uint64_t x106 = (x104 + x64);
+	{ uint64_t x107 = (x106 >> 0x19);
+	{ uint32_t x108 = ((uint32_t)x106 & 0x1ffffff);
+	{ uint64_t x109 = (x107 + x61);
+	{ uint64_t x110 = (x109 >> 0x1a);
+	{ uint32_t x111 = ((uint32_t)x109 & 0x3ffffff);
+	{ uint64_t x112 = (x110 + x49);
+	{ uint64_t x113 = (x112 >> 0x19);
+	{ uint32_t x114 = ((uint32_t)x112 & 0x1ffffff);
+	{ uint64_t x115 = (x87 + (0x13 * x113));
+	{ uint32_t x116 = (uint32_t) (x115 >> 0x1a);
+	{ uint32_t x117 = ((uint32_t)x115 & 0x3ffffff);
+	{ uint32_t x118 = (x116 + x90);
+	{ uint32_t x119 = (x118 >> 0x19);
+	{ uint32_t x120 = (x118 & 0x1ffffff);
+	out[0] = x117;
+	out[1] = x120;
+	out[2] = (x119 + x93);
+	out[3] = x96;
+	out[4] = x99;
+	out[5] = x102;
+	out[6] = x105;
+	out[7] = x108;
+	out[8] = x111;
+	out[9] = x114;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
 
-		/* After the first iteration, input[1..9] are non-negative and fit within
-		 * 25 or 26 bits, depending on position. However, input[0] may be
-		 * negative.
-		 */
-	}
+static __always_inline void fe_mul_ttt(fe *h, const fe *f, const fe *g)
+{
+	fe_mul_impl(h->v, f->v, g->v);
+}
 
-	/* The first borrow-propagation pass above ended with every limb
-		 except (possibly) input[0] non-negative.
-		 If input[0] was negative after the first pass, then it was because of a
-		 carry from input[9]. On entry, input[9] < 2^26 so the carry was, at most,
-		 one, since (2**26-1) >> 25 = 1. Thus input[0] >= -19.
-		 In the second pass, each limb is decreased by at most one. Thus the second
-		 borrow-propagation pass could only have wrapped around to decrease
-		 input[0] again if the first pass left input[0] negative *and* input[1]
-		 through input[9] were all zero.  In that case, input[1] is now 2^25 - 1,
-		 and this last borrow-propagation step will leave input[1] non-negative. */
-	{
-		const int32_t mask = input[0] >> 31;
-		const int32_t carry = -((input[0] & mask) >> 26);
-
-		input[0] = input[0] + (carry << 26);
-		input[1] = input[1] - carry;
-	}
+static __always_inline void fe_mul_tlt(fe *h, const fe_loose *f, const fe *g)
+{
+	fe_mul_impl(h->v, f->v, g->v);
+}
 
-	/* All input[i] are now non-negative. However, there might be values between
-	 * 2^25 and 2^26 in a limb which is, nominally, 25 bits wide.
-	 */
-	for (j = 0; j < 2; j++) {
-		for (i = 0; i < 9; i++) {
-			if ((i & 1) == 1) {
-				const int32_t carry = input[i] >> 25;
-
-				input[i] &= 0x1ffffff;
-				input[i+1] += carry;
-			} else {
-				const int32_t carry = input[i] >> 26;
-
-				input[i] &= 0x3ffffff;
-				input[i+1] += carry;
-			}
-		}
-
-		{
-			const int32_t carry = input[9] >> 25;
-
-			input[9] &= 0x1ffffff;
-			input[0] += 19*carry;
-		}
-	}
+static __always_inline void fe_mul_tll(fe *h, const fe_loose *f, const fe_loose *g)
+{
+	fe_mul_impl(h->v, f->v, g->v);
+}
 
-	/* If the first carry-chain pass, just above, ended up with a carry from
-	 * input[9], and that caused input[0] to be out-of-bounds, then input[0] was
-	 * < 2^26 + 2*19, because the carry was, at most, two.
-	 *
-	 * If the second pass carried from input[9] again then input[0] is < 2*19 and
-	 * the input[9] -> input[0] carry didn't push input[0] out of bounds.
-	 */
+static __always_inline void fe_sqr_impl(uint32_t out[10], const uint32_t in1[10])
+{
+	{ const uint32_t x17 = in1[9];
+	{ const uint32_t x18 = in1[8];
+	{ const uint32_t x16 = in1[7];
+	{ const uint32_t x14 = in1[6];
+	{ const uint32_t x12 = in1[5];
+	{ const uint32_t x10 = in1[4];
+	{ const uint32_t x8 = in1[3];
+	{ const uint32_t x6 = in1[2];
+	{ const uint32_t x4 = in1[1];
+	{ const uint32_t x2 = in1[0];
+	{ uint64_t x19 = ((uint64_t)x2 * x2);
+	{ uint64_t x20 = ((uint64_t)(0x2 * x2) * x4);
+	{ uint64_t x21 = (0x2 * (((uint64_t)x4 * x4) + ((uint64_t)x2 * x6)));
+	{ uint64_t x22 = (0x2 * (((uint64_t)x4 * x6) + ((uint64_t)x2 * x8)));
+	{ uint64_t x23 = ((((uint64_t)x6 * x6) + ((uint64_t)(0x4 * x4) * x8)) + ((uint64_t)(0x2 * x2) * x10));
+	{ uint64_t x24 = (0x2 * ((((uint64_t)x6 * x8) + ((uint64_t)x4 * x10)) + ((uint64_t)x2 * x12)));
+	{ uint64_t x25 = (0x2 * (((((uint64_t)x8 * x8) + ((uint64_t)x6 * x10)) + ((uint64_t)x2 * x14)) + ((uint64_t)(0x2 * x4) * x12)));
+	{ uint64_t x26 = (0x2 * (((((uint64_t)x8 * x10) + ((uint64_t)x6 * x12)) + ((uint64_t)x4 * x14)) + ((uint64_t)x2 * x16)));
+	{ uint64_t x27 = (((uint64_t)x10 * x10) + (0x2 * ((((uint64_t)x6 * x14) + ((uint64_t)x2 * x18)) + (0x2 * (((uint64_t)x4 * x16) + ((uint64_t)x8 * x12))))));
+	{ uint64_t x28 = (0x2 * ((((((uint64_t)x10 * x12) + ((uint64_t)x8 * x14)) + ((uint64_t)x6 * x16)) + ((uint64_t)x4 * x18)) + ((uint64_t)x2 * x17)));
+	{ uint64_t x29 = (0x2 * (((((uint64_t)x12 * x12) + ((uint64_t)x10 * x14)) + ((uint64_t)x6 * x18)) + (0x2 * (((uint64_t)x8 * x16) + ((uint64_t)x4 * x17)))));
+	{ uint64_t x30 = (0x2 * (((((uint64_t)x12 * x14) + ((uint64_t)x10 * x16)) + ((uint64_t)x8 * x18)) + ((uint64_t)x6 * x17)));
+	{ uint64_t x31 = (((uint64_t)x14 * x14) + (0x2 * (((uint64_t)x10 * x18) + (0x2 * (((uint64_t)x12 * x16) + ((uint64_t)x8 * x17))))));
+	{ uint64_t x32 = (0x2 * ((((uint64_t)x14 * x16) + ((uint64_t)x12 * x18)) + ((uint64_t)x10 * x17)));
+	{ uint64_t x33 = (0x2 * ((((uint64_t)x16 * x16) + ((uint64_t)x14 * x18)) + ((uint64_t)(0x2 * x12) * x17)));
+	{ uint64_t x34 = (0x2 * (((uint64_t)x16 * x18) + ((uint64_t)x14 * x17)));
+	{ uint64_t x35 = (((uint64_t)x18 * x18) + ((uint64_t)(0x4 * x16) * x17));
+	{ uint64_t x36 = ((uint64_t)(0x2 * x18) * x17);
+	{ uint64_t x37 = ((uint64_t)(0x2 * x17) * x17);
+	{ uint64_t x38 = (x27 + (x37 << 0x4));
+	{ uint64_t x39 = (x38 + (x37 << 0x1));
+	{ uint64_t x40 = (x39 + x37);
+	{ uint64_t x41 = (x26 + (x36 << 0x4));
+	{ uint64_t x42 = (x41 + (x36 << 0x1));
+	{ uint64_t x43 = (x42 + x36);
+	{ uint64_t x44 = (x25 + (x35 << 0x4));
+	{ uint64_t x45 = (x44 + (x35 << 0x1));
+	{ uint64_t x46 = (x45 + x35);
+	{ uint64_t x47 = (x24 + (x34 << 0x4));
+	{ uint64_t x48 = (x47 + (x34 << 0x1));
+	{ uint64_t x49 = (x48 + x34);
+	{ uint64_t x50 = (x23 + (x33 << 0x4));
+	{ uint64_t x51 = (x50 + (x33 << 0x1));
+	{ uint64_t x52 = (x51 + x33);
+	{ uint64_t x53 = (x22 + (x32 << 0x4));
+	{ uint64_t x54 = (x53 + (x32 << 0x1));
+	{ uint64_t x55 = (x54 + x32);
+	{ uint64_t x56 = (x21 + (x31 << 0x4));
+	{ uint64_t x57 = (x56 + (x31 << 0x1));
+	{ uint64_t x58 = (x57 + x31);
+	{ uint64_t x59 = (x20 + (x30 << 0x4));
+	{ uint64_t x60 = (x59 + (x30 << 0x1));
+	{ uint64_t x61 = (x60 + x30);
+	{ uint64_t x62 = (x19 + (x29 << 0x4));
+	{ uint64_t x63 = (x62 + (x29 << 0x1));
+	{ uint64_t x64 = (x63 + x29);
+	{ uint64_t x65 = (x64 >> 0x1a);
+	{ uint32_t x66 = ((uint32_t)x64 & 0x3ffffff);
+	{ uint64_t x67 = (x65 + x61);
+	{ uint64_t x68 = (x67 >> 0x19);
+	{ uint32_t x69 = ((uint32_t)x67 & 0x1ffffff);
+	{ uint64_t x70 = (x68 + x58);
+	{ uint64_t x71 = (x70 >> 0x1a);
+	{ uint32_t x72 = ((uint32_t)x70 & 0x3ffffff);
+	{ uint64_t x73 = (x71 + x55);
+	{ uint64_t x74 = (x73 >> 0x19);
+	{ uint32_t x75 = ((uint32_t)x73 & 0x1ffffff);
+	{ uint64_t x76 = (x74 + x52);
+	{ uint64_t x77 = (x76 >> 0x1a);
+	{ uint32_t x78 = ((uint32_t)x76 & 0x3ffffff);
+	{ uint64_t x79 = (x77 + x49);
+	{ uint64_t x80 = (x79 >> 0x19);
+	{ uint32_t x81 = ((uint32_t)x79 & 0x1ffffff);
+	{ uint64_t x82 = (x80 + x46);
+	{ uint64_t x83 = (x82 >> 0x1a);
+	{ uint32_t x84 = ((uint32_t)x82 & 0x3ffffff);
+	{ uint64_t x85 = (x83 + x43);
+	{ uint64_t x86 = (x85 >> 0x19);
+	{ uint32_t x87 = ((uint32_t)x85 & 0x1ffffff);
+	{ uint64_t x88 = (x86 + x40);
+	{ uint64_t x89 = (x88 >> 0x1a);
+	{ uint32_t x90 = ((uint32_t)x88 & 0x3ffffff);
+	{ uint64_t x91 = (x89 + x28);
+	{ uint64_t x92 = (x91 >> 0x19);
+	{ uint32_t x93 = ((uint32_t)x91 & 0x1ffffff);
+	{ uint64_t x94 = (x66 + (0x13 * x92));
+	{ uint32_t x95 = (uint32_t) (x94 >> 0x1a);
+	{ uint32_t x96 = ((uint32_t)x94 & 0x3ffffff);
+	{ uint32_t x97 = (x95 + x69);
+	{ uint32_t x98 = (x97 >> 0x19);
+	{ uint32_t x99 = (x97 & 0x1ffffff);
+	out[0] = x96;
+	out[1] = x99;
+	out[2] = (x98 + x72);
+	out[3] = x75;
+	out[4] = x78;
+	out[5] = x81;
+	out[6] = x84;
+	out[7] = x87;
+	out[8] = x90;
+	out[9] = x93;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
 
-	/* It still remains the case that input might be between 2^255-19 and 2^255.
-	 * In this case, input[1..9] must take their maximum value and input[0] must
-	 * be >= (2^255-19) & 0x3ffffff, which is 0x3ffffed.
-	 */
-	mask = int32_t_gte(input[0], 0x3ffffed);
-	for (i = 1; i < 10; i++) {
-		if ((i & 1) == 1) {
-			mask &= int32_t_eq(input[i], 0x1ffffff);
-		} else {
-			mask &= int32_t_eq(input[i], 0x3ffffff);
-		}
-	}
+static __always_inline void fe_sq_tl(fe *h, const fe_loose *f)
+{
+	fe_sqr_impl(h->v, f->v);
+}
 
-	/* mask is either 0xffffffff (if input >= 2^255-19) and zero otherwise. Thus
-	 * this conditionally subtracts 2^255-19.
-	 */
-	input[0] -= mask & 0x3ffffed;
-
-	for (i = 1; i < 10; i++) {
-		if ((i & 1) == 1) {
-			input[i] -= mask & 0x1ffffff;
-		} else {
-			input[i] -= mask & 0x3ffffff;
-		}
-	}
+static __always_inline void fe_sq_tt(fe *h, const fe *f)
+{
+	fe_sqr_impl(h->v, f->v);
+}
 
-	input[1] <<= 2;
-	input[2] <<= 3;
-	input[3] <<= 5;
-	input[4] <<= 6;
-	input[6] <<= 1;
-	input[7] <<= 3;
-	input[8] <<= 4;
-	input[9] <<= 6;
-#define F(i, s) \
-	output[s+0] |=  input[i] & 0xff; \
-	output[s+1]  = (input[i] >> 8) & 0xff; \
-	output[s+2]  = (input[i] >> 16) & 0xff; \
-	output[s+3]  = (input[i] >> 24) & 0xff;
-	output[0] = 0;
-	output[16] = 0;
-	F(0, 0);
-	F(1, 3);
-	F(2, 6);
-	F(3, 9);
-	F(4, 12);
-	F(5, 16);
-	F(6, 19);
-	F(7, 22);
-	F(8, 25);
-	F(9, 28);
-#undef F
-}
-
-/* Input: Q, Q', Q-Q'
- * Output: 2Q, Q+Q'
- *
- *   x2 z3: long form
- *   x3 z3: long form
- *   x z: short form, destroyed
- *   xprime zprime: short form, destroyed
- *   qmqp: short form, preserved
- *
- * On entry and exit, the absolute value of the limbs of all inputs and outputs
- * are < 2^26.
- */
-static void fmonty(limb *x2, limb *z2,  /* output 2Q */
-		   limb *x3, limb *z3,  /* output Q + Q' */
-		   limb *x, limb *z,	/* input Q */
-		   limb *xprime, limb *zprime,  /* input Q' */
-
-		   const limb *qmqp /* input Q - Q' */)
-{
-	limb origx[10], origxprime[10], zzz[19], xx[19], zz[19], xxprime[19],
-				zzprime[19], zzzprime[19], xxxprime[19];
-
-	__builtin_memcpy(origx, x, 10 * sizeof(limb));
-	fsum(x, z);
-	/* |x[i]| < 2^27 */
-	fdifference(z, origx);  /* does x - z */
-	/* |z[i]| < 2^27 */
-
-	__builtin_memcpy(origxprime, xprime, sizeof(limb) * 10);
-	fsum(xprime, zprime);
-	/* |xprime[i]| < 2^27 */
-	fdifference(zprime, origxprime);
-	/* |zprime[i]| < 2^27 */
-	fproduct(xxprime, xprime, z);
-	/* |xxprime[i]| < 14*2^54: the largest product of two limbs will be <
-	 * 2^(27+27) and fproduct adds together, at most, 14 of those products.
-	 * (Approximating that to 2^58 doesn't work out.)
-	 */
-	fproduct(zzprime, x, zprime);
-	/* |zzprime[i]| < 14*2^54 */
-	freduce_degree(xxprime);
-	freduce_coefficients(xxprime);
-	/* |xxprime[i]| < 2^26 */
-	freduce_degree(zzprime);
-	freduce_coefficients(zzprime);
-	/* |zzprime[i]| < 2^26 */
-	__builtin_memcpy(origxprime, xxprime, sizeof(limb) * 10);
-	fsum(xxprime, zzprime);
-	/* |xxprime[i]| < 2^27 */
-	fdifference(zzprime, origxprime);
-	/* |zzprime[i]| < 2^27 */
-	fsquare(xxxprime, xxprime);
-	/* |xxxprime[i]| < 2^26 */
-	fsquare(zzzprime, zzprime);
-	/* |zzzprime[i]| < 2^26 */
-	fproduct(zzprime, zzzprime, qmqp);
-	/* |zzprime[i]| < 14*2^52 */
-	freduce_degree(zzprime);
-	freduce_coefficients(zzprime);
-	/* |zzprime[i]| < 2^26 */
-	__builtin_memcpy(x3, xxxprime, sizeof(limb) * 10);
-	__builtin_memcpy(z3, zzprime, sizeof(limb) * 10);
-
-	fsquare(xx, x);
-	/* |xx[i]| < 2^26 */
-	fsquare(zz, z);
-	/* |zz[i]| < 2^26 */
-	fproduct(x2, xx, zz);
-	/* |x2[i]| < 14*2^52 */
-	freduce_degree(x2);
-	freduce_coefficients(x2);
-	/* |x2[i]| < 2^26 */
-	fdifference(zz, xx);  // does zz = xx - zz
-	/* |zz[i]| < 2^27 */
-	__builtin_memset(zzz + 10, 0, sizeof(limb) * 9);
-	fscalar_product(zzz, zz, 121665);
-	/* |zzz[i]| < 2^(27+17) */
-	/* No need to call freduce_degree here:
-		 fscalar_product doesn't increase the degree of its input. */
-	freduce_coefficients(zzz);
-	/* |zzz[i]| < 2^26 */
-	fsum(zzz, xx);
-	/* |zzz[i]| < 2^27 */
-	fproduct(z2, zz, zzz);
-	/* |z2[i]| < 14*2^(26+27) */
-	freduce_degree(z2);
-	freduce_coefficients(z2);
-	/* |z2|i| < 2^26 */
-}
-
-/* Conditionally swap two reduced-form limb arrays if 'iswap' is 1, but leave
- * them unchanged if 'iswap' is 0.  Runs in data-invariant time to avoid
- * side-channel attacks.
- *
- * NOTE that this function requires that 'iswap' be 1 or 0; other values give
- * wrong results.  Also, the two limb arrays must be in reduced-coefficient,
- * reduced-degree form: the values in a[10..19] or b[10..19] aren't swapped,
- * and all all values in a[0..9],b[0..9] must have magnitude less than
- * INT32_MAX.
- */
-static void swap_conditional(limb a[static 19], limb b[static 19], limb iswap)
+static __always_inline void fe_loose_invert(fe *out, const fe_loose *z)
 {
-	unsigned int i;
-	const int32_t swap = (int32_t) -iswap;
+	fe t0;
+	fe t1;
+	fe t2;
+	fe t3;
+	int i;
 
-	for (i = 0; i < 10; ++i) {
-		const int32_t x = swap & (((int32_t)a[i]) ^ ((int32_t)b[i]));
+	fe_sq_tl(&t0, z);
+	fe_sq_tt(&t1, &t0);
+	for (i = 1; i < 2; ++i)
+		fe_sq_tt(&t1, &t1);
+	fe_mul_tlt(&t1, z, &t1);
+	fe_mul_ttt(&t0, &t0, &t1);
+	fe_sq_tt(&t2, &t0);
+	fe_mul_ttt(&t1, &t1, &t2);
+	fe_sq_tt(&t2, &t1);
+	for (i = 1; i < 5; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t1, &t2, &t1);
+	fe_sq_tt(&t2, &t1);
+	for (i = 1; i < 10; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t2, &t2, &t1);
+	fe_sq_tt(&t3, &t2);
+	for (i = 1; i < 20; ++i)
+		fe_sq_tt(&t3, &t3);
+	fe_mul_ttt(&t2, &t3, &t2);
+	fe_sq_tt(&t2, &t2);
+	for (i = 1; i < 10; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t1, &t2, &t1);
+	fe_sq_tt(&t2, &t1);
+	for (i = 1; i < 50; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t2, &t2, &t1);
+	fe_sq_tt(&t3, &t2);
+	for (i = 1; i < 100; ++i)
+		fe_sq_tt(&t3, &t3);
+	fe_mul_ttt(&t2, &t3, &t2);
+	fe_sq_tt(&t2, &t2);
+	for (i = 1; i < 50; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t1, &t2, &t1);
+	fe_sq_tt(&t1, &t1);
+	for (i = 1; i < 5; ++i)
+		fe_sq_tt(&t1, &t1);
+	fe_mul_ttt(out, &t1, &t0);
+}
 
-		a[i] = ((int32_t)a[i]) ^ x;
-		b[i] = ((int32_t)b[i]) ^ x;
-	}
+static __always_inline void fe_invert(fe *out, const fe *z)
+{
+	fe_loose l;
+	fe_copy_lt(&l, z);
+	fe_loose_invert(out, &l);
 }
 
-/* Calculates nQ where Q is the x-coordinate of a point on the curve
+/* Replace (f,g) with (g,f) if b == 1;
+ * replace (f,g) with (f,g) if b == 0.
  *
- *   resultx/resultz: the x coordinate of the resulting curve point (short form)
- *   n: a little endian, 32-byte number
- *   q: a point of the curve (short form)
+ * Preconditions: b in {0,1}
  */
-static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
-{
-	limb a[19] = {0}, b[19] = {1}, c[19] = {1}, d[19] = {0};
-	limb *nqpqx = a, *nqpqz = b, *nqx = c, *nqz = d, *t;
-	limb e[19] = {0}, f[19] = {1}, g[19] = {0}, h[19] = {1};
-	limb *nqpqx2 = e, *nqpqz2 = f, *nqx2 = g, *nqz2 = h;
-
-	unsigned int i, j;
-
-	__builtin_memcpy(nqpqx, q, sizeof(limb) * 10);
-
-	for (i = 0; i < 32; ++i) {
-		uint8_t byte = n[31 - i];
-
-		for (j = 0; j < 8; ++j) {
-			const limb bit = byte >> 7;
-
-			swap_conditional(nqx, nqpqx, bit);
-			swap_conditional(nqz, nqpqz, bit);
-			fmonty(nqx2, nqz2,
-				   nqpqx2, nqpqz2,
-				   nqx, nqz,
-				   nqpqx, nqpqz,
-				   q);
-			swap_conditional(nqx2, nqpqx2, bit);
-			swap_conditional(nqz2, nqpqz2, bit);
-
-			t = nqx;
-			nqx = nqx2;
-			nqx2 = t;
-			t = nqz;
-			nqz = nqz2;
-			nqz2 = t;
-			t = nqpqx;
-			nqpqx = nqpqx2;
-			nqpqx2 = t;
-			t = nqpqz;
-			nqpqz = nqpqz2;
-			nqpqz2 = t;
-
-			byte <<= 1;
-		}
+static __always_inline void fe_cswap(fe *f, fe *g, unsigned int b)
+{
+	unsigned i;
+	b = 0-b;
+	for (i = 0; i < 10; i++) {
+		uint32_t x = f->v[i] ^ g->v[i];
+		x &= b;
+		f->v[i] ^= x;
+		g->v[i] ^= x;
 	}
+}
 
-	__builtin_memcpy(resultx, nqx, sizeof(limb) * 10);
-	__builtin_memcpy(resultz, nqz, sizeof(limb) * 10);
+/* NOTE: based on fiat-crypto fe_mul, edited for in2=121666, 0, 0.*/
+static __always_inline void fe_mul_121666_impl(uint32_t out[10], const uint32_t in1[10])
+{
+	{ const uint32_t x20 = in1[9];
+	{ const uint32_t x21 = in1[8];
+	{ const uint32_t x19 = in1[7];
+	{ const uint32_t x17 = in1[6];
+	{ const uint32_t x15 = in1[5];
+	{ const uint32_t x13 = in1[4];
+	{ const uint32_t x11 = in1[3];
+	{ const uint32_t x9 = in1[2];
+	{ const uint32_t x7 = in1[1];
+	{ const uint32_t x5 = in1[0];
+	{ const uint32_t x38 = 0;
+	{ const uint32_t x39 = 0;
+	{ const uint32_t x37 = 0;
+	{ const uint32_t x35 = 0;
+	{ const uint32_t x33 = 0;
+	{ const uint32_t x31 = 0;
+	{ const uint32_t x29 = 0;
+	{ const uint32_t x27 = 0;
+	{ const uint32_t x25 = 0;
+	{ const uint32_t x23 = 121666;
+	{ uint64_t x40 = ((uint64_t)x23 * x5);
+	{ uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));
+	{ uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));
+	{ uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));
+	{ uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));
+	{ uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));
+	{ uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));
+	{ uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));
+	{ uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));
+	{ uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));
+	{ uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));
+	{ uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));
+	{ uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));
+	{ uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));
+	{ uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));
+	{ uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));
+	{ uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));
+	{ uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));
+	{ uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);
+	{ uint64_t x59 = (x48 + (x58 << 0x4));
+	{ uint64_t x60 = (x59 + (x58 << 0x1));
+	{ uint64_t x61 = (x60 + x58);
+	{ uint64_t x62 = (x47 + (x57 << 0x4));
+	{ uint64_t x63 = (x62 + (x57 << 0x1));
+	{ uint64_t x64 = (x63 + x57);
+	{ uint64_t x65 = (x46 + (x56 << 0x4));
+	{ uint64_t x66 = (x65 + (x56 << 0x1));
+	{ uint64_t x67 = (x66 + x56);
+	{ uint64_t x68 = (x45 + (x55 << 0x4));
+	{ uint64_t x69 = (x68 + (x55 << 0x1));
+	{ uint64_t x70 = (x69 + x55);
+	{ uint64_t x71 = (x44 + (x54 << 0x4));
+	{ uint64_t x72 = (x71 + (x54 << 0x1));
+	{ uint64_t x73 = (x72 + x54);
+	{ uint64_t x74 = (x43 + (x53 << 0x4));
+	{ uint64_t x75 = (x74 + (x53 << 0x1));
+	{ uint64_t x76 = (x75 + x53);
+	{ uint64_t x77 = (x42 + (x52 << 0x4));
+	{ uint64_t x78 = (x77 + (x52 << 0x1));
+	{ uint64_t x79 = (x78 + x52);
+	{ uint64_t x80 = (x41 + (x51 << 0x4));
+	{ uint64_t x81 = (x80 + (x51 << 0x1));
+	{ uint64_t x82 = (x81 + x51);
+	{ uint64_t x83 = (x40 + (x50 << 0x4));
+	{ uint64_t x84 = (x83 + (x50 << 0x1));
+	{ uint64_t x85 = (x84 + x50);
+	{ uint64_t x86 = (x85 >> 0x1a);
+	{ uint32_t x87 = ((uint32_t)x85 & 0x3ffffff);
+	{ uint64_t x88 = (x86 + x82);
+	{ uint64_t x89 = (x88 >> 0x19);
+	{ uint32_t x90 = ((uint32_t)x88 & 0x1ffffff);
+	{ uint64_t x91 = (x89 + x79);
+	{ uint64_t x92 = (x91 >> 0x1a);
+	{ uint32_t x93 = ((uint32_t)x91 & 0x3ffffff);
+	{ uint64_t x94 = (x92 + x76);
+	{ uint64_t x95 = (x94 >> 0x19);
+	{ uint32_t x96 = ((uint32_t)x94 & 0x1ffffff);
+	{ uint64_t x97 = (x95 + x73);
+	{ uint64_t x98 = (x97 >> 0x1a);
+	{ uint32_t x99 = ((uint32_t)x97 & 0x3ffffff);
+	{ uint64_t x100 = (x98 + x70);
+	{ uint64_t x101 = (x100 >> 0x19);
+	{ uint32_t x102 = ((uint32_t)x100 & 0x1ffffff);
+	{ uint64_t x103 = (x101 + x67);
+	{ uint64_t x104 = (x103 >> 0x1a);
+	{ uint32_t x105 = ((uint32_t)x103 & 0x3ffffff);
+	{ uint64_t x106 = (x104 + x64);
+	{ uint64_t x107 = (x106 >> 0x19);
+	{ uint32_t x108 = ((uint32_t)x106 & 0x1ffffff);
+	{ uint64_t x109 = (x107 + x61);
+	{ uint64_t x110 = (x109 >> 0x1a);
+	{ uint32_t x111 = ((uint32_t)x109 & 0x3ffffff);
+	{ uint64_t x112 = (x110 + x49);
+	{ uint64_t x113 = (x112 >> 0x19);
+	{ uint32_t x114 = ((uint32_t)x112 & 0x1ffffff);
+	{ uint64_t x115 = (x87 + (0x13 * x113));
+	{ uint32_t x116 = (uint32_t) (x115 >> 0x1a);
+	{ uint32_t x117 = ((uint32_t)x115 & 0x3ffffff);
+	{ uint32_t x118 = (x116 + x90);
+	{ uint32_t x119 = (x118 >> 0x19);
+	{ uint32_t x120 = (x118 & 0x1ffffff);
+	out[0] = x117;
+	out[1] = x120;
+	out[2] = (x119 + x93);
+	out[3] = x96;
+	out[4] = x99;
+	out[5] = x102;
+	out[6] = x105;
+	out[7] = x108;
+	out[8] = x111;
+	out[9] = x114;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
 }
 
-static void crecip(limb *out, const limb *z)
+static __always_inline void fe_mul121666(fe *h, const fe_loose *f)
 {
-	limb z2[10];
-	limb z9[10];
-	limb z11[10];
-	limb z2_5_0[10];
-	limb z2_10_0[10];
-	limb z2_20_0[10];
-	limb z2_50_0[10];
-	limb z2_100_0[10];
-	limb t0[10];
-	limb t1[10];
-	int i;
+	fe_mul_121666_impl(h->v, f->v);
+}
 
-	/* 2 */ fsquare(z2, z);
-	/* 4 */ fsquare(t1, z2);
-	/* 8 */ fsquare(t0, t1);
-	/* 9 */ fmul(z9, t0, z);
-	/* 11 */ fmul(z11, z9, z2);
-	/* 22 */ fsquare(t0, z11);
-	/* 2^5 - 2^0 = 31 */ fmul(z2_5_0, t0, z9);
-
-	/* 2^6 - 2^1 */ fsquare(t0, z2_5_0);
-	/* 2^7 - 2^2 */ fsquare(t1, t0);
-	/* 2^8 - 2^3 */ fsquare(t0, t1);
-	/* 2^9 - 2^4 */ fsquare(t1, t0);
-	/* 2^10 - 2^5 */ fsquare(t0, t1);
-	/* 2^10 - 2^0 */ fmul(z2_10_0, t0, z2_5_0);
-
-	/* 2^11 - 2^1 */ fsquare(t0, z2_10_0);
-	/* 2^12 - 2^2 */ fsquare(t1, t0);
-	/* 2^20 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
-	/* 2^20 - 2^0 */ fmul(z2_20_0, t1, z2_10_0);
-
-	/* 2^21 - 2^1 */ fsquare(t0, z2_20_0);
-	/* 2^22 - 2^2 */ fsquare(t1, t0);
-	/* 2^40 - 2^20 */ for (i = 2; i < 20; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
-	/* 2^40 - 2^0 */ fmul(t0, t1, z2_20_0);
-
-	/* 2^41 - 2^1 */ fsquare(t1, t0);
-	/* 2^42 - 2^2 */ fsquare(t0, t1);
-	/* 2^50 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t1, t0); fsquare(t0, t1); }
-	/* 2^50 - 2^0 */ fmul(z2_50_0, t0, z2_10_0);
-
-	/* 2^51 - 2^1 */ fsquare(t0, z2_50_0);
-	/* 2^52 - 2^2 */ fsquare(t1, t0);
-	/* 2^100 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
-	/* 2^100 - 2^0 */ fmul(z2_100_0, t1, z2_50_0);
-
-	/* 2^101 - 2^1 */ fsquare(t1, z2_100_0);
-	/* 2^102 - 2^2 */ fsquare(t0, t1);
-	/* 2^200 - 2^100 */ for (i = 2; i < 100; i += 2) { fsquare(t1, t0); fsquare(t0, t1); }
-	/* 2^200 - 2^0 */ fmul(t1, t0, z2_100_0);
-
-	/* 2^201 - 2^1 */ fsquare(t0, t1);
-	/* 2^202 - 2^2 */ fsquare(t1, t0);
-	/* 2^250 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
-	/* 2^250 - 2^0 */ fmul(t0, t1, z2_50_0);
-
-	/* 2^251 - 2^1 */ fsquare(t1, t0);
-	/* 2^252 - 2^2 */ fsquare(t0, t1);
-	/* 2^253 - 2^3 */ fsquare(t1, t0);
-	/* 2^254 - 2^4 */ fsquare(t0, t1);
-	/* 2^255 - 2^5 */ fsquare(t1, t0);
-	/* 2^255 - 21 */ fmul(out, t1, z11);
-}
-
-static inline void curve25519_normalize_secret(uint8_t secret[static 32])
+static __always_inline void normalize_secret(uint8_t secret[static 32])
 {
 	secret[0] &= 248;
 	secret[31] &= 127;
 	secret[31] |= 64;
 }
-static inline void curve25519(uint8_t mypublic[static 32], const uint8_t secret[static 32], const uint8_t basepoint[static 32])
+
+static void curve25519(uint8_t out[static 32], const uint8_t scalar[static 32], const uint8_t point[static 32])
 {
-	limb bp[10], x[10], z[11], zmone[10];
+	fe x1, x2, z2, x3, z3, tmp0, tmp1;
+	fe_loose x2l, z2l, x3l, tmp0l, tmp1l;
+	unsigned swap = 0;
+	int pos;
 	uint8_t e[32];
 
-	__builtin_memcpy(e, secret, 32);
-	curve25519_normalize_secret(e);
+	__builtin_memcpy(e, scalar, 32);
+	normalize_secret(e);
+
+	/* The following implementation was transcribed to Coq and proven to
+	 * correspond to unary scalar multiplication in affine coordinates given that
+	 * x1 != 0 is the x coordinate of some point on the curve. It was also checked
+	 * in Coq that doing a ladderstep with x1 = x3 = 0 gives z2' = z3' = 0, and z2
+	 * = z3 = 0 gives z2' = z3' = 0. The statement was quantified over the
+	 * underlying field, so it applies to Curve25519 itself and the quadratic
+	 * twist of Curve25519. It was not proven in Coq that prime-field arithmetic
+	 * correctly simulates extension-field arithmetic on prime-field values.
+	 * The decoding of the byte array representation of e was not considered.
+	 * Specification of Montgomery curves in affine coordinates:
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Spec/MontgomeryCurve.v#L27>
+	 * Proof that these form a group that is isomorphic to a Weierstrass curve:
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/AffineProofs.v#L35>
+	 * Coq transcription and correctness proof of the loop (where scalarbits=255):
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L118>
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L278>
+	 * preconditions: 0 <= e < 2^255 (not necessarily e < order), fe_invert(0) = 0
+	 */
+	fe_frombytes(&x1, point);
+	fe_1(&x2);
+	fe_0(&z2);
+	fe_copy(&x3, &x1);
+	fe_1(&z3);
+
+	for (pos = 254; pos >= 0; --pos) {
+		/* loop invariant as of right before the test, for the case where x1 != 0:
+		 *   pos >= -1; if z2 = 0 then x2 is nonzero; if z3 = 0 then x3 is nonzero
+		 *   let r := e >> (pos+1) in the following equalities of projective points:
+		 *   to_xz (r*P)     === if swap then (x3, z3) else (x2, z2)
+		 *   to_xz ((r+1)*P) === if swap then (x2, z2) else (x3, z3)
+		 *   x1 is the nonzero x coordinate of the nonzero point (r*P-(r+1)*P)
+		 */
+		unsigned b = 1 & (e[pos / 8] >> (pos & 7));
+		swap ^= b;
+		fe_cswap(&x2, &x3, swap);
+		fe_cswap(&z2, &z3, swap);
+		swap = b;
+		/* Coq transcription of ladderstep formula (called from transcribed loop):
+		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L89>
+		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L131>
+		 * x1 != 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L217>
+		 * x1  = 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L147>
+		 */
+		fe_sub(&tmp0l, &x3, &z3);
+		fe_sub(&tmp1l, &x2, &z2);
+		fe_add(&x2l, &x2, &z2);
+		fe_add(&z2l, &x3, &z3);
+		fe_mul_tll(&z3, &tmp0l, &x2l);
+		fe_mul_tll(&z2, &z2l, &tmp1l);
+		fe_sq_tl(&tmp0, &tmp1l);
+		fe_sq_tl(&tmp1, &x2l);
+		fe_add(&x3l, &z3, &z2);
+		fe_sub(&z2l, &z3, &z2);
+		fe_mul_ttt(&x2, &tmp1, &tmp0);
+		fe_sub(&tmp1l, &tmp1, &tmp0);
+		fe_sq_tl(&z2, &z2l);
+		fe_mul121666(&z3, &tmp1l);
+		fe_sq_tl(&x3, &x3l);
+		fe_add(&tmp0l, &tmp0, &z3);
+		fe_mul_ttt(&z3, &x1, &z2);
+		fe_mul_tll(&z2, &tmp1l, &tmp0l);
+	}
+	/* here pos=-1, so r=e, so to_xz (e*P) === if swap then (x3, z3) else (x2, z2) */
+	fe_cswap(&x2, &x3, swap);
+	fe_cswap(&z2, &z3, swap);
 
-	fexpand(bp, basepoint);
-	cmult(x, z, e, bp);
-	crecip(zmone, z);
-	fmul(z, x, zmone);
-	fcontract(mypublic, z);
+	fe_invert(&z2, &z2);
+	fe_mul_ttt(&x2, &x2, &z2);
+	fe_tobytes(out, &x2);
 }
 
 EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(uint8_t public[static 32], const uint8_t private[static 32])
@@ -889,7 +873,7 @@ EMSCRIPTEN_KEEPALIVE void curve25519_generate_private(uint8_t private[static 32]
 	
 	for (i = 0; i < 32; ++i)
 		private[i] = EM_ASM_INT_V({ return Module.getRandomValue(); });
-	curve25519_normalize_secret(private);
+	normalize_secret(private);
 }
 
 static inline void encode_base64(char dest[4], const uint8_t src[3])

commit feea1e6f30f5a48679ddb73e9dbe74144055ef57
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 18 11:46:01 2018 +0100

    wg: import new curve25519 implementations
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/curve25519.c b/src/curve25519.c
index 3e770b2..ee7df84 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -1,1277 +1,1571 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2008 Google Inc. All Rights Reserved.
- * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2016-2017 INRIA and Microsoft Corporation.
+ * Copyright (C) 2015-2016 The fiat-crypto Authors.
+ * Copyright (C) 2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
- * Original author: Adam Langley <agl@imperialviolet.org>
+ * This is a machine-generated formally verified implementation of curve25519 DH from:
+ * https://github.com/mitls/hacl-star and https://github.com/mit-plv/fiat-crypto
  */
 
 #include "curve25519.h"
 
 #include <stdint.h>
 #include <string.h>
+#include <endian.h>
 
 #ifndef __always_inline
 #define __always_inline __inline __attribute__((__always_inline__))
 #endif
 
+#ifndef __aligned
+#define __aligned(x) __attribute__((aligned(x)))
+#endif
+
 #ifdef __SIZEOF_INT128__
-typedef uint64_t limb;
-typedef limb felem[5];
 typedef __uint128_t uint128_t;
 
-/* Sum two numbers: output += in */
-static __always_inline void fsum(limb *output, const limb *in)
+static __always_inline uint64_t uint64_t_eq_mask(uint64_t x, uint64_t y)
 {
-	output[0] += in[0];
-	output[1] += in[1];
-	output[2] += in[2];
-	output[3] += in[3];
-	output[4] += in[4];
+	x = ~(x ^ y);
+	x &= x << 32;
+	x &= x << 16;
+	x &= x << 8;
+	x &= x << 4;
+	x &= x << 2;
+	x &= x << 1;
+	return ((int64_t)x) >> 63;
 }
 
-/* Find the difference of two numbers: output = in - output
- * (note the order of the arguments!)
- *
- * Assumes that out[i] < 2**52
- * On return, out[i] < 2**55
- */
-static __always_inline void fdifference_backwards(felem out, const felem in)
+static __always_inline uint64_t uint64_t_gte_mask(uint64_t x, uint64_t y)
 {
-	/* 152 is 19 << 3 */
-	static const limb two54m152 = (((limb)1) << 54) - 152;
-	static const limb two54m8 = (((limb)1) << 54) - 8;
+	uint64_t low63 = ~((uint64_t)((int64_t)((int64_t)(x & 0x7fffffffffffffffLLU) - (int64_t)(y & 0x7fffffffffffffffLLU)) >> 63));
+	uint64_t high_bit = ~((uint64_t)((int64_t)((int64_t)(x & 0x8000000000000000LLU) - (int64_t)(y & 0x8000000000000000LLU)) >> 63));
+	return low63 & high_bit;
+}
 
-	out[0] = in[0] + two54m152 - out[0];
-	out[1] = in[1] + two54m8 - out[1];
-	out[2] = in[2] + two54m8 - out[2];
-	out[3] = in[3] + two54m8 - out[3];
-	out[4] = in[4] + two54m8 - out[4];
+static __always_inline void modulo_carry_top(uint64_t *b)
+{
+	uint64_t b4 = b[4];
+	uint64_t b0 = b[0];
+	uint64_t b4_ = b4 & 0x7ffffffffffffLLU;
+	uint64_t b0_ = b0 + 19 * (b4 >> 51);
+	b[4] = b4_;
+	b[0] = b0_;
 }
 
-/* Multiply a number by a scalar: output = in * scalar */
-static __always_inline void fscalar_product(felem output, const felem in, const limb scalar)
+static __always_inline void fproduct_copy_from_wide_(uint64_t *output, uint128_t *input)
 {
-	uint128_t a;
+	{
+		uint128_t xi = input[0];
+		output[0] = ((uint64_t)(xi));
+	}
+	{
+		uint128_t xi = input[1];
+		output[1] = ((uint64_t)(xi));
+	}
+	{
+		uint128_t xi = input[2];
+		output[2] = ((uint64_t)(xi));
+	}
+	{
+		uint128_t xi = input[3];
+		output[3] = ((uint64_t)(xi));
+	}
+	{
+		uint128_t xi = input[4];
+		output[4] = ((uint64_t)(xi));
+	}
+}
 
-	a = ((uint128_t) in[0]) * scalar;
-	output[0] = ((limb)a) & 0x7ffffffffffffUL;
+static __always_inline void fproduct_sum_scalar_multiplication_(uint128_t *output, uint64_t *input, uint64_t s)
+{
+	uint32_t i;
+	for (i = 0; i < 5; ++i) {
+		uint128_t xi = output[i];
+		uint64_t yi = input[i];
+		output[i] = ((xi) + (((uint128_t)(yi) * (s))));
+	}
+}
 
-	a = ((uint128_t) in[1]) * scalar + ((limb) (a >> 51));
-	output[1] = ((limb)a) & 0x7ffffffffffffUL;
+static __always_inline void fproduct_carry_wide_(uint128_t *tmp)
+{
+	uint32_t i;
+	for (i = 0; i < 4; ++i) {
+		uint32_t ctr = i;
+		uint128_t tctr = tmp[ctr];
+		uint128_t tctrp1 = tmp[ctr + 1];
+		uint64_t r0 = ((uint64_t)(tctr)) & 0x7ffffffffffffLLU;
+		uint128_t c = ((tctr) >> (51));
+		tmp[ctr] = ((uint128_t)(r0));
+		tmp[ctr + 1] = ((tctrp1) + (c));
+	}
+}
 
-	a = ((uint128_t) in[2]) * scalar + ((limb) (a >> 51));
-	output[2] = ((limb)a) & 0x7ffffffffffffUL;
+static __always_inline void fmul_shift_reduce(uint64_t *output)
+{
+	uint64_t tmp = output[4];
+	uint64_t b0;
+	{
+		uint32_t ctr = 5 - 0 - 1;
+		uint64_t z = output[ctr - 1];
+		output[ctr] = z;
+	}
+	{
+		uint32_t ctr = 5 - 1 - 1;
+		uint64_t z = output[ctr - 1];
+		output[ctr] = z;
+	}
+	{
+		uint32_t ctr = 5 - 2 - 1;
+		uint64_t z = output[ctr - 1];
+		output[ctr] = z;
+	}
+	{
+		uint32_t ctr = 5 - 3 - 1;
+		uint64_t z = output[ctr - 1];
+		output[ctr] = z;
+	}
+	output[0] = tmp;
+	b0 = output[0];
+	output[0] = 19 * b0;
+}
 
-	a = ((uint128_t) in[3]) * scalar + ((limb) (a >> 51));
-	output[3] = ((limb)a) & 0x7ffffffffffffUL;
+static __always_inline void fmul_mul_shift_reduce_(uint128_t *output, uint64_t *input, uint64_t *input21)
+{
+	uint32_t i;
+	uint64_t input2i;
+	{
+		uint64_t input2i = input21[0];
+		fproduct_sum_scalar_multiplication_(output, input, input2i);
+		fmul_shift_reduce(input);
+	}
+	{
+		uint64_t input2i = input21[1];
+		fproduct_sum_scalar_multiplication_(output, input, input2i);
+		fmul_shift_reduce(input);
+	}
+	{
+		uint64_t input2i = input21[2];
+		fproduct_sum_scalar_multiplication_(output, input, input2i);
+		fmul_shift_reduce(input);
+	}
+	{
+		uint64_t input2i = input21[3];
+		fproduct_sum_scalar_multiplication_(output, input, input2i);
+		fmul_shift_reduce(input);
+	}
+	i = 4;
+	input2i = input21[i];
+	fproduct_sum_scalar_multiplication_(output, input, input2i);
+}
 
-	a = ((uint128_t) in[4]) * scalar + ((limb) (a >> 51));
-	output[4] = ((limb)a) & 0x7ffffffffffffUL;
+static __always_inline void fmul_fmul(uint64_t *output, uint64_t *input, uint64_t *input21)
+{
+	uint64_t tmp[5];
+	memcpy(tmp, input, 5 * sizeof(*input));
+	{
+		uint128_t b4;
+		uint128_t b0;
+		uint128_t b4_;
+		uint128_t b0_;
+		uint64_t i0;
+		uint64_t i1;
+		uint64_t i0_;
+		uint64_t i1_;
+		uint128_t t[5];
+		{
+			uint32_t _i;
+			for (_i = 0; _i < 5; ++_i)
+				t[_i] = ((uint128_t)(0));
+		}
+		fmul_mul_shift_reduce_(t, tmp, input21);
+		fproduct_carry_wide_(t);
+		b4 = t[4];
+		b0 = t[0];
+		b4_ = ((b4) & (((uint128_t)(0x7ffffffffffffLLU))));
+		b0_ = ((b0) + (((uint128_t)(19) * (((uint64_t)(((b4) >> (51))))))));
+		t[4] = b4_;
+		t[0] = b0_;
+		fproduct_copy_from_wide_(output, t);
+		i0 = output[0];
+		i1 = output[1];
+		i0_ = i0 & 0x7ffffffffffffLLU;
+		i1_ = i1 + (i0 >> 51);
+		output[0] = i0_;
+		output[1] = i1_;
+	}
+}
 
-	output[0] += (a >> 51) * 19;
+static __always_inline void fsquare_fsquare__(uint128_t *tmp, uint64_t *output)
+{
+	uint64_t r0 = output[0];
+	uint64_t r1 = output[1];
+	uint64_t r2 = output[2];
+	uint64_t r3 = output[3];
+	uint64_t r4 = output[4];
+	uint64_t d0 = r0 * 2;
+	uint64_t d1 = r1 * 2;
+	uint64_t d2 = r2 * 2 * 19;
+	uint64_t d419 = r4 * 19;
+	uint64_t d4 = d419 * 2;
+	uint128_t s0 = ((((((uint128_t)(r0) * (r0))) + (((uint128_t)(d4) * (r1))))) + (((uint128_t)(d2) * (r3))));
+	uint128_t s1 = ((((((uint128_t)(d0) * (r1))) + (((uint128_t)(d4) * (r2))))) + (((uint128_t)(r3 * 19) * (r3))));
+	uint128_t s2 = ((((((uint128_t)(d0) * (r2))) + (((uint128_t)(r1) * (r1))))) + (((uint128_t)(d4) * (r3))));
+	uint128_t s3 = ((((((uint128_t)(d0) * (r3))) + (((uint128_t)(d1) * (r2))))) + (((uint128_t)(r4) * (d419))));
+	uint128_t s4 = ((((((uint128_t)(d0) * (r4))) + (((uint128_t)(d1) * (r3))))) + (((uint128_t)(r2) * (r2))));
+	tmp[0] = s0;
+	tmp[1] = s1;
+	tmp[2] = s2;
+	tmp[3] = s3;
+	tmp[4] = s4;
 }
 
-/* Multiply two numbers: output = in2 * in
- *
- * output must be distinct to both inputs. The inputs are reduced coefficient
- * form, the output is not.
- *
- * Assumes that in[i] < 2**55 and likewise for in2.
- * On return, output[i] < 2**52
- */
-static __always_inline void fmul(felem output, const felem in2, const felem in)
+static __always_inline void fsquare_fsquare_(uint128_t *tmp, uint64_t *output)
 {
-	uint128_t t[5];
-	limb r0, r1, r2, r3, r4, s0, s1, s2, s3, s4, c;
-
-	r0 = in[0];
-	r1 = in[1];
-	r2 = in[2];
-	r3 = in[3];
-	r4 = in[4];
-
-	s0 = in2[0];
-	s1 = in2[1];
-	s2 = in2[2];
-	s3 = in2[3];
-	s4 = in2[4];
-
-	t[0]  =  ((uint128_t) r0) * s0;
-	t[1]  =  ((uint128_t) r0) * s1 + ((uint128_t) r1) * s0;
-	t[2]  =  ((uint128_t) r0) * s2 + ((uint128_t) r2) * s0 + ((uint128_t) r1) * s1;
-	t[3]  =  ((uint128_t) r0) * s3 + ((uint128_t) r3) * s0 + ((uint128_t) r1) * s2 + ((uint128_t) r2) * s1;
-	t[4]  =  ((uint128_t) r0) * s4 + ((uint128_t) r4) * s0 + ((uint128_t) r3) * s1 + ((uint128_t) r1) * s3 + ((uint128_t) r2) * s2;
-
-	r4 *= 19;
-	r1 *= 19;
-	r2 *= 19;
-	r3 *= 19;
-
-	t[0] += ((uint128_t) r4) * s1 + ((uint128_t) r1) * s4 + ((uint128_t) r2) * s3 + ((uint128_t) r3) * s2;
-	t[1] += ((uint128_t) r4) * s2 + ((uint128_t) r2) * s4 + ((uint128_t) r3) * s3;
-	t[2] += ((uint128_t) r4) * s3 + ((uint128_t) r3) * s4;
-	t[3] += ((uint128_t) r4) * s4;
-
-			r0 = (limb)t[0] & 0x7ffffffffffffUL; c = (limb)(t[0] >> 51);
-	t[1] += c;      r1 = (limb)t[1] & 0x7ffffffffffffUL; c = (limb)(t[1] >> 51);
-	t[2] += c;      r2 = (limb)t[2] & 0x7ffffffffffffUL; c = (limb)(t[2] >> 51);
-	t[3] += c;      r3 = (limb)t[3] & 0x7ffffffffffffUL; c = (limb)(t[3] >> 51);
-	t[4] += c;      r4 = (limb)t[4] & 0x7ffffffffffffUL; c = (limb)(t[4] >> 51);
-	r0 +=   c * 19; c = r0 >> 51; r0 = r0 & 0x7ffffffffffffUL;
-	r1 +=   c;      c = r1 >> 51; r1 = r1 & 0x7ffffffffffffUL;
-	r2 +=   c;
-
-	output[0] = r0;
-	output[1] = r1;
-	output[2] = r2;
-	output[3] = r3;
-	output[4] = r4;
-}
-
-static __always_inline void fsquare_times(felem output, const felem in, limb count)
+	uint128_t b4;
+	uint128_t b0;
+	uint128_t b4_;
+	uint128_t b0_;
+	uint64_t i0;
+	uint64_t i1;
+	uint64_t i0_;
+	uint64_t i1_;
+	fsquare_fsquare__(tmp, output);
+	fproduct_carry_wide_(tmp);
+	b4 = tmp[4];
+	b0 = tmp[0];
+	b4_ = ((b4) & (((uint128_t)(0x7ffffffffffffLLU))));
+	b0_ = ((b0) + (((uint128_t)(19) * (((uint64_t)(((b4) >> (51))))))));
+	tmp[4] = b4_;
+	tmp[0] = b0_;
+	fproduct_copy_from_wide_(output, tmp);
+	i0 = output[0];
+	i1 = output[1];
+	i0_ = i0 & 0x7ffffffffffffLLU;
+	i1_ = i1 + (i0 >> 51);
+	output[0] = i0_;
+	output[1] = i1_;
+}
+
+static __always_inline void fsquare_fsquare_times_(uint64_t *input, uint128_t *tmp, uint32_t count1)
 {
-	uint128_t t[5];
-	limb r0, r1, r2, r3, r4, c;
-	limb d0, d1, d2, d4, d419;
-
-	r0 = in[0];
-	r1 = in[1];
-	r2 = in[2];
-	r3 = in[3];
-	r4 = in[4];
-
-	do {
-		d0 = r0 * 2;
-		d1 = r1 * 2;
-		d2 = r2 * 2 * 19;
-		d419 = r4 * 19;
-		d4 = d419 * 2;
-
-		t[0] = ((uint128_t) r0) * r0 + ((uint128_t) d4) * r1 + (((uint128_t) d2) * (r3     ));
-		t[1] = ((uint128_t) d0) * r1 + ((uint128_t) d4) * r2 + (((uint128_t) r3) * (r3 * 19));
-		t[2] = ((uint128_t) d0) * r2 + ((uint128_t) r1) * r1 + (((uint128_t) d4) * (r3     ));
-		t[3] = ((uint128_t) d0) * r3 + ((uint128_t) d1) * r2 + (((uint128_t) r4) * (d419   ));
-		t[4] = ((uint128_t) d0) * r4 + ((uint128_t) d1) * r3 + (((uint128_t) r2) * (r2     ));
-
-				r0 = (limb)t[0] & 0x7ffffffffffffUL; c = (limb)(t[0] >> 51);
-		t[1] += c;      r1 = (limb)t[1] & 0x7ffffffffffffUL; c = (limb)(t[1] >> 51);
-		t[2] += c;      r2 = (limb)t[2] & 0x7ffffffffffffUL; c = (limb)(t[2] >> 51);
-		t[3] += c;      r3 = (limb)t[3] & 0x7ffffffffffffUL; c = (limb)(t[3] >> 51);
-		t[4] += c;      r4 = (limb)t[4] & 0x7ffffffffffffUL; c = (limb)(t[4] >> 51);
-		r0 +=   c * 19; c = r0 >> 51; r0 = r0 & 0x7ffffffffffffUL;
-		r1 +=   c;      c = r1 >> 51; r1 = r1 & 0x7ffffffffffffUL;
-		r2 +=   c;
-	} while (--count);
-
-	output[0] = r0;
-	output[1] = r1;
-	output[2] = r2;
-	output[3] = r3;
-	output[4] = r4;
-}
-
-/* Load a little-endian 64-bit number  */
-static limb load_limb(const uint8_t *in)
-{
-	return
-		((limb)in[0]) |
-		(((limb)in[1]) << 8) |
-		(((limb)in[2]) << 16) |
-		(((limb)in[3]) << 24) |
-		(((limb)in[4]) << 32) |
-		(((limb)in[5]) << 40) |
-		(((limb)in[6]) << 48) |
-		(((limb)in[7]) << 56);
-}
-
-static void store_limb(uint8_t *out, limb in)
-{
-	out[0] = in & 0xff;
-	out[1] = (in >> 8) & 0xff;
-	out[2] = (in >> 16) & 0xff;
-	out[3] = (in >> 24) & 0xff;
-	out[4] = (in >> 32) & 0xff;
-	out[5] = (in >> 40) & 0xff;
-	out[6] = (in >> 48) & 0xff;
-	out[7] = (in >> 56) & 0xff;
-}
-
-/* Take a little-endian, 32-byte number and expand it into polynomial form */
-static void fexpand(limb *output, const uint8_t *in)
-{
-	output[0] = load_limb(in) & 0x7ffffffffffffUL;
-	output[1] = (load_limb(in+6) >> 3) & 0x7ffffffffffffUL;
-	output[2] = (load_limb(in+12) >> 6) & 0x7ffffffffffffUL;
-	output[3] = (load_limb(in+19) >> 1) & 0x7ffffffffffffUL;
-	output[4] = (load_limb(in+24) >> 12) & 0x7ffffffffffffUL;
-}
-
-/* Take a fully reduced polynomial form number and contract it into a
- * little-endian, 32-byte array
- */
-static void fcontract(uint8_t *output, const felem input)
+	uint32_t i;
+	fsquare_fsquare_(tmp, input);
+	for (i = 1; i < count1; ++i)
+		fsquare_fsquare_(tmp, input);
+}
+
+static __always_inline void fsquare_fsquare_times(uint64_t *output, uint64_t *input, uint32_t count1)
 {
 	uint128_t t[5];
+	{
+		uint32_t _i;
+		for (_i = 0; _i < 5; ++_i)
+			t[_i] = ((uint128_t)(0));
+	}
+	memcpy(output, input, 5 * sizeof(*input));
+	fsquare_fsquare_times_(output, t, count1);
+}
 
-	t[0] = input[0];
-	t[1] = input[1];
-	t[2] = input[2];
-	t[3] = input[3];
-	t[4] = input[4];
-
-	t[1] += t[0] >> 51; t[0] &= 0x7ffffffffffffUL;
-	t[2] += t[1] >> 51; t[1] &= 0x7ffffffffffffUL;
-	t[3] += t[2] >> 51; t[2] &= 0x7ffffffffffffUL;
-	t[4] += t[3] >> 51; t[3] &= 0x7ffffffffffffUL;
-	t[0] += 19 * (t[4] >> 51); t[4] &= 0x7ffffffffffffUL;
-
-	t[1] += t[0] >> 51; t[0] &= 0x7ffffffffffffUL;
-	t[2] += t[1] >> 51; t[1] &= 0x7ffffffffffffUL;
-	t[3] += t[2] >> 51; t[2] &= 0x7ffffffffffffUL;
-	t[4] += t[3] >> 51; t[3] &= 0x7ffffffffffffUL;
-	t[0] += 19 * (t[4] >> 51); t[4] &= 0x7ffffffffffffUL;
+static __always_inline void fsquare_fsquare_times_inplace(uint64_t *output, uint32_t count1)
+{
+	uint128_t t[5];
+	{
+		uint32_t _i;
+		for (_i = 0; _i < 5; ++_i)
+			t[_i] = ((uint128_t)(0));
+	}
+	fsquare_fsquare_times_(output, t, count1);
+}
 
-	/* now t is between 0 and 2^255-1, properly carried. */
-	/* case 1: between 0 and 2^255-20. case 2: between 2^255-19 and 2^255-1. */
+static __always_inline void crecip_crecip(uint64_t *out, uint64_t *z)
+{
+	uint64_t buf[20] = { 0 };
+	uint64_t *a0 = buf;
+	uint64_t *t00 = buf + 5;
+	uint64_t *b0 = buf + 10;
+	uint64_t *t01;
+	uint64_t *b1;
+	uint64_t *c0;
+	uint64_t *a;
+	uint64_t *t0;
+	uint64_t *b;
+	uint64_t *c;
+	fsquare_fsquare_times(a0, z, 1);
+	fsquare_fsquare_times(t00, a0, 2);
+	fmul_fmul(b0, t00, z);
+	fmul_fmul(a0, b0, a0);
+	fsquare_fsquare_times(t00, a0, 1);
+	fmul_fmul(b0, t00, b0);
+	fsquare_fsquare_times(t00, b0, 5);
+	t01 = buf + 5;
+	b1 = buf + 10;
+	c0 = buf + 15;
+	fmul_fmul(b1, t01, b1);
+	fsquare_fsquare_times(t01, b1, 10);
+	fmul_fmul(c0, t01, b1);
+	fsquare_fsquare_times(t01, c0, 20);
+	fmul_fmul(t01, t01, c0);
+	fsquare_fsquare_times_inplace(t01, 10);
+	fmul_fmul(b1, t01, b1);
+	fsquare_fsquare_times(t01, b1, 50);
+	a = buf;
+	t0 = buf + 5;
+	b = buf + 10;
+	c = buf + 15;
+	fmul_fmul(c, t0, b);
+	fsquare_fsquare_times(t0, c, 100);
+	fmul_fmul(t0, t0, c);
+	fsquare_fsquare_times_inplace(t0, 50);
+	fmul_fmul(t0, t0, b);
+	fsquare_fsquare_times_inplace(t0, 5);
+	fmul_fmul(out, t0, a);
+}
 
-	t[0] += 19;
+static __always_inline void fsum(uint64_t *a, uint64_t *b)
+{
+	uint32_t i;
+	for (i = 0; i < 5; ++i) {
+		uint64_t xi = a[i];
+		uint64_t yi = b[i];
+		a[i] = xi + yi;
+	}
+}
 
-	t[1] += t[0] >> 51; t[0] &= 0x7ffffffffffffUL;
-	t[2] += t[1] >> 51; t[1] &= 0x7ffffffffffffUL;
-	t[3] += t[2] >> 51; t[2] &= 0x7ffffffffffffUL;
-	t[4] += t[3] >> 51; t[3] &= 0x7ffffffffffffUL;
-	t[0] += 19 * (t[4] >> 51); t[4] &= 0x7ffffffffffffUL;
+static __always_inline void fdifference(uint64_t *a, uint64_t *b)
+{
+	uint64_t tmp[5] = { 0 };
+	uint64_t b0;
+	uint64_t b1;
+	uint64_t b2;
+	uint64_t b3;
+	uint64_t b4;
+	memcpy(tmp, b, 5 * sizeof(*b));
+	b0 = tmp[0];
+	b1 = tmp[1];
+	b2 = tmp[2];
+	b3 = tmp[3];
+	b4 = tmp[4];
+	tmp[0] = b0 + 0x3fffffffffff68LLU;
+	tmp[1] = b1 + 0x3ffffffffffff8LLU;
+	tmp[2] = b2 + 0x3ffffffffffff8LLU;
+	tmp[3] = b3 + 0x3ffffffffffff8LLU;
+	tmp[4] = b4 + 0x3ffffffffffff8LLU;
+	{
+		uint64_t xi = a[0];
+		uint64_t yi = tmp[0];
+		a[0] = yi - xi;
+	}
+	{
+		uint64_t xi = a[1];
+		uint64_t yi = tmp[1];
+		a[1] = yi - xi;
+	}
+	{
+		uint64_t xi = a[2];
+		uint64_t yi = tmp[2];
+		a[2] = yi - xi;
+	}
+	{
+		uint64_t xi = a[3];
+		uint64_t yi = tmp[3];
+		a[3] = yi - xi;
+	}
+	{
+		uint64_t xi = a[4];
+		uint64_t yi = tmp[4];
+		a[4] = yi - xi;
+	}
+}
 
-	/* now between 19 and 2^255-1 in both cases, and offset by 19. */
+static __always_inline void fscalar(uint64_t *output, uint64_t *b, uint64_t s)
+{
+	uint128_t tmp[5];
+	uint128_t b4;
+	uint128_t b0;
+	uint128_t b4_;
+	uint128_t b0_;
+	{
+		uint64_t xi = b[0];
+		tmp[0] = ((uint128_t)(xi) * (s));
+	}
+	{
+		uint64_t xi = b[1];
+		tmp[1] = ((uint128_t)(xi) * (s));
+	}
+	{
+		uint64_t xi = b[2];
+		tmp[2] = ((uint128_t)(xi) * (s));
+	}
+	{
+		uint64_t xi = b[3];
+		tmp[3] = ((uint128_t)(xi) * (s));
+	}
+	{
+		uint64_t xi = b[4];
+		tmp[4] = ((uint128_t)(xi) * (s));
+	}
+	fproduct_carry_wide_(tmp);
+	b4 = tmp[4];
+	b0 = tmp[0];
+	b4_ = ((b4) & (((uint128_t)(0x7ffffffffffffLLU))));
+	b0_ = ((b0) + (((uint128_t)(19) * (((uint64_t)(((b4) >> (51))))))));
+	tmp[4] = b4_;
+	tmp[0] = b0_;
+	fproduct_copy_from_wide_(output, tmp);
+}
 
-	t[0] += 0x8000000000000UL - 19;
-	t[1] += 0x8000000000000UL - 1;
-	t[2] += 0x8000000000000UL - 1;
-	t[3] += 0x8000000000000UL - 1;
-	t[4] += 0x8000000000000UL - 1;
+static __always_inline void fmul(uint64_t *output, uint64_t *a, uint64_t *b)
+{
+	fmul_fmul(output, a, b);
+}
 
-	/* now between 2^255 and 2^256-20, and offset by 2^255. */
+static __always_inline void crecip(uint64_t *output, uint64_t *input)
+{
+	crecip_crecip(output, input);
+}
 
-	t[1] += t[0] >> 51; t[0] &= 0x7ffffffffffffUL;
-	t[2] += t[1] >> 51; t[1] &= 0x7ffffffffffffUL;
-	t[3] += t[2] >> 51; t[2] &= 0x7ffffffffffffUL;
-	t[4] += t[3] >> 51; t[3] &= 0x7ffffffffffffUL;
-	t[4] &= 0x7ffffffffffffUL;
+static __always_inline void point_swap_conditional_step(uint64_t *a, uint64_t *b, uint64_t swap1, uint32_t ctr)
+{
+	uint32_t i = ctr - 1;
+	uint64_t ai = a[i];
+	uint64_t bi = b[i];
+	uint64_t x = swap1 & (ai ^ bi);
+	uint64_t ai1 = ai ^ x;
+	uint64_t bi1 = bi ^ x;
+	a[i] = ai1;
+	b[i] = bi1;
+}
 
-	store_limb(output,    t[0] | (t[1] << 51));
-	store_limb(output+8,  (t[1] >> 13) | (t[2] << 38));
-	store_limb(output+16, (t[2] >> 26) | (t[3] << 25));
-	store_limb(output+24, (t[3] >> 39) | (t[4] << 12));
+static __always_inline void point_swap_conditional_(uint64_t *a, uint64_t *b, uint64_t swap1, uint32_t ctr)
+{
+	uint32_t i;
+	for (i = ctr; i > 0; --i)
+		point_swap_conditional_step(a, b, swap1, i);
 }
 
-/* Input: Q, Q', Q-Q'
- * Output: 2Q, Q+Q'
- *
- *   x2 z3: long form
- *   x3 z3: long form
- *   x z: short form, destroyed
- *   xprime zprime: short form, destroyed
- *   qmqp: short form, preserved
- */
-static void fmonty(limb *x2, limb *z2, /* output 2Q */
-			 limb *x3, limb *z3, /* output Q + Q' */
-			 limb *x, limb *z,   /* input Q */
-			 limb *xprime, limb *zprime, /* input Q' */
+static __always_inline void point_swap_conditional(uint64_t *a, uint64_t *b, uint64_t iswap)
+{
+	uint64_t swap1 = 0 - iswap;
+	point_swap_conditional_(a, b, swap1, 5);
+	point_swap_conditional_(a + 5, b + 5, swap1, 5);
+}
 
-			 const limb *qmqp /* input Q - Q' */)
+static __always_inline void point_copy(uint64_t *output, uint64_t *input)
 {
-	limb origx[5], origxprime[5], zzz[5], xx[5], zz[5], xxprime[5], zzprime[5], zzzprime[5];
+	memcpy(output, input, 5 * sizeof(*input));
+	memcpy(output + 5, input + 5, 5 * sizeof(*input));
+}
 
-	memcpy(origx, x, 5 * sizeof(limb));
+static __always_inline void addanddouble_fmonty(uint64_t *pp, uint64_t *ppq, uint64_t *p, uint64_t *pq, uint64_t *qmqp)
+{
+	uint64_t *qx = qmqp;
+	uint64_t *x2 = pp;
+	uint64_t *z2 = pp + 5;
+	uint64_t *x3 = ppq;
+	uint64_t *z3 = ppq + 5;
+	uint64_t *x = p;
+	uint64_t *z = p + 5;
+	uint64_t *xprime = pq;
+	uint64_t *zprime = pq + 5;
+	uint64_t buf[40] = { 0 };
+	uint64_t *origx = buf;
+	uint64_t *origxprime0 = buf + 5;
+	uint64_t *xxprime0;
+	uint64_t *zzprime0;
+	uint64_t *origxprime;
+	xxprime0 = buf + 25;
+	zzprime0 = buf + 30;
+	memcpy(origx, x, 5 * sizeof(*x));
 	fsum(x, z);
-	fdifference_backwards(z, origx);  // does x - z
-
-	memcpy(origxprime, xprime, sizeof(limb) * 5);
+	fdifference(z, origx);
+	memcpy(origxprime0, xprime, 5 * sizeof(*xprime));
 	fsum(xprime, zprime);
-	fdifference_backwards(zprime, origxprime);
-	fmul(xxprime, xprime, z);
-	fmul(zzprime, x, zprime);
-	memcpy(origxprime, xxprime, sizeof(limb) * 5);
-	fsum(xxprime, zzprime);
-	fdifference_backwards(zzprime, origxprime);
-	fsquare_times(x3, xxprime, 1);
-	fsquare_times(zzzprime, zzprime, 1);
-	fmul(z3, zzzprime, qmqp);
-
-	fsquare_times(xx, x, 1);
-	fsquare_times(zz, z, 1);
-	fmul(x2, xx, zz);
-	fdifference_backwards(zz, xx);  // does zz = xx - zz
-	fscalar_product(zzz, zz, 121665);
-	fsum(zzz, xx);
-	fmul(z2, zz, zzz);
-}
-
-/* Maybe swap the contents of two limb arrays (@a and @b), each @len elements
- * long. Perform the swap iff @swap is non-zero.
- *
- * This function performs the swap without leaking any side-channel
- * information.
- */
-static void swap_conditional(limb a[static 5], limb b[static 5], limb iswap)
+	fdifference(zprime, origxprime0);
+	fmul(xxprime0, xprime, z);
+	fmul(zzprime0, x, zprime);
+	origxprime = buf + 5;
+	{
+		uint64_t *xx0;
+		uint64_t *zz0;
+		uint64_t *xxprime;
+		uint64_t *zzprime;
+		uint64_t *zzzprime;
+		xx0 = buf + 15;
+		zz0 = buf + 20;
+		xxprime = buf + 25;
+		zzprime = buf + 30;
+		zzzprime = buf + 35;
+		memcpy(origxprime, xxprime, 5 * sizeof(*xxprime));
+		fsum(xxprime, zzprime);
+		fdifference(zzprime, origxprime);
+		fsquare_fsquare_times(x3, xxprime, 1);
+		fsquare_fsquare_times(zzzprime, zzprime, 1);
+		fmul(z3, zzzprime, qx);
+		fsquare_fsquare_times(xx0, x, 1);
+		fsquare_fsquare_times(zz0, z, 1);
+		{
+			uint64_t *zzz;
+			uint64_t *xx;
+			uint64_t *zz;
+			uint64_t scalar;
+			zzz = buf + 10;
+			xx = buf + 15;
+			zz = buf + 20;
+			fmul(x2, xx, zz);
+			fdifference(zz, xx);
+			scalar = 121665;
+			fscalar(zzz, zz, scalar);
+			fsum(zzz, xx);
+			fmul(z2, zzz, zz);
+		}
+	}
+}
+
+static __always_inline void ladder_smallloop_cmult_small_loop_step(uint64_t *nq, uint64_t *nqpq, uint64_t *nq2, uint64_t *nqpq2, uint64_t *q, uint8_t byt)
 {
-	unsigned int i;
-	const limb swap = -iswap;
+	uint64_t bit0 = (uint64_t)(byt >> 7);
+	uint64_t bit;
+	point_swap_conditional(nq, nqpq, bit0);
+	addanddouble_fmonty(nq2, nqpq2, nq, nqpq, q);
+	bit = (uint64_t)(byt >> 7);
+	point_swap_conditional(nq2, nqpq2, bit);
+}
 
-	for (i = 0; i < 5; ++i) {
-		const limb x = swap & (a[i] ^ b[i]);
+static __always_inline void ladder_smallloop_cmult_small_loop_double_step(uint64_t *nq, uint64_t *nqpq, uint64_t *nq2, uint64_t *nqpq2, uint64_t *q, uint8_t byt)
+{
+	uint8_t byt1;
+	ladder_smallloop_cmult_small_loop_step(nq, nqpq, nq2, nqpq2, q, byt);
+	byt1 = byt << 1;
+	ladder_smallloop_cmult_small_loop_step(nq2, nqpq2, nq, nqpq, q, byt1);
+}
 
-		a[i] ^= x;
-		b[i] ^= x;
+static __always_inline void ladder_smallloop_cmult_small_loop(uint64_t *nq, uint64_t *nqpq, uint64_t *nq2, uint64_t *nqpq2, uint64_t *q, uint8_t byt, uint32_t i)
+{
+	while (i--) {
+		ladder_smallloop_cmult_small_loop_double_step(nq, nqpq, nq2, nqpq2, q, byt);
+		byt <<= 2;
 	}
 }
 
-/* Calculates nQ where Q is the x-coordinate of a point on the curve
- *
- *   resultx/resultz: the x coordinate of the resulting curve point (short form)
- *   n: a little endian, 32-byte number
- *   q: a point of the curve (short form)
- */
-static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
-{
-	limb a[5] = {0}, b[5] = {1}, c[5] = {1}, d[5] = {0};
-	limb *nqpqx = a, *nqpqz = b, *nqx = c, *nqz = d, *t;
-	limb e[5] = {0}, f[5] = {1}, g[5] = {0}, h[5] = {1};
-	limb *nqpqx2 = e, *nqpqz2 = f, *nqx2 = g, *nqz2 = h;
-
-	unsigned int i, j;
-
-	memcpy(nqpqx, q, sizeof(limb) * 5);
-
-	for (i = 0; i < 32; ++i) {
-		uint8_t byte = n[31 - i];
-
-		for (j = 0; j < 8; ++j) {
-			const limb bit = byte >> 7;
-
-			swap_conditional(nqx, nqpqx, bit);
-			swap_conditional(nqz, nqpqz, bit);
-			fmonty(nqx2, nqz2,
-						 nqpqx2, nqpqz2,
-						 nqx, nqz,
-						 nqpqx, nqpqz,
-						 q);
-			swap_conditional(nqx2, nqpqx2, bit);
-			swap_conditional(nqz2, nqpqz2, bit);
-
-			t = nqx;
-			nqx = nqx2;
-			nqx2 = t;
-			t = nqz;
-			nqz = nqz2;
-			nqz2 = t;
-			t = nqpqx;
-			nqpqx = nqpqx2;
-			nqpqx2 = t;
-			t = nqpqz;
-			nqpqz = nqpqz2;
-			nqpqz2 = t;
-
-			byte <<= 1;
-		}
+static __always_inline void ladder_bigloop_cmult_big_loop(uint8_t *n1, uint64_t *nq, uint64_t *nqpq, uint64_t *nq2, uint64_t *nqpq2, uint64_t *q, uint32_t i)
+{
+	while (i--) {
+		uint8_t byte = n1[i];
+		ladder_smallloop_cmult_small_loop(nq, nqpq, nq2, nqpq2, q, byte, 4);
 	}
-
-	memcpy(resultx, nqx, sizeof(limb) * 5);
-	memcpy(resultz, nqz, sizeof(limb) * 5);
-}
-
-static void crecip(felem out, const felem z)
-{
-	felem a, t0, b, c;
-
-	/* 2 */ fsquare_times(a, z, 1); // a = 2
-	/* 8 */ fsquare_times(t0, a, 2);
-	/* 9 */ fmul(b, t0, z); // b = 9
-	/* 11 */ fmul(a, b, a); // a = 11
-	/* 22 */ fsquare_times(t0, a, 1);
-	/* 2^5 - 2^0 = 31 */ fmul(b, t0, b);
-	/* 2^10 - 2^5 */ fsquare_times(t0, b, 5);
-	/* 2^10 - 2^0 */ fmul(b, t0, b);
-	/* 2^20 - 2^10 */ fsquare_times(t0, b, 10);
-	/* 2^20 - 2^0 */ fmul(c, t0, b);
-	/* 2^40 - 2^20 */ fsquare_times(t0, c, 20);
-	/* 2^40 - 2^0 */ fmul(t0, t0, c);
-	/* 2^50 - 2^10 */ fsquare_times(t0, t0, 10);
-	/* 2^50 - 2^0 */ fmul(b, t0, b);
-	/* 2^100 - 2^50 */ fsquare_times(t0, b, 50);
-	/* 2^100 - 2^0 */ fmul(c, t0, b);
-	/* 2^200 - 2^100 */ fsquare_times(t0, c, 100);
-	/* 2^200 - 2^0 */ fmul(t0, t0, c);
-	/* 2^250 - 2^50 */ fsquare_times(t0, t0, 50);
-	/* 2^250 - 2^0 */ fmul(t0, t0, b);
-	/* 2^255 - 2^5 */ fsquare_times(t0, t0, 5);
-	/* 2^255 - 21 */ fmul(out, t0, a);
 }
 
-void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE])
+static __always_inline void ladder_cmult(uint64_t *result, uint8_t *n1, uint64_t *q)
 {
-	limb bp[5], x[5], z[5], zmone[5];
-	uint8_t e[32];
+	uint64_t point_buf[40] = { 0 };
+	uint64_t *nq = point_buf;
+	uint64_t *nqpq = point_buf + 10;
+	uint64_t *nq2 = point_buf + 20;
+	uint64_t *nqpq2 = point_buf + 30;
+	point_copy(nqpq, q);
+	nq[0] = 1;
+	ladder_bigloop_cmult_big_loop(n1, nq, nqpq, nq2, nqpq2, q, 32);
+	point_copy(result, nq);
+}
 
-	memcpy(e, secret, 32);
-	curve25519_normalize_secret(e);
+static __always_inline void format_fexpand(uint64_t *output, const uint8_t *input)
+{
+	const uint8_t *x00 = input + 6;
+	const uint8_t *x01 = input + 12;
+	const uint8_t *x02 = input + 19;
+	const uint8_t *x0 = input + 24;
+	uint64_t i0, i1, i2, i3, i4, output0, output1, output2, output3, output4;
+	i0 = le64toh(*(uint64_t *)input);
+	i1 = le64toh(*(uint64_t *)x00);
+	i2 = le64toh(*(uint64_t *)x01);
+	i3 = le64toh(*(uint64_t *)x02);
+	i4 = le64toh(*(uint64_t *)x0);
+	output0 = i0 & 0x7ffffffffffffLLU;
+	output1 = i1 >> 3 & 0x7ffffffffffffLLU;
+	output2 = i2 >> 6 & 0x7ffffffffffffLLU;
+	output3 = i3 >> 1 & 0x7ffffffffffffLLU;
+	output4 = i4 >> 12 & 0x7ffffffffffffLLU;
+	output[0] = output0;
+	output[1] = output1;
+	output[2] = output2;
+	output[3] = output3;
+	output[4] = output4;
+}
 
-	fexpand(bp, basepoint);
-	cmult(x, z, e, bp);
-	crecip(zmone, z);
-	fmul(z, x, zmone);
-	fcontract(mypublic, z);
+static __always_inline void format_fcontract_first_carry_pass(uint64_t *input)
+{
+	uint64_t t0 = input[0];
+	uint64_t t1 = input[1];
+	uint64_t t2 = input[2];
+	uint64_t t3 = input[3];
+	uint64_t t4 = input[4];
+	uint64_t t1_ = t1 + (t0 >> 51);
+	uint64_t t0_ = t0 & 0x7ffffffffffffLLU;
+	uint64_t t2_ = t2 + (t1_ >> 51);
+	uint64_t t1__ = t1_ & 0x7ffffffffffffLLU;
+	uint64_t t3_ = t3 + (t2_ >> 51);
+	uint64_t t2__ = t2_ & 0x7ffffffffffffLLU;
+	uint64_t t4_ = t4 + (t3_ >> 51);
+	uint64_t t3__ = t3_ & 0x7ffffffffffffLLU;
+	input[0] = t0_;
+	input[1] = t1__;
+	input[2] = t2__;
+	input[3] = t3__;
+	input[4] = t4_;
 }
 
-#else
-typedef int64_t limb;
+static __always_inline void format_fcontract_first_carry_full(uint64_t *input)
+{
+	format_fcontract_first_carry_pass(input);
+	modulo_carry_top(input);
+}
 
-/* Field element representation:
- *
- * Field elements are written as an array of signed, 64-bit limbs, least
- * significant first. The value of the field element is:
- *   x[0] + 2^26x[1] + x^51x[2] + 2^102x[3] + ...
- *
- * i.e. the limbs are 26, 25, 26, 25, ... bits wide.
- */
+static __always_inline void format_fcontract_second_carry_pass(uint64_t *input)
+{
+	uint64_t t0 = input[0];
+	uint64_t t1 = input[1];
+	uint64_t t2 = input[2];
+	uint64_t t3 = input[3];
+	uint64_t t4 = input[4];
+	uint64_t t1_ = t1 + (t0 >> 51);
+	uint64_t t0_ = t0 & 0x7ffffffffffffLLU;
+	uint64_t t2_ = t2 + (t1_ >> 51);
+	uint64_t t1__ = t1_ & 0x7ffffffffffffLLU;
+	uint64_t t3_ = t3 + (t2_ >> 51);
+	uint64_t t2__ = t2_ & 0x7ffffffffffffLLU;
+	uint64_t t4_ = t4 + (t3_ >> 51);
+	uint64_t t3__ = t3_ & 0x7ffffffffffffLLU;
+	input[0] = t0_;
+	input[1] = t1__;
+	input[2] = t2__;
+	input[3] = t3__;
+	input[4] = t4_;
+}
 
-/* Sum two numbers: output += in */
-static void fsum(limb *output, const limb *in)
+static __always_inline void format_fcontract_second_carry_full(uint64_t *input)
 {
-	unsigned int i;
+	uint64_t i0;
+	uint64_t i1;
+	uint64_t i0_;
+	uint64_t i1_;
+	format_fcontract_second_carry_pass(input);
+	modulo_carry_top(input);
+	i0 = input[0];
+	i1 = input[1];
+	i0_ = i0 & 0x7ffffffffffffLLU;
+	i1_ = i1 + (i0 >> 51);
+	input[0] = i0_;
+	input[1] = i1_;
+}
 
-	for (i = 0; i < 10; i += 2) {
-		output[0 + i] = output[0 + i] + in[0 + i];
-		output[1 + i] = output[1 + i] + in[1 + i];
-	}
+static __always_inline void format_fcontract_trim(uint64_t *input)
+{
+	uint64_t a0 = input[0];
+	uint64_t a1 = input[1];
+	uint64_t a2 = input[2];
+	uint64_t a3 = input[3];
+	uint64_t a4 = input[4];
+	uint64_t mask0 = uint64_t_gte_mask(a0, 0x7ffffffffffedLLU);
+	uint64_t mask1 = uint64_t_eq_mask(a1, 0x7ffffffffffffLLU);
+	uint64_t mask2 = uint64_t_eq_mask(a2, 0x7ffffffffffffLLU);
+	uint64_t mask3 = uint64_t_eq_mask(a3, 0x7ffffffffffffLLU);
+	uint64_t mask4 = uint64_t_eq_mask(a4, 0x7ffffffffffffLLU);
+	uint64_t mask = (((mask0 & mask1) & mask2) & mask3) & mask4;
+	uint64_t a0_ = a0 - (0x7ffffffffffedLLU & mask);
+	uint64_t a1_ = a1 - (0x7ffffffffffffLLU & mask);
+	uint64_t a2_ = a2 - (0x7ffffffffffffLLU & mask);
+	uint64_t a3_ = a3 - (0x7ffffffffffffLLU & mask);
+	uint64_t a4_ = a4 - (0x7ffffffffffffLLU & mask);
+	input[0] = a0_;
+	input[1] = a1_;
+	input[2] = a2_;
+	input[3] = a3_;
+	input[4] = a4_;
 }
 
-/* Find the difference of two numbers: output = in - output
- * (note the order of the arguments!).
- */
-static void fdifference(limb *output, const limb *in)
+static __always_inline void format_fcontract_store(uint8_t *output, uint64_t *input)
 {
-	unsigned int i;
+	uint64_t t0 = input[0];
+	uint64_t t1 = input[1];
+	uint64_t t2 = input[2];
+	uint64_t t3 = input[3];
+	uint64_t t4 = input[4];
+	uint64_t o0 = t1 << 51 | t0;
+	uint64_t o1 = t2 << 38 | t1 >> 13;
+	uint64_t o2 = t3 << 25 | t2 >> 26;
+	uint64_t o3 = t4 << 12 | t3 >> 39;
+	uint8_t *b0 = output;
+	uint8_t *b1 = output + 8;
+	uint8_t *b2 = output + 16;
+	uint8_t *b3 = output + 24;
+	*(uint64_t *)b0 = htole64(o0);
+	*(uint64_t *)b1 = htole64(o1);
+	*(uint64_t *)b2 = htole64(o2);
+	*(uint64_t *)b3 = htole64(o3);
+}
 
-	for (i = 0; i < 10; ++i) {
-		output[i] = in[i] - output[i];
-	}
+static __always_inline void format_fcontract(uint8_t *output, uint64_t *input)
+{
+	format_fcontract_first_carry_full(input);
+	format_fcontract_second_carry_full(input);
+	format_fcontract_trim(input);
+	format_fcontract_store(output, input);
 }
 
-/* Multiply a number by a scalar: output = in * scalar */
-static void fscalar_product(limb *output, const limb *in, const limb scalar)
+static __always_inline void format_scalar_of_point(uint8_t *scalar, uint64_t *point)
 {
-	unsigned int i;
+	uint64_t *x = point;
+	uint64_t *z = point + 5;
+	uint64_t buf[10] __aligned(32) = { 0 };
+	uint64_t *zmone = buf;
+	uint64_t *sc = buf + 5;
+	crecip(zmone, z);
+	fmul(sc, x, zmone);
+	format_fcontract(scalar, sc);
+}
 
-	for (i = 0; i < 10; ++i) {
-		output[i] = in[i] * scalar;
+void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE])
+{
+	uint64_t buf0[10] __aligned(32) = { 0 };
+	uint64_t *x0 = buf0;
+	uint64_t *z = buf0 + 5;
+	uint64_t *q;
+	format_fexpand(x0, basepoint);
+	z[0] = 1;
+	q = buf0;
+	{
+		uint8_t e[32] __aligned(32) = { 0 };
+		uint8_t *scalar;
+		memcpy(e, secret, 32);
+		curve25519_normalize_secret(e);
+		scalar = e;
+		{
+			uint64_t buf[15] = { 0 };
+			uint64_t *nq = buf;
+			uint64_t *x = nq;
+			x[0] = 1;
+			ladder_cmult(nq, scalar, q);
+			format_scalar_of_point(mypublic, nq);
+		}
 	}
 }
-
-/* Multiply two numbers: output = in2 * in
- *
- * output must be distinct to both inputs. The inputs are reduced coefficient
- * form, the output is not.
- *
- * output[x] <= 14 * the largest product of the input limbs.
- */
-static void fproduct(limb *output, const limb *in2, const limb *in)
-{
-	output[0] =       ((limb) ((int32_t) in2[0])) * ((int32_t) in[0]);
-	output[1] =       ((limb) ((int32_t) in2[0])) * ((int32_t) in[1]) +
-					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[0]);
-	output[2] =  2 *  ((limb) ((int32_t) in2[1])) * ((int32_t) in[1]) +
-					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[2]) +
-					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[0]);
-	output[3] =       ((limb) ((int32_t) in2[1])) * ((int32_t) in[2]) +
-					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[1]) +
-					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[0]);
-	output[4] =       ((limb) ((int32_t) in2[2])) * ((int32_t) in[2]) +
-				       2 * (((limb) ((int32_t) in2[1])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[1])) +
-					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[0]);
-	output[5] =       ((limb) ((int32_t) in2[2])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[2]) +
-					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[1]) +
-					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[0]);
-	output[6] =  2 * (((limb) ((int32_t) in2[3])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[1])) +
-					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[2]) +
-					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[0]);
-	output[7] =       ((limb) ((int32_t) in2[3])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[2]) +
-					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[1]) +
-					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[0]);
-	output[8] =       ((limb) ((int32_t) in2[4])) * ((int32_t) in[4]) +
-				       2 * (((limb) ((int32_t) in2[3])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[1])) +
-					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[2]) +
-					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[0]);
-	output[9] =       ((limb) ((int32_t) in2[4])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[2]) +
-					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[1]) +
-					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[9]) +
-					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[0]);
-	output[10] = 2 * (((limb) ((int32_t) in2[5])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[9]) +
-					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[1])) +
-					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[2]);
-	output[11] =      ((limb) ((int32_t) in2[5])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[9]) +
-					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[2]);
-	output[12] =      ((limb) ((int32_t) in2[6])) * ((int32_t) in[6]) +
-				       2 * (((limb) ((int32_t) in2[5])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[9]) +
-					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[3])) +
-					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[4]);
-	output[13] =      ((limb) ((int32_t) in2[6])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[9]) +
-					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[4]);
-	output[14] = 2 * (((limb) ((int32_t) in2[7])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[9]) +
-					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[5])) +
-					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[6]);
-	output[15] =      ((limb) ((int32_t) in2[7])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[9]) +
-					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[6]);
-	output[16] =      ((limb) ((int32_t) in2[8])) * ((int32_t) in[8]) +
-				       2 * (((limb) ((int32_t) in2[7])) * ((int32_t) in[9]) +
-					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[7]));
-	output[17] =      ((limb) ((int32_t) in2[8])) * ((int32_t) in[9]) +
-					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[8]);
-	output[18] = 2 *  ((limb) ((int32_t) in2[9])) * ((int32_t) in[9]);
-}
-
-/* Reduce a long form to a short form by taking the input mod 2^255 - 19.
- *
- * On entry: |output[i]| < 14*2^54
- * On exit: |output[0..8]| < 280*2^54
+#else
+/* fe means field element. Here the field is \Z/(2^255-19). An element t,
+ * entries t[0]...t[9], represents the integer t[0]+2^26 t[1]+2^51 t[2]+2^77
+ * t[3]+2^102 t[4]+...+2^230 t[9].
+ * fe limbs are bounded by 1.125*2^26,1.125*2^25,1.125*2^26,1.125*2^25,etc.
+ * Multiplication and carrying produce fe from fe_loose.
  */
-static void freduce_degree(limb *output)
-{
-	/* Each of these shifts and adds ends up multiplying the value by 19.
-	 *
-	 * For output[0..8], the absolute entry value is < 14*2^54 and we add, at
-	 * most, 19*14*2^54 thus, on exit, |output[0..8]| < 280*2^54.
-	 */
-	output[8] += output[18] << 4;
-	output[8] += output[18] << 1;
-	output[8] += output[18];
-	output[7] += output[17] << 4;
-	output[7] += output[17] << 1;
-	output[7] += output[17];
-	output[6] += output[16] << 4;
-	output[6] += output[16] << 1;
-	output[6] += output[16];
-	output[5] += output[15] << 4;
-	output[5] += output[15] << 1;
-	output[5] += output[15];
-	output[4] += output[14] << 4;
-	output[4] += output[14] << 1;
-	output[4] += output[14];
-	output[3] += output[13] << 4;
-	output[3] += output[13] << 1;
-	output[3] += output[13];
-	output[2] += output[12] << 4;
-	output[2] += output[12] << 1;
-	output[2] += output[12];
-	output[1] += output[11] << 4;
-	output[1] += output[11] << 1;
-	output[1] += output[11];
-	output[0] += output[10] << 4;
-	output[0] += output[10] << 1;
-	output[0] += output[10];
-}
-
-#if (-1 & 3) != 3
-#error "This code only works on a two's complement system"
-#endif
+typedef struct fe { uint32_t v[10]; } fe;
 
-/* return v / 2^26, using only shifts and adds.
- *
- * On entry: v can take any value.
+/* fe_loose limbs are bounded by 3.375*2^26,3.375*2^25,3.375*2^26,3.375*2^25,etc.
+ * Addition and subtraction produce fe_loose from (fe, fe).
  */
-static inline limb div_by_2_26(const limb v)
+typedef struct fe_loose { uint32_t v[10]; } fe_loose;
+
+static __always_inline void fe_frombytes_impl(uint32_t h[10], const uint8_t *s)
 {
-	/* High word of v; no shift needed. */
-	const uint32_t highword = (uint32_t) (((uint64_t) v) >> 32);
-	/* Set to all 1s if v was negative; else set to 0s. */
-	const int32_t sign = ((int32_t) highword) >> 31;
-	/* Set to 0x3ffffff if v was negative; else set to 0. */
-	const int32_t roundoff = ((uint32_t) sign) >> 6;
-	/* Should return v / (1<<26) */
-	return (v + roundoff) >> 26;
+	/* Ignores top bit of s. */
+	uint32_t a0 = le32toh(*(uint32_t *)(s));
+	uint32_t a1 = le32toh(*(uint32_t *)(s+4));
+	uint32_t a2 = le32toh(*(uint32_t *)(s+8));
+	uint32_t a3 = le32toh(*(uint32_t *)(s+12));
+	uint32_t a4 = le32toh(*(uint32_t *)(s+16));
+	uint32_t a5 = le32toh(*(uint32_t *)(s+20));
+	uint32_t a6 = le32toh(*(uint32_t *)(s+24));
+	uint32_t a7 = le32toh(*(uint32_t *)(s+28));
+	h[0] = a0&((1<<26)-1);                    /* 26 used, 32-26 left.   26 */
+	h[1] = (a0>>26) | ((a1&((1<<19)-1))<< 6); /* (32-26) + 19 =  6+19 = 25 */
+	h[2] = (a1>>19) | ((a2&((1<<13)-1))<<13); /* (32-19) + 13 = 13+13 = 26 */
+	h[3] = (a2>>13) | ((a3&((1<< 6)-1))<<19); /* (32-13) +  6 = 19+ 6 = 25 */
+	h[4] = (a3>> 6);                          /* (32- 6)              = 26 */
+	h[5] = a4&((1<<25)-1);                    /*                        25 */
+	h[6] = (a4>>25) | ((a5&((1<<19)-1))<< 7); /* (32-25) + 19 =  7+19 = 26 */
+	h[7] = (a5>>19) | ((a6&((1<<12)-1))<<13); /* (32-19) + 12 = 13+12 = 25 */
+	h[8] = (a6>>12) | ((a7&((1<< 6)-1))<<20); /* (32-12) +  6 = 20+ 6 = 26 */
+	h[9] = (a7>> 6)&((1<<25)-1); /*                                     25 */
 }
 
-/* return v / (2^25), using only shifts and adds.
- *
- * On entry: v can take any value.
- */
-static inline limb div_by_2_25(const limb v)
+static __always_inline void fe_frombytes(fe *h, const uint8_t *s)
 {
-	/* High word of v; no shift needed*/
-	const uint32_t highword = (uint32_t) (((uint64_t) v) >> 32);
-	/* Set to all 1s if v was negative; else set to 0s. */
-	const int32_t sign = ((int32_t) highword) >> 31;
-	/* Set to 0x1ffffff if v was negative; else set to 0. */
-	const int32_t roundoff = ((uint32_t) sign) >> 7;
-	/* Should return v / (1<<25) */
-	return (v + roundoff) >> 25;
+	fe_frombytes_impl(h->v, s);
 }
 
-/* Reduce all coefficients of the short form input so that |x| < 2^26.
- *
- * On entry: |output[i]| < 280*2^54
- */
-static void freduce_coefficients(limb *output)
+static __always_inline uint8_t /*bool*/ addcarryx_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
 {
-	unsigned int i;
-
-	output[10] = 0;
-
-	for (i = 0; i < 10; i += 2) {
-		limb over = div_by_2_26(output[i]);
-		/* The entry condition (that |output[i]| < 280*2^54) means that over is, at
-		 * most, 280*2^28 in the first iteration of this loop. This is added to the
-		 * next limb and we can approximate the resulting bound of that limb by
-		 * 281*2^54.
-		 */
-		output[i] -= over << 26;
-		output[i+1] += over;
-
-		/* For the first iteration, |output[i+1]| < 281*2^54, thus |over| <
-		 * 281*2^29. When this is added to the next limb, the resulting bound can
-		 * be approximated as 281*2^54.
-		 *
-		 * For subsequent iterations of the loop, 281*2^54 remains a conservative
-		 * bound and no overflow occurs.
-		 */
-		over = div_by_2_25(output[i+1]);
-		output[i+1] -= over << 25;
-		output[i+2] += over;
-	}
-	/* Now |output[10]| < 281*2^29 and all other coefficients are reduced. */
-	output[0] += output[10] << 4;
-	output[0] += output[10] << 1;
-	output[0] += output[10];
-
-	output[10] = 0;
-
-	/* Now output[1..9] are reduced, and |output[0]| < 2^26 + 19*281*2^29
-	 * So |over| will be no more than 2^16.
+	/* This function extracts 25 bits of result and 1 bit of carry (26 total), so
+	 * a 32-bit intermediate is sufficient.
 	 */
-	{
-		limb over = div_by_2_26(output[0]);
-
-		output[0] -= over << 26;
-		output[1] += over;
-	}
+	uint32_t x = a + b + c;
+	*low = x & ((1 << 25) - 1);
+	return (x >> 25) & 1;
+}
 
-	/* Now output[0,2..9] are reduced, and |output[1]| < 2^25 + 2^16 < 2^26. The
-	 * bound on |output[1]| is sufficient to meet our needs.
+static __always_inline uint8_t /*bool*/ addcarryx_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
+{
+	/* This function extracts 26 bits of result and 1 bit of carry (27 total), so
+	 * a 32-bit intermediate is sufficient.
 	 */
+	uint32_t x = a + b + c;
+	*low = x & ((1 << 26) - 1);
+	return (x >> 26) & 1;
 }
 
-/* A helpful wrapper around fproduct: output = in * in2.
- *
- * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27.
- *
- * output must be distinct to both inputs. The output is reduced degree
- * (indeed, one need only provide storage for 10 limbs) and |output[i]| < 2^26.
- */
-static void fmul(limb *output, const limb *in, const limb *in2)
+static __always_inline uint8_t /*bool*/ subborrow_u25(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
 {
-	limb t[19];
-
-	fproduct(t, in, in2);
-	/* |t[i]| < 14*2^54 */
-	freduce_degree(t);
-	freduce_coefficients(t);
-	/* |t[i]| < 2^26 */
-	memcpy(output, t, sizeof(limb) * 10);
+	/* This function extracts 25 bits of result and 1 bit of borrow (26 total), so
+	 * a 32-bit intermediate is sufficient.
+	 */
+	uint32_t x = a - b - c;
+	*low = x & ((1 << 25) - 1);
+	return x >> 31;
 }
 
-/* Square a number: output = in**2
- *
- * output must be distinct from the input. The inputs are reduced coefficient
- * form, the output is not.
- *
- * output[x] <= 14 * the largest product of the input limbs.
- */
-static void fsquare_inner(limb *output, const limb *in)
-{
-	output[0] =       ((limb) ((int32_t) in[0])) * ((int32_t) in[0]);
-	output[1] =  2 *  ((limb) ((int32_t) in[0])) * ((int32_t) in[1]);
-	output[2] =  2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[1]) +
-					    ((limb) ((int32_t) in[0])) * ((int32_t) in[2]));
-	output[3] =  2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[2]) +
-					    ((limb) ((int32_t) in[0])) * ((int32_t) in[3]));
-	output[4] =       ((limb) ((int32_t) in[2])) * ((int32_t) in[2]) +
-				       4 *  ((limb) ((int32_t) in[1])) * ((int32_t) in[3]) +
-				       2 *  ((limb) ((int32_t) in[0])) * ((int32_t) in[4]);
-	output[5] =  2 * (((limb) ((int32_t) in[2])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in[1])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in[0])) * ((int32_t) in[5]));
-	output[6] =  2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[3]) +
-					    ((limb) ((int32_t) in[2])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in[0])) * ((int32_t) in[6]) +
-				       2 *  ((limb) ((int32_t) in[1])) * ((int32_t) in[5]));
-	output[7] =  2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[4]) +
-					    ((limb) ((int32_t) in[2])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in[1])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in[0])) * ((int32_t) in[7]));
-	output[8] =       ((limb) ((int32_t) in[4])) * ((int32_t) in[4]) +
-				       2 * (((limb) ((int32_t) in[2])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in[0])) * ((int32_t) in[8]) +
-				       2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in[3])) * ((int32_t) in[5])));
-	output[9] =  2 * (((limb) ((int32_t) in[4])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in[3])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in[2])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in[1])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in[0])) * ((int32_t) in[9]));
-	output[10] = 2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[5]) +
-					    ((limb) ((int32_t) in[4])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in[2])) * ((int32_t) in[8]) +
-				       2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in[1])) * ((int32_t) in[9])));
-	output[11] = 2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[6]) +
-					    ((limb) ((int32_t) in[4])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in[3])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in[2])) * ((int32_t) in[9]));
-	output[12] =      ((limb) ((int32_t) in[6])) * ((int32_t) in[6]) +
-				       2 * (((limb) ((int32_t) in[4])) * ((int32_t) in[8]) +
-				       2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in[3])) * ((int32_t) in[9])));
-	output[13] = 2 * (((limb) ((int32_t) in[6])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in[5])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in[4])) * ((int32_t) in[9]));
-	output[14] = 2 * (((limb) ((int32_t) in[7])) * ((int32_t) in[7]) +
-					    ((limb) ((int32_t) in[6])) * ((int32_t) in[8]) +
-				       2 *  ((limb) ((int32_t) in[5])) * ((int32_t) in[9]));
-	output[15] = 2 * (((limb) ((int32_t) in[7])) * ((int32_t) in[8]) +
-					    ((limb) ((int32_t) in[6])) * ((int32_t) in[9]));
-	output[16] =      ((limb) ((int32_t) in[8])) * ((int32_t) in[8]) +
-				       4 *  ((limb) ((int32_t) in[7])) * ((int32_t) in[9]);
-	output[17] = 2 *  ((limb) ((int32_t) in[8])) * ((int32_t) in[9]);
-	output[18] = 2 *  ((limb) ((int32_t) in[9])) * ((int32_t) in[9]);
-}
-
-/* fsquare sets output = in^2.
- *
- * On entry: The |in| argument is in reduced coefficients form and |in[i]| <
- * 2^27.
- *
- * On exit: The |output| argument is in reduced coefficients form (indeed, one
- * need only provide storage for 10 limbs) and |out[i]| < 2^26.
- */
-static void fsquare(limb *output, const limb *in)
+static __always_inline uint8_t /*bool*/ subborrow_u26(uint8_t /*bool*/ c, uint32_t a, uint32_t b, uint32_t *low)
 {
-	limb t[19];
-
-	fsquare_inner(t, in);
-	/* |t[i]| < 14*2^54 because the largest product of two limbs will be <
-	 * 2^(27+27) and fsquare_inner adds together, at most, 14 of those
-	 * products.
+	/* This function extracts 26 bits of result and 1 bit of borrow (27 total), so
+	 * a 32-bit intermediate is sufficient.
 	 */
-	freduce_degree(t);
-	freduce_coefficients(t);
-	/* |t[i]| < 2^26 */
-	memcpy(output, t, sizeof(limb) * 10);
-}
-
-/* Take a little-endian, 32-byte number and expand it into polynomial form */
-static void fexpand(limb *output, const uint8_t *input)
-{
-#define F(n, start, shift, mask) \
-	output[n] = ((((limb) input[start + 0]) | \
-		      ((limb) input[start + 1]) << 8 | \
-		      ((limb) input[start + 2]) << 16 | \
-		      ((limb) input[start + 3]) << 24) >> shift) & mask;
-	F(0, 0, 0, 0x3ffffff);
-	F(1, 3, 2, 0x1ffffff);
-	F(2, 6, 3, 0x3ffffff);
-	F(3, 9, 5, 0x1ffffff);
-	F(4, 12, 6, 0x3ffffff);
-	F(5, 16, 0, 0x1ffffff);
-	F(6, 19, 1, 0x3ffffff);
-	F(7, 22, 3, 0x1ffffff);
-	F(8, 25, 4, 0x3ffffff);
-	F(9, 28, 6, 0x1ffffff);
-#undef F
-}
-
-#if (-32 >> 1) != -16
-#error "This code only works when >> does sign-extension on negative numbers"
-#endif
+	uint32_t x = a - b - c;
+	*low = x & ((1 << 26) - 1);
+	return x >> 31;
+}
 
-/* int32_t_eq returns 0xffffffff iff a == b and zero otherwise. */
-static int32_t int32_t_eq(int32_t a, int32_t b)
+static __always_inline uint32_t cmovznz32(uint32_t t, uint32_t z, uint32_t nz)
 {
-	a = ~(a ^ b);
-	a &= a << 16;
-	a &= a << 8;
-	a &= a << 4;
-	a &= a << 2;
-	a &= a << 1;
-	return a >> 31;
+	t = -!!t; /* all set if nonzero, 0 if 0 */
+	return (t&nz) | ((~t)&z);
 }
 
-/* int32_t_gte returns 0xffffffff if a >= b and zero otherwise, where a and b are
- * both non-negative.
- */
-static int32_t int32_t_gte(int32_t a, int32_t b)
+static __always_inline void fe_freeze(uint32_t out[10], const uint32_t in1[10])
 {
-	a -= b;
-	/* a >= 0 iff a >= b. */
-	return ~(a >> 31);
+	{ const uint32_t x17 = in1[9];
+	{ const uint32_t x18 = in1[8];
+	{ const uint32_t x16 = in1[7];
+	{ const uint32_t x14 = in1[6];
+	{ const uint32_t x12 = in1[5];
+	{ const uint32_t x10 = in1[4];
+	{ const uint32_t x8 = in1[3];
+	{ const uint32_t x6 = in1[2];
+	{ const uint32_t x4 = in1[1];
+	{ const uint32_t x2 = in1[0];
+	{ uint32_t x20; uint8_t/*bool*/ x21 = subborrow_u26(0x0, x2, 0x3ffffed, &x20);
+	{ uint32_t x23; uint8_t/*bool*/ x24 = subborrow_u25(x21, x4, 0x1ffffff, &x23);
+	{ uint32_t x26; uint8_t/*bool*/ x27 = subborrow_u26(x24, x6, 0x3ffffff, &x26);
+	{ uint32_t x29; uint8_t/*bool*/ x30 = subborrow_u25(x27, x8, 0x1ffffff, &x29);
+	{ uint32_t x32; uint8_t/*bool*/ x33 = subborrow_u26(x30, x10, 0x3ffffff, &x32);
+	{ uint32_t x35; uint8_t/*bool*/ x36 = subborrow_u25(x33, x12, 0x1ffffff, &x35);
+	{ uint32_t x38; uint8_t/*bool*/ x39 = subborrow_u26(x36, x14, 0x3ffffff, &x38);
+	{ uint32_t x41; uint8_t/*bool*/ x42 = subborrow_u25(x39, x16, 0x1ffffff, &x41);
+	{ uint32_t x44; uint8_t/*bool*/ x45 = subborrow_u26(x42, x18, 0x3ffffff, &x44);
+	{ uint32_t x47; uint8_t/*bool*/ x48 = subborrow_u25(x45, x17, 0x1ffffff, &x47);
+	{ uint32_t x49 = cmovznz32(x48, 0x0, 0xffffffff);
+	{ uint32_t x50 = (x49 & 0x3ffffed);
+	{ uint32_t x52; uint8_t/*bool*/ x53 = addcarryx_u26(0x0, x20, x50, &x52);
+	{ uint32_t x54 = (x49 & 0x1ffffff);
+	{ uint32_t x56; uint8_t/*bool*/ x57 = addcarryx_u25(x53, x23, x54, &x56);
+	{ uint32_t x58 = (x49 & 0x3ffffff);
+	{ uint32_t x60; uint8_t/*bool*/ x61 = addcarryx_u26(x57, x26, x58, &x60);
+	{ uint32_t x62 = (x49 & 0x1ffffff);
+	{ uint32_t x64; uint8_t/*bool*/ x65 = addcarryx_u25(x61, x29, x62, &x64);
+	{ uint32_t x66 = (x49 & 0x3ffffff);
+	{ uint32_t x68; uint8_t/*bool*/ x69 = addcarryx_u26(x65, x32, x66, &x68);
+	{ uint32_t x70 = (x49 & 0x1ffffff);
+	{ uint32_t x72; uint8_t/*bool*/ x73 = addcarryx_u25(x69, x35, x70, &x72);
+	{ uint32_t x74 = (x49 & 0x3ffffff);
+	{ uint32_t x76; uint8_t/*bool*/ x77 = addcarryx_u26(x73, x38, x74, &x76);
+	{ uint32_t x78 = (x49 & 0x1ffffff);
+	{ uint32_t x80; uint8_t/*bool*/ x81 = addcarryx_u25(x77, x41, x78, &x80);
+	{ uint32_t x82 = (x49 & 0x3ffffff);
+	{ uint32_t x84; uint8_t/*bool*/ x85 = addcarryx_u26(x81, x44, x82, &x84);
+	{ uint32_t x86 = (x49 & 0x1ffffff);
+	{ uint32_t x88; addcarryx_u25(x85, x47, x86, &x88);
+	out[0] = x52;
+	out[1] = x56;
+	out[2] = x60;
+	out[3] = x64;
+	out[4] = x68;
+	out[5] = x72;
+	out[6] = x76;
+	out[7] = x80;
+	out[8] = x84;
+	out[9] = x88;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
 }
 
-/* Take a fully reduced polynomial form number and contract it into a
- * little-endian, 32-byte array.
- *
- * On entry: |input_limbs[i]| < 2^26
- */
-static void fcontract(uint8_t *output, limb *input_limbs)
+static __always_inline void fe_tobytes(uint8_t s[32], const fe *f)
 {
-	int i;
-	int j;
-	int32_t input[10];
-	int32_t mask;
-
-	/* |input_limbs[i]| < 2^26, so it's valid to convert to an int32_t. */
-	for (i = 0; i < 10; i++) {
-		input[i] = input_limbs[i];
-	}
-
-	for (j = 0; j < 2; ++j) {
-		for (i = 0; i < 9; ++i) {
-			if ((i & 1) == 1) {
-				/* This calculation is a time-invariant way to make input[i]
-				 * non-negative by borrowing from the next-larger limb.
-				 */
-				const int32_t mask = input[i] >> 31;
-				const int32_t carry = -((input[i] & mask) >> 25);
-
-				input[i] = input[i] + (carry << 25);
-				input[i+1] = input[i+1] - carry;
-			} else {
-				const int32_t mask = input[i] >> 31;
-				const int32_t carry = -((input[i] & mask) >> 26);
-
-				input[i] = input[i] + (carry << 26);
-				input[i+1] = input[i+1] - carry;
-			}
-		}
+	uint32_t h[10];
+	fe_freeze(h, f->v);
+	s[0] = h[0] >> 0;
+	s[1] = h[0] >> 8;
+	s[2] = h[0] >> 16;
+	s[3] = (h[0] >> 24) | (h[1] << 2);
+	s[4] = h[1] >> 6;
+	s[5] = h[1] >> 14;
+	s[6] = (h[1] >> 22) | (h[2] << 3);
+	s[7] = h[2] >> 5;
+	s[8] = h[2] >> 13;
+	s[9] = (h[2] >> 21) | (h[3] << 5);
+	s[10] = h[3] >> 3;
+	s[11] = h[3] >> 11;
+	s[12] = (h[3] >> 19) | (h[4] << 6);
+	s[13] = h[4] >> 2;
+	s[14] = h[4] >> 10;
+	s[15] = h[4] >> 18;
+	s[16] = h[5] >> 0;
+	s[17] = h[5] >> 8;
+	s[18] = h[5] >> 16;
+	s[19] = (h[5] >> 24) | (h[6] << 1);
+	s[20] = h[6] >> 7;
+	s[21] = h[6] >> 15;
+	s[22] = (h[6] >> 23) | (h[7] << 3);
+	s[23] = h[7] >> 5;
+	s[24] = h[7] >> 13;
+	s[25] = (h[7] >> 21) | (h[8] << 4);
+	s[26] = h[8] >> 4;
+	s[27] = h[8] >> 12;
+	s[28] = (h[8] >> 20) | (h[9] << 6);
+	s[29] = h[9] >> 2;
+	s[30] = h[9] >> 10;
+	s[31] = h[9] >> 18;
+}
 
-		/* There's no greater limb for input[9] to borrow from, but we can multiply
-		 * by 19 and borrow from input[0], which is valid mod 2^255-19.
-		 */
-		{
-			const int32_t mask = input[9] >> 31;
-			const int32_t carry = -((input[9] & mask) >> 25);
+/* h = f */
+static __always_inline void fe_copy(fe *h, const fe *f)
+{
+	memmove(h, f, sizeof(uint32_t) * 10);
+}
 
-			input[9] = input[9] + (carry << 25);
-			input[0] = input[0] - (carry * 19);
-		}
+static __always_inline void fe_copy_lt(fe_loose *h, const fe *f)
+{
+	memmove(h, f, sizeof(uint32_t) * 10);
+}
 
-		/* After the first iteration, input[1..9] are non-negative and fit within
-		 * 25 or 26 bits, depending on position. However, input[0] may be
-		 * negative.
-		 */
-	}
+/* h = 0 */
+static __always_inline void fe_0(fe *h)
+{
+	memset(h, 0, sizeof(uint32_t) * 10);
+}
 
-	/* The first borrow-propagation pass above ended with every limb
-		 except (possibly) input[0] non-negative.
-		 If input[0] was negative after the first pass, then it was because of a
-		 carry from input[9]. On entry, input[9] < 2^26 so the carry was, at most,
-		 one, since (2**26-1) >> 25 = 1. Thus input[0] >= -19.
-		 In the second pass, each limb is decreased by at most one. Thus the second
-		 borrow-propagation pass could only have wrapped around to decrease
-		 input[0] again if the first pass left input[0] negative *and* input[1]
-		 through input[9] were all zero.  In that case, input[1] is now 2^25 - 1,
-		 and this last borrow-propagation step will leave input[1] non-negative. */
-	{
-		const int32_t mask = input[0] >> 31;
-		const int32_t carry = -((input[0] & mask) >> 26);
+/* h = 1 */
+static __always_inline void fe_1(fe *h)
+{
+	memset(h, 0, sizeof(uint32_t) * 10);
+	h->v[0] = 1;
+}
 
-		input[0] = input[0] + (carry << 26);
-		input[1] = input[1] - carry;
-	}
+static __always_inline void fe_add_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+{
+	{ const uint32_t x20 = in1[9];
+	{ const uint32_t x21 = in1[8];
+	{ const uint32_t x19 = in1[7];
+	{ const uint32_t x17 = in1[6];
+	{ const uint32_t x15 = in1[5];
+	{ const uint32_t x13 = in1[4];
+	{ const uint32_t x11 = in1[3];
+	{ const uint32_t x9 = in1[2];
+	{ const uint32_t x7 = in1[1];
+	{ const uint32_t x5 = in1[0];
+	{ const uint32_t x38 = in2[9];
+	{ const uint32_t x39 = in2[8];
+	{ const uint32_t x37 = in2[7];
+	{ const uint32_t x35 = in2[6];
+	{ const uint32_t x33 = in2[5];
+	{ const uint32_t x31 = in2[4];
+	{ const uint32_t x29 = in2[3];
+	{ const uint32_t x27 = in2[2];
+	{ const uint32_t x25 = in2[1];
+	{ const uint32_t x23 = in2[0];
+	out[0] = (x5 + x23);
+	out[1] = (x7 + x25);
+	out[2] = (x9 + x27);
+	out[3] = (x11 + x29);
+	out[4] = (x13 + x31);
+	out[5] = (x15 + x33);
+	out[6] = (x17 + x35);
+	out[7] = (x19 + x37);
+	out[8] = (x21 + x39);
+	out[9] = (x20 + x38);
+	}}}}}}}}}}}}}}}}}}}}
+}
 
-	/* All input[i] are now non-negative. However, there might be values between
-	 * 2^25 and 2^26 in a limb which is, nominally, 25 bits wide.
-	 */
-	for (j = 0; j < 2; j++) {
-		for (i = 0; i < 9; i++) {
-			if ((i & 1) == 1) {
-				const int32_t carry = input[i] >> 25;
-
-				input[i] &= 0x1ffffff;
-				input[i+1] += carry;
-			} else {
-				const int32_t carry = input[i] >> 26;
-
-				input[i] &= 0x3ffffff;
-				input[i+1] += carry;
-			}
-		}
+/* h = f + g
+ * Can overlap h with f or g.
+ */
+static __always_inline void fe_add(fe_loose *h, const fe *f, const fe *g)
+{
+	fe_add_impl(h->v, f->v, g->v);
+}
 
-		{
-			const int32_t carry = input[9] >> 25;
+static __always_inline void fe_sub_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+{
+	{ const uint32_t x20 = in1[9];
+	{ const uint32_t x21 = in1[8];
+	{ const uint32_t x19 = in1[7];
+	{ const uint32_t x17 = in1[6];
+	{ const uint32_t x15 = in1[5];
+	{ const uint32_t x13 = in1[4];
+	{ const uint32_t x11 = in1[3];
+	{ const uint32_t x9 = in1[2];
+	{ const uint32_t x7 = in1[1];
+	{ const uint32_t x5 = in1[0];
+	{ const uint32_t x38 = in2[9];
+	{ const uint32_t x39 = in2[8];
+	{ const uint32_t x37 = in2[7];
+	{ const uint32_t x35 = in2[6];
+	{ const uint32_t x33 = in2[5];
+	{ const uint32_t x31 = in2[4];
+	{ const uint32_t x29 = in2[3];
+	{ const uint32_t x27 = in2[2];
+	{ const uint32_t x25 = in2[1];
+	{ const uint32_t x23 = in2[0];
+	out[0] = ((0x7ffffda + x5) - x23);
+	out[1] = ((0x3fffffe + x7) - x25);
+	out[2] = ((0x7fffffe + x9) - x27);
+	out[3] = ((0x3fffffe + x11) - x29);
+	out[4] = ((0x7fffffe + x13) - x31);
+	out[5] = ((0x3fffffe + x15) - x33);
+	out[6] = ((0x7fffffe + x17) - x35);
+	out[7] = ((0x3fffffe + x19) - x37);
+	out[8] = ((0x7fffffe + x21) - x39);
+	out[9] = ((0x3fffffe + x20) - x38);
+	}}}}}}}}}}}}}}}}}}}}
+}
 
-			input[9] &= 0x1ffffff;
-			input[0] += 19*carry;
-		}
-	}
+/* h = f - g
+ * Can overlap h with f or g.
+ */
+static __always_inline void fe_sub(fe_loose *h, const fe *f, const fe *g)
+{
+	fe_sub_impl(h->v, f->v, g->v);
+}
 
-	/* If the first carry-chain pass, just above, ended up with a carry from
-	 * input[9], and that caused input[0] to be out-of-bounds, then input[0] was
-	 * < 2^26 + 2*19, because the carry was, at most, two.
-	 *
-	 * If the second pass carried from input[9] again then input[0] is < 2*19 and
-	 * the input[9] -> input[0] carry didn't push input[0] out of bounds.
-	 */
+static __always_inline void fe_mul_impl(uint32_t out[10], const uint32_t in1[10], const uint32_t in2[10])
+{
+	{ const uint32_t x20 = in1[9];
+	{ const uint32_t x21 = in1[8];
+	{ const uint32_t x19 = in1[7];
+	{ const uint32_t x17 = in1[6];
+	{ const uint32_t x15 = in1[5];
+	{ const uint32_t x13 = in1[4];
+	{ const uint32_t x11 = in1[3];
+	{ const uint32_t x9 = in1[2];
+	{ const uint32_t x7 = in1[1];
+	{ const uint32_t x5 = in1[0];
+	{ const uint32_t x38 = in2[9];
+	{ const uint32_t x39 = in2[8];
+	{ const uint32_t x37 = in2[7];
+	{ const uint32_t x35 = in2[6];
+	{ const uint32_t x33 = in2[5];
+	{ const uint32_t x31 = in2[4];
+	{ const uint32_t x29 = in2[3];
+	{ const uint32_t x27 = in2[2];
+	{ const uint32_t x25 = in2[1];
+	{ const uint32_t x23 = in2[0];
+	{ uint64_t x40 = ((uint64_t)x23 * x5);
+	{ uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));
+	{ uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));
+	{ uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));
+	{ uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));
+	{ uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));
+	{ uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));
+	{ uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));
+	{ uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));
+	{ uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));
+	{ uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));
+	{ uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));
+	{ uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));
+	{ uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));
+	{ uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));
+	{ uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));
+	{ uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));
+	{ uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));
+	{ uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);
+	{ uint64_t x59 = (x48 + (x58 << 0x4));
+	{ uint64_t x60 = (x59 + (x58 << 0x1));
+	{ uint64_t x61 = (x60 + x58);
+	{ uint64_t x62 = (x47 + (x57 << 0x4));
+	{ uint64_t x63 = (x62 + (x57 << 0x1));
+	{ uint64_t x64 = (x63 + x57);
+	{ uint64_t x65 = (x46 + (x56 << 0x4));
+	{ uint64_t x66 = (x65 + (x56 << 0x1));
+	{ uint64_t x67 = (x66 + x56);
+	{ uint64_t x68 = (x45 + (x55 << 0x4));
+	{ uint64_t x69 = (x68 + (x55 << 0x1));
+	{ uint64_t x70 = (x69 + x55);
+	{ uint64_t x71 = (x44 + (x54 << 0x4));
+	{ uint64_t x72 = (x71 + (x54 << 0x1));
+	{ uint64_t x73 = (x72 + x54);
+	{ uint64_t x74 = (x43 + (x53 << 0x4));
+	{ uint64_t x75 = (x74 + (x53 << 0x1));
+	{ uint64_t x76 = (x75 + x53);
+	{ uint64_t x77 = (x42 + (x52 << 0x4));
+	{ uint64_t x78 = (x77 + (x52 << 0x1));
+	{ uint64_t x79 = (x78 + x52);
+	{ uint64_t x80 = (x41 + (x51 << 0x4));
+	{ uint64_t x81 = (x80 + (x51 << 0x1));
+	{ uint64_t x82 = (x81 + x51);
+	{ uint64_t x83 = (x40 + (x50 << 0x4));
+	{ uint64_t x84 = (x83 + (x50 << 0x1));
+	{ uint64_t x85 = (x84 + x50);
+	{ uint64_t x86 = (x85 >> 0x1a);
+	{ uint32_t x87 = ((uint32_t)x85 & 0x3ffffff);
+	{ uint64_t x88 = (x86 + x82);
+	{ uint64_t x89 = (x88 >> 0x19);
+	{ uint32_t x90 = ((uint32_t)x88 & 0x1ffffff);
+	{ uint64_t x91 = (x89 + x79);
+	{ uint64_t x92 = (x91 >> 0x1a);
+	{ uint32_t x93 = ((uint32_t)x91 & 0x3ffffff);
+	{ uint64_t x94 = (x92 + x76);
+	{ uint64_t x95 = (x94 >> 0x19);
+	{ uint32_t x96 = ((uint32_t)x94 & 0x1ffffff);
+	{ uint64_t x97 = (x95 + x73);
+	{ uint64_t x98 = (x97 >> 0x1a);
+	{ uint32_t x99 = ((uint32_t)x97 & 0x3ffffff);
+	{ uint64_t x100 = (x98 + x70);
+	{ uint64_t x101 = (x100 >> 0x19);
+	{ uint32_t x102 = ((uint32_t)x100 & 0x1ffffff);
+	{ uint64_t x103 = (x101 + x67);
+	{ uint64_t x104 = (x103 >> 0x1a);
+	{ uint32_t x105 = ((uint32_t)x103 & 0x3ffffff);
+	{ uint64_t x106 = (x104 + x64);
+	{ uint64_t x107 = (x106 >> 0x19);
+	{ uint32_t x108 = ((uint32_t)x106 & 0x1ffffff);
+	{ uint64_t x109 = (x107 + x61);
+	{ uint64_t x110 = (x109 >> 0x1a);
+	{ uint32_t x111 = ((uint32_t)x109 & 0x3ffffff);
+	{ uint64_t x112 = (x110 + x49);
+	{ uint64_t x113 = (x112 >> 0x19);
+	{ uint32_t x114 = ((uint32_t)x112 & 0x1ffffff);
+	{ uint64_t x115 = (x87 + (0x13 * x113));
+	{ uint32_t x116 = (uint32_t) (x115 >> 0x1a);
+	{ uint32_t x117 = ((uint32_t)x115 & 0x3ffffff);
+	{ uint32_t x118 = (x116 + x90);
+	{ uint32_t x119 = (x118 >> 0x19);
+	{ uint32_t x120 = (x118 & 0x1ffffff);
+	out[0] = x117;
+	out[1] = x120;
+	out[2] = (x119 + x93);
+	out[3] = x96;
+	out[4] = x99;
+	out[5] = x102;
+	out[6] = x105;
+	out[7] = x108;
+	out[8] = x111;
+	out[9] = x114;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
 
-	/* It still remains the case that input might be between 2^255-19 and 2^255.
-	 * In this case, input[1..9] must take their maximum value and input[0] must
-	 * be >= (2^255-19) & 0x3ffffff, which is 0x3ffffed.
-	 */
-	mask = int32_t_gte(input[0], 0x3ffffed);
-	for (i = 1; i < 10; i++) {
-		if ((i & 1) == 1) {
-			mask &= int32_t_eq(input[i], 0x1ffffff);
-		} else {
-			mask &= int32_t_eq(input[i], 0x3ffffff);
-		}
-	}
+static __always_inline void fe_mul_ttt(fe *h, const fe *f, const fe *g)
+{
+	fe_mul_impl(h->v, f->v, g->v);
+}
 
-	/* mask is either 0xffffffff (if input >= 2^255-19) and zero otherwise. Thus
-	 * this conditionally subtracts 2^255-19.
-	 */
-	input[0] -= mask & 0x3ffffed;
+static __always_inline void fe_mul_tlt(fe *h, const fe_loose *f, const fe *g)
+{
+	fe_mul_impl(h->v, f->v, g->v);
+}
 
-	for (i = 1; i < 10; i++) {
-		if ((i & 1) == 1) {
-			input[i] -= mask & 0x1ffffff;
-		} else {
-			input[i] -= mask & 0x3ffffff;
-		}
-	}
+static __always_inline void fe_mul_tll(fe *h, const fe_loose *f, const fe_loose *g)
+{
+	fe_mul_impl(h->v, f->v, g->v);
+}
 
-	input[1] <<= 2;
-	input[2] <<= 3;
-	input[3] <<= 5;
-	input[4] <<= 6;
-	input[6] <<= 1;
-	input[7] <<= 3;
-	input[8] <<= 4;
-	input[9] <<= 6;
-#define F(i, s) \
-	output[s+0] |=  input[i] & 0xff; \
-	output[s+1]  = (input[i] >> 8) & 0xff; \
-	output[s+2]  = (input[i] >> 16) & 0xff; \
-	output[s+3]  = (input[i] >> 24) & 0xff;
-	output[0] = 0;
-	output[16] = 0;
-	F(0, 0);
-	F(1, 3);
-	F(2, 6);
-	F(3, 9);
-	F(4, 12);
-	F(5, 16);
-	F(6, 19);
-	F(7, 22);
-	F(8, 25);
-	F(9, 28);
-#undef F
-}
-
-/* Input: Q, Q', Q-Q'
- * Output: 2Q, Q+Q'
- *
- *   x2 z3: long form
- *   x3 z3: long form
- *   x z: short form, destroyed
- *   xprime zprime: short form, destroyed
- *   qmqp: short form, preserved
- *
- * On entry and exit, the absolute value of the limbs of all inputs and outputs
- * are < 2^26.
- */
-static void fmonty(limb *x2, limb *z2,  /* output 2Q */
-		   limb *x3, limb *z3,  /* output Q + Q' */
-		   limb *x, limb *z,    /* input Q */
-		   limb *xprime, limb *zprime,  /* input Q' */
+static __always_inline void fe_sqr_impl(uint32_t out[10], const uint32_t in1[10])
+{
+	{ const uint32_t x17 = in1[9];
+	{ const uint32_t x18 = in1[8];
+	{ const uint32_t x16 = in1[7];
+	{ const uint32_t x14 = in1[6];
+	{ const uint32_t x12 = in1[5];
+	{ const uint32_t x10 = in1[4];
+	{ const uint32_t x8 = in1[3];
+	{ const uint32_t x6 = in1[2];
+	{ const uint32_t x4 = in1[1];
+	{ const uint32_t x2 = in1[0];
+	{ uint64_t x19 = ((uint64_t)x2 * x2);
+	{ uint64_t x20 = ((uint64_t)(0x2 * x2) * x4);
+	{ uint64_t x21 = (0x2 * (((uint64_t)x4 * x4) + ((uint64_t)x2 * x6)));
+	{ uint64_t x22 = (0x2 * (((uint64_t)x4 * x6) + ((uint64_t)x2 * x8)));
+	{ uint64_t x23 = ((((uint64_t)x6 * x6) + ((uint64_t)(0x4 * x4) * x8)) + ((uint64_t)(0x2 * x2) * x10));
+	{ uint64_t x24 = (0x2 * ((((uint64_t)x6 * x8) + ((uint64_t)x4 * x10)) + ((uint64_t)x2 * x12)));
+	{ uint64_t x25 = (0x2 * (((((uint64_t)x8 * x8) + ((uint64_t)x6 * x10)) + ((uint64_t)x2 * x14)) + ((uint64_t)(0x2 * x4) * x12)));
+	{ uint64_t x26 = (0x2 * (((((uint64_t)x8 * x10) + ((uint64_t)x6 * x12)) + ((uint64_t)x4 * x14)) + ((uint64_t)x2 * x16)));
+	{ uint64_t x27 = (((uint64_t)x10 * x10) + (0x2 * ((((uint64_t)x6 * x14) + ((uint64_t)x2 * x18)) + (0x2 * (((uint64_t)x4 * x16) + ((uint64_t)x8 * x12))))));
+	{ uint64_t x28 = (0x2 * ((((((uint64_t)x10 * x12) + ((uint64_t)x8 * x14)) + ((uint64_t)x6 * x16)) + ((uint64_t)x4 * x18)) + ((uint64_t)x2 * x17)));
+	{ uint64_t x29 = (0x2 * (((((uint64_t)x12 * x12) + ((uint64_t)x10 * x14)) + ((uint64_t)x6 * x18)) + (0x2 * (((uint64_t)x8 * x16) + ((uint64_t)x4 * x17)))));
+	{ uint64_t x30 = (0x2 * (((((uint64_t)x12 * x14) + ((uint64_t)x10 * x16)) + ((uint64_t)x8 * x18)) + ((uint64_t)x6 * x17)));
+	{ uint64_t x31 = (((uint64_t)x14 * x14) + (0x2 * (((uint64_t)x10 * x18) + (0x2 * (((uint64_t)x12 * x16) + ((uint64_t)x8 * x17))))));
+	{ uint64_t x32 = (0x2 * ((((uint64_t)x14 * x16) + ((uint64_t)x12 * x18)) + ((uint64_t)x10 * x17)));
+	{ uint64_t x33 = (0x2 * ((((uint64_t)x16 * x16) + ((uint64_t)x14 * x18)) + ((uint64_t)(0x2 * x12) * x17)));
+	{ uint64_t x34 = (0x2 * (((uint64_t)x16 * x18) + ((uint64_t)x14 * x17)));
+	{ uint64_t x35 = (((uint64_t)x18 * x18) + ((uint64_t)(0x4 * x16) * x17));
+	{ uint64_t x36 = ((uint64_t)(0x2 * x18) * x17);
+	{ uint64_t x37 = ((uint64_t)(0x2 * x17) * x17);
+	{ uint64_t x38 = (x27 + (x37 << 0x4));
+	{ uint64_t x39 = (x38 + (x37 << 0x1));
+	{ uint64_t x40 = (x39 + x37);
+	{ uint64_t x41 = (x26 + (x36 << 0x4));
+	{ uint64_t x42 = (x41 + (x36 << 0x1));
+	{ uint64_t x43 = (x42 + x36);
+	{ uint64_t x44 = (x25 + (x35 << 0x4));
+	{ uint64_t x45 = (x44 + (x35 << 0x1));
+	{ uint64_t x46 = (x45 + x35);
+	{ uint64_t x47 = (x24 + (x34 << 0x4));
+	{ uint64_t x48 = (x47 + (x34 << 0x1));
+	{ uint64_t x49 = (x48 + x34);
+	{ uint64_t x50 = (x23 + (x33 << 0x4));
+	{ uint64_t x51 = (x50 + (x33 << 0x1));
+	{ uint64_t x52 = (x51 + x33);
+	{ uint64_t x53 = (x22 + (x32 << 0x4));
+	{ uint64_t x54 = (x53 + (x32 << 0x1));
+	{ uint64_t x55 = (x54 + x32);
+	{ uint64_t x56 = (x21 + (x31 << 0x4));
+	{ uint64_t x57 = (x56 + (x31 << 0x1));
+	{ uint64_t x58 = (x57 + x31);
+	{ uint64_t x59 = (x20 + (x30 << 0x4));
+	{ uint64_t x60 = (x59 + (x30 << 0x1));
+	{ uint64_t x61 = (x60 + x30);
+	{ uint64_t x62 = (x19 + (x29 << 0x4));
+	{ uint64_t x63 = (x62 + (x29 << 0x1));
+	{ uint64_t x64 = (x63 + x29);
+	{ uint64_t x65 = (x64 >> 0x1a);
+	{ uint32_t x66 = ((uint32_t)x64 & 0x3ffffff);
+	{ uint64_t x67 = (x65 + x61);
+	{ uint64_t x68 = (x67 >> 0x19);
+	{ uint32_t x69 = ((uint32_t)x67 & 0x1ffffff);
+	{ uint64_t x70 = (x68 + x58);
+	{ uint64_t x71 = (x70 >> 0x1a);
+	{ uint32_t x72 = ((uint32_t)x70 & 0x3ffffff);
+	{ uint64_t x73 = (x71 + x55);
+	{ uint64_t x74 = (x73 >> 0x19);
+	{ uint32_t x75 = ((uint32_t)x73 & 0x1ffffff);
+	{ uint64_t x76 = (x74 + x52);
+	{ uint64_t x77 = (x76 >> 0x1a);
+	{ uint32_t x78 = ((uint32_t)x76 & 0x3ffffff);
+	{ uint64_t x79 = (x77 + x49);
+	{ uint64_t x80 = (x79 >> 0x19);
+	{ uint32_t x81 = ((uint32_t)x79 & 0x1ffffff);
+	{ uint64_t x82 = (x80 + x46);
+	{ uint64_t x83 = (x82 >> 0x1a);
+	{ uint32_t x84 = ((uint32_t)x82 & 0x3ffffff);
+	{ uint64_t x85 = (x83 + x43);
+	{ uint64_t x86 = (x85 >> 0x19);
+	{ uint32_t x87 = ((uint32_t)x85 & 0x1ffffff);
+	{ uint64_t x88 = (x86 + x40);
+	{ uint64_t x89 = (x88 >> 0x1a);
+	{ uint32_t x90 = ((uint32_t)x88 & 0x3ffffff);
+	{ uint64_t x91 = (x89 + x28);
+	{ uint64_t x92 = (x91 >> 0x19);
+	{ uint32_t x93 = ((uint32_t)x91 & 0x1ffffff);
+	{ uint64_t x94 = (x66 + (0x13 * x92));
+	{ uint32_t x95 = (uint32_t) (x94 >> 0x1a);
+	{ uint32_t x96 = ((uint32_t)x94 & 0x3ffffff);
+	{ uint32_t x97 = (x95 + x69);
+	{ uint32_t x98 = (x97 >> 0x19);
+	{ uint32_t x99 = (x97 & 0x1ffffff);
+	out[0] = x96;
+	out[1] = x99;
+	out[2] = (x98 + x72);
+	out[3] = x75;
+	out[4] = x78;
+	out[5] = x81;
+	out[6] = x84;
+	out[7] = x87;
+	out[8] = x90;
+	out[9] = x93;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
 
-		   const limb *qmqp /* input Q - Q' */)
+static __always_inline void fe_sq_tl(fe *h, const fe_loose *f)
 {
-	limb origx[10], origxprime[10], zzz[19], xx[19], zz[19], xxprime[19],
-				zzprime[19], zzzprime[19], xxxprime[19];
+	fe_sqr_impl(h->v, f->v);
+}
 
-	memcpy(origx, x, 10 * sizeof(limb));
-	fsum(x, z);
-	/* |x[i]| < 2^27 */
-	fdifference(z, origx);  /* does x - z */
-	/* |z[i]| < 2^27 */
+static __always_inline void fe_sq_tt(fe *h, const fe *f)
+{
+	fe_sqr_impl(h->v, f->v);
+}
 
-	memcpy(origxprime, xprime, sizeof(limb) * 10);
-	fsum(xprime, zprime);
-	/* |xprime[i]| < 2^27 */
-	fdifference(zprime, origxprime);
-	/* |zprime[i]| < 2^27 */
-	fproduct(xxprime, xprime, z);
-	/* |xxprime[i]| < 14*2^54: the largest product of two limbs will be <
-	 * 2^(27+27) and fproduct adds together, at most, 14 of those products.
-	 * (Approximating that to 2^58 doesn't work out.)
-	 */
-	fproduct(zzprime, x, zprime);
-	/* |zzprime[i]| < 14*2^54 */
-	freduce_degree(xxprime);
-	freduce_coefficients(xxprime);
-	/* |xxprime[i]| < 2^26 */
-	freduce_degree(zzprime);
-	freduce_coefficients(zzprime);
-	/* |zzprime[i]| < 2^26 */
-	memcpy(origxprime, xxprime, sizeof(limb) * 10);
-	fsum(xxprime, zzprime);
-	/* |xxprime[i]| < 2^27 */
-	fdifference(zzprime, origxprime);
-	/* |zzprime[i]| < 2^27 */
-	fsquare(xxxprime, xxprime);
-	/* |xxxprime[i]| < 2^26 */
-	fsquare(zzzprime, zzprime);
-	/* |zzzprime[i]| < 2^26 */
-	fproduct(zzprime, zzzprime, qmqp);
-	/* |zzprime[i]| < 14*2^52 */
-	freduce_degree(zzprime);
-	freduce_coefficients(zzprime);
-	/* |zzprime[i]| < 2^26 */
-	memcpy(x3, xxxprime, sizeof(limb) * 10);
-	memcpy(z3, zzprime, sizeof(limb) * 10);
-
-	fsquare(xx, x);
-	/* |xx[i]| < 2^26 */
-	fsquare(zz, z);
-	/* |zz[i]| < 2^26 */
-	fproduct(x2, xx, zz);
-	/* |x2[i]| < 14*2^52 */
-	freduce_degree(x2);
-	freduce_coefficients(x2);
-	/* |x2[i]| < 2^26 */
-	fdifference(zz, xx);  // does zz = xx - zz
-	/* |zz[i]| < 2^27 */
-	memset(zzz + 10, 0, sizeof(limb) * 9);
-	fscalar_product(zzz, zz, 121665);
-	/* |zzz[i]| < 2^(27+17) */
-	/* No need to call freduce_degree here:
-		 fscalar_product doesn't increase the degree of its input. */
-	freduce_coefficients(zzz);
-	/* |zzz[i]| < 2^26 */
-	fsum(zzz, xx);
-	/* |zzz[i]| < 2^27 */
-	fproduct(z2, zz, zzz);
-	/* |z2[i]| < 14*2^(26+27) */
-	freduce_degree(z2);
-	freduce_coefficients(z2);
-	/* |z2|i| < 2^26 */
-}
-
-/* Conditionally swap two reduced-form limb arrays if 'iswap' is 1, but leave
- * them unchanged if 'iswap' is 0.  Runs in data-invariant time to avoid
- * side-channel attacks.
- *
- * NOTE that this function requires that 'iswap' be 1 or 0; other values give
- * wrong results.  Also, the two limb arrays must be in reduced-coefficient,
- * reduced-degree form: the values in a[10..19] or b[10..19] aren't swapped,
- * and all all values in a[0..9],b[0..9] must have magnitude less than
- * INT32_MAX.
- */
-static void swap_conditional(limb a[static 19], limb b[static 19], limb iswap)
+static __always_inline void fe_loose_invert(fe *out, const fe_loose *z)
 {
-	unsigned int i;
-	const int32_t swap = (int32_t) -iswap;
+	fe t0;
+	fe t1;
+	fe t2;
+	fe t3;
+	int i;
 
-	for (i = 0; i < 10; ++i) {
-		const int32_t x = swap & (((int32_t)a[i]) ^ ((int32_t)b[i]));
+	fe_sq_tl(&t0, z);
+	fe_sq_tt(&t1, &t0);
+	for (i = 1; i < 2; ++i)
+		fe_sq_tt(&t1, &t1);
+	fe_mul_tlt(&t1, z, &t1);
+	fe_mul_ttt(&t0, &t0, &t1);
+	fe_sq_tt(&t2, &t0);
+	fe_mul_ttt(&t1, &t1, &t2);
+	fe_sq_tt(&t2, &t1);
+	for (i = 1; i < 5; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t1, &t2, &t1);
+	fe_sq_tt(&t2, &t1);
+	for (i = 1; i < 10; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t2, &t2, &t1);
+	fe_sq_tt(&t3, &t2);
+	for (i = 1; i < 20; ++i)
+		fe_sq_tt(&t3, &t3);
+	fe_mul_ttt(&t2, &t3, &t2);
+	fe_sq_tt(&t2, &t2);
+	for (i = 1; i < 10; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t1, &t2, &t1);
+	fe_sq_tt(&t2, &t1);
+	for (i = 1; i < 50; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t2, &t2, &t1);
+	fe_sq_tt(&t3, &t2);
+	for (i = 1; i < 100; ++i)
+		fe_sq_tt(&t3, &t3);
+	fe_mul_ttt(&t2, &t3, &t2);
+	fe_sq_tt(&t2, &t2);
+	for (i = 1; i < 50; ++i)
+		fe_sq_tt(&t2, &t2);
+	fe_mul_ttt(&t1, &t2, &t1);
+	fe_sq_tt(&t1, &t1);
+	for (i = 1; i < 5; ++i)
+		fe_sq_tt(&t1, &t1);
+	fe_mul_ttt(out, &t1, &t0);
+}
 
-		a[i] = ((int32_t)a[i]) ^ x;
-		b[i] = ((int32_t)b[i]) ^ x;
-	}
+static __always_inline void fe_invert(fe *out, const fe *z)
+{
+	fe_loose l;
+	fe_copy_lt(&l, z);
+	fe_loose_invert(out, &l);
 }
 
-/* Calculates nQ where Q is the x-coordinate of a point on the curve
+/* Replace (f,g) with (g,f) if b == 1;
+ * replace (f,g) with (f,g) if b == 0.
  *
- *   resultx/resultz: the x coordinate of the resulting curve point (short form)
- *   n: a little endian, 32-byte number
- *   q: a point of the curve (short form)
+ * Preconditions: b in {0,1}
  */
-static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
-{
-	limb a[19] = {0}, b[19] = {1}, c[19] = {1}, d[19] = {0};
-	limb *nqpqx = a, *nqpqz = b, *nqx = c, *nqz = d, *t;
-	limb e[19] = {0}, f[19] = {1}, g[19] = {0}, h[19] = {1};
-	limb *nqpqx2 = e, *nqpqz2 = f, *nqx2 = g, *nqz2 = h;
-
-	unsigned int i, j;
-
-	memcpy(nqpqx, q, sizeof(limb) * 10);
-
-	for (i = 0; i < 32; ++i) {
-		uint8_t byte = n[31 - i];
-
-		for (j = 0; j < 8; ++j) {
-			const limb bit = byte >> 7;
-
-			swap_conditional(nqx, nqpqx, bit);
-			swap_conditional(nqz, nqpqz, bit);
-			fmonty(nqx2, nqz2,
-			       nqpqx2, nqpqz2,
-			       nqx, nqz,
-			       nqpqx, nqpqz,
-			       q);
-			swap_conditional(nqx2, nqpqx2, bit);
-			swap_conditional(nqz2, nqpqz2, bit);
-
-			t = nqx;
-			nqx = nqx2;
-			nqx2 = t;
-			t = nqz;
-			nqz = nqz2;
-			nqz2 = t;
-			t = nqpqx;
-			nqpqx = nqpqx2;
-			nqpqx2 = t;
-			t = nqpqz;
-			nqpqz = nqpqz2;
-			nqpqz2 = t;
-
-			byte <<= 1;
-		}
+static __always_inline void fe_cswap(fe *f, fe *g, unsigned int b)
+{
+	unsigned i;
+	b = 0-b;
+	for (i = 0; i < 10; i++) {
+		uint32_t x = f->v[i] ^ g->v[i];
+		x &= b;
+		f->v[i] ^= x;
+		g->v[i] ^= x;
 	}
-
-	memcpy(resultx, nqx, sizeof(limb) * 10);
-	memcpy(resultz, nqz, sizeof(limb) * 10);
 }
 
-static void crecip(limb *out, const limb *z)
+/* NOTE: based on fiat-crypto fe_mul, edited for in2=121666, 0, 0.*/
+static __always_inline void fe_mul_121666_impl(uint32_t out[10], const uint32_t in1[10])
 {
-	limb z2[10];
-	limb z9[10];
-	limb z11[10];
-	limb z2_5_0[10];
-	limb z2_10_0[10];
-	limb z2_20_0[10];
-	limb z2_50_0[10];
-	limb z2_100_0[10];
-	limb t0[10];
-	limb t1[10];
-	int i;
+	{ const uint32_t x20 = in1[9];
+	{ const uint32_t x21 = in1[8];
+	{ const uint32_t x19 = in1[7];
+	{ const uint32_t x17 = in1[6];
+	{ const uint32_t x15 = in1[5];
+	{ const uint32_t x13 = in1[4];
+	{ const uint32_t x11 = in1[3];
+	{ const uint32_t x9 = in1[2];
+	{ const uint32_t x7 = in1[1];
+	{ const uint32_t x5 = in1[0];
+	{ const uint32_t x38 = 0;
+	{ const uint32_t x39 = 0;
+	{ const uint32_t x37 = 0;
+	{ const uint32_t x35 = 0;
+	{ const uint32_t x33 = 0;
+	{ const uint32_t x31 = 0;
+	{ const uint32_t x29 = 0;
+	{ const uint32_t x27 = 0;
+	{ const uint32_t x25 = 0;
+	{ const uint32_t x23 = 121666;
+	{ uint64_t x40 = ((uint64_t)x23 * x5);
+	{ uint64_t x41 = (((uint64_t)x23 * x7) + ((uint64_t)x25 * x5));
+	{ uint64_t x42 = ((((uint64_t)(0x2 * x25) * x7) + ((uint64_t)x23 * x9)) + ((uint64_t)x27 * x5));
+	{ uint64_t x43 = (((((uint64_t)x25 * x9) + ((uint64_t)x27 * x7)) + ((uint64_t)x23 * x11)) + ((uint64_t)x29 * x5));
+	{ uint64_t x44 = (((((uint64_t)x27 * x9) + (0x2 * (((uint64_t)x25 * x11) + ((uint64_t)x29 * x7)))) + ((uint64_t)x23 * x13)) + ((uint64_t)x31 * x5));
+	{ uint64_t x45 = (((((((uint64_t)x27 * x11) + ((uint64_t)x29 * x9)) + ((uint64_t)x25 * x13)) + ((uint64_t)x31 * x7)) + ((uint64_t)x23 * x15)) + ((uint64_t)x33 * x5));
+	{ uint64_t x46 = (((((0x2 * ((((uint64_t)x29 * x11) + ((uint64_t)x25 * x15)) + ((uint64_t)x33 * x7))) + ((uint64_t)x27 * x13)) + ((uint64_t)x31 * x9)) + ((uint64_t)x23 * x17)) + ((uint64_t)x35 * x5));
+	{ uint64_t x47 = (((((((((uint64_t)x29 * x13) + ((uint64_t)x31 * x11)) + ((uint64_t)x27 * x15)) + ((uint64_t)x33 * x9)) + ((uint64_t)x25 * x17)) + ((uint64_t)x35 * x7)) + ((uint64_t)x23 * x19)) + ((uint64_t)x37 * x5));
+	{ uint64_t x48 = (((((((uint64_t)x31 * x13) + (0x2 * (((((uint64_t)x29 * x15) + ((uint64_t)x33 * x11)) + ((uint64_t)x25 * x19)) + ((uint64_t)x37 * x7)))) + ((uint64_t)x27 * x17)) + ((uint64_t)x35 * x9)) + ((uint64_t)x23 * x21)) + ((uint64_t)x39 * x5));
+	{ uint64_t x49 = (((((((((((uint64_t)x31 * x15) + ((uint64_t)x33 * x13)) + ((uint64_t)x29 * x17)) + ((uint64_t)x35 * x11)) + ((uint64_t)x27 * x19)) + ((uint64_t)x37 * x9)) + ((uint64_t)x25 * x21)) + ((uint64_t)x39 * x7)) + ((uint64_t)x23 * x20)) + ((uint64_t)x38 * x5));
+	{ uint64_t x50 = (((((0x2 * ((((((uint64_t)x33 * x15) + ((uint64_t)x29 * x19)) + ((uint64_t)x37 * x11)) + ((uint64_t)x25 * x20)) + ((uint64_t)x38 * x7))) + ((uint64_t)x31 * x17)) + ((uint64_t)x35 * x13)) + ((uint64_t)x27 * x21)) + ((uint64_t)x39 * x9));
+	{ uint64_t x51 = (((((((((uint64_t)x33 * x17) + ((uint64_t)x35 * x15)) + ((uint64_t)x31 * x19)) + ((uint64_t)x37 * x13)) + ((uint64_t)x29 * x21)) + ((uint64_t)x39 * x11)) + ((uint64_t)x27 * x20)) + ((uint64_t)x38 * x9));
+	{ uint64_t x52 = (((((uint64_t)x35 * x17) + (0x2 * (((((uint64_t)x33 * x19) + ((uint64_t)x37 * x15)) + ((uint64_t)x29 * x20)) + ((uint64_t)x38 * x11)))) + ((uint64_t)x31 * x21)) + ((uint64_t)x39 * x13));
+	{ uint64_t x53 = (((((((uint64_t)x35 * x19) + ((uint64_t)x37 * x17)) + ((uint64_t)x33 * x21)) + ((uint64_t)x39 * x15)) + ((uint64_t)x31 * x20)) + ((uint64_t)x38 * x13));
+	{ uint64_t x54 = (((0x2 * ((((uint64_t)x37 * x19) + ((uint64_t)x33 * x20)) + ((uint64_t)x38 * x15))) + ((uint64_t)x35 * x21)) + ((uint64_t)x39 * x17));
+	{ uint64_t x55 = (((((uint64_t)x37 * x21) + ((uint64_t)x39 * x19)) + ((uint64_t)x35 * x20)) + ((uint64_t)x38 * x17));
+	{ uint64_t x56 = (((uint64_t)x39 * x21) + (0x2 * (((uint64_t)x37 * x20) + ((uint64_t)x38 * x19))));
+	{ uint64_t x57 = (((uint64_t)x39 * x20) + ((uint64_t)x38 * x21));
+	{ uint64_t x58 = ((uint64_t)(0x2 * x38) * x20);
+	{ uint64_t x59 = (x48 + (x58 << 0x4));
+	{ uint64_t x60 = (x59 + (x58 << 0x1));
+	{ uint64_t x61 = (x60 + x58);
+	{ uint64_t x62 = (x47 + (x57 << 0x4));
+	{ uint64_t x63 = (x62 + (x57 << 0x1));
+	{ uint64_t x64 = (x63 + x57);
+	{ uint64_t x65 = (x46 + (x56 << 0x4));
+	{ uint64_t x66 = (x65 + (x56 << 0x1));
+	{ uint64_t x67 = (x66 + x56);
+	{ uint64_t x68 = (x45 + (x55 << 0x4));
+	{ uint64_t x69 = (x68 + (x55 << 0x1));
+	{ uint64_t x70 = (x69 + x55);
+	{ uint64_t x71 = (x44 + (x54 << 0x4));
+	{ uint64_t x72 = (x71 + (x54 << 0x1));
+	{ uint64_t x73 = (x72 + x54);
+	{ uint64_t x74 = (x43 + (x53 << 0x4));
+	{ uint64_t x75 = (x74 + (x53 << 0x1));
+	{ uint64_t x76 = (x75 + x53);
+	{ uint64_t x77 = (x42 + (x52 << 0x4));
+	{ uint64_t x78 = (x77 + (x52 << 0x1));
+	{ uint64_t x79 = (x78 + x52);
+	{ uint64_t x80 = (x41 + (x51 << 0x4));
+	{ uint64_t x81 = (x80 + (x51 << 0x1));
+	{ uint64_t x82 = (x81 + x51);
+	{ uint64_t x83 = (x40 + (x50 << 0x4));
+	{ uint64_t x84 = (x83 + (x50 << 0x1));
+	{ uint64_t x85 = (x84 + x50);
+	{ uint64_t x86 = (x85 >> 0x1a);
+	{ uint32_t x87 = ((uint32_t)x85 & 0x3ffffff);
+	{ uint64_t x88 = (x86 + x82);
+	{ uint64_t x89 = (x88 >> 0x19);
+	{ uint32_t x90 = ((uint32_t)x88 & 0x1ffffff);
+	{ uint64_t x91 = (x89 + x79);
+	{ uint64_t x92 = (x91 >> 0x1a);
+	{ uint32_t x93 = ((uint32_t)x91 & 0x3ffffff);
+	{ uint64_t x94 = (x92 + x76);
+	{ uint64_t x95 = (x94 >> 0x19);
+	{ uint32_t x96 = ((uint32_t)x94 & 0x1ffffff);
+	{ uint64_t x97 = (x95 + x73);
+	{ uint64_t x98 = (x97 >> 0x1a);
+	{ uint32_t x99 = ((uint32_t)x97 & 0x3ffffff);
+	{ uint64_t x100 = (x98 + x70);
+	{ uint64_t x101 = (x100 >> 0x19);
+	{ uint32_t x102 = ((uint32_t)x100 & 0x1ffffff);
+	{ uint64_t x103 = (x101 + x67);
+	{ uint64_t x104 = (x103 >> 0x1a);
+	{ uint32_t x105 = ((uint32_t)x103 & 0x3ffffff);
+	{ uint64_t x106 = (x104 + x64);
+	{ uint64_t x107 = (x106 >> 0x19);
+	{ uint32_t x108 = ((uint32_t)x106 & 0x1ffffff);
+	{ uint64_t x109 = (x107 + x61);
+	{ uint64_t x110 = (x109 >> 0x1a);
+	{ uint32_t x111 = ((uint32_t)x109 & 0x3ffffff);
+	{ uint64_t x112 = (x110 + x49);
+	{ uint64_t x113 = (x112 >> 0x19);
+	{ uint32_t x114 = ((uint32_t)x112 & 0x1ffffff);
+	{ uint64_t x115 = (x87 + (0x13 * x113));
+	{ uint32_t x116 = (uint32_t) (x115 >> 0x1a);
+	{ uint32_t x117 = ((uint32_t)x115 & 0x3ffffff);
+	{ uint32_t x118 = (x116 + x90);
+	{ uint32_t x119 = (x118 >> 0x19);
+	{ uint32_t x120 = (x118 & 0x1ffffff);
+	out[0] = x117;
+	out[1] = x120;
+	out[2] = (x119 + x93);
+	out[3] = x96;
+	out[4] = x99;
+	out[5] = x102;
+	out[6] = x105;
+	out[7] = x108;
+	out[8] = x111;
+	out[9] = x114;
+	}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
+}
 
-	/* 2 */ fsquare(z2, z);
-	/* 4 */ fsquare(t1, z2);
-	/* 8 */ fsquare(t0, t1);
-	/* 9 */ fmul(z9, t0, z);
-	/* 11 */ fmul(z11, z9, z2);
-	/* 22 */ fsquare(t0, z11);
-	/* 2^5 - 2^0 = 31 */ fmul(z2_5_0, t0, z9);
-
-	/* 2^6 - 2^1 */ fsquare(t0, z2_5_0);
-	/* 2^7 - 2^2 */ fsquare(t1, t0);
-	/* 2^8 - 2^3 */ fsquare(t0, t1);
-	/* 2^9 - 2^4 */ fsquare(t1, t0);
-	/* 2^10 - 2^5 */ fsquare(t0, t1);
-	/* 2^10 - 2^0 */ fmul(z2_10_0, t0, z2_5_0);
-
-	/* 2^11 - 2^1 */ fsquare(t0, z2_10_0);
-	/* 2^12 - 2^2 */ fsquare(t1, t0);
-	/* 2^20 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
-	/* 2^20 - 2^0 */ fmul(z2_20_0, t1, z2_10_0);
-
-	/* 2^21 - 2^1 */ fsquare(t0, z2_20_0);
-	/* 2^22 - 2^2 */ fsquare(t1, t0);
-	/* 2^40 - 2^20 */ for (i = 2; i < 20; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
-	/* 2^40 - 2^0 */ fmul(t0, t1, z2_20_0);
-
-	/* 2^41 - 2^1 */ fsquare(t1, t0);
-	/* 2^42 - 2^2 */ fsquare(t0, t1);
-	/* 2^50 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t1, t0); fsquare(t0, t1); }
-	/* 2^50 - 2^0 */ fmul(z2_50_0, t0, z2_10_0);
-
-	/* 2^51 - 2^1 */ fsquare(t0, z2_50_0);
-	/* 2^52 - 2^2 */ fsquare(t1, t0);
-	/* 2^100 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
-	/* 2^100 - 2^0 */ fmul(z2_100_0, t1, z2_50_0);
-
-	/* 2^101 - 2^1 */ fsquare(t1, z2_100_0);
-	/* 2^102 - 2^2 */ fsquare(t0, t1);
-	/* 2^200 - 2^100 */ for (i = 2; i < 100; i += 2) { fsquare(t1, t0); fsquare(t0, t1); }
-	/* 2^200 - 2^0 */ fmul(t1, t0, z2_100_0);
-
-	/* 2^201 - 2^1 */ fsquare(t0, t1);
-	/* 2^202 - 2^2 */ fsquare(t1, t0);
-	/* 2^250 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
-	/* 2^250 - 2^0 */ fmul(t0, t1, z2_50_0);
-
-	/* 2^251 - 2^1 */ fsquare(t1, t0);
-	/* 2^252 - 2^2 */ fsquare(t0, t1);
-	/* 2^253 - 2^3 */ fsquare(t1, t0);
-	/* 2^254 - 2^4 */ fsquare(t0, t1);
-	/* 2^255 - 2^5 */ fsquare(t1, t0);
-	/* 2^255 - 21 */ fmul(out, t1, z11);
+static __always_inline void fe_mul121666(fe *h, const fe_loose *f)
+{
+	fe_mul_121666_impl(h->v, f->v);
 }
 
-void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE])
+void curve25519(uint8_t out[static CURVE25519_POINT_SIZE], const uint8_t scalar[static CURVE25519_POINT_SIZE], const uint8_t point[static CURVE25519_POINT_SIZE])
 {
-	limb bp[10], x[10], z[11], zmone[10];
+	fe x1, x2, z2, x3, z3, tmp0, tmp1;
+	fe_loose x2l, z2l, x3l, tmp0l, tmp1l;
+	unsigned swap = 0;
+	int pos;
 	uint8_t e[32];
 
-	memcpy(e, secret, 32);
+	memcpy(e, scalar, 32);
 	curve25519_normalize_secret(e);
 
-	fexpand(bp, basepoint);
-	cmult(x, z, e, bp);
-	crecip(zmone, z);
-	fmul(z, x, zmone);
-	fcontract(mypublic, z);
+	/* The following implementation was transcribed to Coq and proven to
+	 * correspond to unary scalar multiplication in affine coordinates given that
+	 * x1 != 0 is the x coordinate of some point on the curve. It was also checked
+	 * in Coq that doing a ladderstep with x1 = x3 = 0 gives z2' = z3' = 0, and z2
+	 * = z3 = 0 gives z2' = z3' = 0. The statement was quantified over the
+	 * underlying field, so it applies to Curve25519 itself and the quadratic
+	 * twist of Curve25519. It was not proven in Coq that prime-field arithmetic
+	 * correctly simulates extension-field arithmetic on prime-field values.
+	 * The decoding of the byte array representation of e was not considered.
+	 * Specification of Montgomery curves in affine coordinates:
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Spec/MontgomeryCurve.v#L27>
+	 * Proof that these form a group that is isomorphic to a Weierstrass curve:
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/AffineProofs.v#L35>
+	 * Coq transcription and correctness proof of the loop (where scalarbits=255):
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L118>
+	 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L278>
+	 * preconditions: 0 <= e < 2^255 (not necessarily e < order), fe_invert(0) = 0
+	 */
+	fe_frombytes(&x1, point);
+	fe_1(&x2);
+	fe_0(&z2);
+	fe_copy(&x3, &x1);
+	fe_1(&z3);
+
+	for (pos = 254; pos >= 0; --pos) {
+		/* loop invariant as of right before the test, for the case where x1 != 0:
+		 *   pos >= -1; if z2 = 0 then x2 is nonzero; if z3 = 0 then x3 is nonzero
+		 *   let r := e >> (pos+1) in the following equalities of projective points:
+		 *   to_xz (r*P)     === if swap then (x3, z3) else (x2, z2)
+		 *   to_xz ((r+1)*P) === if swap then (x2, z2) else (x3, z3)
+		 *   x1 is the nonzero x coordinate of the nonzero point (r*P-(r+1)*P)
+		 */
+		unsigned b = 1 & (e[pos / 8] >> (pos & 7));
+		swap ^= b;
+		fe_cswap(&x2, &x3, swap);
+		fe_cswap(&z2, &z3, swap);
+		swap = b;
+		/* Coq transcription of ladderstep formula (called from transcribed loop):
+		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZ.v#L89>
+		 * <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L131>
+		 * x1 != 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L217>
+		 * x1  = 0 <https://github.com/mit-plv/fiat-crypto/blob/2456d821825521f7e03e65882cc3521795b0320f/src/Curves/Montgomery/XZProofs.v#L147>
+		 */
+		fe_sub(&tmp0l, &x3, &z3);
+		fe_sub(&tmp1l, &x2, &z2);
+		fe_add(&x2l, &x2, &z2);
+		fe_add(&z2l, &x3, &z3);
+		fe_mul_tll(&z3, &tmp0l, &x2l);
+		fe_mul_tll(&z2, &z2l, &tmp1l);
+		fe_sq_tl(&tmp0, &tmp1l);
+		fe_sq_tl(&tmp1, &x2l);
+		fe_add(&x3l, &z3, &z2);
+		fe_sub(&z2l, &z3, &z2);
+		fe_mul_ttt(&x2, &tmp1, &tmp0);
+		fe_sub(&tmp1l, &tmp1, &tmp0);
+		fe_sq_tl(&z2, &z2l);
+		fe_mul121666(&z3, &tmp1l);
+		fe_sq_tl(&x3, &x3l);
+		fe_add(&tmp0l, &tmp0, &z3);
+		fe_mul_ttt(&z3, &x1, &z2);
+		fe_mul_tll(&z2, &tmp1l, &tmp0l);
+	}
+	/* here pos=-1, so r=e, so to_xz (e*P) === if swap then (x3, z3) else (x2, z2) */
+	fe_cswap(&x2, &x3, swap);
+	fe_cswap(&z2, &z3, swap);
+
+	fe_invert(&z2, &z2);
+	fe_mul_ttt(&x2, &x2, &z2);
+	fe_tobytes(out, &x2);
 }
 #endif
 

commit 723abc50989e187c98961ead5f8a9e686f5379ff
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 18 11:24:04 2018 +0100

    wg: plug memleak in config error path
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 6590aaf..5ab6ece 100644
--- a/src/config.c
+++ b/src/config.c
@@ -310,6 +310,7 @@ static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **la
 		}
 
 		if (!parse_ip(new_allowedip, ip)) {
+			free(new_allowedip);
 			free(saved_entry);
 			free(mutable);
 			return false;

commit b0d5a8d27cf6a4b341df93e6f8de880f51a9fb6d
Author: Piotr Lizoczyk <piotr.lizonczyk@gmail.com>
Date:   Wed Jan 10 17:46:57 2018 +0100

    external-tests: add python implementation
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/python/main.py b/contrib/external-tests/python/main.py
new file mode 100755
index 0000000..ac20688
--- /dev/null
+++ b/contrib/external-tests/python/main.py
@@ -0,0 +1,94 @@
+#!/usr/bin/python3
+
+# SPDX-License-Identifier: MIT
+# Author: Piotr Lizonczyk <plizonczyk.public@gmail.com>
+
+import base64
+import datetime
+from hashlib import blake2s
+import socket
+import struct
+
+from scapy.layers.inet import IP, ICMP
+
+from noise.connection import NoiseConnection, Keypair
+
+
+address = ('demo.wireguard.com', 12913)
+
+our_private = base64.b64decode('WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=')
+their_public = base64.b64decode('qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=')
+preshared = base64.b64decode('FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=')
+prologue = b'WireGuard v1 zx2c4 Jason@zx2c4.com'
+
+noise = NoiseConnection.from_name(b'Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s')
+noise.set_as_initiator()
+noise.set_keypair_from_private_bytes(Keypair.STATIC, our_private)
+noise.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, their_public)
+noise.set_psks(psk=preshared)
+noise.set_prologue(prologue)
+noise.start_handshake()
+
+sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+
+
+# 1. Prepare and send handshake initiation packet
+now = datetime.datetime.now()
+tai = struct.pack('!qi', 4611686018427387914 + int(now.timestamp()), int(now.microsecond * 1e3))
+initiation_packet = b'\x01'  # Type: initiation
+initiation_packet += b'\x00' * 3  # Reserved
+initiation_packet += struct.pack('<i', 28)  # Sender index: 28 (arbitrary)
+initiation_packet += noise.write_message(payload=tai)
+mac_key = blake2s(b'mac1----' + their_public).digest()
+initiation_packet += blake2s(initiation_packet, digest_size=16, key=mac_key).digest()
+initiation_packet += b'\x00' * 16
+
+sock.sendto(initiation_packet, address)
+
+
+# 2. Receive response to finalize handshake
+response_packet = sock.recv(92)
+assert response_packet[0] == 2  # Type: response
+assert response_packet[1:4] == b'\x00' * 3  # Reserved
+their_index, our_index = struct.unpack('<ii', response_packet[4:12])
+assert our_index == 28
+payload = noise.read_message(response_packet[12:60])
+assert payload == b''
+assert noise.handshake_finished
+
+
+# 3. Prepare, encrypt and send ping packet
+icmp_packet = ICMP(type=8, id=921, seq=438)/b'WireGuard'
+ip_packet = IP(proto=1, ttl=20, src="10.189.129.2", dst="10.189.129.1", id=0)/icmp_packet
+ping_packet = b'\x04'  # Type: data
+ping_packet += b'\x00' * 3  # Reserved
+ping_packet += struct.pack('<iq', their_index, 0)
+ping_packet += noise.encrypt(bytes(ip_packet))
+
+sock.sendto(ping_packet, address)
+
+
+# 4. Retrieve ping response, decrypt and verify
+encrypted_response = sock.recv(80)
+assert encrypted_response[0] == 4  # Type: data
+assert encrypted_response[1:4] == b'\x00' * 3  # Reserved
+our_index, nonce = struct.unpack('<iq', encrypted_response[4:16])
+assert our_index == 28
+assert nonce == 0
+ip = IP(noise.decrypt(encrypted_response[16:]))
+icmp = ip[1]
+payload = ip[2]
+assert icmp.type == 0
+assert icmp.code == 0
+assert icmp.id == 921
+assert icmp.seq == 438
+assert payload.load == b'WireGuard'
+
+
+# 5. Send keepalive
+keepalive = b'\x04'  # Type: data
+keepalive += b'\x00' * 3  # Reserved
+keepalive += struct.pack('<iq', their_index, 1)
+keepalive += noise.encrypt(b'')
+
+sock.sendto(keepalive, address)

commit 7fc4c0af45ee2b1757d93f544361d22bcffc1461
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 10 02:37:03 2018 +0100

    wg-quick: ifnames have max len of 15
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/reresolve-dns/reresolve-dns.sh b/contrib/reresolve-dns/reresolve-dns.sh
index 274aed8..7f913ab 100755
--- a/contrib/reresolve-dns/reresolve-dns.sh
+++ b/contrib/reresolve-dns/reresolve-dns.sh
@@ -9,8 +9,8 @@ shopt -s extglob
 export LC_ALL=C
 
 CONFIG_FILE="$1"
-[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,16}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
-[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,16})\.conf$ ]]
+[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
+[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]]
 INTERFACE="${BASH_REMATCH[1]}"
 
 process_peer() {
diff --git a/src/wg-quick.8 b/src/wg-quick.8
index 2039094..ceffb0d 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -97,7 +97,7 @@ interface upon shutdown.
 .P
 Recommended \fIINTERFACE\fP names include `wg0' or `wgvpn0' or even `wgmgmtlan0'.
 However, the number at the end is in fact optional, and really
-any free-form string [a-zA-Z0-9_=+.-]{1,16} will work. So even interface names corresponding
+any free-form string [a-zA-Z0-9_=+.-]{1,15} will work. So even interface names corresponding
 to geographic locations would suffice, such as `cincinnati', `nyc', or `paris', if that's
 somehow desirable.
 
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index aceeebc..a028b98 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -29,9 +29,9 @@ ARGS=( "$@" )
 parse_options() {
 	local interface_section=0 line key value
 	CONFIG_FILE="$1"
-	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,16}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
+	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,15}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
-	[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,16})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
+	[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,15})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
 	CONFIG_FILE="$(readlink -f "$CONFIG_FILE")"
 	((($(stat -c '0%#a' "$CONFIG_FILE") & $(stat -c '0%#a' "${CONFIG_FILE%/*}") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
 	INTERFACE="${BASH_REMATCH[1]}"

commit 9207dec08fdf6d1ea1f740bd98cf122603e919bd
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 3 21:58:00 2018 +0100

    global: year bump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/dns-hatchet/apply.sh b/contrib/dns-hatchet/apply.sh
index 4596d4b..11e5bed 100755
--- a/contrib/dns-hatchet/apply.sh
+++ b/contrib/dns-hatchet/apply.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 ME="$(readlink -f "$(dirname "$(readlink -f "$0")")")"
 TOOLS="$ME/../../../src/tools"
diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 9b60636..e9e8da3 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 package main
 
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index fdd220e..5604a43 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 extern crate snow;
 extern crate base64;
diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index b8e619e..4ec6a76 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 struct def {
diff --git a/contrib/extract-keys/extract-keys.c b/contrib/extract-keys/extract-keys.c
index d6faded..fc757a2 100644
--- a/contrib/extract-keys/extract-keys.c
+++ b/contrib/extract-keys/extract-keys.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <endian.h>
diff --git a/contrib/json/wg-json b/contrib/json/wg-json
index 33c01e8..3c36e65 100755
--- a/contrib/json/wg-json
+++ b/contrib/json/wg-json
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 exec < <(exec wg show all dump)
 
diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
index 8b3e853..45efec7 100644
--- a/contrib/keygen-html/keygen.html
+++ b/contrib/keygen-html/keygen.html
@@ -2,7 +2,7 @@
 <script>
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 function sendPubkeyToServer(pubkey, username, password)
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index ae036d5..20d3f91 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
  * Copyright (C) 2008 Google Inc. All Rights Reserved.
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <emscripten.h>
diff --git a/contrib/keygen-html/src/glue.js b/contrib/keygen-html/src/glue.js
index f79c383..981e533 100644
--- a/contrib/keygen-html/src/glue.js
+++ b/contrib/keygen-html/src/glue.js
@@ -1,6 +1,6 @@
 /*! SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 window["WireGuard"] = {
 	"generateKeypair": function() {
diff --git a/contrib/nat-hole-punching/nat-punch-client.c b/contrib/nat-hole-punching/nat-punch-client.c
index f27d220..0133c3c 100644
--- a/contrib/nat-hole-punching/nat-punch-client.c
+++ b/contrib/nat-hole-punching/nat-punch-client.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Example only. Do not run in production.
  */
diff --git a/contrib/nat-hole-punching/nat-punch-server.c b/contrib/nat-hole-punching/nat-punch-server.c
index f9b919b..29e065e 100644
--- a/contrib/nat-hole-punching/nat-punch-server.c
+++ b/contrib/nat-hole-punching/nat-punch-server.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Example only. Do not run in production.
  */
diff --git a/contrib/ncat-client-server/client.sh b/contrib/ncat-client-server/client.sh
index af081a3..9ad9180 100755
--- a/contrib/ncat-client-server/client.sh
+++ b/contrib/ncat-client-server/client.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
 [[ $UID == 0 ]] || { echo "You must be root to run this."; exit 1; }
diff --git a/contrib/ncat-client-server/server.sh b/contrib/ncat-client-server/server.sh
index d63b7e1..08885b0 100755
--- a/contrib/ncat-client-server/server.sh
+++ b/contrib/ncat-client-server/server.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 if [[ -z $NCAT_REMOTE_ADDR ]]; then
 	ip link del dev wg0 2>/dev/null
diff --git a/contrib/reresolve-dns/reresolve-dns.sh b/contrib/reresolve-dns/reresolve-dns.sh
index a1ff5df..274aed8 100755
--- a/contrib/reresolve-dns/reresolve-dns.sh
+++ b/contrib/reresolve-dns/reresolve-dns.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
 shopt -s nocasematch
diff --git a/contrib/sticky-sockets/sticky-sockets.c b/contrib/sticky-sockets/sticky-sockets.c
index 94ba35d..879b296 100644
--- a/contrib/sticky-sockets/sticky-sockets.c
+++ b/contrib/sticky-sockets/sticky-sockets.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This implements userspace semantics of "sticky sockets", modeled after
  * WireGuard's kernelspace implementation.
diff --git a/contrib/synergy/synergy-client.sh b/contrib/synergy/synergy-client.sh
index d01980a..997280a 100755
--- a/contrib/synergy/synergy-client.sh
+++ b/contrib/synergy/synergy-client.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
 if [[ $UID == 0 ]]; then
diff --git a/contrib/synergy/synergy-server.sh b/contrib/synergy/synergy-server.sh
index 65f5a0e..eb3a20f 100755
--- a/contrib/synergy/synergy-server.sh
+++ b/contrib/synergy/synergy-server.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
 if [[ $UID == 0 ]]; then
diff --git a/src/Makefile b/src/Makefile
index e277b2f..72296aa 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 PKG_CONFIG ?= pkg-config
 PREFIX ?= /usr
diff --git a/src/completion/wg-quick.bash-completion b/src/completion/wg-quick.bash-completion
index f7df346..e5e3983 100644
--- a/src/completion/wg-quick.bash-completion
+++ b/src/completion/wg-quick.bash-completion
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_quick_completion() {
 	local i a
diff --git a/src/completion/wg.bash-completion b/src/completion/wg.bash-completion
index 9d0a9a5..00ccfd3 100644
--- a/src/completion/wg.bash-completion
+++ b/src/completion/wg.bash-completion
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_completion() {
 	local a
diff --git a/src/config.c b/src/config.c
index 1fddb64..6590aaf 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <arpa/inet.h>
diff --git a/src/config.h b/src/config.h
index 8f29b4f..9dec248 100644
--- a/src/config.h
+++ b/src/config.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef CONFIG_H
diff --git a/src/containers.h b/src/containers.h
index a22c42d..8294ec7 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef CONTAINERS_H
diff --git a/src/curve25519.c b/src/curve25519.c
index f83f76f..3e770b2 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
  * Copyright (C) 2008 Google Inc. All Rights Reserved.
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Adam Langley <agl@imperialviolet.org>
  */
diff --git a/src/curve25519.h b/src/curve25519.h
index 1108cd8..6028bb5 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef CURVE25519_H
diff --git a/src/encoding.c b/src/encoding.c
index 5d5f6d0..a8bfd24 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a specialized constant-time base64/hex implementation that resists side-channel attacks.
  */
diff --git a/src/encoding.h b/src/encoding.h
index 0b0a53e..0e361ff 100644
--- a/src/encoding.h
+++ b/src/encoding.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef ENCODING_H
diff --git a/src/genkey.c b/src/genkey.c
index 8f3433b..5971528 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <errno.h>
diff --git a/src/ipc.c b/src/ipc.c
index 221cd4e..7223fd7 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifdef __linux__
diff --git a/src/ipc.h b/src/ipc.h
index 31ff53f..89e26cc 100644
--- a/src/ipc.h
+++ b/src/ipc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef IPC_H
diff --git a/src/mnlg.c b/src/mnlg.c
index f0fdfd6..c68ead1 100644
--- a/src/mnlg.c
+++ b/src/mnlg.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
  */
diff --git a/src/mnlg.h b/src/mnlg.h
index 70c2b03..fab3afd 100644
--- a/src/mnlg.h
+++ b/src/mnlg.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
  */
diff --git a/src/pubkey.c b/src/pubkey.c
index 39461c2..385145b 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <errno.h>
diff --git a/src/set.c b/src/set.c
index 9ecf94b..7f9374d 100644
--- a/src/set.c
+++ b/src/set.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stdio.h>
diff --git a/src/setconf.c b/src/setconf.c
index b87a13f..b5b3cfb 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stddef.h>
diff --git a/src/show.c b/src/show.c
index c5be788..0574a78 100644
--- a/src/show.c
+++ b/src/show.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <arpa/inet.h>
diff --git a/src/showconf.c b/src/showconf.c
index 2e3fbd4..fa3fd2d 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <arpa/inet.h>
diff --git a/src/subcommands.h b/src/subcommands.h
index 1d977ce..c4aa4c6 100644
--- a/src/subcommands.h
+++ b/src/subcommands.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef SUBCOMMANDS_H
diff --git a/src/terminal.c b/src/terminal.c
index c9e4eb5..e3f6039 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <ctype.h>
diff --git a/src/terminal.h b/src/terminal.h
index 68bd9a3..8c2ffa6 100644
--- a/src/terminal.h
+++ b/src/terminal.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #ifndef TERMINAL_H
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 89effdf..aceeebc 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -1,7 +1,7 @@
 #!/bin/bash
 # SPDX-License-Identifier: GPL-2.0
 #
-# Copyright (C) 2016-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg.c b/src/wg.c
index 94f0857..18a1480 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2018 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
 
 #include <stddef.h>

commit 5536e6de4667aad0cc1b9720b5cef6605455ca99
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Dec 13 01:17:55 2017 +0100

    wg-quick: dumber matching for default routes
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index c2d43fc..89effdf 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -152,7 +152,7 @@ add_route() {
 
 	if [[ -n $TABLE && $TABLE != auto ]]; then
 		cmd ip route add "$1" dev "$INTERFACE" table "$TABLE"
-	elif [[ $1 == 0.0.0.0/0 || $1 =~ ^[0:]+/0$ ]]; then
+	elif [[ $1 == */0 ]]; then
 		add_default "$1"
 	else
 		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || cmd ip route add "$1" dev "$INTERFACE"

commit 31d8ebcd2a69fd321b669c91c082d3c8392405db
Author: Luis Ressel <aranea@aixah.de>
Date:   Tue Dec 12 23:10:08 2017 +0100

    wg-quick: add the "Table" config option
    
    * Table=auto (default) selects the current behaviour
    * Table=off disables creation of routes altogether
    * All other values are passed through to "ip route add"'s table option
    
    Signed-off-by: Luis Ressel <aranea@aixah.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index fd1d23f..2039094 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -79,6 +79,11 @@ MTU \(em if not specified, the MTU is automatically determined from the endpoint
 or the system default route, which is usually a sane choice. However, to manually specify
 an MTU to override this automatic discovery, this value may be specified explicitly.
 .IP \(bu
+Table \(em Controls the routing table to which routes are added. There are two
+special values: `off' disables the creation of routes altogether, and `auto'
+(the default) adds routes to the default table and enables special handling of
+default routes.
+.IP \(bu
 PreUp, PostUp, PreDown, PostDown \(em script snippets which will be executed by
 .BR bash (1)
 before/after setting up/tearing down the interface, most commonly used
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index b2acbff..c2d43fc 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -16,6 +16,7 @@ INTERFACE=""
 ADDRESSES=( )
 MTU=""
 DNS=( )
+TABLE=""
 PRE_UP=( )
 POST_UP=( )
 PRE_DOWN=( )
@@ -45,6 +46,7 @@ parse_options() {
 			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
 			MTU) MTU="$value"; continue ;;
 			DNS) DNS+=( ${value//,/ } ); continue ;;
+			Table) TABLE="$value"; continue ;;
 			PreUp) PRE_UP+=( "$value" ); continue ;;
 			PreDown) PRE_DOWN+=( "$value" ); continue ;;
 			PostUp) POST_UP+=( "$value" ); continue ;;
@@ -146,10 +148,14 @@ unset_dns() {
 }
 
 add_route() {
-	if [[ $1 == 0.0.0.0/0 || $1 =~ ^[0:]+/0$ ]]; then
+	[[ $TABLE != off ]] || return 0
+
+	if [[ -n $TABLE && $TABLE != auto ]]; then
+		cmd ip route add "$1" dev "$INTERFACE" table "$TABLE"
+	elif [[ $1 == 0.0.0.0/0 || $1 =~ ^[0:]+/0$ ]]; then
 		add_default "$1"
 	else
-		cmd ip route add "$1" dev "$INTERFACE"
+		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || cmd ip route add "$1" dev "$INTERFACE"
 	fi
 }
 
@@ -189,6 +195,7 @@ save_config() {
 		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
 	done < <(resolvconf -l "tun.$INTERFACE" 2>/dev/null)
 	[[ -n $MTU && $(ip link show dev "$INTERFACE") =~ mtu\ ([0-9]+) ]] && new_config+="MTU = ${BASH_REMATCH[1]}"$'\n'
+	[[ -n $TABLE ]] && new_config+="Table = $TABLE"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
 	for cmd in "${PRE_UP[@]}"; do
 		new_config+="PreUp = $cmd"$'\n'
@@ -236,6 +243,9 @@ cmd_usage() {
 	    IP addresses (with an optional CIDR mask) to be set for the interface.
 	  - DNS: an optional DNS server to use while the device is up.
 	  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.
+	  - Table: an optional routing table to which routes will be added; if
+	    unspecified or \`auto', the default table is used. If \`off', no routes
+	    are added.
 	  - PreUp, PostUp, PreDown, PostDown: script snippets which will be executed
 	    by bash(1) at the corresponding phases of the link, most commonly used
 	    to configure DNS. The string \`%i' is expanded to INTERFACE.
@@ -260,7 +270,7 @@ cmd_up() {
 	up_if
 	set_dns
 	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
-		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"
+		add_route "$i"
 	done
 	execute_hooks "${POST_UP[@]}"
 	trap - INT TERM EXIT

commit 89b983fa2237ed939d6c4463c2018c41f57a73b3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Dec 12 01:08:18 2017 +0100

    keygen-html: remove prebuilt file
    
    We also reduce the optimization level, just in case, but add closure
    compiler into the mix.
    
    Suggested-by: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/.gitignore b/contrib/keygen-html/.gitignore
new file mode 100644
index 0000000..f8bae92
--- /dev/null
+++ b/contrib/keygen-html/.gitignore
@@ -0,0 +1 @@
+curve25519_generate.js
diff --git a/contrib/keygen-html/Makefile b/contrib/keygen-html/Makefile
new file mode 100644
index 0000000..0902275
--- /dev/null
+++ b/contrib/keygen-html/Makefile
@@ -0,0 +1,6 @@
+curve25519_generate.js: src/curve25519_generate.c src/glue.js
+	emcc -O2 --memory-init-file 0 --closure 1 --post-js src/glue.js -o $@ src/curve25519_generate.c
+clean:
+	rm -f curve25519_generate.js
+all: curve25519_generate.js
+.PHONY: clean all
diff --git a/contrib/keygen-html/README b/contrib/keygen-html/README
index f1c3412..eaa4244 100644
--- a/contrib/keygen-html/README
+++ b/contrib/keygen-html/README
@@ -17,3 +17,11 @@ introduces interesting side-channel attacks.
 Secrets aren't zerored after use. Maybe you can get around this with
 some tricks taking advantage of browser allocator behavior and different
 processes, but it seems pretty hard.
+
+Building
+--------
+
+In order to use the example `keygen.html` file, you must first build
+the C sources using emscripten. Simply run:
+
+    $ make
diff --git a/contrib/keygen-html/curve25519_generate.js b/contrib/keygen-html/curve25519_generate.js
deleted file mode 100644
index 82b2a53..0000000
--- a/contrib/keygen-html/curve25519_generate.js
+++ /dev/null
@@ -1,21 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 2008 Google Inc. All Rights Reserved.
- * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- */
-var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;if(Module["ENVIRONMENT"]){if(Module["ENVIRONMENT"]==="WEB"){ENVIRONMENT_IS_WEB=true}else if(Module["ENVIRONMENT"]==="WORKER"){ENVIRONMENT_IS_WORKER=true}else if(Module["ENVIRONMENT"]==="NODE"){ENVIRONMENT_IS_NODE=true}else if(Module["ENVIRONMENT"]==="SHELL"){ENVIRONMENT_IS_SHELL=true}else{throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.")}}else{ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER}if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=console.log;if(!Module["printErr"])Module["printErr"]=console.warn;var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=require("fs");if(!nodePath)nodePath=require("path");filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename)}return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(!Module["thisProgram"]){if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}else{Module["thisProgram"]="unknown-program"}}Module["arguments"]=process["argv"].slice(2);if(typeof module!=="undefined"){module["exports"]=Module}process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}));Module["inspect"]=(function(){return"[Emscripten Module object]"})}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined"){Module["read"]=function shell_read(f){var data=tryParseAsDataURI(f);if(data){return intArrayToString(data)}return read(f)}}else{Module["read"]=function shell_read(){throw"no read() available"}}Module["readBinary"]=function readBinary(f){var data;data=tryParseAsDataURI(f);if(data){return data}if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs}else if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof quit==="function"){Module["quit"]=(function(status,toThrow){quit(status)})}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function shell_read(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){Module["readBinary"]=function readBinary(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}}}Module["readAsync"]=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror()};xhr.onerror=onerror;xhr.send(null)};if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=function shell_print(x){console.log(x)};if(!Module["printErr"])Module["printErr"]=function shell_printErr(x){console.warn(x)}}else{var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?(function(x){dump(x)}):(function(x){})}if(typeof Module["setWindowTitle"]==="undefined"){Module["setWindowTitle"]=(function(title){document.title=title})}}else{throw new Error("Unknown runtime environment. Where are we?")}if(!Module["print"]){Module["print"]=(function(){})}if(!Module["printErr"]){Module["printErr"]=Module["print"]}if(!Module["arguments"]){Module["arguments"]=[]}if(!Module["thisProgram"]){Module["thisProgram"]="./this.program"}if(!Module["quit"]){Module["quit"]=(function(status,toThrow){throw toThrow})}Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=undefined;var Runtime={setTempRet0:(function(value){tempRet0=value;return value}),getTempRet0:(function(){return tempRet0}),stackSave:(function(){return STACKTOP}),stackRestore:(function(stackTop){STACKTOP=stackTop}),getNativeTypeSize:(function(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return Runtime.QUANTUM_SIZE}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else{return 0}}}}),getNativeFieldSize:(function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)}),STACK_ALIGN:16,prepVararg:(function(ptr,type){if(type==="double"||type==="i64"){if(ptr&7){assert((ptr&7)===4);ptr+=4}}else{assert((ptr&3)===0)}return ptr}),getAlignSize:(function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)}),dynCall:(function(sig,ptr,args){if(args&&args.length){return Module["dynCall_"+sig].apply(null,[ptr].concat(args))}else{return Module["dynCall_"+sig].call(null,ptr)}}),functionPointers:[],addFunction:(function(func){for(var i=0;i<Runtime.functionPointers.length;i++){if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=func;return 2*(1+i)}}throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."}),removeFunction:(function(index){Runtime.functionPointers[(index-2)/2]=null}),warnOnce:(function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown={};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}}),funcWrappers:{},getFuncWrapper:(function(func,sig){if(!func)return;assert(sig);if(!Runtime.funcWrappers[sig]){Runtime.funcWrappers[sig]={}}var sigCache=Runtime.funcWrappers[sig];if(!sigCache[func]){if(sig.length===1){sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func)}}else if(sig.length===2){sigCache[func]=function dynCall_wrapper(arg){return Runtime.dynCall(sig,func,[arg])}}else{sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,Array.prototype.slice.call(arguments))}}}return sigCache[func]}),getCompilerSetting:(function(name){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"}),stackAlloc:(function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+15&-16;return ret}),staticAlloc:(function(size){var ret=STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+15&-16;return ret}),dynamicAlloc:(function(size){var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=(ret+size+15|0)&-16;HEAP32[DYNAMICTOP_PTR>>2]=end;if(end>=TOTAL_MEMORY){var success=enlargeMemory();if(!success){HEAP32[DYNAMICTOP_PTR>>2]=ret;return 0}}return ret}),alignMemory:(function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:16))*(quantum?quantum:16);return ret}),makeBigInt:(function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret}),GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var ABORT=0;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}var JSfuncs={"stackSave":(function(){Runtime.stackSave()}),"stackRestore":(function(){Runtime.stackRestore()}),"arrayToC":(function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=Runtime.stackAlloc(len);stringToUTF8(str,ret,len)}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};function ccall(ident,returnType,argTypes,args,opts){var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0){Runtime.stackRestore(stack)}return ret}function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident);var numericArgs=argTypes.every((function(type){return type==="number"}));var numericRet=returnType!=="string";if(numericRet&&numericArgs){return cfunc}return(function(){return ccall(ident,returnType,argTypes,arguments)})}Module["ccall"]=ccall;Module["cwrap"]=cwrap;function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}Module["setValue"]=setValue;function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for getValue: "+type)}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[typeof _malloc==="function"?_malloc:Runtime.staticAlloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var stop;ptr=ret;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function"){curr=Runtime.getFunctionIndex(curr)}type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}Module["allocate"]=allocate;function getMemory(size){if(!staticSealed)return Runtime.staticAlloc(size);if(!runtimeInitialized)return Runtime.dynamicAlloc(size);return _malloc(size)}Module["getMemory"]=getMemory;function Pointer_stringify(ptr,length){if(length===0||!ptr)return"";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}return Module["UTF8ToString"](ptr)}Module["Pointer_stringify"]=Pointer_stringify;function AsciiToString(ptr){var str="";while(1){var ch=HEAP8[ptr++>>0];if(!ch)return str;str+=String.fromCharCode(ch)}}Module["AsciiToString"]=AsciiToString;function stringToAscii(str,outPtr){return writeAsciiToMemory(str,outPtr,false)}Module["stringToAscii"]=stringToAscii;var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx){var endPtr=idx;while(u8Array[endPtr])++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var u0,u1,u2,u3,u4,u5;var str="";while(1){u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u3=u8Array[idx++]&63;if((u0&248)==240){u0=(u0&7)<<18|u1<<12|u2<<6|u3}else{u4=u8Array[idx++]&63;if((u0&252)==248){u0=(u0&3)<<24|u1<<18|u2<<12|u3<<6|u4}else{u5=u8Array[idx++]&63;u0=(u0&1)<<30|u1<<24|u2<<18|u3<<12|u4<<6|u5}}}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}}Module["UTF8ArrayToString"]=UTF8ArrayToString;function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}Module["UTF8ToString"]=UTF8ToString;function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=2097151){if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=67108863){if(outIdx+4>=endIdx)break;outU8Array[outIdx++]=248|u>>24;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+5>=endIdx)break;outU8Array[outIdx++]=252|u>>30;outU8Array[outIdx++]=128|u>>24&63;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}Module["stringToUTF8Array"]=stringToUTF8Array;function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}Module["stringToUTF8"]=stringToUTF8;function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){++len}else if(u<=2047){len+=2}else if(u<=65535){len+=3}else if(u<=2097151){len+=4}else if(u<=67108863){len+=5}else{len+=6}}return len}Module["lengthBytesUTF8"]=lengthBytesUTF8;var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function demangle(func){var __cxa_demangle_func=Module["___cxa_demangle"]||Module["__cxa_demangle"];if(__cxa_demangle_func){try{var s=func.substr(1);var len=lengthBytesUTF8(s)+1;var buf=_malloc(len);stringToUTF8(s,buf,len);var status=_malloc(4);var ret=__cxa_demangle_func(buf,0,0,status);if(getValue(status,"i32")===0&&ret){return Pointer_stringify(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}return func}Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");return func}function demangleAll(text){var regex=/__Z[\w\d_]+/g;return text.replace(regex,(function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}Module["stackTrace"]=stackTrace;var HEAP,buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer)}var STATIC_BASE,STATICTOP,staticSealed;var STACK_BASE,STACKTOP,STACK_MAX;var DYNAMIC_BASE,DYNAMICTOP_PTR;STATIC_BASE=STATICTOP=STACK_BASE=STACKTOP=STACK_MAX=DYNAMIC_BASE=DYNAMICTOP_PTR=0;staticSealed=false;function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function enlargeMemory(){abortOnCannotGrowMemory()}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(TOTAL_MEMORY<TOTAL_STACK)Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");if(Module["buffer"]){buffer=Module["buffer"]}else{{buffer=new ArrayBuffer(TOTAL_MEMORY)}}updateGlobalBufferViews();function getTotalMemory(){return TOTAL_MEMORY}HEAP32[0]=1668509029;HEAP16[1]=25459;if(HEAPU8[2]!==115||HEAPU8[3]!==99)throw"Runtime error: expected the system to be little-endian!";Module["HEAP"]=HEAP;Module["buffer"]=buffer;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func)}else{Module["dynCall_vi"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module["addOnPreRun"]=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module["addOnInit"]=addOnInit;function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module["addOnPreMain"]=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module["addOnExit"]=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module["addOnPostRun"]=addOnPostRun;function writeStringToMemory(string,buffer,dontAddNull){Runtime.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var lastChar,end;if(dontAddNull){end=buffer+lengthBytesUTF8(string);lastChar=HEAP8[end]}stringToUTF8(string,buffer,Infinity);if(dontAddNull)HEAP8[end]=lastChar}Module["writeStringToMemory"]=writeStringToMemory;function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}Module["writeAsciiToMemory"]=writeAsciiToMemory;if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];if(!Math["clz32"])Math["clz32"]=(function(x){x=x>>>0;for(var i=0;i<32;i++){if(x&1<<31-i)return i}return 32});Math.clz32=Math["clz32"];if(!Math["trunc"])Math["trunc"]=(function(x){return x<0?Math.ceil(x):Math.floor(x)});Math.trunc=Math["trunc"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_round=Math.round;var Math_min=Math.min;var Math_clz32=Math.clz32;var Math_trunc=Math.trunc;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}Module["addRunDependency"]=addRunDependency;function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;var ASM_CONSTS=[(function(){var getRandomValue=(function(){var buf=new Uint32Array(1);window.crypto.getRandomValues(buf);return buf[0]>>>0});Module.getRandomValue=getRandomValue}),(function(){return Module.getRandomValue()})];function _emscripten_asm_const_i(code){return ASM_CONSTS[code]()}STATIC_BASE=Runtime.GLOBAL_BASE;STATICTOP=STATIC_BASE+2192;__ATINIT__.push();memoryInitializer="data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAACAAAAjAQAAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAr/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAAeyB2YXIgZ2V0UmFuZG9tVmFsdWUgPSBmdW5jdGlvbigpIHsgdmFyIGJ1ZiA9IG5ldyBVaW50MzJBcnJheSgxKTsgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmKTsgcmV0dXJuIGJ1ZlswXSA+Pj4gMDsgfTsgTW9kdWxlLmdldFJhbmRvbVZhbHVlID0gZ2V0UmFuZG9tVmFsdWU7IH0AeyByZXR1cm4gTW9kdWxlLmdldFJhbmRvbVZhbHVlKCk7IH0=";var tempDoublePtr=STATICTOP;STATICTOP+=16;function ___lock(){}var SYSCALLS={varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=Pointer_stringify(SYSCALLS.get());return ret}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0)})};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;if(!___syscall146.buffer){___syscall146.buffers=[null,[],[]];___syscall146.printChar=(function(stream,curr){var buffer=___syscall146.buffers[stream];assert(buffer);if(curr===0||curr===10){(stream===1?Module["print"]:Module["printErr"])(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}})}for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){___syscall146.printChar(stream,HEAPU8[ptr+j])}ret+=len}return ret}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___unlock(){}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}__ATEXIT__.push((function(){var fflush=Module["_fflush"];if(fflush)fflush(0);var printChar=___syscall146.printChar;if(!printChar)return;var buffers=___syscall146.buffers;if(buffers[1].length)printChar(1,10);if(buffers[2].length)printChar(2,10)}));DYNAMICTOP_PTR=allocate(1,"i32",ALLOC_STATIC);STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=Runtime.alignMemory(STACK_MAX);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;staticSealed=true;var ASSERTIONS=false;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){if(ASSERTIONS){assert(false,"Character code "+chr+" ("+String.fromCharCode(chr)+")  at offset "+i+" not in 0x00-0xFF.")}chr&=255}ret.push(String.fromCharCode(chr))}return ret.join("")}Module["intArrayFromString"]=intArrayFromString;Module["intArrayToString"]=intArrayToString;var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var decodeBase64=typeof atob==="function"?atob:(function(input){var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2)}if(enc4!==64){output=output+String.fromCharCode(chr3)}}while(i<input.length);return output});function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer.from(s,"base64")}catch(_){buf=new Buffer(s,"base64")}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i)}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){var dataURIPrefix="data:application/octet-stream;base64,";if(!(String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0)}}function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0)}}Module.asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array,"NaN":NaN,"Infinity":Infinity};Module.asmLibraryArg={"abort":abort,"assert":assert,"enlargeMemory":enlargeMemory,"getTotalMemory":getTotalMemory,"abortOnCannotGrowMemory":abortOnCannotGrowMemory,"invoke_ii":invoke_ii,"invoke_iiii":invoke_iiii,"___lock":___lock,"___setErrNo":___setErrNo,"___syscall140":___syscall140,"___syscall146":___syscall146,"___syscall54":___syscall54,"___syscall6":___syscall6,"___unlock":___unlock,"_emscripten_asm_const_i":_emscripten_asm_const_i,"_emscripten_memcpy_big":_emscripten_memcpy_big,"DYNAMICTOP_PTR":DYNAMICTOP_PTR,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX};// EMSCRIPTEN_START_ASM
-var asm=(/** @suppress {uselessCode} */ function(global,env,buffer) {
-"use asm";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.DYNAMICTOP_PTR|0;var j=env.tempDoublePtr|0;var k=env.ABORT|0;var l=env.STACKTOP|0;var m=env.STACK_MAX|0;var n=0;var o=0;var p=0;var q=0;var r=global.NaN,s=global.Infinity;var t=0,u=0,v=0,w=0,x=0.0;var y=0;var z=global.Math.floor;var A=global.Math.abs;var B=global.Math.sqrt;var C=global.Math.pow;var D=global.Math.cos;var E=global.Math.sin;var F=global.Math.tan;var G=global.Math.acos;var H=global.Math.asin;var I=global.Math.atan;var J=global.Math.atan2;var K=global.Math.exp;var L=global.Math.log;var M=global.Math.ceil;var N=global.Math.imul;var O=global.Math.min;var P=global.Math.max;var Q=global.Math.clz32;var R=env.abort;var S=env.assert;var T=env.enlargeMemory;var U=env.getTotalMemory;var V=env.abortOnCannotGrowMemory;var W=env.invoke_ii;var X=env.invoke_iiii;var Y=env.___lock;var Z=env.___setErrNo;var _=env.___syscall140;var $=env.___syscall146;var aa=env.___syscall54;var ba=env.___syscall6;var ca=env.___unlock;var da=env._emscripten_asm_const_i;var ea=env._emscripten_memcpy_big;var fa=0.0;
-// EMSCRIPTEN_START_FUNCS
-function ia(a){a=a|0;var b=0;b=l;l=l+a|0;l=l+15&-16;return b|0}function ja(){return l|0}function ka(a){a=a|0;l=a}function la(a,b){a=a|0;b=b|0;l=a;m=b}function ma(a,b){a=a|0;b=b|0;if(!n){n=a;o=b}}function na(a){a=a|0;y=a}function oa(){return y|0}function pa(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Ra=0,Sa=0,Va=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Fb=0,Gb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,Nb=0,Ob=0,Pb=0,Qb=0,Rb=0,Sb=0,Tb=0,Ub=0,Vb=0,Wb=0,Xb=0;Ob=l;l=l+2640|0;rb=Ob+2456|0;sb=Ob+2304|0;Mb=Ob+2152|0;tb=Ob+2e3|0;ub=Ob+1848|0;vb=Ob+1696|0;Nb=Ob+1544|0;Fb=Ob+1392|0;Gb=Ob+1240|0;Hb=Ob+1088|0;h=Ob+936|0;g=Ob+784|0;f=Ob+632|0;e=Ob+480|0;Ib=Ob+328|0;pb=Ob+248|0;Jb=Ob+168|0;Kb=Ob+80|0;Lb=Ob;qb=Ob+2608|0;ob=qb;da=ob+32|0;do{a[ob>>0]=a[d>>0]|0;ob=ob+1|0;d=d+1|0}while((ob|0)<(da|0));a[qb>>0]=a[qb>>0]&-8;ob=qb+31|0;a[ob>>0]=a[ob>>0]&63|64;ob=pb;c[ob>>2]=9;c[ob+4>>2]=0;ob=pb+8|0;da=ob+72|0;do{c[ob>>2]=0;ob=ob+4|0}while((ob|0)<(da|0));Wa(Fb+8|0,0,144)|0;ob=Fb;c[ob>>2]=1;c[ob+4>>2]=0;Wa(Gb+8|0,0,144)|0;ob=Gb;c[ob>>2]=1;c[ob+4>>2]=0;Wa(Hb|0,0,152)|0;Wa(h|0,0,152)|0;Wa(g+8|0,0,144)|0;ob=g;c[ob>>2]=1;c[ob+4>>2]=0;Wa(f|0,0,152)|0;Wa(e+8|0,0,144)|0;ob=e;c[ob>>2]=1;c[ob+4>>2]=0;ob=Nb+80|0;da=ob+72|0;do{c[ob>>2]=0;ob=ob+4|0}while((ob|0)<(da|0));ob=Nb;d=pb;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));oa=Mb+144|0;pa=Mb+64|0;qa=Mb+136|0;ra=Mb+56|0;wa=Mb+128|0;xa=Mb+48|0;ya=Mb+120|0;za=Mb+40|0;Aa=Mb+112|0;Ba=Mb+32|0;Ca=Mb+104|0;Da=Mb+24|0;Ea=Mb+96|0;Fa=Mb+16|0;Ga=Mb+88|0;Ha=Mb+8|0;Ia=Mb+80|0;Ja=tb+144|0;Ka=tb+64|0;La=tb+136|0;Ma=tb+56|0;Na=tb+128|0;Oa=tb+48|0;Pa=tb+120|0;Ra=tb+40|0;Sa=tb+112|0;Va=tb+32|0;Xa=tb+104|0;Ya=tb+24|0;Za=tb+96|0;_a=tb+16|0;$a=tb+88|0;ab=tb+8|0;bb=tb+80|0;fa=Mb+72|0;cb=tb+72|0;db=rb+8|0;eb=sb+8|0;fb=rb+16|0;gb=sb+16|0;hb=rb+24|0;ib=sb+24|0;jb=rb+32|0;kb=sb+32|0;lb=rb+40|0;mb=sb+40|0;nb=rb+48|0;ga=sb+48|0;ha=rb+56|0;ia=sb+56|0;ja=rb+64|0;ka=sb+64|0;la=rb+72|0;ma=sb+72|0;wb=Ib+80|0;xb=Ib+8|0;yb=Ib+16|0;zb=Ib+24|0;Ab=Ib+32|0;Bb=Ib+40|0;Cb=Ib+48|0;Db=Ib+56|0;Eb=Ib+64|0;na=Ib+72|0;m=Nb;ea=0;d=Fb;i=Hb;j=Gb;while(1){k=a[qb+(31-ea)>>0]|0;$=0;aa=e;ba=f;ca=g;g=d;e=i;f=j;_=m;while(1){Y=k&255;Z=Y>>>7;sa(f,_,Z,0);sa(e,g,Z,0);x=f;k=c[x>>2]|0;x=c[x+4>>2]|0;V=f+8|0;T=V;G=c[T>>2]|0;T=c[T+4>>2]|0;Sb=f+16|0;B=Sb;A=c[B>>2]|0;B=c[B+4>>2]|0;C=f+24|0;Pb=C;W=c[Pb>>2]|0;Pb=c[Pb+4>>2]|0;t=f+32|0;u=t;Tb=c[u>>2]|0;u=c[u+4>>2]|0;r=f+40|0;m=r;D=c[m>>2]|0;m=c[m+4>>2]|0;S=f+48|0;da=S;X=c[da>>2]|0;da=c[da+4>>2]|0;J=f+56|0;E=J;P=c[E>>2]|0;E=c[E+4>>2]|0;Ub=f+64|0;v=Ub;M=c[v>>2]|0;v=c[v+4>>2]|0;q=f+72|0;Qb=q;Rb=c[Qb>>2]|0;Qb=c[Qb+4>>2]|0;z=e;L=c[z>>2]|0;z=c[z+4>>2]|0;s=Ta(L|0,z|0,k|0,x|0)|0;o=f;c[o>>2]=s;c[o+4>>2]=y;o=e+8|0;s=o;U=c[s>>2]|0;s=c[s+4>>2]|0;I=Ta(U|0,s|0,G|0,T|0)|0;c[V>>2]=I;c[V+4>>2]=y;V=e+16|0;I=V;O=c[I>>2]|0;I=c[I+4>>2]|0;j=Ta(O|0,I|0,A|0,B|0)|0;c[Sb>>2]=j;c[Sb+4>>2]=y;Sb=e+24|0;j=Sb;i=c[j>>2]|0;j=c[j+4>>2]|0;Wb=Ta(i|0,j|0,W|0,Pb|0)|0;c[C>>2]=Wb;c[C+4>>2]=y;C=e+32|0;Wb=C;p=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;K=Ta(p|0,Wb|0,Tb|0,u|0)|0;c[t>>2]=K;c[t+4>>2]=y;t=e+40|0;K=t;Q=c[K>>2]|0;K=c[K+4>>2]|0;w=Ta(Q|0,K|0,D|0,m|0)|0;c[r>>2]=w;c[r+4>>2]=y;r=e+48|0;w=r;H=c[w>>2]|0;w=c[w+4>>2]|0;n=Ta(H|0,w|0,X|0,da|0)|0;c[S>>2]=n;c[S+4>>2]=y;S=e+56|0;n=S;F=c[n>>2]|0;n=c[n+4>>2]|0;ob=Ta(F|0,n|0,P|0,E|0)|0;c[J>>2]=ob;c[J+4>>2]=y;J=e+64|0;ob=J;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;Vb=Ta(d|0,ob|0,M|0,v|0)|0;c[Ub>>2]=Vb;c[Ub+4>>2]=y;Ub=e+72|0;Vb=Ub;R=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Xb=Ta(R|0,Vb|0,Rb|0,Qb|0)|0;c[q>>2]=Xb;c[q+4>>2]=y;z=Ua(k|0,x|0,L|0,z|0)|0;L=e;c[L>>2]=z;c[L+4>>2]=y;s=Ua(G|0,T|0,U|0,s|0)|0;c[o>>2]=s;c[o+4>>2]=y;I=Ua(A|0,B|0,O|0,I|0)|0;c[V>>2]=I;c[V+4>>2]=y;j=Ua(W|0,Pb|0,i|0,j|0)|0;c[Sb>>2]=j;c[Sb+4>>2]=y;Wb=Ua(Tb|0,u|0,p|0,Wb|0)|0;c[C>>2]=Wb;c[C+4>>2]=y;K=Ua(D|0,m|0,Q|0,K|0)|0;c[t>>2]=K;c[t+4>>2]=y;w=Ua(X|0,da|0,H|0,w|0)|0;c[r>>2]=w;c[r+4>>2]=y;n=Ua(P|0,E|0,F|0,n|0)|0;c[S>>2]=n;c[S+4>>2]=y;ob=Ua(M|0,v|0,d|0,ob|0)|0;c[J>>2]=ob;c[J+4>>2]=y;Vb=Ua(Rb|0,Qb|0,R|0,Vb|0)|0;c[Ub>>2]=Vb;c[Ub+4>>2]=y;Ub=_;Vb=c[Ub>>2]|0;Ub=c[Ub+4>>2]|0;R=_+8|0;Qb=R;Rb=c[Qb>>2]|0;Qb=c[Qb+4>>2]|0;J=_+16|0;ob=J;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;v=_+24|0;M=v;S=c[M>>2]|0;M=c[M+4>>2]|0;n=_+32|0;F=n;E=c[F>>2]|0;F=c[F+4>>2]|0;P=_+40|0;r=P;w=c[r>>2]|0;r=c[r+4>>2]|0;H=_+48|0;da=H;X=c[da>>2]|0;da=c[da+4>>2]|0;t=_+56|0;K=t;Q=c[K>>2]|0;K=c[K+4>>2]|0;m=_+64|0;D=m;C=c[D>>2]|0;D=c[D+4>>2]|0;Wb=_+72|0;p=Wb;u=c[p>>2]|0;p=c[p+4>>2]|0;Tb=g;Sb=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;j=Ta(Sb|0,Tb|0,Vb|0,Ub|0)|0;i=_;c[i>>2]=j;c[i+4>>2]=y;i=g+8|0;j=i;Pb=c[j>>2]|0;j=c[j+4>>2]|0;W=Ta(Pb|0,j|0,Rb|0,Qb|0)|0;c[R>>2]=W;c[R+4>>2]=y;R=g+16|0;W=R;V=c[W>>2]|0;W=c[W+4>>2]|0;I=Ta(V|0,W|0,d|0,ob|0)|0;c[J>>2]=I;c[J+4>>2]=y;J=g+24|0;I=J;O=c[I>>2]|0;I=c[I+4>>2]|0;B=Ta(O|0,I|0,S|0,M|0)|0;c[v>>2]=B;c[v+4>>2]=y;v=g+32|0;B=v;A=c[B>>2]|0;B=c[B+4>>2]|0;o=Ta(A|0,B|0,E|0,F|0)|0;c[n>>2]=o;c[n+4>>2]=y;n=g+40|0;o=n;s=c[o>>2]|0;o=c[o+4>>2]|0;U=Ta(s|0,o|0,w|0,r|0)|0;c[P>>2]=U;c[P+4>>2]=y;P=g+48|0;U=P;T=c[U>>2]|0;U=c[U+4>>2]|0;G=Ta(T|0,U|0,X|0,da|0)|0;c[H>>2]=G;c[H+4>>2]=y;H=g+56|0;G=H;L=c[G>>2]|0;G=c[G+4>>2]|0;z=Ta(L|0,G|0,Q|0,K|0)|0;c[t>>2]=z;c[t+4>>2]=y;t=g+64|0;z=t;x=c[z>>2]|0;z=c[z+4>>2]|0;k=Ta(x|0,z|0,C|0,D|0)|0;c[m>>2]=k;c[m+4>>2]=y;m=g+72|0;k=m;q=c[k>>2]|0;k=c[k+4>>2]|0;Xb=Ta(q|0,k|0,u|0,p|0)|0;c[Wb>>2]=Xb;c[Wb+4>>2]=y;Tb=Ua(Vb|0,Ub|0,Sb|0,Tb|0)|0;Sb=g;c[Sb>>2]=Tb;c[Sb+4>>2]=y;j=Ua(Rb|0,Qb|0,Pb|0,j|0)|0;c[i>>2]=j;c[i+4>>2]=y;W=Ua(d|0,ob|0,V|0,W|0)|0;c[R>>2]=W;c[R+4>>2]=y;I=Ua(S|0,M|0,O|0,I|0)|0;c[J>>2]=I;c[J+4>>2]=y;B=Ua(E|0,F|0,A|0,B|0)|0;c[v>>2]=B;c[v+4>>2]=y;o=Ua(w|0,r|0,s|0,o|0)|0;c[n>>2]=o;c[n+4>>2]=y;U=Ua(X|0,da|0,T|0,U|0)|0;c[P>>2]=U;c[P+4>>2]=y;G=Ua(Q|0,K|0,L|0,G|0)|0;c[H>>2]=G;c[H+4>>2]=y;z=Ua(C|0,D|0,x|0,z|0)|0;c[t>>2]=z;c[t+4>>2]=y;k=Ua(u|0,p|0,q|0,k|0)|0;c[m>>2]=k;c[m+4>>2]=y;ta(Mb,_,e);ta(tb,f,g);m=oa;k=c[m>>2]|0;m=c[m+4>>2]|0;q=pa;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=pa;c[u>>2]=t;c[u+4>>2]=y;u=qa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=ra;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=ra;c[q>>2]=p;c[q+4>>2]=y;q=wa;p=c[q>>2]|0;q=c[q+4>>2]|0;u=xa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=xa;c[m>>2]=k;c[m+4>>2]=y;m=ya;k=c[m>>2]|0;m=c[m+4>>2]|0;q=za;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=za;c[u>>2]=t;c[u+4>>2]=y;u=Aa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Ba;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=Ba;c[q>>2]=p;c[q+4>>2]=y;q=Ca;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Da;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=Da;c[m>>2]=k;c[m+4>>2]=y;m=Ea;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Fa;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=Fa;c[u>>2]=t;c[u+4>>2]=y;u=Ga;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Ha;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=Ha;c[q>>2]=p;c[q+4>>2]=y;q=Ia;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Mb;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=Mb;c[m>>2]=k;c[m+4>>2]=y;ua(Mb);m=Ja;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Ka;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=Ka;c[u>>2]=t;c[u+4>>2]=y;u=La;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Ma;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=Ma;c[q>>2]=p;c[q+4>>2]=y;q=Na;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Oa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=Oa;c[m>>2]=k;c[m+4>>2]=y;m=Pa;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Ra;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=Ra;c[u>>2]=t;c[u+4>>2]=y;u=Sa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Va;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=Va;c[q>>2]=p;c[q+4>>2]=y;q=Xa;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Ya;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=Ya;c[m>>2]=k;c[m+4>>2]=y;m=Za;k=c[m>>2]|0;m=c[m+4>>2]|0;q=_a;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=_a;c[u>>2]=t;c[u+4>>2]=y;u=$a;t=c[u>>2]|0;u=c[u+4>>2]|0;m=ab;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=ab;c[q>>2]=p;c[q+4>>2]=y;q=bb;p=c[q>>2]|0;q=c[q+4>>2]|0;u=tb;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=tb;c[m>>2]=k;c[m+4>>2]=y;ua(tb);m=Mb;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Ha;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Fa;t=c[u>>2]|0;u=c[u+4>>2]|0;z=Da;x=c[z>>2]|0;z=c[z+4>>2]|0;D=Ba;C=c[D>>2]|0;D=c[D+4>>2]|0;H=za;G=c[H>>2]|0;H=c[H+4>>2]|0;L=xa;K=c[L>>2]|0;L=c[L+4>>2]|0;Q=ra;P=c[Q>>2]|0;Q=c[Q+4>>2]|0;U=pa;T=c[U>>2]|0;U=c[U+4>>2]|0;da=fa;X=c[da>>2]|0;da=c[da+4>>2]|0;n=tb;o=c[n>>2]|0;n=c[n+4>>2]|0;s=Ta(o|0,n|0,k|0,m|0)|0;r=Mb;c[r>>2]=s;c[r+4>>2]=y;r=ab;s=c[r>>2]|0;r=c[r+4>>2]|0;w=Ta(s|0,r|0,p|0,q|0)|0;v=Ha;c[v>>2]=w;c[v+4>>2]=y;v=_a;w=c[v>>2]|0;v=c[v+4>>2]|0;B=Ta(w|0,v|0,t|0,u|0)|0;A=Fa;c[A>>2]=B;c[A+4>>2]=y;A=Ya;B=c[A>>2]|0;A=c[A+4>>2]|0;F=Ta(B|0,A|0,x|0,z|0)|0;E=Da;c[E>>2]=F;c[E+4>>2]=y;E=Va;F=c[E>>2]|0;E=c[E+4>>2]|0;J=Ta(F|0,E|0,C|0,D|0)|0;I=Ba;c[I>>2]=J;c[I+4>>2]=y;I=Ra;J=c[I>>2]|0;I=c[I+4>>2]|0;O=Ta(J|0,I|0,G|0,H|0)|0;M=za;c[M>>2]=O;c[M+4>>2]=y;M=Oa;O=c[M>>2]|0;M=c[M+4>>2]|0;S=Ta(O|0,M|0,K|0,L|0)|0;R=xa;c[R>>2]=S;c[R+4>>2]=y;R=Ma;S=c[R>>2]|0;R=c[R+4>>2]|0;W=Ta(S|0,R|0,P|0,Q|0)|0;V=ra;c[V>>2]=W;c[V+4>>2]=y;V=Ka;W=c[V>>2]|0;V=c[V+4>>2]|0;ob=Ta(W|0,V|0,T|0,U|0)|0;d=pa;c[d>>2]=ob;c[d+4>>2]=y;d=cb;ob=c[d>>2]|0;d=c[d+4>>2]|0;i=Ta(ob|0,d|0,X|0,da|0)|0;j=fa;c[j>>2]=i;c[j+4>>2]=y;n=Ua(k|0,m|0,o|0,n|0)|0;o=tb;c[o>>2]=n;c[o+4>>2]=y;r=Ua(p|0,q|0,s|0,r|0)|0;s=ab;c[s>>2]=r;c[s+4>>2]=y;v=Ua(t|0,u|0,w|0,v|0)|0;w=_a;c[w>>2]=v;c[w+4>>2]=y;A=Ua(x|0,z|0,B|0,A|0)|0;B=Ya;c[B>>2]=A;c[B+4>>2]=y;E=Ua(C|0,D|0,F|0,E|0)|0;F=Va;c[F>>2]=E;c[F+4>>2]=y;I=Ua(G|0,H|0,J|0,I|0)|0;J=Ra;c[J>>2]=I;c[J+4>>2]=y;M=Ua(K|0,L|0,O|0,M|0)|0;O=Oa;c[O>>2]=M;c[O+4>>2]=y;R=Ua(P|0,Q|0,S|0,R|0)|0;S=Ma;c[S>>2]=R;c[S+4>>2]=y;V=Ua(T|0,U|0,W|0,V|0)|0;W=Ka;c[W>>2]=V;c[W+4>>2]=y;d=Ua(X|0,da|0,ob|0,d|0)|0;ob=cb;c[ob>>2]=d;c[ob+4>>2]=y;va(vb,Mb);va(ub,tb);ta(tb,ub,pb);ob=Ja;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Ka;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Qa(d|0,ob|0,18,0)|0;V=y;ob=Ta(X|0,da|0,d|0,ob|0)|0;V=Ta(ob|0,y|0,W|0,V|0)|0;W=Ka;c[W>>2]=V;c[W+4>>2]=y;W=La;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Ma;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(V|0,W|0,18,0)|0;X=y;W=Ta(d|0,ob|0,V|0,W|0)|0;X=Ta(W|0,y|0,da|0,X|0)|0;da=Ma;c[da>>2]=X;c[da+4>>2]=y;da=Na;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Oa;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Qa(X|0,da|0,18,0)|0;d=y;da=Ta(V|0,W|0,X|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Oa;c[ob>>2]=d;c[ob+4>>2]=y;ob=Pa;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Ra;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Qa(d|0,ob|0,18,0)|0;V=y;ob=Ta(X|0,da|0,d|0,ob|0)|0;V=Ta(ob|0,y|0,W|0,V|0)|0;W=Ra;c[W>>2]=V;c[W+4>>2]=y;W=Sa;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Va;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(V|0,W|0,18,0)|0;X=y;W=Ta(d|0,ob|0,V|0,W|0)|0;X=Ta(W|0,y|0,da|0,X|0)|0;da=Va;c[da>>2]=X;c[da+4>>2]=y;da=Xa;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Ya;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Qa(X|0,da|0,18,0)|0;d=y;da=Ta(V|0,W|0,X|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ya;c[ob>>2]=d;c[ob+4>>2]=y;ob=Za;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=_a;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Qa(d|0,ob|0,18,0)|0;V=y;ob=Ta(X|0,da|0,d|0,ob|0)|0;V=Ta(ob|0,y|0,W|0,V|0)|0;W=_a;c[W>>2]=V;c[W+4>>2]=y;W=$a;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(V|0,W|0,18,0)|0;X=y;W=Ta(d|0,ob|0,V|0,W|0)|0;X=Ta(W|0,y|0,da|0,X|0)|0;da=ab;c[da>>2]=X;c[da+4>>2]=y;da=bb;X=c[da>>2]|0;da=c[da+4>>2]|0;W=tb;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Qa(X|0,da|0,18,0)|0;d=y;da=Ta(V|0,W|0,X|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=tb;c[ob>>2]=d;c[ob+4>>2]=y;ua(tb);ob=h;d=vb;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));ob=ca;d=tb;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(rb,f);va(sb,e);ta(ba,rb,sb);j=ba+144|0;o=c[j>>2]|0;j=c[j+4>>2]|0;n=ba+64|0;m=n;k=c[m>>2]|0;m=c[m+4>>2]|0;d=Qa(o|0,j|0,18,0)|0;i=y;j=Ta(k|0,m|0,o|0,j|0)|0;i=Ta(j|0,y|0,d|0,i|0)|0;c[n>>2]=i;c[n+4>>2]=y;n=ba+136|0;i=c[n>>2]|0;n=c[n+4>>2]|0;d=ba+56|0;j=d;o=c[j>>2]|0;j=c[j+4>>2]|0;m=Qa(i|0,n|0,18,0)|0;k=y;n=Ta(o|0,j|0,i|0,n|0)|0;k=Ta(n|0,y|0,m|0,k|0)|0;c[d>>2]=k;c[d+4>>2]=y;d=ba+128|0;k=c[d>>2]|0;d=c[d+4>>2]|0;m=ba+48|0;n=m;i=c[n>>2]|0;n=c[n+4>>2]|0;j=Qa(k|0,d|0,18,0)|0;o=y;d=Ta(i|0,n|0,k|0,d|0)|0;o=Ta(d|0,y|0,j|0,o|0)|0;c[m>>2]=o;c[m+4>>2]=y;m=ba+120|0;o=c[m>>2]|0;m=c[m+4>>2]|0;j=ba+40|0;d=j;k=c[d>>2]|0;d=c[d+4>>2]|0;n=Qa(o|0,m|0,18,0)|0;i=y;m=Ta(k|0,d|0,o|0,m|0)|0;i=Ta(m|0,y|0,n|0,i|0)|0;c[j>>2]=i;c[j+4>>2]=y;j=ba+112|0;i=c[j>>2]|0;j=c[j+4>>2]|0;n=ba+32|0;m=n;o=c[m>>2]|0;m=c[m+4>>2]|0;d=Qa(i|0,j|0,18,0)|0;k=y;j=Ta(o|0,m|0,i|0,j|0)|0;k=Ta(j|0,y|0,d|0,k|0)|0;c[n>>2]=k;c[n+4>>2]=y;n=ba+104|0;k=c[n>>2]|0;n=c[n+4>>2]|0;d=ba+24|0;j=d;i=c[j>>2]|0;j=c[j+4>>2]|0;m=Qa(k|0,n|0,18,0)|0;o=y;n=Ta(i|0,j|0,k|0,n|0)|0;o=Ta(n|0,y|0,m|0,o|0)|0;c[d>>2]=o;c[d+4>>2]=y;d=ba+96|0;o=c[d>>2]|0;d=c[d+4>>2]|0;m=ba+16|0;n=m;k=c[n>>2]|0;n=c[n+4>>2]|0;j=Qa(o|0,d|0,18,0)|0;i=y;d=Ta(k|0,n|0,o|0,d|0)|0;i=Ta(d|0,y|0,j|0,i|0)|0;c[m>>2]=i;c[m+4>>2]=y;m=ba+88|0;i=c[m>>2]|0;m=c[m+4>>2]|0;j=ba+8|0;d=j;o=c[d>>2]|0;d=c[d+4>>2]|0;n=Qa(i|0,m|0,18,0)|0;k=y;m=Ta(o|0,d|0,i|0,m|0)|0;k=Ta(m|0,y|0,n|0,k|0)|0;c[j>>2]=k;c[j+4>>2]=y;j=ba+80|0;k=c[j>>2]|0;j=c[j+4>>2]|0;n=ba;m=c[n>>2]|0;n=c[n+4>>2]|0;i=Qa(k|0,j|0,18,0)|0;d=y;j=Ta(m|0,n|0,k|0,j|0)|0;d=Ta(j|0,y|0,i|0,d|0)|0;i=ba;c[i>>2]=d;c[i+4>>2]=y;ua(ba);i=rb;d=c[i>>2]|0;i=c[i+4>>2]|0;j=sb;j=Ua(d|0,i|0,c[j>>2]|0,c[j+4>>2]|0)|0;k=y;n=sb;c[n>>2]=j;c[n+4>>2]=k;n=db;m=c[n>>2]|0;n=c[n+4>>2]|0;o=eb;o=Ua(m|0,n|0,c[o>>2]|0,c[o+4>>2]|0)|0;p=y;r=eb;c[r>>2]=o;c[r+4>>2]=p;r=fb;q=c[r>>2]|0;r=c[r+4>>2]|0;s=gb;s=Ua(q|0,r|0,c[s>>2]|0,c[s+4>>2]|0)|0;t=y;v=gb;c[v>>2]=s;c[v+4>>2]=t;v=hb;u=c[v>>2]|0;v=c[v+4>>2]|0;w=ib;w=Ua(u|0,v|0,c[w>>2]|0,c[w+4>>2]|0)|0;x=y;A=ib;c[A>>2]=w;c[A+4>>2]=x;A=jb;z=c[A>>2]|0;A=c[A+4>>2]|0;B=kb;B=Ua(z|0,A|0,c[B>>2]|0,c[B+4>>2]|0)|0;C=y;E=kb;c[E>>2]=B;c[E+4>>2]=C;E=lb;D=c[E>>2]|0;E=c[E+4>>2]|0;F=mb;F=Ua(D|0,E|0,c[F>>2]|0,c[F+4>>2]|0)|0;G=y;I=mb;c[I>>2]=F;c[I+4>>2]=G;I=nb;H=c[I>>2]|0;I=c[I+4>>2]|0;J=ga;J=Ua(H|0,I|0,c[J>>2]|0,c[J+4>>2]|0)|0;K=y;M=ga;c[M>>2]=J;c[M+4>>2]=K;M=ha;L=c[M>>2]|0;M=c[M+4>>2]|0;O=ia;O=Ua(L|0,M|0,c[O>>2]|0,c[O+4>>2]|0)|0;P=y;R=ia;c[R>>2]=O;c[R+4>>2]=P;R=ja;Q=c[R>>2]|0;R=c[R+4>>2]|0;S=ka;S=Ua(Q|0,R|0,c[S>>2]|0,c[S+4>>2]|0)|0;T=y;V=ka;c[V>>2]=S;c[V+4>>2]=T;V=la;U=c[V>>2]|0;V=c[V+4>>2]|0;W=ma;W=Ua(U|0,V|0,c[W>>2]|0,c[W+4>>2]|0)|0;X=y;ob=ma;c[ob>>2]=W;c[ob+4>>2]=X;ob=wb;da=ob+72|0;do{c[ob>>2]=0;ob=ob+4|0}while((ob|0)<(da|0));Vb=Qa(j|0,k|0,121665,0)|0;Rb=Ib;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(o|0,p|0,121665,0)|0;Vb=xb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Qa(s|0,t|0,121665,0)|0;Rb=yb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(w|0,x|0,121665,0)|0;Vb=zb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Qa(B|0,C|0,121665,0)|0;Rb=Ab;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(F|0,G|0,121665,0)|0;Vb=Bb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Qa(J|0,K|0,121665,0)|0;Rb=Cb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(O|0,P|0,121665,0)|0;Vb=Db;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Qa(S|0,T|0,121665,0)|0;Rb=Eb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(W|0,X|0,121665,0)|0;Vb=na;c[Vb>>2]=Rb;c[Vb+4>>2]=y;ua(Ib);Vb=Ib;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,d|0,i|0)|0;Rb=Ib;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=xb;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,m|0,n|0)|0;Vb=xb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=yb;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,q|0,r|0)|0;Rb=yb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=zb;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,u|0,v|0)|0;Vb=zb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Ab;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,z|0,A|0)|0;Rb=Ab;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Bb;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,D|0,E|0)|0;Vb=Bb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Cb;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,H|0,I|0)|0;Rb=Cb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Db;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,L|0,M|0)|0;Vb=Db;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Eb;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,Q|0,R|0)|0;Rb=Eb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=na;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,U|0,V|0)|0;Vb=na;c[Vb>>2]=Rb;c[Vb+4>>2]=y;ta(aa,sb,Ib);Vb=aa+144|0;Rb=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Tb=aa+64|0;Sb=Tb;Ub=c[Sb>>2]|0;Sb=c[Sb+4>>2]|0;Wb=Qa(Rb|0,Vb|0,18,0)|0;Xb=y;Vb=Ta(Ub|0,Sb|0,Rb|0,Vb|0)|0;Xb=Ta(Vb|0,y|0,Wb|0,Xb|0)|0;c[Tb>>2]=Xb;c[Tb+4>>2]=y;Tb=aa+136|0;Xb=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Wb=aa+56|0;Vb=Wb;Rb=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Sb=Qa(Xb|0,Tb|0,18,0)|0;Ub=y;Tb=Ta(Rb|0,Vb|0,Xb|0,Tb|0)|0;Ub=Ta(Tb|0,y|0,Sb|0,Ub|0)|0;c[Wb>>2]=Ub;c[Wb+4>>2]=y;Wb=aa+128|0;Ub=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;Sb=aa+48|0;Tb=Sb;Xb=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Vb=Qa(Ub|0,Wb|0,18,0)|0;Rb=y;Wb=Ta(Xb|0,Tb|0,Ub|0,Wb|0)|0;Rb=Ta(Wb|0,y|0,Vb|0,Rb|0)|0;c[Sb>>2]=Rb;c[Sb+4>>2]=y;Sb=aa+120|0;Rb=c[Sb>>2]|0;Sb=c[Sb+4>>2]|0;Vb=aa+40|0;Wb=Vb;Ub=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;Tb=Qa(Rb|0,Sb|0,18,0)|0;Xb=y;Sb=Ta(Ub|0,Wb|0,Rb|0,Sb|0)|0;Xb=Ta(Sb|0,y|0,Tb|0,Xb|0)|0;c[Vb>>2]=Xb;c[Vb+4>>2]=y;Vb=aa+112|0;Xb=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Tb=aa+32|0;Sb=Tb;Rb=c[Sb>>2]|0;Sb=c[Sb+4>>2]|0;Wb=Qa(Xb|0,Vb|0,18,0)|0;Ub=y;Vb=Ta(Rb|0,Sb|0,Xb|0,Vb|0)|0;Ub=Ta(Vb|0,y|0,Wb|0,Ub|0)|0;c[Tb>>2]=Ub;c[Tb+4>>2]=y;Tb=aa+104|0;Ub=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Wb=aa+24|0;Vb=Wb;Xb=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Sb=Qa(Ub|0,Tb|0,18,0)|0;Rb=y;Tb=Ta(Xb|0,Vb|0,Ub|0,Tb|0)|0;Rb=Ta(Tb|0,y|0,Sb|0,Rb|0)|0;c[Wb>>2]=Rb;c[Wb+4>>2]=y;Wb=aa+96|0;Rb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;Sb=aa+16|0;Tb=Sb;Ub=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Vb=Qa(Rb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(Ub|0,Tb|0,Rb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,Vb|0,Xb|0)|0;c[Sb>>2]=Xb;c[Sb+4>>2]=y;Sb=aa+88|0;Xb=c[Sb>>2]|0;Sb=c[Sb+4>>2]|0;Vb=aa+8|0;Wb=Vb;Rb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;Tb=Qa(Xb|0,Sb|0,18,0)|0;Ub=y;Sb=Ta(Rb|0,Wb|0,Xb|0,Sb|0)|0;Ub=Ta(Sb|0,y|0,Tb|0,Ub|0)|0;c[Vb>>2]=Ub;c[Vb+4>>2]=y;Vb=aa+80|0;Ub=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Tb=aa;Sb=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Xb=Qa(Ub|0,Vb|0,18,0)|0;Wb=y;Vb=Ta(Sb|0,Tb|0,Ub|0,Vb|0)|0;Wb=Ta(Vb|0,y|0,Xb|0,Wb|0)|0;Xb=aa;c[Xb>>2]=Wb;c[Xb+4>>2]=y;ua(aa);sa(ba,h,Z,0);sa(aa,ca,Z,0);$=$+1|0;if(($|0)==8)break;else{Ub=_;Vb=g;Wb=f;Xb=e;k=Y<<1&255;_=h;f=ba;e=aa;g=ca;h=Ub;ca=Vb;ba=Wb;aa=Xb}}ea=ea+1|0;if((ea|0)==32)break;else{m=h;h=_;d=ca;i=aa;j=ba}}ob=Jb;d=ba;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));ob=Kb;d=aa;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(rb,Kb);va(Hb,rb);va(Gb,Hb);ta(Ib,Gb,Kb);e=Ib+144|0;j=e;i=c[j>>2]|0;j=c[j+4>>2]|0;h=Eb;g=c[h>>2]|0;h=c[h+4>>2]|0;f=Qa(i|0,j|0,18,0)|0;k=y;j=Ta(g|0,h|0,i|0,j|0)|0;k=Ta(j|0,y|0,f|0,k|0)|0;f=Eb;c[f>>2]=k;c[f+4>>2]=y;f=Ib+136|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;i=Db;h=c[i>>2]|0;i=c[i+4>>2]|0;g=Qa(j|0,k|0,18,0)|0;m=y;k=Ta(h|0,i|0,j|0,k|0)|0;m=Ta(k|0,y|0,g|0,m|0)|0;g=Db;c[g>>2]=m;c[g+4>>2]=y;g=Ib+128|0;m=g;k=c[m>>2]|0;m=c[m+4>>2]|0;j=Cb;i=c[j>>2]|0;j=c[j+4>>2]|0;h=Qa(k|0,m|0,18,0)|0;da=y;m=Ta(i|0,j|0,k|0,m|0)|0;da=Ta(m|0,y|0,h|0,da|0)|0;h=Cb;c[h>>2]=da;c[h+4>>2]=y;h=Ib+120|0;da=h;m=c[da>>2]|0;da=c[da+4>>2]|0;k=Bb;j=c[k>>2]|0;k=c[k+4>>2]|0;i=Qa(m|0,da|0,18,0)|0;d=y;da=Ta(j|0,k|0,m|0,da|0)|0;d=Ta(da|0,y|0,i|0,d|0)|0;i=Bb;c[i>>2]=d;c[i+4>>2]=y;i=Ib+112|0;d=i;da=c[d>>2]|0;d=c[d+4>>2]|0;m=Ab;k=c[m>>2]|0;m=c[m+4>>2]|0;j=Qa(da|0,d|0,18,0)|0;ob=y;d=Ta(k|0,m|0,da|0,d|0)|0;ob=Ta(d|0,y|0,j|0,ob|0)|0;j=Ab;c[j>>2]=ob;c[j+4>>2]=y;j=Ib+104|0;ob=j;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=zb;m=c[da>>2]|0;da=c[da+4>>2]|0;k=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(m|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,k|0,Vb|0)|0;k=zb;c[k>>2]=Vb;c[k+4>>2]=y;k=Ib+96|0;Vb=k;ob=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;d=yb;da=c[d>>2]|0;d=c[d+4>>2]|0;m=Qa(ob|0,Vb|0,18,0)|0;Wb=y;Vb=Ta(da|0,d|0,ob|0,Vb|0)|0;Wb=Ta(Vb|0,y|0,m|0,Wb|0)|0;m=yb;c[m>>2]=Wb;c[m+4>>2]=y;m=Ib+88|0;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=sb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));ta(Ib,sb,rb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Mb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,Mb);ta(Ib,Gb,sb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=tb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,tb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);ta(Ib,Gb,tb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=ub;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,ub);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);ta(Ib,Hb,ub);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=vb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,vb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);ta(Ib,Hb,vb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Gb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);ta(Ib,Gb,ub);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Nb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,Nb);va(Hb,Gb);d=2;do{va(Gb,Hb);va(Hb,Gb);d=d+2|0}while((d|0)<50);ta(Ib,Hb,Nb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Fb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Hb,Fb);va(Gb,Hb);d=2;do{va(Hb,Gb);va(Gb,Hb);d=d+2|0}while((d|0)<100);ta(Ib,Gb,Fb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Hb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,Hb);va(Hb,Gb);d=2;do{va(Gb,Hb);va(Hb,Gb);d=d+2|0}while((d|0)<50);ta(Ib,Hb,Nb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Gb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);ta(Ib,Hb,Mb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Lb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));ta(Ib,Jb,Lb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Kb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));Nb=c[Kb>>2]|0;Pb=(Nb>>31&Nb)>>26;Wb=Pb+(c[Kb+8>>2]|0)|0;Db=(Wb>>31&Wb)>>25;Qb=Db+(c[Kb+16>>2]|0)|0;Xb=(Qb>>31&Qb)>>26;Rb=Xb+(c[Kb+24>>2]|0)|0;Cb=(Rb>>31&Rb)>>25;Sb=Cb+(c[Kb+32>>2]|0)|0;Jb=(Sb>>31&Sb)>>26;Tb=Jb+(c[Kb+40>>2]|0)|0;Ib=(Tb>>31&Tb)>>25;Ub=Ib+(c[Kb+48>>2]|0)|0;Hb=(Ub>>31&Ub)>>26;Vb=Hb+(c[Kb+56>>2]|0)|0;Mb=(Vb>>31&Vb)>>25;Lb=Mb+(c[Kb+64>>2]|0)|0;Gb=(Lb>>31&Lb)>>26;Fb=Gb+(c[Kb+72>>2]|0)|0;Eb=(Fb>>31&Fb)>>25;Nb=(N(Pb,-67108864)|0)+Nb+(Eb*19|0)|0;Pb=(Nb>>31&Nb)>>26;Wb=(N(Db,-33554432)|0)+Wb+Pb|0;Db=(Wb>>31&Wb)>>25;Qb=(N(Xb,-67108864)|0)+Qb+Db|0;Xb=(Qb>>31&Qb)>>26;Rb=(N(Cb,-33554432)|0)+Rb+Xb|0;Kb=(Rb>>31&Rb)>>25;Sb=(N(Jb,-67108864)|0)+Sb+Kb|0;Jb=(Sb>>31&Sb)>>26;Tb=(N(Ib,-33554432)|0)+Tb+Jb|0;Ib=(Tb>>31&Tb)>>25;Ub=(N(Hb,-67108864)|0)+Ub+Ib|0;Hb=(Ub>>31&Ub)>>26;Vb=(N(Mb,-33554432)|0)+Vb+Hb|0;Mb=(Vb>>31&Vb)>>25;Lb=(N(Gb,-67108864)|0)+Lb+Mb|0;Gb=(Lb>>31&Lb)>>26;Fb=(N(Eb,-33554432)|0)+Fb+Gb|0;Eb=(Fb>>31&Fb)>>25;Nb=(N(Pb,-67108864)|0)+Nb+(Eb*19|0)|0;Pb=(Nb>>31&Nb)>>26;Nb=(N(Pb,-67108864)|0)+Nb|0;Pb=(N(Db,-33554432)|0)+Wb+Pb+(Nb>>26)|0;Qb=(N(Xb,-67108864)|0)+Qb+(Pb>>25)|0;Rb=(N(Kb,-33554432)|0)+Rb+(Qb>>26)|0;Sb=(N(Jb,-67108864)|0)+Sb+(Rb>>25)|0;Tb=(N(Ib,-33554432)|0)+Tb+(Sb>>26)|0;Ub=(N(Hb,-67108864)|0)+Ub+(Tb>>25)|0;Vb=(N(Mb,-33554432)|0)+Vb+(Ub>>26)|0;Lb=(N(Gb,-67108864)|0)+Lb+(Vb>>25)|0;Fb=(N(Eb,-33554432)|0)+Fb+(Lb>>26)|0;Eb=(Fb>>25)*19|0;Gb=Eb+(Nb&67108863)>>26;Mb=Gb+(Pb&33554431)>>25;Pb=Gb+Pb|0;Gb=Mb+(Qb&67108863)>>26;Qb=Mb+Qb|0;Mb=Gb+(Rb&33554431)>>25;Rb=Gb+Rb|0;Gb=Mb+(Sb&67108863)>>26;Sb=Mb+Sb|0;Mb=Gb+(Tb&33554431)>>25;Tb=Gb+Tb|0;Gb=Mb+(Ub&67108863)>>26;Ub=Mb+Ub|0;Mb=Gb+(Vb&33554431)>>25;Vb=Gb+Vb|0;Gb=Mb+(Lb&67108863)>>26;Lb=Mb+Lb|0;Mb=Gb+Fb|0;Nb=((Gb+(Fb&33554431)>>25)*19|0)+(Eb+Nb&67108863)|0;Eb=(Pb|-33554432)&Pb<<16;Eb=Eb<<8&Eb;Eb=Eb<<4&Eb;Eb=Eb<<2&Eb;Fb=(Qb|-67108864)&Qb<<16;Fb=Fb<<8&Fb;Fb=Fb<<4&Fb;Fb=Fb<<2&Fb;Gb=(Rb|-33554432)&Rb<<16;Gb=Gb<<8&Gb;Gb=Gb<<4&Gb;Gb=Gb<<2&Gb;Hb=(Sb|-67108864)&Sb<<16;Hb=Hb<<8&Hb;Hb=Hb<<4&Hb;Hb=Hb<<2&Hb;Ib=(Tb|-33554432)&Tb<<16;Ib=Ib<<8&Ib;Ib=Ib<<4&Ib;Ib=Ib<<2&Ib;Jb=(Ub|-67108864)&Ub<<16;Jb=Jb<<8&Jb;Jb=Jb<<4&Jb;Jb=Jb<<2&Jb;Kb=(Vb|-33554432)&Vb<<16;Kb=Kb<<8&Kb;Kb=Kb<<4&Kb;Kb=Kb<<2&Kb;Xb=(Lb|-67108864)&Lb<<16;Xb=Xb<<8&Xb;Xb=Xb<<4&Xb;Xb=Xb<<2&Xb;Wb=(Mb|-33554432)&Mb<<16;Wb=Wb<<8&Wb;Wb=Wb<<4&Wb;Wb=Wb<<2&Wb;Wb=(Eb<<1&Eb&Fb&Fb<<1&Gb&Gb<<1&Hb&Hb<<1&Ib&Ib<<1)>>31&~(Nb+-67108845>>31)&(Jb<<1&Jb)>>31&(Kb<<1&Kb)>>31&(Xb<<1&Xb)>>31&(Wb<<1&Wb)>>31;Nb=Nb-(Wb&67108845)|0;Xb=Wb&33554431;Pb=(Pb&33554431)-Xb|0;Wb=Wb&67108863;Qb=(Qb&67108863)-Wb|0;Rb=(Rb&33554431)-Xb|0;Sb=(Sb&67108863)-Wb|0;Tb=(Tb&33554431)-Xb|0;Ub=(Ub&67108863)-Wb|0;Vb=(Vb&33554431)-Xb|0;Wb=(Lb&67108863)-Wb|0;Xb=(Mb&33554431)-Xb|0;a[b>>0]=Nb;a[b+1>>0]=Nb>>>8;a[b+2>>0]=Nb>>>16;a[b+3>>0]=Pb<<2|Nb>>>24;a[b+4>>0]=Pb>>>6;a[b+5>>0]=Pb>>>14;a[b+6>>0]=Qb<<3|Pb>>>22;a[b+7>>0]=Qb>>>5;a[b+8>>0]=Qb>>>13;a[b+9>>0]=Rb<<5|Qb>>>21;a[b+10>>0]=Rb>>>3;a[b+11>>0]=Rb>>>11;a[b+12>>0]=Sb<<6|Rb>>>19;a[b+13>>0]=Sb>>>2;a[b+14>>0]=Sb>>>10;a[b+15>>0]=Sb>>>18;a[b+16>>0]=Tb;a[b+17>>0]=Tb>>>8;a[b+18>>0]=Tb>>>16;a[b+19>>0]=Ub<<1|Tb>>>24;a[b+20>>0]=Ub>>>7;a[b+21>>0]=Ub>>>15;a[b+22>>0]=Vb<<3|Ub>>>23;a[b+23>>0]=Vb>>>5;a[b+24>>0]=Vb>>>13;a[b+25>>0]=Wb<<4|Vb>>>21;a[b+26>>0]=Wb>>>4;a[b+27>>0]=Wb>>>12;a[b+28>>0]=Xb<<6|Wb>>>20;a[b+29>>0]=Xb>>>2;a[b+30>>0]=Xb>>>10;a[b+31>>0]=Xb>>>18;l=Ob;return}function qa(b){b=b|0;var c=0;da(0)|0;c=0;do{a[b+c>>0]=da(1)|0;c=c+1|0}while((c|0)!=32);a[b>>0]=a[b>>0]&-8;b=b+31|0;a[b>>0]=a[b>>0]&63|64;return}function ra(b,c){b=b|0;c=c|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;f=0;g=a[c>>0]|0;h=c;e=b;while(1){i=a[h+2>>0]|0;j=d[h+1>>0]|0;k=j>>>4|(g&255)<<4&48;j=j<<2&60|(i&255)>>>6;l=(g&255)>>>2&255;a[e>>0]=l+65+((25-l|0)>>>8&6)-((51-l|0)>>>8&75)-((61-l|0)>>>8&15)+((62-l|0)>>>8&3);a[e+1>>0]=k+65+((25-k|0)>>>8&6)-((51-k|0)>>>8&75)-((61-k|0)>>>8&15)+((62-k|0)>>>8&3);a[e+2>>0]=j+65+((25-j|0)>>>8&6)-((51-j|0)>>>8&75)-((61-j|0)>>>8&15)+((62-j|0)>>>8&3);i=i&63;a[e+3>>0]=i+65+((25-i|0)>>>8&6)-((51-i|0)>>>8&75)-((61-i|0)>>>8&15)+((62-i|0)>>>8&3);e=f+1|0;h=c+(e*3|0)|0;g=a[h>>0]|0;if((e|0)==10)break;else{f=e;e=b+(e<<2)|0}}l=d[c+31>>0]|0;k=l>>>4|(g&255)<<4&48;l=l<<2&60;j=(g&255)>>>2&255;a[b+40>>0]=j+65+((25-j|0)>>>8&6)-((51-j|0)>>>8&75)-((61-j|0)>>>8&15)+((62-j|0)>>>8&3);a[b+41>>0]=k+65+((25-k|0)>>>8&6)-((51-k|0)>>>8&75)-((61-k|0)>>>8&15)+((62-k|0)>>>8&3);a[b+42>>0]=((25-l|0)>>>8&6)+(l|65)-((51-l|0)>>>8&75);a[b+43>>0]=61;a[b+44>>0]=0;return}function sa(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0;d=Ua(0,0,d|0,e|0)|0;i=y;g=a;e=c[g>>2]|0;g=c[g+4>>2]|0;f=b;h=(c[f>>2]^e)&d;f=(c[f+4>>2]^g)&i;e=Ra(0,h^e|0,32)|0;g=a;c[g>>2]=e;c[g+4>>2]=y;g=b;h=Ra(0,c[g>>2]^h|0,32)|0;g=b;c[g>>2]=h;c[g+4>>2]=y;g=a+8|0;h=g;f=c[h>>2]|0;h=c[h+4>>2]|0;e=b+8|0;j=e;k=(c[j>>2]^f)&d;j=(c[j+4>>2]^h)&i;f=Ra(0,k^f|0,32)|0;c[g>>2]=f;c[g+4>>2]=y;g=e;k=Ra(0,c[g>>2]^k|0,32)|0;c[e>>2]=k;c[e+4>>2]=y;e=a+16|0;k=e;g=c[k>>2]|0;k=c[k+4>>2]|0;j=b+16|0;f=j;h=(c[f>>2]^g)&d;f=(c[f+4>>2]^k)&i;g=Ra(0,h^g|0,32)|0;c[e>>2]=g;c[e+4>>2]=y;e=j;h=Ra(0,c[e>>2]^h|0,32)|0;c[j>>2]=h;c[j+4>>2]=y;j=a+24|0;h=j;e=c[h>>2]|0;h=c[h+4>>2]|0;f=b+24|0;g=f;k=(c[g>>2]^e)&d;g=(c[g+4>>2]^h)&i;e=Ra(0,k^e|0,32)|0;c[j>>2]=e;c[j+4>>2]=y;j=f;k=Ra(0,c[j>>2]^k|0,32)|0;c[f>>2]=k;c[f+4>>2]=y;f=a+32|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;g=b+32|0;e=g;h=(c[e>>2]^j)&d;e=(c[e+4>>2]^k)&i;j=Ra(0,h^j|0,32)|0;c[f>>2]=j;c[f+4>>2]=y;f=g;h=Ra(0,c[f>>2]^h|0,32)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+40|0;h=g;f=c[h>>2]|0;h=c[h+4>>2]|0;e=b+40|0;j=e;k=(c[j>>2]^f)&d;j=(c[j+4>>2]^h)&i;f=Ra(0,k^f|0,32)|0;c[g>>2]=f;c[g+4>>2]=y;g=e;k=Ra(0,c[g>>2]^k|0,32)|0;c[e>>2]=k;c[e+4>>2]=y;e=a+48|0;k=e;g=c[k>>2]|0;k=c[k+4>>2]|0;j=b+48|0;f=j;h=(c[f>>2]^g)&d;f=(c[f+4>>2]^k)&i;g=Ra(0,h^g|0,32)|0;c[e>>2]=g;c[e+4>>2]=y;e=j;h=Ra(0,c[e>>2]^h|0,32)|0;c[j>>2]=h;c[j+4>>2]=y;j=a+56|0;h=j;e=c[h>>2]|0;h=c[h+4>>2]|0;f=b+56|0;g=f;k=(c[g>>2]^e)&d;g=(c[g+4>>2]^h)&i;e=Ra(0,k^e|0,32)|0;c[j>>2]=e;c[j+4>>2]=y;j=f;k=Ra(0,c[j>>2]^k|0,32)|0;c[f>>2]=k;c[f+4>>2]=y;f=a+64|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;g=b+64|0;e=g;h=(c[e>>2]^j)&d;e=(c[e+4>>2]^k)&i;j=Ra(0,h^j|0,32)|0;c[f>>2]=j;c[f+4>>2]=y;f=g;h=Ra(0,c[f>>2]^h|0,32)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+72|0;h=g;f=c[h>>2]|0;h=c[h+4>>2]|0;e=b+72|0;a=e;d=(c[a>>2]^f)&d;a=(c[a+4>>2]^h)&i;f=Ra(0,d^f|0,32)|0;b=g;c[b>>2]=f;c[b+4>>2]=y;b=e;d=Ra(0,c[b>>2]^d|0,32)|0;c[e>>2]=d;c[e+4>>2]=y;return}function ta(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0;h=Ra(0,c[b>>2]|0,32)|0;n=y;w=Ra(0,c[d>>2]|0,32)|0;n=Qa(w|0,y|0,h|0,n|0)|0;h=a;c[h>>2]=n;c[h+4>>2]=y;h=Ra(0,c[b>>2]|0,32)|0;n=y;w=d+8|0;s=Ra(0,c[w>>2]|0,32)|0;n=Qa(s|0,y|0,h|0,n|0)|0;h=y;s=b+8|0;r=Ra(0,c[s>>2]|0,32)|0;p=y;v=Ra(0,c[d>>2]|0,32)|0;p=Qa(v|0,y|0,r|0,p|0)|0;h=Ta(p|0,y|0,n|0,h|0)|0;n=a+8|0;c[n>>2]=h;c[n+4>>2]=y;n=Ra(0,c[s>>2]|0,31)|0;h=y;p=Ra(0,c[w>>2]|0,32)|0;h=Qa(p|0,y|0,n|0,h|0)|0;n=y;p=Ra(0,c[b>>2]|0,32)|0;r=y;v=d+16|0;l=Ra(0,c[v>>2]|0,32)|0;r=Qa(l|0,y|0,p|0,r|0)|0;n=Ta(r|0,y|0,h|0,n|0)|0;h=y;r=b+16|0;p=Ra(0,c[r>>2]|0,32)|0;l=y;u=Ra(0,c[d>>2]|0,32)|0;l=Qa(u|0,y|0,p|0,l|0)|0;l=Ta(n|0,h|0,l|0,y|0)|0;h=a+16|0;c[h>>2]=l;c[h+4>>2]=y;h=Ra(0,c[s>>2]|0,32)|0;l=y;n=Ra(0,c[v>>2]|0,32)|0;l=Qa(n|0,y|0,h|0,l|0)|0;h=y;n=Ra(0,c[r>>2]|0,32)|0;p=y;u=Ra(0,c[w>>2]|0,32)|0;p=Qa(u|0,y|0,n|0,p|0)|0;h=Ta(p|0,y|0,l|0,h|0)|0;l=y;p=Ra(0,c[b>>2]|0,32)|0;n=y;u=d+24|0;g=Ra(0,c[u>>2]|0,32)|0;n=Qa(g|0,y|0,p|0,n|0)|0;n=Ta(h|0,l|0,n|0,y|0)|0;l=y;h=b+24|0;p=Ra(0,c[h>>2]|0,32)|0;g=y;j=Ra(0,c[d>>2]|0,32)|0;g=Qa(j|0,y|0,p|0,g|0)|0;g=Ta(n|0,l|0,g|0,y|0)|0;l=a+24|0;c[l>>2]=g;c[l+4>>2]=y;l=Ra(0,c[r>>2]|0,32)|0;g=y;n=Ra(0,c[v>>2]|0,32)|0;g=Qa(n|0,y|0,l|0,g|0)|0;l=y;n=Ra(0,c[s>>2]|0,32)|0;p=y;j=Ra(0,c[u>>2]|0,32)|0;p=Qa(j|0,y|0,n|0,p|0)|0;n=y;j=Ra(0,c[h>>2]|0,32)|0;q=y;o=Ra(0,c[w>>2]|0,32)|0;q=Qa(o|0,y|0,j|0,q|0)|0;n=Ta(q|0,y|0,p|0,n|0)|0;n=Sa(n|0,y|0,1)|0;l=Ta(n|0,y|0,g|0,l|0)|0;g=y;n=Ra(0,c[b>>2]|0,32)|0;p=y;q=d+32|0;j=Ra(0,c[q>>2]|0,32)|0;p=Qa(j|0,y|0,n|0,p|0)|0;p=Ta(l|0,g|0,p|0,y|0)|0;g=y;l=b+32|0;n=Ra(0,c[l>>2]|0,32)|0;j=y;o=Ra(0,c[d>>2]|0,32)|0;j=Qa(o|0,y|0,n|0,j|0)|0;j=Ta(p|0,g|0,j|0,y|0)|0;g=a+32|0;c[g>>2]=j;c[g+4>>2]=y;g=Ra(0,c[r>>2]|0,32)|0;j=y;p=Ra(0,c[u>>2]|0,32)|0;j=Qa(p|0,y|0,g|0,j|0)|0;g=y;p=Ra(0,c[h>>2]|0,32)|0;n=y;o=Ra(0,c[v>>2]|0,32)|0;n=Qa(o|0,y|0,p|0,n|0)|0;g=Ta(n|0,y|0,j|0,g|0)|0;j=y;n=Ra(0,c[s>>2]|0,32)|0;p=y;o=Ra(0,c[q>>2]|0,32)|0;p=Qa(o|0,y|0,n|0,p|0)|0;p=Ta(g|0,j|0,p|0,y|0)|0;j=y;g=Ra(0,c[l>>2]|0,32)|0;n=y;o=Ra(0,c[w>>2]|0,32)|0;n=Qa(o|0,y|0,g|0,n|0)|0;n=Ta(p|0,j|0,n|0,y|0)|0;j=y;p=Ra(0,c[b>>2]|0,32)|0;g=y;o=d+40|0;t=Ra(0,c[o>>2]|0,32)|0;g=Qa(t|0,y|0,p|0,g|0)|0;g=Ta(n|0,j|0,g|0,y|0)|0;j=y;n=b+40|0;p=Ra(0,c[n>>2]|0,32)|0;t=y;k=Ra(0,c[d>>2]|0,32)|0;t=Qa(k|0,y|0,p|0,t|0)|0;t=Ta(g|0,j|0,t|0,y|0)|0;j=a+40|0;c[j>>2]=t;c[j+4>>2]=y;j=Ra(0,c[h>>2]|0,32)|0;t=y;g=Ra(0,c[u>>2]|0,32)|0;t=Qa(g|0,y|0,j|0,t|0)|0;j=y;g=Ra(0,c[s>>2]|0,32)|0;p=y;k=Ra(0,c[o>>2]|0,32)|0;p=Qa(k|0,y|0,g|0,p|0)|0;j=Ta(p|0,y|0,t|0,j|0)|0;t=y;p=Ra(0,c[n>>2]|0,32)|0;g=y;k=Ra(0,c[w>>2]|0,32)|0;g=Qa(k|0,y|0,p|0,g|0)|0;g=Ta(j|0,t|0,g|0,y|0)|0;g=Sa(g|0,y|0,1)|0;t=y;j=Ra(0,c[r>>2]|0,32)|0;p=y;k=Ra(0,c[q>>2]|0,32)|0;p=Qa(k|0,y|0,j|0,p|0)|0;p=Ta(g|0,t|0,p|0,y|0)|0;t=y;g=Ra(0,c[l>>2]|0,32)|0;j=y;k=Ra(0,c[v>>2]|0,32)|0;j=Qa(k|0,y|0,g|0,j|0)|0;j=Ta(p|0,t|0,j|0,y|0)|0;t=y;p=Ra(0,c[b>>2]|0,32)|0;g=y;k=d+48|0;x=Ra(0,c[k>>2]|0,32)|0;g=Qa(x|0,y|0,p|0,g|0)|0;g=Ta(j|0,t|0,g|0,y|0)|0;t=y;j=b+48|0;p=Ra(0,c[j>>2]|0,32)|0;x=y;m=Ra(0,c[d>>2]|0,32)|0;x=Qa(m|0,y|0,p|0,x|0)|0;x=Ta(g|0,t|0,x|0,y|0)|0;t=a+48|0;c[t>>2]=x;c[t+4>>2]=y;t=Ra(0,c[h>>2]|0,32)|0;x=y;g=Ra(0,c[q>>2]|0,32)|0;x=Qa(g|0,y|0,t|0,x|0)|0;t=y;g=Ra(0,c[l>>2]|0,32)|0;p=y;m=Ra(0,c[u>>2]|0,32)|0;p=Qa(m|0,y|0,g|0,p|0)|0;t=Ta(p|0,y|0,x|0,t|0)|0;x=y;p=Ra(0,c[r>>2]|0,32)|0;g=y;m=Ra(0,c[o>>2]|0,32)|0;g=Qa(m|0,y|0,p|0,g|0)|0;g=Ta(t|0,x|0,g|0,y|0)|0;x=y;t=Ra(0,c[n>>2]|0,32)|0;p=y;m=Ra(0,c[v>>2]|0,32)|0;p=Qa(m|0,y|0,t|0,p|0)|0;p=Ta(g|0,x|0,p|0,y|0)|0;x=y;g=Ra(0,c[s>>2]|0,32)|0;t=y;m=Ra(0,c[k>>2]|0,32)|0;t=Qa(m|0,y|0,g|0,t|0)|0;t=Ta(p|0,x|0,t|0,y|0)|0;x=y;p=Ra(0,c[j>>2]|0,32)|0;g=y;m=Ra(0,c[w>>2]|0,32)|0;g=Qa(m|0,y|0,p|0,g|0)|0;g=Ta(t|0,x|0,g|0,y|0)|0;x=y;t=Ra(0,c[b>>2]|0,32)|0;p=y;m=d+56|0;z=Ra(0,c[m>>2]|0,32)|0;p=Qa(z|0,y|0,t|0,p|0)|0;p=Ta(g|0,x|0,p|0,y|0)|0;x=y;g=b+56|0;t=Ra(0,c[g>>2]|0,32)|0;z=y;i=Ra(0,c[d>>2]|0,32)|0;z=Qa(i|0,y|0,t|0,z|0)|0;z=Ta(p|0,x|0,z|0,y|0)|0;x=a+56|0;c[x>>2]=z;c[x+4>>2]=y;x=Ra(0,c[l>>2]|0,32)|0;z=y;p=Ra(0,c[q>>2]|0,32)|0;z=Qa(p|0,y|0,x|0,z|0)|0;x=y;p=Ra(0,c[h>>2]|0,32)|0;t=y;i=Ra(0,c[o>>2]|0,32)|0;t=Qa(i|0,y|0,p|0,t|0)|0;p=y;i=Ra(0,c[n>>2]|0,32)|0;f=y;e=Ra(0,c[u>>2]|0,32)|0;f=Qa(e|0,y|0,i|0,f|0)|0;p=Ta(f|0,y|0,t|0,p|0)|0;t=y;f=Ra(0,c[s>>2]|0,32)|0;i=y;e=Ra(0,c[m>>2]|0,32)|0;i=Qa(e|0,y|0,f|0,i|0)|0;i=Ta(p|0,t|0,i|0,y|0)|0;t=y;p=Ra(0,c[g>>2]|0,32)|0;f=y;e=Ra(0,c[w>>2]|0,32)|0;f=Qa(e|0,y|0,p|0,f|0)|0;f=Ta(i|0,t|0,f|0,y|0)|0;f=Sa(f|0,y|0,1)|0;x=Ta(f|0,y|0,z|0,x|0)|0;z=y;f=Ra(0,c[r>>2]|0,32)|0;t=y;i=Ra(0,c[k>>2]|0,32)|0;t=Qa(i|0,y|0,f|0,t|0)|0;t=Ta(x|0,z|0,t|0,y|0)|0;z=y;x=Ra(0,c[j>>2]|0,32)|0;f=y;i=Ra(0,c[v>>2]|0,32)|0;f=Qa(i|0,y|0,x|0,f|0)|0;f=Ta(t|0,z|0,f|0,y|0)|0;z=y;t=Ra(0,c[b>>2]|0,32)|0;x=y;i=d+64|0;p=Ra(0,c[i>>2]|0,32)|0;x=Qa(p|0,y|0,t|0,x|0)|0;x=Ta(f|0,z|0,x|0,y|0)|0;z=y;f=b+64|0;t=Ra(0,c[f>>2]|0,32)|0;p=y;e=Ra(0,c[d>>2]|0,32)|0;p=Qa(e|0,y|0,t|0,p|0)|0;p=Ta(x|0,z|0,p|0,y|0)|0;z=a+64|0;c[z>>2]=p;c[z+4>>2]=y;z=Ra(0,c[l>>2]|0,32)|0;p=y;x=Ra(0,c[o>>2]|0,32)|0;p=Qa(x|0,y|0,z|0,p|0)|0;z=y;x=Ra(0,c[n>>2]|0,32)|0;t=y;e=Ra(0,c[q>>2]|0,32)|0;t=Qa(e|0,y|0,x|0,t|0)|0;z=Ta(t|0,y|0,p|0,z|0)|0;p=y;t=Ra(0,c[h>>2]|0,32)|0;x=y;e=Ra(0,c[k>>2]|0,32)|0;x=Qa(e|0,y|0,t|0,x|0)|0;x=Ta(z|0,p|0,x|0,y|0)|0;p=y;z=Ra(0,c[j>>2]|0,32)|0;t=y;e=Ra(0,c[u>>2]|0,32)|0;t=Qa(e|0,y|0,z|0,t|0)|0;t=Ta(x|0,p|0,t|0,y|0)|0;p=y;x=Ra(0,c[r>>2]|0,32)|0;z=y;e=Ra(0,c[m>>2]|0,32)|0;z=Qa(e|0,y|0,x|0,z|0)|0;z=Ta(t|0,p|0,z|0,y|0)|0;p=y;t=Ra(0,c[g>>2]|0,32)|0;x=y;e=Ra(0,c[v>>2]|0,32)|0;x=Qa(e|0,y|0,t|0,x|0)|0;x=Ta(z|0,p|0,x|0,y|0)|0;p=y;z=Ra(0,c[s>>2]|0,32)|0;t=y;e=Ra(0,c[i>>2]|0,32)|0;t=Qa(e|0,y|0,z|0,t|0)|0;t=Ta(x|0,p|0,t|0,y|0)|0;p=y;x=Ra(0,c[f>>2]|0,32)|0;z=y;e=Ra(0,c[w>>2]|0,32)|0;z=Qa(e|0,y|0,x|0,z|0)|0;z=Ta(t|0,p|0,z|0,y|0)|0;p=y;t=Ra(0,c[b>>2]|0,32)|0;x=y;e=d+72|0;A=Ra(0,c[e>>2]|0,32)|0;x=Qa(A|0,y|0,t|0,x|0)|0;x=Ta(z|0,p|0,x|0,y|0)|0;p=y;b=b+72|0;z=Ra(0,c[b>>2]|0,32)|0;t=y;d=Ra(0,c[d>>2]|0,32)|0;t=Qa(d|0,y|0,z|0,t|0)|0;t=Ta(x|0,p|0,t|0,y|0)|0;d=a+72|0;c[d>>2]=t;c[d+4>>2]=y;d=Ra(0,c[n>>2]|0,32)|0;t=y;p=Ra(0,c[o>>2]|0,32)|0;t=Qa(p|0,y|0,d|0,t|0)|0;d=y;p=Ra(0,c[h>>2]|0,32)|0;x=y;z=Ra(0,c[m>>2]|0,32)|0;x=Qa(z|0,y|0,p|0,x|0)|0;d=Ta(x|0,y|0,t|0,d|0)|0;t=y;x=Ra(0,c[g>>2]|0,32)|0;p=y;z=Ra(0,c[u>>2]|0,32)|0;p=Qa(z|0,y|0,x|0,p|0)|0;p=Ta(d|0,t|0,p|0,y|0)|0;t=y;d=Ra(0,c[s>>2]|0,32)|0;s=y;x=Ra(0,c[e>>2]|0,32)|0;s=Qa(x|0,y|0,d|0,s|0)|0;s=Ta(p|0,t|0,s|0,y|0)|0;t=y;p=Ra(0,c[b>>2]|0,32)|0;d=y;w=Ra(0,c[w>>2]|0,32)|0;d=Qa(w|0,y|0,p|0,d|0)|0;d=Ta(s|0,t|0,d|0,y|0)|0;d=Sa(d|0,y|0,1)|0;t=y;s=Ra(0,c[l>>2]|0,32)|0;p=y;w=Ra(0,c[k>>2]|0,32)|0;p=Qa(w|0,y|0,s|0,p|0)|0;p=Ta(d|0,t|0,p|0,y|0)|0;t=y;d=Ra(0,c[j>>2]|0,32)|0;s=y;w=Ra(0,c[q>>2]|0,32)|0;s=Qa(w|0,y|0,d|0,s|0)|0;s=Ta(p|0,t|0,s|0,y|0)|0;t=y;p=Ra(0,c[r>>2]|0,32)|0;d=y;w=Ra(0,c[i>>2]|0,32)|0;d=Qa(w|0,y|0,p|0,d|0)|0;d=Ta(s|0,t|0,d|0,y|0)|0;t=y;s=Ra(0,c[f>>2]|0,32)|0;p=y;w=Ra(0,c[v>>2]|0,32)|0;p=Qa(w|0,y|0,s|0,p|0)|0;p=Ta(d|0,t|0,p|0,y|0)|0;t=a+80|0;c[t>>2]=p;c[t+4>>2]=y;t=Ra(0,c[n>>2]|0,32)|0;p=y;d=Ra(0,c[k>>2]|0,32)|0;p=Qa(d|0,y|0,t|0,p|0)|0;t=y;d=Ra(0,c[j>>2]|0,32)|0;s=y;w=Ra(0,c[o>>2]|0,32)|0;s=Qa(w|0,y|0,d|0,s|0)|0;t=Ta(s|0,y|0,p|0,t|0)|0;p=y;s=Ra(0,c[l>>2]|0,32)|0;d=y;w=Ra(0,c[m>>2]|0,32)|0;d=Qa(w|0,y|0,s|0,d|0)|0;d=Ta(t|0,p|0,d|0,y|0)|0;p=y;t=Ra(0,c[g>>2]|0,32)|0;s=y;w=Ra(0,c[q>>2]|0,32)|0;s=Qa(w|0,y|0,t|0,s|0)|0;s=Ta(d|0,p|0,s|0,y|0)|0;p=y;d=Ra(0,c[h>>2]|0,32)|0;t=y;w=Ra(0,c[i>>2]|0,32)|0;t=Qa(w|0,y|0,d|0,t|0)|0;t=Ta(s|0,p|0,t|0,y|0)|0;p=y;s=Ra(0,c[f>>2]|0,32)|0;d=y;w=Ra(0,c[u>>2]|0,32)|0;d=Qa(w|0,y|0,s|0,d|0)|0;d=Ta(t|0,p|0,d|0,y|0)|0;p=y;r=Ra(0,c[r>>2]|0,32)|0;t=y;s=Ra(0,c[e>>2]|0,32)|0;t=Qa(s|0,y|0,r|0,t|0)|0;t=Ta(d|0,p|0,t|0,y|0)|0;p=y;d=Ra(0,c[b>>2]|0,32)|0;r=y;v=Ra(0,c[v>>2]|0,32)|0;r=Qa(v|0,y|0,d|0,r|0)|0;r=Ta(t|0,p|0,r|0,y|0)|0;p=a+88|0;c[p>>2]=r;c[p+4>>2]=y;p=Ra(0,c[j>>2]|0,32)|0;r=y;t=Ra(0,c[k>>2]|0,32)|0;r=Qa(t|0,y|0,p|0,r|0)|0;p=y;t=Ra(0,c[n>>2]|0,32)|0;d=y;v=Ra(0,c[m>>2]|0,32)|0;d=Qa(v|0,y|0,t|0,d|0)|0;t=y;v=Ra(0,c[g>>2]|0,32)|0;s=y;w=Ra(0,c[o>>2]|0,32)|0;s=Qa(w|0,y|0,v|0,s|0)|0;t=Ta(s|0,y|0,d|0,t|0)|0;d=y;h=Ra(0,c[h>>2]|0,32)|0;s=y;v=Ra(0,c[e>>2]|0,32)|0;s=Qa(v|0,y|0,h|0,s|0)|0;s=Ta(t|0,d|0,s|0,y|0)|0;d=y;t=Ra(0,c[b>>2]|0,32)|0;h=y;u=Ra(0,c[u>>2]|0,32)|0;h=Qa(u|0,y|0,t|0,h|0)|0;h=Ta(s|0,d|0,h|0,y|0)|0;h=Sa(h|0,y|0,1)|0;p=Ta(h|0,y|0,r|0,p|0)|0;r=y;h=Ra(0,c[l>>2]|0,32)|0;d=y;s=Ra(0,c[i>>2]|0,32)|0;d=Qa(s|0,y|0,h|0,d|0)|0;d=Ta(p|0,r|0,d|0,y|0)|0;r=y;p=Ra(0,c[f>>2]|0,32)|0;h=y;s=Ra(0,c[q>>2]|0,32)|0;h=Qa(s|0,y|0,p|0,h|0)|0;h=Ta(d|0,r|0,h|0,y|0)|0;r=a+96|0;c[r>>2]=h;c[r+4>>2]=y;r=Ra(0,c[j>>2]|0,32)|0;h=y;d=Ra(0,c[m>>2]|0,32)|0;h=Qa(d|0,y|0,r|0,h|0)|0;r=y;d=Ra(0,c[g>>2]|0,32)|0;p=y;s=Ra(0,c[k>>2]|0,32)|0;p=Qa(s|0,y|0,d|0,p|0)|0;r=Ta(p|0,y|0,h|0,r|0)|0;h=y;p=Ra(0,c[n>>2]|0,32)|0;d=y;s=Ra(0,c[i>>2]|0,32)|0;d=Qa(s|0,y|0,p|0,d|0)|0;d=Ta(r|0,h|0,d|0,y|0)|0;h=y;r=Ra(0,c[f>>2]|0,32)|0;p=y;s=Ra(0,c[o>>2]|0,32)|0;p=Qa(s|0,y|0,r|0,p|0)|0;p=Ta(d|0,h|0,p|0,y|0)|0;h=y;l=Ra(0,c[l>>2]|0,32)|0;d=y;r=Ra(0,c[e>>2]|0,32)|0;d=Qa(r|0,y|0,l|0,d|0)|0;d=Ta(p|0,h|0,d|0,y|0)|0;h=y;p=Ra(0,c[b>>2]|0,32)|0;l=y;q=Ra(0,c[q>>2]|0,32)|0;l=Qa(q|0,y|0,p|0,l|0)|0;l=Ta(d|0,h|0,l|0,y|0)|0;h=a+104|0;c[h>>2]=l;c[h+4>>2]=y;h=Ra(0,c[g>>2]|0,32)|0;l=y;d=Ra(0,c[m>>2]|0,32)|0;l=Qa(d|0,y|0,h|0,l|0)|0;h=y;d=Ra(0,c[n>>2]|0,32)|0;n=y;p=Ra(0,c[e>>2]|0,32)|0;n=Qa(p|0,y|0,d|0,n|0)|0;h=Ta(n|0,y|0,l|0,h|0)|0;l=y;n=Ra(0,c[b>>2]|0,32)|0;d=y;o=Ra(0,c[o>>2]|0,32)|0;d=Qa(o|0,y|0,n|0,d|0)|0;d=Ta(h|0,l|0,d|0,y|0)|0;d=Sa(d|0,y|0,1)|0;l=y;h=Ra(0,c[j>>2]|0,32)|0;n=y;o=Ra(0,c[i>>2]|0,32)|0;n=Qa(o|0,y|0,h|0,n|0)|0;n=Ta(d|0,l|0,n|0,y|0)|0;l=y;d=Ra(0,c[f>>2]|0,32)|0;h=y;o=Ra(0,c[k>>2]|0,32)|0;h=Qa(o|0,y|0,d|0,h|0)|0;h=Ta(n|0,l|0,h|0,y|0)|0;l=a+112|0;c[l>>2]=h;c[l+4>>2]=y;l=Ra(0,c[g>>2]|0,32)|0;h=y;n=Ra(0,c[i>>2]|0,32)|0;h=Qa(n|0,y|0,l|0,h|0)|0;l=y;n=Ra(0,c[f>>2]|0,32)|0;d=y;o=Ra(0,c[m>>2]|0,32)|0;d=Qa(o|0,y|0,n|0,d|0)|0;l=Ta(d|0,y|0,h|0,l|0)|0;h=y;d=Ra(0,c[j>>2]|0,32)|0;j=y;n=Ra(0,c[e>>2]|0,32)|0;j=Qa(n|0,y|0,d|0,j|0)|0;j=Ta(l|0,h|0,j|0,y|0)|0;h=y;l=Ra(0,c[b>>2]|0,32)|0;d=y;k=Ra(0,c[k>>2]|0,32)|0;d=Qa(k|0,y|0,l|0,d|0)|0;d=Ta(j|0,h|0,d|0,y|0)|0;h=a+120|0;c[h>>2]=d;c[h+4>>2]=y;h=Ra(0,c[f>>2]|0,32)|0;d=y;j=Ra(0,c[i>>2]|0,32)|0;d=Qa(j|0,y|0,h|0,d|0)|0;h=y;g=Ra(0,c[g>>2]|0,32)|0;j=y;l=Ra(0,c[e>>2]|0,32)|0;j=Qa(l|0,y|0,g|0,j|0)|0;g=y;l=Ra(0,c[b>>2]|0,32)|0;k=y;m=Ra(0,c[m>>2]|0,32)|0;k=Qa(m|0,y|0,l|0,k|0)|0;g=Ta(k|0,y|0,j|0,g|0)|0;g=Sa(g|0,y|0,1)|0;h=Ta(g|0,y|0,d|0,h|0)|0;d=a+128|0;c[d>>2]=h;c[d+4>>2]=y;f=Ra(0,c[f>>2]|0,32)|0;d=y;h=Ra(0,c[e>>2]|0,32)|0;d=Qa(h|0,y|0,f|0,d|0)|0;f=y;h=Ra(0,c[b>>2]|0,32)|0;g=y;i=Ra(0,c[i>>2]|0,32)|0;g=Qa(i|0,y|0,h|0,g|0)|0;f=Ta(g|0,y|0,d|0,f|0)|0;d=a+136|0;c[d>>2]=f;c[d+4>>2]=y;d=Ra(0,c[b>>2]|0,31)|0;b=y;e=Ra(0,c[e>>2]|0,32)|0;b=Qa(e|0,y|0,d|0,b|0)|0;d=a+144|0;c[d>>2]=b;c[d+4>>2]=y;return}function ua(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;f=a+80|0;d=f;c[d>>2]=0;c[d+4>>2]=0;d=a;e=c[d>>2]|0;d=c[d+4>>2]|0;i=Ta(d>>31>>>6|0,0,e|0,d|0)|0;i=Ra(i|0,y|0,26)|0;g=y;b=Sa(i|0,g|0,26)|0;b=Ua(e|0,d|0,b|0,y|0)|0;d=a;c[d>>2]=b;c[d+4>>2]=y;d=a+8|0;b=d;b=Ta(i|0,g|0,c[b>>2]|0,c[b+4>>2]|0)|0;g=y;i=Ta(g>>31>>>7|0,0,b|0,g|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(b|0,g|0,j|0,y|0)|0;g=d;c[g>>2]=j;c[g+4>>2]=y;g=a+16|0;j=g;j=Ta(i|0,e|0,c[j>>2]|0,c[j+4>>2]|0)|0;e=y;i=Ta(e>>31>>>6|0,0,j|0,e|0)|0;i=Ra(i|0,y|0,26)|0;b=y;h=Sa(i|0,b|0,26)|0;h=Ua(j|0,e|0,h|0,y|0)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+24|0;h=g;h=Ta(i|0,b|0,c[h>>2]|0,c[h+4>>2]|0)|0;b=y;i=Ta(b>>31>>>7|0,0,h|0,b|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(h|0,b|0,j|0,y|0)|0;c[g>>2]=j;c[g+4>>2]=y;g=a+32|0;j=g;j=Ta(i|0,e|0,c[j>>2]|0,c[j+4>>2]|0)|0;e=y;i=Ta(e>>31>>>6|0,0,j|0,e|0)|0;i=Ra(i|0,y|0,26)|0;b=y;h=Sa(i|0,b|0,26)|0;h=Ua(j|0,e|0,h|0,y|0)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+40|0;h=g;h=Ta(i|0,b|0,c[h>>2]|0,c[h+4>>2]|0)|0;b=y;i=Ta(b>>31>>>7|0,0,h|0,b|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(h|0,b|0,j|0,y|0)|0;c[g>>2]=j;c[g+4>>2]=y;g=a+48|0;j=g;j=Ta(i|0,e|0,c[j>>2]|0,c[j+4>>2]|0)|0;e=y;i=Ta(e>>31>>>6|0,0,j|0,e|0)|0;i=Ra(i|0,y|0,26)|0;b=y;h=Sa(i|0,b|0,26)|0;h=Ua(j|0,e|0,h|0,y|0)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+56|0;h=g;h=Ta(i|0,b|0,c[h>>2]|0,c[h+4>>2]|0)|0;b=y;i=Ta(b>>31>>>7|0,0,h|0,b|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(h|0,b|0,j|0,y|0)|0;c[g>>2]=j;c[g+4>>2]=y;g=a+64|0;j=g;j=Ta(i|0,e|0,c[j>>2]|0,c[j+4>>2]|0)|0;e=y;i=Ta(e>>31>>>6|0,0,j|0,e|0)|0;i=Ra(i|0,y|0,26)|0;b=y;h=Sa(i|0,b|0,26)|0;h=Ua(j|0,e|0,h|0,y|0)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+72|0;h=g;h=Ta(i|0,b|0,c[h>>2]|0,c[h+4>>2]|0)|0;b=y;i=Ta(b>>31>>>7|0,0,h|0,b|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(h|0,b|0,j|0,y|0)|0;c[g>>2]=j;c[g+4>>2]=y;g=f;g=Ta(i|0,e|0,c[g>>2]|0,c[g+4>>2]|0)|0;e=y;i=a;j=c[i>>2]|0;i=c[i+4>>2]|0;b=Qa(g|0,e|0,18,0)|0;h=y;e=Ta(j|0,i|0,g|0,e|0)|0;h=Ta(e|0,y|0,b|0,h|0)|0;b=y;c[f>>2]=0;c[f+4>>2]=0;f=Ta(b>>31>>>6|0,0,h|0,b|0)|0;f=Ra(f|0,y|0,26)|0;e=y;g=Sa(f|0,e|0,26)|0;g=Ua(h|0,b|0,g|0,y|0)|0;b=a;c[b>>2]=g;c[b+4>>2]=y;b=d;b=Ta(f|0,e|0,c[b>>2]|0,c[b+4>>2]|0)|0;a=d;c[a>>2]=b;c[a+4>>2]=y;return}function va(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0;e=l;l=l+160|0;d=e;u=c[b>>2]|0;R=Ra(0,u|0,32)|0;N=y;A=Qa(R|0,N|0,R|0,N|0)|0;E=d;c[E>>2]=A;c[E+4>>2]=y;u=Ra(0,u|0,31)|0;E=y;A=b+8|0;F=c[A>>2]|0;g=Ra(0,F|0,32)|0;x=y;z=Qa(g|0,x|0,u|0,E|0)|0;h=d+8|0;k=h;c[k>>2]=z;c[k+4>>2]=y;k=Qa(g|0,x|0,g|0,x|0)|0;z=y;i=b+16|0;f=Ra(0,c[i>>2]|0,32)|0;H=y;q=Qa(f|0,H|0,R|0,N|0)|0;z=Ta(q|0,y|0,k|0,z|0)|0;z=Sa(z|0,y|0,1)|0;k=d+16|0;q=k;c[q>>2]=z;c[q+4>>2]=y;q=Qa(f|0,H|0,g|0,x|0)|0;z=y;G=b+24|0;P=Ra(0,c[G>>2]|0,32)|0;Q=y;t=Qa(P|0,Q|0,R|0,N|0)|0;z=Ta(t|0,y|0,q|0,z|0)|0;z=Sa(z|0,y|0,1)|0;q=d+24|0;t=q;c[t>>2]=z;c[t+4>>2]=y;t=Qa(f|0,H|0,f|0,H|0)|0;z=y;m=Ra(0,F|0,30)|0;m=Qa(P|0,Q|0,m|0,y|0)|0;z=Ta(m|0,y|0,t|0,z|0)|0;t=y;m=b+32|0;D=Ra(0,c[m>>2]|0,32)|0;r=y;E=Qa(D|0,r|0,u|0,E|0)|0;E=Ta(z|0,t|0,E|0,y|0)|0;t=d+32|0;z=t;c[z>>2]=E;c[z+4>>2]=y;z=Qa(P|0,Q|0,f|0,H|0)|0;E=y;u=Qa(D|0,r|0,g|0,x|0)|0;E=Ta(u|0,y|0,z|0,E|0)|0;z=y;u=b+40|0;v=Ra(0,c[u>>2]|0,32)|0;j=y;M=Qa(v|0,j|0,R|0,N|0)|0;M=Ta(E|0,z|0,M|0,y|0)|0;M=Sa(M|0,y|0,1)|0;z=d+40|0;E=z;c[E>>2]=M;c[E+4>>2]=y;E=Qa(P|0,Q|0,P|0,Q|0)|0;M=y;C=Qa(D|0,r|0,f|0,H|0)|0;M=Ta(C|0,y|0,E|0,M|0)|0;E=y;C=b+48|0;p=Ra(0,c[C>>2]|0,32)|0;o=y;J=Qa(p|0,o|0,R|0,N|0)|0;J=Ta(M|0,E|0,J|0,y|0)|0;E=y;F=Ra(0,F|0,31)|0;F=Qa(v|0,j|0,F|0,y|0)|0;F=Ta(J|0,E|0,F|0,y|0)|0;F=Sa(F|0,y|0,1)|0;E=d+48|0;J=E;c[J>>2]=F;c[J+4>>2]=y;J=Qa(D|0,r|0,P|0,Q|0)|0;F=y;M=Qa(v|0,j|0,f|0,H|0)|0;F=Ta(M|0,y|0,J|0,F|0)|0;J=y;M=Qa(p|0,o|0,g|0,x|0)|0;M=Ta(F|0,J|0,M|0,y|0)|0;J=y;F=b+56|0;s=Ra(0,c[F>>2]|0,32)|0;n=y;B=Qa(s|0,n|0,R|0,N|0)|0;B=Ta(M|0,J|0,B|0,y|0)|0;B=Sa(B|0,y|0,1)|0;J=d+56|0;M=J;c[M>>2]=B;c[M+4>>2]=y;M=Qa(D|0,r|0,D|0,r|0)|0;B=y;K=Qa(p|0,o|0,f|0,H|0)|0;O=y;L=b+64|0;I=Ra(0,c[L>>2]|0,32)|0;w=y;N=Qa(I|0,w|0,R|0,N|0)|0;O=Ta(N|0,y|0,K|0,O|0)|0;K=y;x=Qa(s|0,n|0,g|0,x|0)|0;g=y;N=Qa(v|0,j|0,P|0,Q|0)|0;g=Ta(N|0,y|0,x|0,g|0)|0;g=Sa(g|0,y|0,1)|0;g=Ta(O|0,K|0,g|0,y|0)|0;g=Sa(g|0,y|0,1)|0;B=Ta(g|0,y|0,M|0,B|0)|0;M=d+64|0;g=M;c[g>>2]=B;c[g+4>>2]=y;g=Qa(v|0,j|0,D|0,r|0)|0;B=y;Q=Qa(p|0,o|0,P|0,Q|0)|0;B=Ta(Q|0,y|0,g|0,B|0)|0;g=y;H=Qa(s|0,n|0,f|0,H|0)|0;H=Ta(B|0,g|0,H|0,y|0)|0;g=y;A=Ra(0,c[A>>2]|0,32)|0;B=y;f=Qa(I|0,w|0,A|0,B|0)|0;f=Ta(H|0,g|0,f|0,y|0)|0;g=y;H=Ra(0,c[b>>2]|0,32)|0;Q=y;P=c[b+72>>2]|0;K=Ra(0,P|0,32)|0;O=y;Q=Qa(K|0,O|0,H|0,Q|0)|0;Q=Ta(f|0,g|0,Q|0,y|0)|0;Q=Sa(Q|0,y|0,1)|0;g=d+72|0;c[g>>2]=Q;c[g+4>>2]=y;g=Qa(v|0,j|0,v|0,j|0)|0;Q=y;b=Qa(p|0,o|0,D|0,r|0)|0;Q=Ta(b|0,y|0,g|0,Q|0)|0;g=y;b=Ra(0,c[i>>2]|0,32)|0;i=y;r=Qa(I|0,w|0,b|0,i|0)|0;r=Ta(Q|0,g|0,r|0,y|0)|0;g=y;G=Ra(0,c[G>>2]|0,32)|0;Q=y;D=Qa(s|0,n|0,G|0,Q|0)|0;f=y;B=Qa(K|0,O|0,A|0,B|0)|0;f=Ta(B|0,y|0,D|0,f|0)|0;f=Sa(f|0,y|0,1)|0;f=Ta(r|0,g|0,f|0,y|0)|0;f=Sa(f|0,y|0,1)|0;g=d+80|0;r=g;c[r>>2]=f;c[r+4>>2]=y;j=Qa(p|0,o|0,v|0,j|0)|0;v=y;m=Ra(0,c[m>>2]|0,32)|0;r=y;f=Qa(s|0,n|0,m|0,r|0)|0;v=Ta(f|0,y|0,j|0,v|0)|0;j=y;f=Qa(I|0,w|0,G|0,Q|0)|0;f=Ta(v|0,j|0,f|0,y|0)|0;j=y;i=Qa(K|0,O|0,b|0,i|0)|0;i=Ta(f|0,j|0,i|0,y|0)|0;j=y;f=Sa(i|0,j|0,1)|0;b=y;v=d+88|0;c[v>>2]=f;c[v+4>>2]=b;o=Qa(p|0,o|0,p|0,o|0)|0;p=y;v=Qa(I|0,w|0,m|0,r|0)|0;D=y;u=c[u>>2]|0;B=Ra(0,u|0,32)|0;A=y;H=Qa(s|0,n|0,B|0,A|0)|0;x=y;Q=Qa(K|0,O|0,G|0,Q|0)|0;x=Ta(Q|0,y|0,H|0,x|0)|0;x=Sa(x|0,y|0,1)|0;D=Ta(x|0,y|0,v|0,D|0)|0;D=Sa(D|0,y|0,1)|0;p=Ta(D|0,y|0,o|0,p|0)|0;o=y;D=d+96|0;c[D>>2]=p;c[D+4>>2]=o;C=Ra(0,c[C>>2]|0,32)|0;D=y;n=Qa(s|0,n|0,C|0,D|0)|0;s=y;A=Qa(I|0,w|0,B|0,A|0)|0;s=Ta(A|0,y|0,n|0,s|0)|0;n=y;r=Qa(K|0,O|0,m|0,r|0)|0;r=Ta(s|0,n|0,r|0,y|0)|0;n=y;s=Sa(r|0,n|0,1)|0;m=y;A=d+104|0;c[A>>2]=s;c[A+4>>2]=m;F=c[F>>2]|0;A=Ra(0,F|0,32)|0;B=y;v=Qa(A|0,B|0,A|0,B|0)|0;x=y;w=Qa(I|0,w|0,C|0,D|0)|0;x=Ta(w|0,y|0,v|0,x|0)|0;v=y;u=Ra(0,u|0,31)|0;u=Qa(K|0,O|0,u|0,y|0)|0;u=Ta(x|0,v|0,u|0,y|0)|0;v=y;x=Sa(u|0,v|0,1)|0;w=y;I=d+112|0;c[I>>2]=x;c[I+4>>2]=w;L=c[L>>2]|0;I=Ra(0,L|0,32)|0;H=y;B=Qa(I|0,H|0,A|0,B|0)|0;A=y;D=Qa(K|0,O|0,C|0,D|0)|0;A=Ta(D|0,y|0,B|0,A|0)|0;B=y;D=Sa(A|0,B|0,1)|0;C=y;Q=d+120|0;c[Q>>2]=D;c[Q+4>>2]=C;H=Qa(I|0,H|0,I|0,H|0)|0;I=y;F=Ra(0,F|0,30)|0;F=Qa(K|0,O|0,F|0,y|0)|0;I=Ta(F|0,y|0,H|0,I|0)|0;H=y;F=d+128|0;c[F>>2]=I;c[F+4>>2]=H;L=Ra(0,L|0,31)|0;L=Qa(K|0,O|0,L|0,y|0)|0;F=y;Q=d+136|0;c[Q>>2]=L;c[Q+4>>2]=F;P=Ra(0,P|0,31)|0;O=Qa(P|0,y|0,K|0,O|0)|0;K=y;P=d+144|0;c[P>>2]=O;c[P+4>>2]=K;P=M;Q=c[P>>2]|0;P=c[P+4>>2]|0;G=Qa(O|0,K|0,18,0)|0;N=y;K=Ta(Q|0,P|0,O|0,K|0)|0;N=Ta(K|0,y|0,G|0,N|0)|0;c[M>>2]=N;c[M+4>>2]=y;M=J;N=c[M>>2]|0;M=c[M+4>>2]|0;G=Qa(L|0,F|0,18,0)|0;K=y;F=Ta(N|0,M|0,L|0,F|0)|0;K=Ta(F|0,y|0,G|0,K|0)|0;c[J>>2]=K;c[J+4>>2]=y;J=E;K=c[J>>2]|0;J=c[J+4>>2]|0;G=Qa(I|0,H|0,18,0)|0;F=y;H=Ta(K|0,J|0,I|0,H|0)|0;F=Ta(H|0,y|0,G|0,F|0)|0;c[E>>2]=F;c[E+4>>2]=y;E=z;F=c[E>>2]|0;E=c[E+4>>2]|0;B=Qa(A|0,B|0,36,0)|0;A=y;C=Ta(F|0,E|0,D|0,C|0)|0;A=Ta(C|0,y|0,B|0,A|0)|0;c[z>>2]=A;c[z+4>>2]=y;z=t;A=c[z>>2]|0;z=c[z+4>>2]|0;v=Qa(u|0,v|0,36,0)|0;u=y;w=Ta(A|0,z|0,x|0,w|0)|0;u=Ta(w|0,y|0,v|0,u|0)|0;c[t>>2]=u;c[t+4>>2]=y;t=q;u=c[t>>2]|0;t=c[t+4>>2]|0;n=Qa(r|0,n|0,36,0)|0;r=y;m=Ta(u|0,t|0,s|0,m|0)|0;r=Ta(m|0,y|0,n|0,r|0)|0;c[q>>2]=r;c[q+4>>2]=y;q=k;r=c[q>>2]|0;q=c[q+4>>2]|0;n=Qa(p|0,o|0,18,0)|0;m=y;o=Ta(r|0,q|0,p|0,o|0)|0;m=Ta(o|0,y|0,n|0,m|0)|0;c[k>>2]=m;c[k+4>>2]=y;k=h;m=c[k>>2]|0;k=c[k+4>>2]|0;j=Qa(i|0,j|0,36,0)|0;i=y;b=Ta(m|0,k|0,f|0,b|0)|0;i=Ta(b|0,y|0,j|0,i|0)|0;c[h>>2]=i;c[h+4>>2]=y;h=c[g>>2]|0;g=c[g+4>>2]|0;i=d;j=c[i>>2]|0;i=c[i+4>>2]|0;b=Qa(h|0,g|0,18,0)|0;f=y;g=Ta(j|0,i|0,h|0,g|0)|0;f=Ta(g|0,y|0,b|0,f|0)|0;b=d;c[b>>2]=f;c[b+4>>2]=y;ua(d);b=d;d=a+80|0;do{c[a>>2]=c[b>>2];a=a+4|0;b=b+4|0}while((a|0)<(d|0));l=e;return}function wa(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;x=l;l=l+16|0;o=x;do if(a>>>0<245){k=a>>>0<11?16:a+11&-8;a=k>>>3;n=c[146]|0;d=n>>>a;if(d&3|0){b=(d&1^1)+a|0;a=624+(b<<1<<2)|0;d=a+8|0;e=c[d>>2]|0;f=e+8|0;g=c[f>>2]|0;if((a|0)==(g|0))c[146]=n&~(1<<b);else{c[g+12>>2]=a;c[d>>2]=g}w=b<<3;c[e+4>>2]=w|3;w=e+w+4|0;c[w>>2]=c[w>>2]|1;w=f;l=x;return w|0}m=c[148]|0;if(k>>>0>m>>>0){if(d|0){b=2<<a;b=d<<a&(b|0-b);b=(b&0-b)+-1|0;h=b>>>12&16;b=b>>>h;d=b>>>5&8;b=b>>>d;f=b>>>2&4;b=b>>>f;a=b>>>1&2;b=b>>>a;e=b>>>1&1;e=(d|h|f|a|e)+(b>>>e)|0;b=624+(e<<1<<2)|0;a=b+8|0;f=c[a>>2]|0;h=f+8|0;d=c[h>>2]|0;if((b|0)==(d|0)){a=n&~(1<<e);c[146]=a}else{c[d+12>>2]=b;c[a>>2]=d;a=n}g=(e<<3)-k|0;c[f+4>>2]=k|3;e=f+k|0;c[e+4>>2]=g|1;c[e+g>>2]=g;if(m|0){f=c[151]|0;b=m>>>3;d=624+(b<<1<<2)|0;b=1<<b;if(!(a&b)){c[146]=a|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=f;c[b+12>>2]=f;c[f+8>>2]=b;c[f+12>>2]=d}c[148]=g;c[151]=e;w=h;l=x;return w|0}i=c[147]|0;if(i){d=(i&0-i)+-1|0;h=d>>>12&16;d=d>>>h;g=d>>>5&8;d=d>>>g;j=d>>>2&4;d=d>>>j;e=d>>>1&2;d=d>>>e;a=d>>>1&1;a=c[888+((g|h|j|e|a)+(d>>>a)<<2)>>2]|0;d=(c[a+4>>2]&-8)-k|0;e=c[a+16+(((c[a+16>>2]|0)==0&1)<<2)>>2]|0;if(!e){j=a;g=d}else{do{h=(c[e+4>>2]&-8)-k|0;j=h>>>0<d>>>0;d=j?h:d;a=j?e:a;e=c[e+16+(((c[e+16>>2]|0)==0&1)<<2)>>2]|0}while((e|0)!=0);j=a;g=d}h=j+k|0;if(j>>>0<h>>>0){f=c[j+24>>2]|0;b=c[j+12>>2]|0;do if((b|0)==(j|0)){a=j+20|0;b=c[a>>2]|0;if(!b){a=j+16|0;b=c[a>>2]|0;if(!b){d=0;break}}while(1){d=b+20|0;e=c[d>>2]|0;if(e|0){b=e;a=d;continue}d=b+16|0;e=c[d>>2]|0;if(!e)break;else{b=e;a=d}}c[a>>2]=0;d=b}else{d=c[j+8>>2]|0;c[d+12>>2]=b;c[b+8>>2]=d;d=b}while(0);do if(f|0){b=c[j+28>>2]|0;a=888+(b<<2)|0;if((j|0)==(c[a>>2]|0)){c[a>>2]=d;if(!d){c[147]=i&~(1<<b);break}}else{c[f+16+(((c[f+16>>2]|0)!=(j|0)&1)<<2)>>2]=d;if(!d)break}c[d+24>>2]=f;b=c[j+16>>2]|0;if(b|0){c[d+16>>2]=b;c[b+24>>2]=d}b=c[j+20>>2]|0;if(b|0){c[d+20>>2]=b;c[b+24>>2]=d}}while(0);if(g>>>0<16){w=g+k|0;c[j+4>>2]=w|3;w=j+w+4|0;c[w>>2]=c[w>>2]|1}else{c[j+4>>2]=k|3;c[h+4>>2]=g|1;c[h+g>>2]=g;if(m|0){e=c[151]|0;b=m>>>3;d=624+(b<<1<<2)|0;b=1<<b;if(!(n&b)){c[146]=n|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=e;c[b+12>>2]=e;c[e+8>>2]=b;c[e+12>>2]=d}c[148]=g;c[151]=h}w=j+8|0;l=x;return w|0}else n=k}else n=k}else n=k}else if(a>>>0<=4294967231){a=a+11|0;k=a&-8;j=c[147]|0;if(j){e=0-k|0;a=a>>>8;if(a)if(k>>>0>16777215)i=31;else{n=(a+1048320|0)>>>16&8;v=a<<n;m=(v+520192|0)>>>16&4;v=v<<m;i=(v+245760|0)>>>16&2;i=14-(m|n|i)+(v<<i>>>15)|0;i=k>>>(i+7|0)&1|i<<1}else i=0;d=c[888+(i<<2)>>2]|0;a:do if(!d){d=0;a=0;v=57}else{a=0;h=k<<((i|0)==31?0:25-(i>>>1)|0);g=0;while(1){f=(c[d+4>>2]&-8)-k|0;if(f>>>0<e>>>0)if(!f){a=d;e=0;f=d;v=61;break a}else{a=d;e=f}f=c[d+20>>2]|0;d=c[d+16+(h>>>31<<2)>>2]|0;g=(f|0)==0|(f|0)==(d|0)?g:f;f=(d|0)==0;if(f){d=g;v=57;break}else h=h<<((f^1)&1)}}while(0);if((v|0)==57){if((d|0)==0&(a|0)==0){a=2<<i;a=j&(a|0-a);if(!a){n=k;break}n=(a&0-a)+-1|0;h=n>>>12&16;n=n>>>h;g=n>>>5&8;n=n>>>g;i=n>>>2&4;n=n>>>i;m=n>>>1&2;n=n>>>m;d=n>>>1&1;a=0;d=c[888+((g|h|i|m|d)+(n>>>d)<<2)>>2]|0}if(!d){i=a;h=e}else{f=d;v=61}}if((v|0)==61)while(1){v=0;d=(c[f+4>>2]&-8)-k|0;n=d>>>0<e>>>0;d=n?d:e;a=n?f:a;f=c[f+16+(((c[f+16>>2]|0)==0&1)<<2)>>2]|0;if(!f){i=a;h=d;break}else{e=d;v=61}}if((i|0)!=0?h>>>0<((c[148]|0)-k|0)>>>0:0){g=i+k|0;if(i>>>0>=g>>>0){w=0;l=x;return w|0}f=c[i+24>>2]|0;b=c[i+12>>2]|0;do if((b|0)==(i|0)){a=i+20|0;b=c[a>>2]|0;if(!b){a=i+16|0;b=c[a>>2]|0;if(!b){b=0;break}}while(1){d=b+20|0;e=c[d>>2]|0;if(e|0){b=e;a=d;continue}d=b+16|0;e=c[d>>2]|0;if(!e)break;else{b=e;a=d}}c[a>>2]=0}else{w=c[i+8>>2]|0;c[w+12>>2]=b;c[b+8>>2]=w}while(0);do if(f){a=c[i+28>>2]|0;d=888+(a<<2)|0;if((i|0)==(c[d>>2]|0)){c[d>>2]=b;if(!b){e=j&~(1<<a);c[147]=e;break}}else{c[f+16+(((c[f+16>>2]|0)!=(i|0)&1)<<2)>>2]=b;if(!b){e=j;break}}c[b+24>>2]=f;a=c[i+16>>2]|0;if(a|0){c[b+16>>2]=a;c[a+24>>2]=b}a=c[i+20>>2]|0;if(a){c[b+20>>2]=a;c[a+24>>2]=b;e=j}else e=j}else e=j;while(0);do if(h>>>0>=16){c[i+4>>2]=k|3;c[g+4>>2]=h|1;c[g+h>>2]=h;b=h>>>3;if(h>>>0<256){d=624+(b<<1<<2)|0;a=c[146]|0;b=1<<b;if(!(a&b)){c[146]=a|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=g;c[b+12>>2]=g;c[g+8>>2]=b;c[g+12>>2]=d;break}b=h>>>8;if(b)if(h>>>0>16777215)b=31;else{v=(b+1048320|0)>>>16&8;w=b<<v;u=(w+520192|0)>>>16&4;w=w<<u;b=(w+245760|0)>>>16&2;b=14-(u|v|b)+(w<<b>>>15)|0;b=h>>>(b+7|0)&1|b<<1}else b=0;d=888+(b<<2)|0;c[g+28>>2]=b;a=g+16|0;c[a+4>>2]=0;c[a>>2]=0;a=1<<b;if(!(e&a)){c[147]=e|a;c[d>>2]=g;c[g+24>>2]=d;c[g+12>>2]=g;c[g+8>>2]=g;break}a=h<<((b|0)==31?0:25-(b>>>1)|0);d=c[d>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(h|0)){v=97;break}e=d+16+(a>>>31<<2)|0;b=c[e>>2]|0;if(!b){v=96;break}else{a=a<<1;d=b}}if((v|0)==96){c[e>>2]=g;c[g+24>>2]=d;c[g+12>>2]=g;c[g+8>>2]=g;break}else if((v|0)==97){v=d+8|0;w=c[v>>2]|0;c[w+12>>2]=g;c[v>>2]=g;c[g+8>>2]=w;c[g+12>>2]=d;c[g+24>>2]=0;break}}else{w=h+k|0;c[i+4>>2]=w|3;w=i+w+4|0;c[w>>2]=c[w>>2]|1}while(0);w=i+8|0;l=x;return w|0}else n=k}else n=k}else n=-1;while(0);d=c[148]|0;if(d>>>0>=n>>>0){b=d-n|0;a=c[151]|0;if(b>>>0>15){w=a+n|0;c[151]=w;c[148]=b;c[w+4>>2]=b|1;c[w+b>>2]=b;c[a+4>>2]=n|3}else{c[148]=0;c[151]=0;c[a+4>>2]=d|3;w=a+d+4|0;c[w>>2]=c[w>>2]|1}w=a+8|0;l=x;return w|0}h=c[149]|0;if(h>>>0>n>>>0){u=h-n|0;c[149]=u;w=c[152]|0;v=w+n|0;c[152]=v;c[v+4>>2]=u|1;c[w+4>>2]=n|3;w=w+8|0;l=x;return w|0}if(!(c[264]|0)){c[266]=4096;c[265]=4096;c[267]=-1;c[268]=-1;c[269]=0;c[257]=0;a=o&-16^1431655768;c[o>>2]=a;c[264]=a;a=4096}else a=c[266]|0;i=n+48|0;j=n+47|0;g=a+j|0;f=0-a|0;k=g&f;if(k>>>0<=n>>>0){w=0;l=x;return w|0}a=c[256]|0;if(a|0?(m=c[254]|0,o=m+k|0,o>>>0<=m>>>0|o>>>0>a>>>0):0){w=0;l=x;return w|0}b:do if(!(c[257]&4)){d=c[152]|0;c:do if(d){e=1032;while(1){a=c[e>>2]|0;if(a>>>0<=d>>>0?(r=e+4|0,(a+(c[r>>2]|0)|0)>>>0>d>>>0):0)break;a=c[e+8>>2]|0;if(!a){v=118;break c}else e=a}b=g-h&f;if(b>>>0<2147483647){a=Xa(b|0)|0;if((a|0)==((c[e>>2]|0)+(c[r>>2]|0)|0)){if((a|0)!=(-1|0)){h=b;g=a;v=135;break b}}else{e=a;v=126}}else b=0}else v=118;while(0);do if((v|0)==118){d=Xa(0)|0;if((d|0)!=(-1|0)?(b=d,p=c[265]|0,q=p+-1|0,b=((q&b|0)==0?0:(q+b&0-p)-b|0)+k|0,p=c[254]|0,q=b+p|0,b>>>0>n>>>0&b>>>0<2147483647):0){r=c[256]|0;if(r|0?q>>>0<=p>>>0|q>>>0>r>>>0:0){b=0;break}a=Xa(b|0)|0;if((a|0)==(d|0)){h=b;g=d;v=135;break b}else{e=a;v=126}}else b=0}while(0);do if((v|0)==126){d=0-b|0;if(!(i>>>0>b>>>0&(b>>>0<2147483647&(e|0)!=(-1|0))))if((e|0)==(-1|0)){b=0;break}else{h=b;g=e;v=135;break b}a=c[266]|0;a=j-b+a&0-a;if(a>>>0>=2147483647){h=b;g=e;v=135;break b}if((Xa(a|0)|0)==(-1|0)){Xa(d|0)|0;b=0;break}else{h=a+b|0;g=e;v=135;break b}}while(0);c[257]=c[257]|4;v=133}else{b=0;v=133}while(0);if(((v|0)==133?k>>>0<2147483647:0)?(u=Xa(k|0)|0,r=Xa(0)|0,s=r-u|0,t=s>>>0>(n+40|0)>>>0,!((u|0)==(-1|0)|t^1|u>>>0<r>>>0&((u|0)!=(-1|0)&(r|0)!=(-1|0))^1)):0){h=t?s:b;g=u;v=135}if((v|0)==135){b=(c[254]|0)+h|0;c[254]=b;if(b>>>0>(c[255]|0)>>>0)c[255]=b;j=c[152]|0;do if(j){b=1032;while(1){a=c[b>>2]|0;d=b+4|0;e=c[d>>2]|0;if((g|0)==(a+e|0)){v=145;break}f=c[b+8>>2]|0;if(!f)break;else b=f}if(((v|0)==145?(c[b+12>>2]&8|0)==0:0)?j>>>0<g>>>0&j>>>0>=a>>>0:0){c[d>>2]=e+h;w=j+8|0;w=(w&7|0)==0?0:0-w&7;v=j+w|0;w=(c[149]|0)+(h-w)|0;c[152]=v;c[149]=w;c[v+4>>2]=w|1;c[v+w+4>>2]=40;c[153]=c[268];break}if(g>>>0<(c[150]|0)>>>0)c[150]=g;d=g+h|0;b=1032;while(1){if((c[b>>2]|0)==(d|0)){v=153;break}a=c[b+8>>2]|0;if(!a)break;else b=a}if((v|0)==153?(c[b+12>>2]&8|0)==0:0){c[b>>2]=g;m=b+4|0;c[m>>2]=(c[m>>2]|0)+h;m=g+8|0;m=g+((m&7|0)==0?0:0-m&7)|0;b=d+8|0;b=d+((b&7|0)==0?0:0-b&7)|0;k=m+n|0;i=b-m-n|0;c[m+4>>2]=n|3;do if((b|0)!=(j|0)){if((b|0)==(c[151]|0)){w=(c[148]|0)+i|0;c[148]=w;c[151]=k;c[k+4>>2]=w|1;c[k+w>>2]=w;break}a=c[b+4>>2]|0;if((a&3|0)==1){h=a&-8;e=a>>>3;d:do if(a>>>0<256){a=c[b+8>>2]|0;d=c[b+12>>2]|0;if((d|0)==(a|0)){c[146]=c[146]&~(1<<e);break}else{c[a+12>>2]=d;c[d+8>>2]=a;break}}else{g=c[b+24>>2]|0;a=c[b+12>>2]|0;do if((a|0)==(b|0)){e=b+16|0;d=e+4|0;a=c[d>>2]|0;if(!a){a=c[e>>2]|0;if(!a){a=0;break}else d=e}while(1){e=a+20|0;f=c[e>>2]|0;if(f|0){a=f;d=e;continue}e=a+16|0;f=c[e>>2]|0;if(!f)break;else{a=f;d=e}}c[d>>2]=0}else{w=c[b+8>>2]|0;c[w+12>>2]=a;c[a+8>>2]=w}while(0);if(!g)break;d=c[b+28>>2]|0;e=888+(d<<2)|0;do if((b|0)!=(c[e>>2]|0)){c[g+16+(((c[g+16>>2]|0)!=(b|0)&1)<<2)>>2]=a;if(!a)break d}else{c[e>>2]=a;if(a|0)break;c[147]=c[147]&~(1<<d);break d}while(0);c[a+24>>2]=g;d=b+16|0;e=c[d>>2]|0;if(e|0){c[a+16>>2]=e;c[e+24>>2]=a}d=c[d+4>>2]|0;if(!d)break;c[a+20>>2]=d;c[d+24>>2]=a}while(0);b=b+h|0;f=h+i|0}else f=i;b=b+4|0;c[b>>2]=c[b>>2]&-2;c[k+4>>2]=f|1;c[k+f>>2]=f;b=f>>>3;if(f>>>0<256){d=624+(b<<1<<2)|0;a=c[146]|0;b=1<<b;if(!(a&b)){c[146]=a|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=k;c[b+12>>2]=k;c[k+8>>2]=b;c[k+12>>2]=d;break}b=f>>>8;do if(!b)b=0;else{if(f>>>0>16777215){b=31;break}v=(b+1048320|0)>>>16&8;w=b<<v;u=(w+520192|0)>>>16&4;w=w<<u;b=(w+245760|0)>>>16&2;b=14-(u|v|b)+(w<<b>>>15)|0;b=f>>>(b+7|0)&1|b<<1}while(0);e=888+(b<<2)|0;c[k+28>>2]=b;a=k+16|0;c[a+4>>2]=0;c[a>>2]=0;a=c[147]|0;d=1<<b;if(!(a&d)){c[147]=a|d;c[e>>2]=k;c[k+24>>2]=e;c[k+12>>2]=k;c[k+8>>2]=k;break}a=f<<((b|0)==31?0:25-(b>>>1)|0);d=c[e>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(f|0)){v=194;break}e=d+16+(a>>>31<<2)|0;b=c[e>>2]|0;if(!b){v=193;break}else{a=a<<1;d=b}}if((v|0)==193){c[e>>2]=k;c[k+24>>2]=d;c[k+12>>2]=k;c[k+8>>2]=k;break}else if((v|0)==194){v=d+8|0;w=c[v>>2]|0;c[w+12>>2]=k;c[v>>2]=k;c[k+8>>2]=w;c[k+12>>2]=d;c[k+24>>2]=0;break}}else{w=(c[149]|0)+i|0;c[149]=w;c[152]=k;c[k+4>>2]=w|1}while(0);w=m+8|0;l=x;return w|0}b=1032;while(1){a=c[b>>2]|0;if(a>>>0<=j>>>0?(w=a+(c[b+4>>2]|0)|0,w>>>0>j>>>0):0)break;b=c[b+8>>2]|0}f=w+-47|0;a=f+8|0;a=f+((a&7|0)==0?0:0-a&7)|0;f=j+16|0;a=a>>>0<f>>>0?j:a;b=a+8|0;d=g+8|0;d=(d&7|0)==0?0:0-d&7;v=g+d|0;d=h+-40-d|0;c[152]=v;c[149]=d;c[v+4>>2]=d|1;c[v+d+4>>2]=40;c[153]=c[268];d=a+4|0;c[d>>2]=27;c[b>>2]=c[258];c[b+4>>2]=c[259];c[b+8>>2]=c[260];c[b+12>>2]=c[261];c[258]=g;c[259]=h;c[261]=0;c[260]=b;b=a+24|0;do{v=b;b=b+4|0;c[b>>2]=7}while((v+8|0)>>>0<w>>>0);if((a|0)!=(j|0)){g=a-j|0;c[d>>2]=c[d>>2]&-2;c[j+4>>2]=g|1;c[a>>2]=g;b=g>>>3;if(g>>>0<256){d=624+(b<<1<<2)|0;a=c[146]|0;b=1<<b;if(!(a&b)){c[146]=a|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=j;c[b+12>>2]=j;c[j+8>>2]=b;c[j+12>>2]=d;break}b=g>>>8;if(b)if(g>>>0>16777215)d=31;else{v=(b+1048320|0)>>>16&8;w=b<<v;u=(w+520192|0)>>>16&4;w=w<<u;d=(w+245760|0)>>>16&2;d=14-(u|v|d)+(w<<d>>>15)|0;d=g>>>(d+7|0)&1|d<<1}else d=0;e=888+(d<<2)|0;c[j+28>>2]=d;c[j+20>>2]=0;c[f>>2]=0;b=c[147]|0;a=1<<d;if(!(b&a)){c[147]=b|a;c[e>>2]=j;c[j+24>>2]=e;c[j+12>>2]=j;c[j+8>>2]=j;break}a=g<<((d|0)==31?0:25-(d>>>1)|0);d=c[e>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(g|0)){v=216;break}e=d+16+(a>>>31<<2)|0;b=c[e>>2]|0;if(!b){v=215;break}else{a=a<<1;d=b}}if((v|0)==215){c[e>>2]=j;c[j+24>>2]=d;c[j+12>>2]=j;c[j+8>>2]=j;break}else if((v|0)==216){v=d+8|0;w=c[v>>2]|0;c[w+12>>2]=j;c[v>>2]=j;c[j+8>>2]=w;c[j+12>>2]=d;c[j+24>>2]=0;break}}}else{w=c[150]|0;if((w|0)==0|g>>>0<w>>>0)c[150]=g;c[258]=g;c[259]=h;c[261]=0;c[155]=c[264];c[154]=-1;b=0;do{w=624+(b<<1<<2)|0;c[w+12>>2]=w;c[w+8>>2]=w;b=b+1|0}while((b|0)!=32);w=g+8|0;w=(w&7|0)==0?0:0-w&7;v=g+w|0;w=h+-40-w|0;c[152]=v;c[149]=w;c[v+4>>2]=w|1;c[v+w+4>>2]=40;c[153]=c[268]}while(0);b=c[149]|0;if(b>>>0>n>>>0){u=b-n|0;c[149]=u;w=c[152]|0;v=w+n|0;c[152]=v;c[v+4>>2]=u|1;c[w+4>>2]=n|3;w=w+8|0;l=x;return w|0}}c[(Ca()|0)>>2]=12;w=0;l=x;return w|0}function xa(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;if(!a)return;d=a+-8|0;f=c[150]|0;a=c[a+-4>>2]|0;b=a&-8;j=d+b|0;do if(!(a&1)){e=c[d>>2]|0;if(!(a&3))return;h=d+(0-e)|0;g=e+b|0;if(h>>>0<f>>>0)return;if((h|0)==(c[151]|0)){a=j+4|0;b=c[a>>2]|0;if((b&3|0)!=3){i=h;b=g;break}c[148]=g;c[a>>2]=b&-2;c[h+4>>2]=g|1;c[h+g>>2]=g;return}d=e>>>3;if(e>>>0<256){a=c[h+8>>2]|0;b=c[h+12>>2]|0;if((b|0)==(a|0)){c[146]=c[146]&~(1<<d);i=h;b=g;break}else{c[a+12>>2]=b;c[b+8>>2]=a;i=h;b=g;break}}f=c[h+24>>2]|0;a=c[h+12>>2]|0;do if((a|0)==(h|0)){d=h+16|0;b=d+4|0;a=c[b>>2]|0;if(!a){a=c[d>>2]|0;if(!a){a=0;break}else b=d}while(1){d=a+20|0;e=c[d>>2]|0;if(e|0){a=e;b=d;continue}d=a+16|0;e=c[d>>2]|0;if(!e)break;else{a=e;b=d}}c[b>>2]=0}else{i=c[h+8>>2]|0;c[i+12>>2]=a;c[a+8>>2]=i}while(0);if(f){b=c[h+28>>2]|0;d=888+(b<<2)|0;if((h|0)==(c[d>>2]|0)){c[d>>2]=a;if(!a){c[147]=c[147]&~(1<<b);i=h;b=g;break}}else{c[f+16+(((c[f+16>>2]|0)!=(h|0)&1)<<2)>>2]=a;if(!a){i=h;b=g;break}}c[a+24>>2]=f;b=h+16|0;d=c[b>>2]|0;if(d|0){c[a+16>>2]=d;c[d+24>>2]=a}b=c[b+4>>2]|0;if(b){c[a+20>>2]=b;c[b+24>>2]=a;i=h;b=g}else{i=h;b=g}}else{i=h;b=g}}else{i=d;h=d}while(0);if(h>>>0>=j>>>0)return;a=j+4|0;e=c[a>>2]|0;if(!(e&1))return;if(!(e&2)){a=c[151]|0;if((j|0)==(c[152]|0)){j=(c[149]|0)+b|0;c[149]=j;c[152]=i;c[i+4>>2]=j|1;if((i|0)!=(a|0))return;c[151]=0;c[148]=0;return}if((j|0)==(a|0)){j=(c[148]|0)+b|0;c[148]=j;c[151]=h;c[i+4>>2]=j|1;c[h+j>>2]=j;return}f=(e&-8)+b|0;d=e>>>3;do if(e>>>0<256){b=c[j+8>>2]|0;a=c[j+12>>2]|0;if((a|0)==(b|0)){c[146]=c[146]&~(1<<d);break}else{c[b+12>>2]=a;c[a+8>>2]=b;break}}else{g=c[j+24>>2]|0;a=c[j+12>>2]|0;do if((a|0)==(j|0)){d=j+16|0;b=d+4|0;a=c[b>>2]|0;if(!a){a=c[d>>2]|0;if(!a){d=0;break}else b=d}while(1){d=a+20|0;e=c[d>>2]|0;if(e|0){a=e;b=d;continue}d=a+16|0;e=c[d>>2]|0;if(!e)break;else{a=e;b=d}}c[b>>2]=0;d=a}else{d=c[j+8>>2]|0;c[d+12>>2]=a;c[a+8>>2]=d;d=a}while(0);if(g|0){a=c[j+28>>2]|0;b=888+(a<<2)|0;if((j|0)==(c[b>>2]|0)){c[b>>2]=d;if(!d){c[147]=c[147]&~(1<<a);break}}else{c[g+16+(((c[g+16>>2]|0)!=(j|0)&1)<<2)>>2]=d;if(!d)break}c[d+24>>2]=g;a=j+16|0;b=c[a>>2]|0;if(b|0){c[d+16>>2]=b;c[b+24>>2]=d}a=c[a+4>>2]|0;if(a|0){c[d+20>>2]=a;c[a+24>>2]=d}}}while(0);c[i+4>>2]=f|1;c[h+f>>2]=f;if((i|0)==(c[151]|0)){c[148]=f;return}}else{c[a>>2]=e&-2;c[i+4>>2]=b|1;c[h+b>>2]=b;f=b}a=f>>>3;if(f>>>0<256){d=624+(a<<1<<2)|0;b=c[146]|0;a=1<<a;if(!(b&a)){c[146]=b|a;a=d;b=d+8|0}else{b=d+8|0;a=c[b>>2]|0}c[b>>2]=i;c[a+12>>2]=i;c[i+8>>2]=a;c[i+12>>2]=d;return}a=f>>>8;if(a)if(f>>>0>16777215)a=31;else{h=(a+1048320|0)>>>16&8;j=a<<h;g=(j+520192|0)>>>16&4;j=j<<g;a=(j+245760|0)>>>16&2;a=14-(g|h|a)+(j<<a>>>15)|0;a=f>>>(a+7|0)&1|a<<1}else a=0;e=888+(a<<2)|0;c[i+28>>2]=a;c[i+20>>2]=0;c[i+16>>2]=0;b=c[147]|0;d=1<<a;do if(b&d){b=f<<((a|0)==31?0:25-(a>>>1)|0);d=c[e>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(f|0)){a=73;break}e=d+16+(b>>>31<<2)|0;a=c[e>>2]|0;if(!a){a=72;break}else{b=b<<1;d=a}}if((a|0)==72){c[e>>2]=i;c[i+24>>2]=d;c[i+12>>2]=i;c[i+8>>2]=i;break}else if((a|0)==73){h=d+8|0;j=c[h>>2]|0;c[j+12>>2]=i;c[h>>2]=i;c[i+8>>2]=j;c[i+12>>2]=d;c[i+24>>2]=0;break}}else{c[147]=b|d;c[e>>2]=i;c[i+24>>2]=e;c[i+12>>2]=i;c[i+8>>2]=i}while(0);j=(c[154]|0)+-1|0;c[154]=j;if(!j)a=1040;else return;while(1){a=c[a>>2]|0;if(!a)break;else a=a+8|0}c[154]=-1;return}function ya(a){a=a|0;var b=0,d=0;b=l;l=l+16|0;d=b;c[d>>2]=Fa(c[a+60>>2]|0)|0;a=Ba(ba(6,d|0)|0)|0;l=b;return a|0}function za(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0;n=l;l=l+48|0;k=n+16|0;g=n;f=n+32|0;i=a+28|0;e=c[i>>2]|0;c[f>>2]=e;j=a+20|0;e=(c[j>>2]|0)-e|0;c[f+4>>2]=e;c[f+8>>2]=b;c[f+12>>2]=d;e=e+d|0;h=a+60|0;c[g>>2]=c[h>>2];c[g+4>>2]=f;c[g+8>>2]=2;g=Ba($(146,g|0)|0)|0;a:do if((e|0)!=(g|0)){b=2;while(1){if((g|0)<0)break;e=e-g|0;p=c[f+4>>2]|0;o=g>>>0>p>>>0;f=o?f+8|0:f;b=(o<<31>>31)+b|0;p=g-(o?p:0)|0;c[f>>2]=(c[f>>2]|0)+p;o=f+4|0;c[o>>2]=(c[o>>2]|0)-p;c[k>>2]=c[h>>2];c[k+4>>2]=f;c[k+8>>2]=b;g=Ba($(146,k|0)|0)|0;if((e|0)==(g|0)){m=3;break a}}c[a+16>>2]=0;c[i>>2]=0;c[j>>2]=0;c[a>>2]=c[a>>2]|32;if((b|0)==2)d=0;else d=d-(c[f+4>>2]|0)|0}else m=3;while(0);if((m|0)==3){p=c[a+44>>2]|0;c[a+16>>2]=p+(c[a+48>>2]|0);c[i>>2]=p;c[j>>2]=p}l=n;return d|0}function Aa(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;f=l;l=l+32|0;g=f;e=f+20|0;c[g>>2]=c[a+60>>2];c[g+4>>2]=0;c[g+8>>2]=b;c[g+12>>2]=e;c[g+16>>2]=d;if((Ba(_(140,g|0)|0)|0)<0){c[e>>2]=-1;a=-1}else a=c[e>>2]|0;l=f;return a|0}function Ba(a){a=a|0;if(a>>>0>4294963200){c[(Ca()|0)>>2]=0-a;a=-1}return a|0}function Ca(){return (Da()|0)+64|0}function Da(){return Ea()|0}function Ea(){return 8}function Fa(a){a=a|0;return a|0}function Ga(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0;g=l;l=l+32|0;f=g;c[b+36>>2]=3;if((c[b>>2]&64|0)==0?(c[f>>2]=c[b+60>>2],c[f+4>>2]=21523,c[f+8>>2]=g+16,aa(54,f|0)|0):0)a[b+75>>0]=-1;f=za(b,d,e)|0;l=g;return f|0}function Ha(){return 1080}function Ia(a){a=a|0;return 0}function Ja(a){a=a|0;return}function Ka(){Y(1144);return 1152}function La(){ca(1144);return}function Ma(a){a=a|0;var b=0,d=0;do if(a){if((c[a+76>>2]|0)<=-1){b=Na(a)|0;break}d=(Ia(a)|0)==0;b=Na(a)|0;if(!d)Ja(a)}else{if(!(c[94]|0))b=0;else b=Ma(c[94]|0)|0;a=c[(Ka()|0)>>2]|0;if(a)do{if((c[a+76>>2]|0)>-1)d=Ia(a)|0;else d=0;if((c[a+20>>2]|0)>>>0>(c[a+28>>2]|0)>>>0)b=Na(a)|0|b;if(d|0)Ja(a);a=c[a+56>>2]|0}while((a|0)!=0);La()}while(0);return b|0}function Na(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;b=a+20|0;h=a+28|0;if((c[b>>2]|0)>>>0>(c[h>>2]|0)>>>0?(ha[c[a+36>>2]&3](a,0,0)|0,(c[b>>2]|0)==0):0)a=-1;else{d=a+4|0;e=c[d>>2]|0;f=a+8|0;g=c[f>>2]|0;if(e>>>0<g>>>0)ha[c[a+40>>2]&3](a,e-g|0,1)|0;c[a+16>>2]=0;c[h>>2]=0;c[b>>2]=0;c[f>>2]=0;c[d>>2]=0;a=0}return a|0}function Oa(){}function Pa(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;e=b&65535;c=N(e,f)|0;d=a>>>16;a=(c>>>16)+(N(e,d)|0)|0;e=b>>>16;b=N(e,f)|0;return (y=(a>>>16)+(N(e,d)|0)+(((a&65535)+b|0)>>>16)|0,a+b<<16|c&65535|0)|0}function Qa(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;c=Pa(e,f)|0;a=y;return (y=(N(b,f)|0)+(N(d,e)|0)+a|a&0,c|0|0)|0}function Ra(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){y=b>>c;return a>>>c|(b&(1<<c)-1)<<32-c}y=(b|0)<0?-1:0;return b>>c-32|0}function Sa(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){y=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}y=a<<c-32;return 0}function Ta(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return (y=b+d+(c>>>0<a>>>0|0)>>>0,c|0)|0}function Ua(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;d=b-d-(c>>>0>a>>>0|0)>>>0;return (y=d,a-c>>>0|0)|0}function Va(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;if((e|0)>=8192)return ea(b|0,d|0,e|0)|0;h=b|0;g=b+e|0;if((b&3)==(d&3)){while(b&3){if(!e)return h|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}e=g&-4|0;f=e-64|0;while((b|0)<=(f|0)){c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[b+28>>2]=c[d+28>>2];c[b+32>>2]=c[d+32>>2];c[b+36>>2]=c[d+36>>2];c[b+40>>2]=c[d+40>>2];c[b+44>>2]=c[d+44>>2];c[b+48>>2]=c[d+48>>2];c[b+52>>2]=c[d+52>>2];c[b+56>>2]=c[d+56>>2];c[b+60>>2]=c[d+60>>2];b=b+64|0;d=d+64|0}while((b|0)<(e|0)){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0}}else{e=g-4|0;while((b|0)<(e|0)){a[b>>0]=a[d>>0]|0;a[b+1>>0]=a[d+1>>0]|0;a[b+2>>0]=a[d+2>>0]|0;a[b+3>>0]=a[d+3>>0]|0;b=b+4|0;d=d+4|0}}while((b|0)<(g|0)){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0}return h|0}function Wa(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=b+e|0;d=d&255;if((e|0)>=67){while(b&3){a[b>>0]=d;b=b+1|0}f=h&-4|0;g=f-64|0;i=d|d<<8|d<<16|d<<24;while((b|0)<=(g|0)){c[b>>2]=i;c[b+4>>2]=i;c[b+8>>2]=i;c[b+12>>2]=i;c[b+16>>2]=i;c[b+20>>2]=i;c[b+24>>2]=i;c[b+28>>2]=i;c[b+32>>2]=i;c[b+36>>2]=i;c[b+40>>2]=i;c[b+44>>2]=i;c[b+48>>2]=i;c[b+52>>2]=i;c[b+56>>2]=i;c[b+60>>2]=i;b=b+64|0}while((b|0)<(f|0)){c[b>>2]=i;b=b+4|0}}while((b|0)<(h|0)){a[b>>0]=d;b=b+1|0}return h-e|0}function Xa(a){a=a|0;var b=0,d=0;d=a+15&-16|0;b=c[i>>2]|0;a=b+d|0;if((d|0)>0&(a|0)<(b|0)|(a|0)<0){V()|0;Z(12);return -1}c[i>>2]=a;if((a|0)>(U()|0)?(T()|0)==0:0){c[i>>2]=b;Z(12);return -1}return b|0}function Ya(a,b){a=a|0;b=b|0;return ga[a&1](b|0)|0}function Za(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return ha[a&3](b|0,c|0,d|0)|0}function _a(a){a=a|0;R(0);return 0}function $a(a,b,c){a=a|0;b=b|0;c=c|0;R(1);return 0}
-
-// EMSCRIPTEN_END_FUNCS
-var ga=[_a,ya];var ha=[$a,Ga,Aa,za];return{___errno_location:Ca,___muldi3:Qa,_bitshift64Ashr:Ra,_bitshift64Shl:Sa,_curve25519_generate_private:qa,_curve25519_generate_public:pa,_emscripten_get_global_libc:Ha,_fflush:Ma,_free:xa,_i64Add:Ta,_i64Subtract:Ua,_key_to_base64:ra,_malloc:wa,_memcpy:Va,_memset:Wa,_sbrk:Xa,dynCall_ii:Ya,dynCall_iiii:Za,establishStackSpace:la,getTempRet0:oa,runPostSets:Oa,setTempRet0:na,setThrew:ma,stackAlloc:ia,stackRestore:ka,stackSave:ja}})
-
-
-// EMSCRIPTEN_END_ASM
-(Module.asmGlobalArg,Module.asmLibraryArg,buffer);var ___errno_location=Module["___errno_location"]=asm["___errno_location"];var ___muldi3=Module["___muldi3"]=asm["___muldi3"];var _bitshift64Ashr=Module["_bitshift64Ashr"]=asm["_bitshift64Ashr"];var _bitshift64Shl=Module["_bitshift64Shl"]=asm["_bitshift64Shl"];var _curve25519_generate_private=Module["_curve25519_generate_private"]=asm["_curve25519_generate_private"];var _curve25519_generate_public=Module["_curve25519_generate_public"]=asm["_curve25519_generate_public"];var _emscripten_get_global_libc=Module["_emscripten_get_global_libc"]=asm["_emscripten_get_global_libc"];var _fflush=Module["_fflush"]=asm["_fflush"];var _free=Module["_free"]=asm["_free"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _i64Subtract=Module["_i64Subtract"]=asm["_i64Subtract"];var _key_to_base64=Module["_key_to_base64"]=asm["_key_to_base64"];var _malloc=Module["_malloc"]=asm["_malloc"];var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _memset=Module["_memset"]=asm["_memset"];var _sbrk=Module["_sbrk"]=asm["_sbrk"];var establishStackSpace=Module["establishStackSpace"]=asm["establishStackSpace"];var getTempRet0=Module["getTempRet0"]=asm["getTempRet0"];var runPostSets=Module["runPostSets"]=asm["runPostSets"];var setTempRet0=Module["setTempRet0"]=asm["setTempRet0"];var setThrew=Module["setThrew"]=asm["setThrew"];var stackAlloc=Module["stackAlloc"]=asm["stackAlloc"];var stackRestore=Module["stackRestore"]=asm["stackRestore"];var stackSave=Module["stackSave"]=asm["stackSave"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];Runtime.stackAlloc=Module["stackAlloc"];Runtime.stackSave=Module["stackSave"];Runtime.stackRestore=Module["stackRestore"];Runtime.establishStackSpace=Module["establishStackSpace"];Runtime.setTempRet0=Module["setTempRet0"];Runtime.getTempRet0=Module["getTempRet0"];Module["asm"]=asm;if(memoryInitializer){if(typeof Module["locateFile"]==="function"){memoryInitializer=Module["locateFile"](memoryInitializer)}else if(Module["memoryInitializerPrefixURL"]){memoryInitializer=Module["memoryInitializerPrefixURL"]+memoryInitializer}if(ENVIRONMENT_IS_NODE||ENVIRONMENT_IS_SHELL){var data=Module["readBinary"](memoryInitializer);HEAPU8.set(data,Runtime.GLOBAL_BASE)}else{addRunDependency("memory initializer");var applyMemoryInitializer=(function(data){if(data.byteLength)data=new Uint8Array(data);HEAPU8.set(data,Runtime.GLOBAL_BASE);if(Module["memoryInitializerRequest"])delete Module["memoryInitializerRequest"].response;removeRunDependency("memory initializer")});function doBrowserLoad(){Module["readAsync"](memoryInitializer,applyMemoryInitializer,(function(){throw"could not load memory initializer "+memoryInitializer}))}var memoryInitializerBytes=tryParseAsDataURI(memoryInitializer);if(memoryInitializerBytes){applyMemoryInitializer(memoryInitializerBytes.buffer)}else if(Module["memoryInitializerRequest"]){function useRequest(){var request=Module["memoryInitializerRequest"];var response=request.response;if(request.status!==200&&request.status!==0){var data=tryParseAsDataURI(Module["memoryInitializerRequestURL"]);if(data){response=data.buffer}else{console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: "+request.status+", retrying "+memoryInitializer);doBrowserLoad();return}}applyMemoryInitializer(response)}if(Module["memoryInitializerRequest"].response){setTimeout(useRequest,0)}else{Module["memoryInitializerRequest"].addEventListener("load",useRequest)}}else{doBrowserLoad()}}}function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;var preloadStartTime=null;var calledMain=false;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"])run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};Module["callMain"]=Module.callMain=function callMain(args){args=args||[];ensureInitRuntime();var argc=args.length+1;function pad(){for(var i=0;i<4-1;i++){argv.push(0)}}var argv=[allocate(intArrayFromString(Module["thisProgram"]),"i8",ALLOC_NORMAL)];pad();for(var i=0;i<argc-1;i=i+1){argv.push(allocate(intArrayFromString(args[i]),"i8",ALLOC_NORMAL));pad()}argv.push(0);argv=allocate(argv,"i32",ALLOC_NORMAL);try{var ret=Module["_main"](argc,argv,0);exit(ret,true)}catch(e){if(e instanceof ExitStatus){return}else if(e=="SimulateInfiniteLoop"){Module["noExitRuntime"]=true;return}else{var toLog=e;if(e&&typeof e==="object"&&e.stack){toLog=[e,e.stack]}Module.printErr("exception thrown: "+toLog);Module["quit"](1,e)}}finally{calledMain=true}};function run(args){args=args||Module["arguments"];if(preloadStartTime===null)preloadStartTime=Date.now();if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(Module["_main"]&&shouldRunNow)Module["callMain"](args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}Module["run"]=Module.run=run;function exit(status,implicit){if(implicit&&Module["noExitRuntime"]){return}if(Module["noExitRuntime"]){}else{ABORT=true;EXITSTATUS=status;STACKTOP=initialStackTop;exitRuntime();if(Module["onExit"])Module["onExit"](status)}if(ENVIRONMENT_IS_NODE){process["exit"](status)}Module["quit"](status,new ExitStatus(status))}Module["exit"]=Module.exit=exit;var abortDecorators=[];function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}if(what!==undefined){Module.print(what);Module.printErr(what);what=JSON.stringify(what)}else{what=""}ABORT=true;EXITSTATUS=1;var extra="\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";var output="abort("+what+") at "+stackTrace()+extra;if(abortDecorators){abortDecorators.forEach((function(decorator){output=decorator(output,what)}))}throw output}Module["abort"]=Module.abort=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"]){shouldRunNow=false}run()
-
-
-
-
diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
index d12f6b9..8b3e853 100644
--- a/contrib/keygen-html/keygen.html
+++ b/contrib/keygen-html/keygen.html
@@ -1,29 +1,9 @@
-<script src="curve25519_generate.js"></script>
+<script src="curve25519_generate.js" onError='document.write("<h3>Did you forget to run \"make\" to compile curve25519_generate.js?</h3><!--");'></script>
 <script>
 /* SPDX-License-Identifier: GPL-2.0
  *
  * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  */
-function generateWireguardKeypair()
-{
-	var privateKey = Module._malloc(32);
-	var publicKey = Module._malloc(32);
-	Module._curve25519_generate_private(privateKey);
-	Module._curve25519_generate_public(publicKey, privateKey);
-	var privateBase64 = Module._malloc(45);
-	var publicBase64 = Module._malloc(45);
-	Module._key_to_base64(privateBase64, privateKey);
-	Module._key_to_base64(publicBase64, publicKey);
-	Module._free(privateKey);
-	Module._free(publicKey);
-	var keypair = {
-		publicKey: Module.Pointer_stringify(publicBase64),
-		privateKey: Module.Pointer_stringify(privateBase64)
-	};
-	Module._free(privateBase64);
-	Module._free(publicBase64);
-	return keypair;
-}
 
 function sendPubkeyToServer(pubkey, username, password)
 {
@@ -44,7 +24,7 @@ function sendPubkeyToServer(pubkey, username, password)
 
 function downloadNewConfiguration()
 {
-	var keypair = generateWireguardKeypair();
+	var keypair = WireGuard.generateKeypair();
 	var serverResponse = sendPubkeyToServer(keypair.publicKey, "zx2c4", "supersecretpassword");
 
 	var config = [];
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index c82f16d..ae036d5 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -2,8 +2,6 @@
  *
  * Copyright (C) 2008 Google Inc. All Rights Reserved.
  * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- *
- * Build with emcc -O3 --memory-init-file 0 -o curve25519_generate.js curve25519_generate.c
  */
 
 #include <emscripten.h>
diff --git a/contrib/keygen-html/src/glue.js b/contrib/keygen-html/src/glue.js
new file mode 100644
index 0000000..f79c383
--- /dev/null
+++ b/contrib/keygen-html/src/glue.js
@@ -0,0 +1,25 @@
+/*! SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+window["WireGuard"] = {
+	"generateKeypair": function() {
+		var privateKey = Module["_malloc"](32);
+		var publicKey = Module["_malloc"](32);
+		Module["_curve25519_generate_private"](privateKey);
+		Module["_curve25519_generate_public"](publicKey, privateKey);
+		var privateBase64 = Module["_malloc"](45);
+		var publicBase64 = Module["_malloc"](45);
+		Module["_key_to_base64"](privateBase64, privateKey);
+		Module["_key_to_base64"](publicBase64, publicKey);
+		Module["_free"](privateKey);
+		Module["_free"](publicKey);
+		var keypair = {
+			publicKey: Module["Pointer_stringify"](publicBase64),
+			privateKey: Module["Pointer_stringify"](privateBase64)
+		};
+		Module["_free"](privateBase64);
+		Module["_free"](publicBase64);
+		return keypair;
+	}
+};

commit 01d00bc03566d17585f640aafe5c76d34bcf5884
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Nov 30 15:23:50 2017 +0000

    global: add SPDX tags to all files
    
    It's good to have SPDX identifiers in all files as the Linux kernel
    developers are working to add these identifiers to all files.
    
    Update all files with the correct SPDX license identifier based on the license
    text of the project or based on the license in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of the
    full boiler plate text.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Modified-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/dns-hatchet/apply.sh b/contrib/dns-hatchet/apply.sh
index ce35ecd..4596d4b 100755
--- a/contrib/dns-hatchet/apply.sh
+++ b/contrib/dns-hatchet/apply.sh
@@ -1,4 +1,7 @@
 #!/bin/bash
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 ME="$(readlink -f "$(dirname "$(readlink -f "$0")")")"
 TOOLS="$ME/../../../src/tools"
diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index abd435f..b8e619e 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 struct def {
 	const char *name;
diff --git a/contrib/extract-keys/extract-keys.c b/contrib/extract-keys/extract-keys.c
index 8a5f24e..d6faded 100644
--- a/contrib/extract-keys/extract-keys.c
+++ b/contrib/extract-keys/extract-keys.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <endian.h>
 #include <errno.h>
diff --git a/contrib/json/wg-json b/contrib/json/wg-json
index 1b9a570..33c01e8 100755
--- a/contrib/json/wg-json
+++ b/contrib/json/wg-json
@@ -1,6 +1,7 @@
 #!/bin/bash
-
-# Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 exec < <(exec wg show all dump)
 
diff --git a/contrib/keygen-html/curve25519_generate.js b/contrib/keygen-html/curve25519_generate.js
index cfbf581..82b2a53 100644
--- a/contrib/keygen-html/curve25519_generate.js
+++ b/contrib/keygen-html/curve25519_generate.js
@@ -1,4 +1,9 @@
-/* License: GPLv2 */ var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;if(Module["ENVIRONMENT"]){if(Module["ENVIRONMENT"]==="WEB"){ENVIRONMENT_IS_WEB=true}else if(Module["ENVIRONMENT"]==="WORKER"){ENVIRONMENT_IS_WORKER=true}else if(Module["ENVIRONMENT"]==="NODE"){ENVIRONMENT_IS_NODE=true}else if(Module["ENVIRONMENT"]==="SHELL"){ENVIRONMENT_IS_SHELL=true}else{throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.")}}else{ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER}if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=console.log;if(!Module["printErr"])Module["printErr"]=console.warn;var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=require("fs");if(!nodePath)nodePath=require("path");filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename)}return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(!Module["thisProgram"]){if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}else{Module["thisProgram"]="unknown-program"}}Module["arguments"]=process["argv"].slice(2);if(typeof module!=="undefined"){module["exports"]=Module}process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}));Module["inspect"]=(function(){return"[Emscripten Module object]"})}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined"){Module["read"]=function shell_read(f){var data=tryParseAsDataURI(f);if(data){return intArrayToString(data)}return read(f)}}else{Module["read"]=function shell_read(){throw"no read() available"}}Module["readBinary"]=function readBinary(f){var data;data=tryParseAsDataURI(f);if(data){return data}if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs}else if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof quit==="function"){Module["quit"]=(function(status,toThrow){quit(status)})}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function shell_read(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){Module["readBinary"]=function readBinary(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}}}Module["readAsync"]=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror()};xhr.onerror=onerror;xhr.send(null)};if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=function shell_print(x){console.log(x)};if(!Module["printErr"])Module["printErr"]=function shell_printErr(x){console.warn(x)}}else{var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?(function(x){dump(x)}):(function(x){})}if(typeof Module["setWindowTitle"]==="undefined"){Module["setWindowTitle"]=(function(title){document.title=title})}}else{throw new Error("Unknown runtime environment. Where are we?")}if(!Module["print"]){Module["print"]=(function(){})}if(!Module["printErr"]){Module["printErr"]=Module["print"]}if(!Module["arguments"]){Module["arguments"]=[]}if(!Module["thisProgram"]){Module["thisProgram"]="./this.program"}if(!Module["quit"]){Module["quit"]=(function(status,toThrow){throw toThrow})}Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=undefined;var Runtime={setTempRet0:(function(value){tempRet0=value;return value}),getTempRet0:(function(){return tempRet0}),stackSave:(function(){return STACKTOP}),stackRestore:(function(stackTop){STACKTOP=stackTop}),getNativeTypeSize:(function(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return Runtime.QUANTUM_SIZE}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else{return 0}}}}),getNativeFieldSize:(function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)}),STACK_ALIGN:16,prepVararg:(function(ptr,type){if(type==="double"||type==="i64"){if(ptr&7){assert((ptr&7)===4);ptr+=4}}else{assert((ptr&3)===0)}return ptr}),getAlignSize:(function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)}),dynCall:(function(sig,ptr,args){if(args&&args.length){return Module["dynCall_"+sig].apply(null,[ptr].concat(args))}else{return Module["dynCall_"+sig].call(null,ptr)}}),functionPointers:[],addFunction:(function(func){for(var i=0;i<Runtime.functionPointers.length;i++){if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=func;return 2*(1+i)}}throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."}),removeFunction:(function(index){Runtime.functionPointers[(index-2)/2]=null}),warnOnce:(function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown={};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}}),funcWrappers:{},getFuncWrapper:(function(func,sig){if(!func)return;assert(sig);if(!Runtime.funcWrappers[sig]){Runtime.funcWrappers[sig]={}}var sigCache=Runtime.funcWrappers[sig];if(!sigCache[func]){if(sig.length===1){sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func)}}else if(sig.length===2){sigCache[func]=function dynCall_wrapper(arg){return Runtime.dynCall(sig,func,[arg])}}else{sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,Array.prototype.slice.call(arguments))}}}return sigCache[func]}),getCompilerSetting:(function(name){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"}),stackAlloc:(function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+15&-16;return ret}),staticAlloc:(function(size){var ret=STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+15&-16;return ret}),dynamicAlloc:(function(size){var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=(ret+size+15|0)&-16;HEAP32[DYNAMICTOP_PTR>>2]=end;if(end>=TOTAL_MEMORY){var success=enlargeMemory();if(!success){HEAP32[DYNAMICTOP_PTR>>2]=ret;return 0}}return ret}),alignMemory:(function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:16))*(quantum?quantum:16);return ret}),makeBigInt:(function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret}),GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var ABORT=0;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}var JSfuncs={"stackSave":(function(){Runtime.stackSave()}),"stackRestore":(function(){Runtime.stackRestore()}),"arrayToC":(function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=Runtime.stackAlloc(len);stringToUTF8(str,ret,len)}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};function ccall(ident,returnType,argTypes,args,opts){var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0){Runtime.stackRestore(stack)}return ret}function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident);var numericArgs=argTypes.every((function(type){return type==="number"}));var numericRet=returnType!=="string";if(numericRet&&numericArgs){return cfunc}return(function(){return ccall(ident,returnType,argTypes,arguments)})}Module["ccall"]=ccall;Module["cwrap"]=cwrap;function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}Module["setValue"]=setValue;function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for getValue: "+type)}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[typeof _malloc==="function"?_malloc:Runtime.staticAlloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var stop;ptr=ret;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function"){curr=Runtime.getFunctionIndex(curr)}type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}Module["allocate"]=allocate;function getMemory(size){if(!staticSealed)return Runtime.staticAlloc(size);if(!runtimeInitialized)return Runtime.dynamicAlloc(size);return _malloc(size)}Module["getMemory"]=getMemory;function Pointer_stringify(ptr,length){if(length===0||!ptr)return"";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}return Module["UTF8ToString"](ptr)}Module["Pointer_stringify"]=Pointer_stringify;function AsciiToString(ptr){var str="";while(1){var ch=HEAP8[ptr++>>0];if(!ch)return str;str+=String.fromCharCode(ch)}}Module["AsciiToString"]=AsciiToString;function stringToAscii(str,outPtr){return writeAsciiToMemory(str,outPtr,false)}Module["stringToAscii"]=stringToAscii;var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx){var endPtr=idx;while(u8Array[endPtr])++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var u0,u1,u2,u3,u4,u5;var str="";while(1){u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u3=u8Array[idx++]&63;if((u0&248)==240){u0=(u0&7)<<18|u1<<12|u2<<6|u3}else{u4=u8Array[idx++]&63;if((u0&252)==248){u0=(u0&3)<<24|u1<<18|u2<<12|u3<<6|u4}else{u5=u8Array[idx++]&63;u0=(u0&1)<<30|u1<<24|u2<<18|u3<<12|u4<<6|u5}}}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}}Module["UTF8ArrayToString"]=UTF8ArrayToString;function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}Module["UTF8ToString"]=UTF8ToString;function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=2097151){if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=67108863){if(outIdx+4>=endIdx)break;outU8Array[outIdx++]=248|u>>24;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+5>=endIdx)break;outU8Array[outIdx++]=252|u>>30;outU8Array[outIdx++]=128|u>>24&63;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}Module["stringToUTF8Array"]=stringToUTF8Array;function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}Module["stringToUTF8"]=stringToUTF8;function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){++len}else if(u<=2047){len+=2}else if(u<=65535){len+=3}else if(u<=2097151){len+=4}else if(u<=67108863){len+=5}else{len+=6}}return len}Module["lengthBytesUTF8"]=lengthBytesUTF8;var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function demangle(func){var __cxa_demangle_func=Module["___cxa_demangle"]||Module["__cxa_demangle"];if(__cxa_demangle_func){try{var s=func.substr(1);var len=lengthBytesUTF8(s)+1;var buf=_malloc(len);stringToUTF8(s,buf,len);var status=_malloc(4);var ret=__cxa_demangle_func(buf,0,0,status);if(getValue(status,"i32")===0&&ret){return Pointer_stringify(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}return func}Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");return func}function demangleAll(text){var regex=/__Z[\w\d_]+/g;return text.replace(regex,(function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}Module["stackTrace"]=stackTrace;var HEAP,buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer)}var STATIC_BASE,STATICTOP,staticSealed;var STACK_BASE,STACKTOP,STACK_MAX;var DYNAMIC_BASE,DYNAMICTOP_PTR;STATIC_BASE=STATICTOP=STACK_BASE=STACKTOP=STACK_MAX=DYNAMIC_BASE=DYNAMICTOP_PTR=0;staticSealed=false;function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function enlargeMemory(){abortOnCannotGrowMemory()}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(TOTAL_MEMORY<TOTAL_STACK)Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");if(Module["buffer"]){buffer=Module["buffer"]}else{{buffer=new ArrayBuffer(TOTAL_MEMORY)}}updateGlobalBufferViews();function getTotalMemory(){return TOTAL_MEMORY}HEAP32[0]=1668509029;HEAP16[1]=25459;if(HEAPU8[2]!==115||HEAPU8[3]!==99)throw"Runtime error: expected the system to be little-endian!";Module["HEAP"]=HEAP;Module["buffer"]=buffer;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func)}else{Module["dynCall_vi"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module["addOnPreRun"]=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module["addOnInit"]=addOnInit;function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module["addOnPreMain"]=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module["addOnExit"]=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module["addOnPostRun"]=addOnPostRun;function writeStringToMemory(string,buffer,dontAddNull){Runtime.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var lastChar,end;if(dontAddNull){end=buffer+lengthBytesUTF8(string);lastChar=HEAP8[end]}stringToUTF8(string,buffer,Infinity);if(dontAddNull)HEAP8[end]=lastChar}Module["writeStringToMemory"]=writeStringToMemory;function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}Module["writeAsciiToMemory"]=writeAsciiToMemory;if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];if(!Math["clz32"])Math["clz32"]=(function(x){x=x>>>0;for(var i=0;i<32;i++){if(x&1<<31-i)return i}return 32});Math.clz32=Math["clz32"];if(!Math["trunc"])Math["trunc"]=(function(x){return x<0?Math.ceil(x):Math.floor(x)});Math.trunc=Math["trunc"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_round=Math.round;var Math_min=Math.min;var Math_clz32=Math.clz32;var Math_trunc=Math.trunc;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}Module["addRunDependency"]=addRunDependency;function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;var ASM_CONSTS=[(function(){var getRandomValue=(function(){var buf=new Uint32Array(1);window.crypto.getRandomValues(buf);return buf[0]>>>0});Module.getRandomValue=getRandomValue}),(function(){return Module.getRandomValue()})];function _emscripten_asm_const_i(code){return ASM_CONSTS[code]()}STATIC_BASE=Runtime.GLOBAL_BASE;STATICTOP=STATIC_BASE+2192;__ATINIT__.push();memoryInitializer="data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAACAAAAjAQAAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAr/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAAeyB2YXIgZ2V0UmFuZG9tVmFsdWUgPSBmdW5jdGlvbigpIHsgdmFyIGJ1ZiA9IG5ldyBVaW50MzJBcnJheSgxKTsgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmKTsgcmV0dXJuIGJ1ZlswXSA+Pj4gMDsgfTsgTW9kdWxlLmdldFJhbmRvbVZhbHVlID0gZ2V0UmFuZG9tVmFsdWU7IH0AeyByZXR1cm4gTW9kdWxlLmdldFJhbmRvbVZhbHVlKCk7IH0=";var tempDoublePtr=STATICTOP;STATICTOP+=16;function ___lock(){}var SYSCALLS={varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=Pointer_stringify(SYSCALLS.get());return ret}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0)})};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;if(!___syscall146.buffer){___syscall146.buffers=[null,[],[]];___syscall146.printChar=(function(stream,curr){var buffer=___syscall146.buffers[stream];assert(buffer);if(curr===0||curr===10){(stream===1?Module["print"]:Module["printErr"])(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}})}for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){___syscall146.printChar(stream,HEAPU8[ptr+j])}ret+=len}return ret}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___unlock(){}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}__ATEXIT__.push((function(){var fflush=Module["_fflush"];if(fflush)fflush(0);var printChar=___syscall146.printChar;if(!printChar)return;var buffers=___syscall146.buffers;if(buffers[1].length)printChar(1,10);if(buffers[2].length)printChar(2,10)}));DYNAMICTOP_PTR=allocate(1,"i32",ALLOC_STATIC);STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=Runtime.alignMemory(STACK_MAX);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;staticSealed=true;var ASSERTIONS=false;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){if(ASSERTIONS){assert(false,"Character code "+chr+" ("+String.fromCharCode(chr)+")  at offset "+i+" not in 0x00-0xFF.")}chr&=255}ret.push(String.fromCharCode(chr))}return ret.join("")}Module["intArrayFromString"]=intArrayFromString;Module["intArrayToString"]=intArrayToString;var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var decodeBase64=typeof atob==="function"?atob:(function(input){var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2)}if(enc4!==64){output=output+String.fromCharCode(chr3)}}while(i<input.length);return output});function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer.from(s,"base64")}catch(_){buf=new Buffer(s,"base64")}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i)}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){var dataURIPrefix="data:application/octet-stream;base64,";if(!(String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0)}}function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0)}}Module.asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array,"NaN":NaN,"Infinity":Infinity};Module.asmLibraryArg={"abort":abort,"assert":assert,"enlargeMemory":enlargeMemory,"getTotalMemory":getTotalMemory,"abortOnCannotGrowMemory":abortOnCannotGrowMemory,"invoke_ii":invoke_ii,"invoke_iiii":invoke_iiii,"___lock":___lock,"___setErrNo":___setErrNo,"___syscall140":___syscall140,"___syscall146":___syscall146,"___syscall54":___syscall54,"___syscall6":___syscall6,"___unlock":___unlock,"_emscripten_asm_const_i":_emscripten_asm_const_i,"_emscripten_memcpy_big":_emscripten_memcpy_big,"DYNAMICTOP_PTR":DYNAMICTOP_PTR,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX};// EMSCRIPTEN_START_ASM
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2008 Google Inc. All Rights Reserved.
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
+var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;if(Module["ENVIRONMENT"]){if(Module["ENVIRONMENT"]==="WEB"){ENVIRONMENT_IS_WEB=true}else if(Module["ENVIRONMENT"]==="WORKER"){ENVIRONMENT_IS_WORKER=true}else if(Module["ENVIRONMENT"]==="NODE"){ENVIRONMENT_IS_NODE=true}else if(Module["ENVIRONMENT"]==="SHELL"){ENVIRONMENT_IS_SHELL=true}else{throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.")}}else{ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER}if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=console.log;if(!Module["printErr"])Module["printErr"]=console.warn;var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=require("fs");if(!nodePath)nodePath=require("path");filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename)}return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(!Module["thisProgram"]){if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}else{Module["thisProgram"]="unknown-program"}}Module["arguments"]=process["argv"].slice(2);if(typeof module!=="undefined"){module["exports"]=Module}process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}));Module["inspect"]=(function(){return"[Emscripten Module object]"})}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined"){Module["read"]=function shell_read(f){var data=tryParseAsDataURI(f);if(data){return intArrayToString(data)}return read(f)}}else{Module["read"]=function shell_read(){throw"no read() available"}}Module["readBinary"]=function readBinary(f){var data;data=tryParseAsDataURI(f);if(data){return data}if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs}else if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof quit==="function"){Module["quit"]=(function(status,toThrow){quit(status)})}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function shell_read(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){Module["readBinary"]=function readBinary(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}}}Module["readAsync"]=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror()};xhr.onerror=onerror;xhr.send(null)};if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=function shell_print(x){console.log(x)};if(!Module["printErr"])Module["printErr"]=function shell_printErr(x){console.warn(x)}}else{var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?(function(x){dump(x)}):(function(x){})}if(typeof Module["setWindowTitle"]==="undefined"){Module["setWindowTitle"]=(function(title){document.title=title})}}else{throw new Error("Unknown runtime environment. Where are we?")}if(!Module["print"]){Module["print"]=(function(){})}if(!Module["printErr"]){Module["printErr"]=Module["print"]}if(!Module["arguments"]){Module["arguments"]=[]}if(!Module["thisProgram"]){Module["thisProgram"]="./this.program"}if(!Module["quit"]){Module["quit"]=(function(status,toThrow){throw toThrow})}Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=undefined;var Runtime={setTempRet0:(function(value){tempRet0=value;return value}),getTempRet0:(function(){return tempRet0}),stackSave:(function(){return STACKTOP}),stackRestore:(function(stackTop){STACKTOP=stackTop}),getNativeTypeSize:(function(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return Runtime.QUANTUM_SIZE}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else{return 0}}}}),getNativeFieldSize:(function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)}),STACK_ALIGN:16,prepVararg:(function(ptr,type){if(type==="double"||type==="i64"){if(ptr&7){assert((ptr&7)===4);ptr+=4}}else{assert((ptr&3)===0)}return ptr}),getAlignSize:(function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)}),dynCall:(function(sig,ptr,args){if(args&&args.length){return Module["dynCall_"+sig].apply(null,[ptr].concat(args))}else{return Module["dynCall_"+sig].call(null,ptr)}}),functionPointers:[],addFunction:(function(func){for(var i=0;i<Runtime.functionPointers.length;i++){if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=func;return 2*(1+i)}}throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."}),removeFunction:(function(index){Runtime.functionPointers[(index-2)/2]=null}),warnOnce:(function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown={};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}}),funcWrappers:{},getFuncWrapper:(function(func,sig){if(!func)return;assert(sig);if(!Runtime.funcWrappers[sig]){Runtime.funcWrappers[sig]={}}var sigCache=Runtime.funcWrappers[sig];if(!sigCache[func]){if(sig.length===1){sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func)}}else if(sig.length===2){sigCache[func]=function dynCall_wrapper(arg){return Runtime.dynCall(sig,func,[arg])}}else{sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,Array.prototype.slice.call(arguments))}}}return sigCache[func]}),getCompilerSetting:(function(name){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"}),stackAlloc:(function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+15&-16;return ret}),staticAlloc:(function(size){var ret=STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+15&-16;return ret}),dynamicAlloc:(function(size){var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=(ret+size+15|0)&-16;HEAP32[DYNAMICTOP_PTR>>2]=end;if(end>=TOTAL_MEMORY){var success=enlargeMemory();if(!success){HEAP32[DYNAMICTOP_PTR>>2]=ret;return 0}}return ret}),alignMemory:(function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:16))*(quantum?quantum:16);return ret}),makeBigInt:(function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret}),GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var ABORT=0;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}var JSfuncs={"stackSave":(function(){Runtime.stackSave()}),"stackRestore":(function(){Runtime.stackRestore()}),"arrayToC":(function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=Runtime.stackAlloc(len);stringToUTF8(str,ret,len)}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};function ccall(ident,returnType,argTypes,args,opts){var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0){Runtime.stackRestore(stack)}return ret}function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident);var numericArgs=argTypes.every((function(type){return type==="number"}));var numericRet=returnType!=="string";if(numericRet&&numericArgs){return cfunc}return(function(){return ccall(ident,returnType,argTypes,arguments)})}Module["ccall"]=ccall;Module["cwrap"]=cwrap;function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}Module["setValue"]=setValue;function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for getValue: "+type)}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[typeof _malloc==="function"?_malloc:Runtime.staticAlloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var stop;ptr=ret;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function"){curr=Runtime.getFunctionIndex(curr)}type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}Module["allocate"]=allocate;function getMemory(size){if(!staticSealed)return Runtime.staticAlloc(size);if(!runtimeInitialized)return Runtime.dynamicAlloc(size);return _malloc(size)}Module["getMemory"]=getMemory;function Pointer_stringify(ptr,length){if(length===0||!ptr)return"";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}return Module["UTF8ToString"](ptr)}Module["Pointer_stringify"]=Pointer_stringify;function AsciiToString(ptr){var str="";while(1){var ch=HEAP8[ptr++>>0];if(!ch)return str;str+=String.fromCharCode(ch)}}Module["AsciiToString"]=AsciiToString;function stringToAscii(str,outPtr){return writeAsciiToMemory(str,outPtr,false)}Module["stringToAscii"]=stringToAscii;var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx){var endPtr=idx;while(u8Array[endPtr])++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var u0,u1,u2,u3,u4,u5;var str="";while(1){u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u3=u8Array[idx++]&63;if((u0&248)==240){u0=(u0&7)<<18|u1<<12|u2<<6|u3}else{u4=u8Array[idx++]&63;if((u0&252)==248){u0=(u0&3)<<24|u1<<18|u2<<12|u3<<6|u4}else{u5=u8Array[idx++]&63;u0=(u0&1)<<30|u1<<24|u2<<18|u3<<12|u4<<6|u5}}}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}}Module["UTF8ArrayToString"]=UTF8ArrayToString;function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}Module["UTF8ToString"]=UTF8ToString;function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=2097151){if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=67108863){if(outIdx+4>=endIdx)break;outU8Array[outIdx++]=248|u>>24;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+5>=endIdx)break;outU8Array[outIdx++]=252|u>>30;outU8Array[outIdx++]=128|u>>24&63;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}Module["stringToUTF8Array"]=stringToUTF8Array;function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}Module["stringToUTF8"]=stringToUTF8;function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){++len}else if(u<=2047){len+=2}else if(u<=65535){len+=3}else if(u<=2097151){len+=4}else if(u<=67108863){len+=5}else{len+=6}}return len}Module["lengthBytesUTF8"]=lengthBytesUTF8;var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function demangle(func){var __cxa_demangle_func=Module["___cxa_demangle"]||Module["__cxa_demangle"];if(__cxa_demangle_func){try{var s=func.substr(1);var len=lengthBytesUTF8(s)+1;var buf=_malloc(len);stringToUTF8(s,buf,len);var status=_malloc(4);var ret=__cxa_demangle_func(buf,0,0,status);if(getValue(status,"i32")===0&&ret){return Pointer_stringify(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}return func}Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");return func}function demangleAll(text){var regex=/__Z[\w\d_]+/g;return text.replace(regex,(function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}Module["stackTrace"]=stackTrace;var HEAP,buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer)}var STATIC_BASE,STATICTOP,staticSealed;var STACK_BASE,STACKTOP,STACK_MAX;var DYNAMIC_BASE,DYNAMICTOP_PTR;STATIC_BASE=STATICTOP=STACK_BASE=STACKTOP=STACK_MAX=DYNAMIC_BASE=DYNAMICTOP_PTR=0;staticSealed=false;function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function enlargeMemory(){abortOnCannotGrowMemory()}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(TOTAL_MEMORY<TOTAL_STACK)Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");if(Module["buffer"]){buffer=Module["buffer"]}else{{buffer=new ArrayBuffer(TOTAL_MEMORY)}}updateGlobalBufferViews();function getTotalMemory(){return TOTAL_MEMORY}HEAP32[0]=1668509029;HEAP16[1]=25459;if(HEAPU8[2]!==115||HEAPU8[3]!==99)throw"Runtime error: expected the system to be little-endian!";Module["HEAP"]=HEAP;Module["buffer"]=buffer;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func)}else{Module["dynCall_vi"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module["addOnPreRun"]=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module["addOnInit"]=addOnInit;function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module["addOnPreMain"]=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module["addOnExit"]=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module["addOnPostRun"]=addOnPostRun;function writeStringToMemory(string,buffer,dontAddNull){Runtime.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var lastChar,end;if(dontAddNull){end=buffer+lengthBytesUTF8(string);lastChar=HEAP8[end]}stringToUTF8(string,buffer,Infinity);if(dontAddNull)HEAP8[end]=lastChar}Module["writeStringToMemory"]=writeStringToMemory;function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}Module["writeAsciiToMemory"]=writeAsciiToMemory;if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];if(!Math["clz32"])Math["clz32"]=(function(x){x=x>>>0;for(var i=0;i<32;i++){if(x&1<<31-i)return i}return 32});Math.clz32=Math["clz32"];if(!Math["trunc"])Math["trunc"]=(function(x){return x<0?Math.ceil(x):Math.floor(x)});Math.trunc=Math["trunc"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_round=Math.round;var Math_min=Math.min;var Math_clz32=Math.clz32;var Math_trunc=Math.trunc;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}Module["addRunDependency"]=addRunDependency;function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;var ASM_CONSTS=[(function(){var getRandomValue=(function(){var buf=new Uint32Array(1);window.crypto.getRandomValues(buf);return buf[0]>>>0});Module.getRandomValue=getRandomValue}),(function(){return Module.getRandomValue()})];function _emscripten_asm_const_i(code){return ASM_CONSTS[code]()}STATIC_BASE=Runtime.GLOBAL_BASE;STATICTOP=STATIC_BASE+2192;__ATINIT__.push();memoryInitializer="data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAACAAAAjAQAAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAr/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAAeyB2YXIgZ2V0UmFuZG9tVmFsdWUgPSBmdW5jdGlvbigpIHsgdmFyIGJ1ZiA9IG5ldyBVaW50MzJBcnJheSgxKTsgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmKTsgcmV0dXJuIGJ1ZlswXSA+Pj4gMDsgfTsgTW9kdWxlLmdldFJhbmRvbVZhbHVlID0gZ2V0UmFuZG9tVmFsdWU7IH0AeyByZXR1cm4gTW9kdWxlLmdldFJhbmRvbVZhbHVlKCk7IH0=";var tempDoublePtr=STATICTOP;STATICTOP+=16;function ___lock(){}var SYSCALLS={varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=Pointer_stringify(SYSCALLS.get());return ret}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0)})};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;if(!___syscall146.buffer){___syscall146.buffers=[null,[],[]];___syscall146.printChar=(function(stream,curr){var buffer=___syscall146.buffers[stream];assert(buffer);if(curr===0||curr===10){(stream===1?Module["print"]:Module["printErr"])(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}})}for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){___syscall146.printChar(stream,HEAPU8[ptr+j])}ret+=len}return ret}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___unlock(){}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}__ATEXIT__.push((function(){var fflush=Module["_fflush"];if(fflush)fflush(0);var printChar=___syscall146.printChar;if(!printChar)return;var buffers=___syscall146.buffers;if(buffers[1].length)printChar(1,10);if(buffers[2].length)printChar(2,10)}));DYNAMICTOP_PTR=allocate(1,"i32",ALLOC_STATIC);STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=Runtime.alignMemory(STACK_MAX);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;staticSealed=true;var ASSERTIONS=false;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){if(ASSERTIONS){assert(false,"Character code "+chr+" ("+String.fromCharCode(chr)+")  at offset "+i+" not in 0x00-0xFF.")}chr&=255}ret.push(String.fromCharCode(chr))}return ret.join("")}Module["intArrayFromString"]=intArrayFromString;Module["intArrayToString"]=intArrayToString;var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var decodeBase64=typeof atob==="function"?atob:(function(input){var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2)}if(enc4!==64){output=output+String.fromCharCode(chr3)}}while(i<input.length);return output});function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer.from(s,"base64")}catch(_){buf=new Buffer(s,"base64")}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i)}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){var dataURIPrefix="data:application/octet-stream;base64,";if(!(String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0)}}function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0)}}Module.asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array,"NaN":NaN,"Infinity":Infinity};Module.asmLibraryArg={"abort":abort,"assert":assert,"enlargeMemory":enlargeMemory,"getTotalMemory":getTotalMemory,"abortOnCannotGrowMemory":abortOnCannotGrowMemory,"invoke_ii":invoke_ii,"invoke_iiii":invoke_iiii,"___lock":___lock,"___setErrNo":___setErrNo,"___syscall140":___syscall140,"___syscall146":___syscall146,"___syscall54":___syscall54,"___syscall6":___syscall6,"___unlock":___unlock,"_emscripten_asm_const_i":_emscripten_asm_const_i,"_emscripten_memcpy_big":_emscripten_memcpy_big,"DYNAMICTOP_PTR":DYNAMICTOP_PTR,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX};// EMSCRIPTEN_START_ASM
 var asm=(/** @suppress {uselessCode} */ function(global,env,buffer) {
 "use asm";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.DYNAMICTOP_PTR|0;var j=env.tempDoublePtr|0;var k=env.ABORT|0;var l=env.STACKTOP|0;var m=env.STACK_MAX|0;var n=0;var o=0;var p=0;var q=0;var r=global.NaN,s=global.Infinity;var t=0,u=0,v=0,w=0,x=0.0;var y=0;var z=global.Math.floor;var A=global.Math.abs;var B=global.Math.sqrt;var C=global.Math.pow;var D=global.Math.cos;var E=global.Math.sin;var F=global.Math.tan;var G=global.Math.acos;var H=global.Math.asin;var I=global.Math.atan;var J=global.Math.atan2;var K=global.Math.exp;var L=global.Math.log;var M=global.Math.ceil;var N=global.Math.imul;var O=global.Math.min;var P=global.Math.max;var Q=global.Math.clz32;var R=env.abort;var S=env.assert;var T=env.enlargeMemory;var U=env.getTotalMemory;var V=env.abortOnCannotGrowMemory;var W=env.invoke_ii;var X=env.invoke_iiii;var Y=env.___lock;var Z=env.___setErrNo;var _=env.___syscall140;var $=env.___syscall146;var aa=env.___syscall54;var ba=env.___syscall6;var ca=env.___unlock;var da=env._emscripten_asm_const_i;var ea=env._emscripten_memcpy_big;var fa=0.0;
 // EMSCRIPTEN_START_FUNCS
diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
index a6c7392..d12f6b9 100644
--- a/contrib/keygen-html/keygen.html
+++ b/contrib/keygen-html/keygen.html
@@ -1,6 +1,9 @@
 <script src="curve25519_generate.js"></script>
 <script>
-// License: GPLv2
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 function generateWireguardKeypair()
 {
 	var privateKey = Module._malloc(32);
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
index df3db05..c82f16d 100644
--- a/contrib/keygen-html/src/curve25519_generate.c
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -1,5 +1,10 @@
-/* License: GPLv2 */
-/* Build with emcc -O3 --memory-init-file 0 -o curve25519_generate.js curve25519_generate.c */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2008 Google Inc. All Rights Reserved.
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * Build with emcc -O3 --memory-init-file 0 -o curve25519_generate.js curve25519_generate.c
+ */
 
 #include <emscripten.h>
 
diff --git a/contrib/nat-hole-punching/nat-punch-client.c b/contrib/nat-hole-punching/nat-punch-client.c
index aa00d35..f27d220 100644
--- a/contrib/nat-hole-punching/nat-punch-client.c
+++ b/contrib/nat-hole-punching/nat-punch-client.c
@@ -1,6 +1,9 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
-
-/* Example only. Do not run in production. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * Example only. Do not run in production.
+ */
 
 #include <stdio.h>
 #include <unistd.h>
diff --git a/contrib/nat-hole-punching/nat-punch-server.c b/contrib/nat-hole-punching/nat-punch-server.c
index ab5ddd7..f9b919b 100644
--- a/contrib/nat-hole-punching/nat-punch-server.c
+++ b/contrib/nat-hole-punching/nat-punch-server.c
@@ -1,6 +1,9 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
-
-/* Example only. Do not run in production. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * Example only. Do not run in production.
+ */
 
 #include <stdio.h>
 #include <unistd.h>
diff --git a/contrib/ncat-client-server/client.sh b/contrib/ncat-client-server/client.sh
index 1d30f49..af081a3 100755
--- a/contrib/ncat-client-server/client.sh
+++ b/contrib/ncat-client-server/client.sh
@@ -1,5 +1,6 @@
 #!/bin/bash
-
+# SPDX-License-Identifier: GPL-2.0
+#
 # Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
diff --git a/contrib/ncat-client-server/server.sh b/contrib/ncat-client-server/server.sh
index b527cf5..d63b7e1 100755
--- a/contrib/ncat-client-server/server.sh
+++ b/contrib/ncat-client-server/server.sh
@@ -1,5 +1,6 @@
 #!/bin/bash
-
+# SPDX-License-Identifier: GPL-2.0
+#
 # Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 if [[ -z $NCAT_REMOTE_ADDR ]]; then
diff --git a/contrib/reresolve-dns/reresolve-dns.sh b/contrib/reresolve-dns/reresolve-dns.sh
index abd5cbf..a1ff5df 100755
--- a/contrib/reresolve-dns/reresolve-dns.sh
+++ b/contrib/reresolve-dns/reresolve-dns.sh
@@ -1,4 +1,8 @@
 #!/bin/bash
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
 set -e
 shopt -s nocasematch
 shopt -s extglob
diff --git a/contrib/sticky-sockets/sticky-sockets.c b/contrib/sticky-sockets/sticky-sockets.c
index 1a910b2..94ba35d 100644
--- a/contrib/sticky-sockets/sticky-sockets.c
+++ b/contrib/sticky-sockets/sticky-sockets.c
@@ -1,4 +1,6 @@
-/* Copyright 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This implements userspace semantics of "sticky sockets", modeled after
  * WireGuard's kernelspace implementation.
diff --git a/contrib/synergy/synergy-client.sh b/contrib/synergy/synergy-client.sh
index ee8727a..d01980a 100755
--- a/contrib/synergy/synergy-client.sh
+++ b/contrib/synergy/synergy-client.sh
@@ -1,5 +1,6 @@
 #!/bin/bash
-
+# SPDX-License-Identifier: GPL-2.0
+#
 # Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
diff --git a/contrib/synergy/synergy-server.sh b/contrib/synergy/synergy-server.sh
index 2832164..65f5a0e 100755
--- a/contrib/synergy/synergy-server.sh
+++ b/contrib/synergy/synergy-server.sh
@@ -1,5 +1,6 @@
 #!/bin/bash
-
+# SPDX-License-Identifier: GPL-2.0
+#
 # Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
diff --git a/src/Makefile b/src/Makefile
index bd727d4..e277b2f 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,3 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
 PKG_CONFIG ?= pkg-config
 PREFIX ?= /usr
 DESTDIR ?=
diff --git a/src/completion/wg-quick.bash-completion b/src/completion/wg-quick.bash-completion
index b931323..f7df346 100644
--- a/src/completion/wg-quick.bash-completion
+++ b/src/completion/wg-quick.bash-completion
@@ -1,4 +1,5 @@
-# Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_quick_completion() {
 	local i a
diff --git a/src/completion/wg.bash-completion b/src/completion/wg.bash-completion
index 5401bc3..9d0a9a5 100644
--- a/src/completion/wg.bash-completion
+++ b/src/completion/wg.bash-completion
@@ -1,4 +1,5 @@
-# Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_completion() {
 	local a
diff --git a/src/config.c b/src/config.c
index 6ff0376..1fddb64 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <arpa/inet.h>
 #include <limits.h>
diff --git a/src/config.h b/src/config.h
index 63a272c..8f29b4f 100644
--- a/src/config.h
+++ b/src/config.h
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #ifndef CONFIG_H
 #define CONFIG_H
diff --git a/src/containers.h b/src/containers.h
index 31eabea..a22c42d 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -1,5 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
-
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #ifndef CONTAINERS_H
 #define CONTAINERS_H
diff --git a/src/curve25519.c b/src/curve25519.c
index 71bd095..f83f76f 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -1,33 +1,9 @@
-/* Original author: Adam Langley <agl@imperialviolet.org>
+/* SPDX-License-Identifier: GPL-2.0
  *
- * Copyright 2008 Google Inc. All Rights Reserved.
+ * Copyright (C) 2008 Google Inc. All Rights Reserved.
  * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
- *   Redistribution and use in source and binary forms of this file, with or
- *   without modification, are permitted provided that the following conditions
- *   are met:
- *
- *       * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *       * Redistributions in binary form must reproduce the above
- *   copyright notice, this list of conditions and the following disclaimer
- *   in the documentation and/or other materials provided with the
- *   distribution.
- *       * Neither the name of Google Inc nor the names of its contributors
- *   may be used to endorse or promote products derived from this software
- *   without specific prior written permission.
- *
- *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Original author: Adam Langley <agl@imperialviolet.org>
  */
 
 #include "curve25519.h"
diff --git a/src/curve25519.h b/src/curve25519.h
index 6e651e9..1108cd8 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #ifndef CURVE25519_H
 #define CURVE25519_H
diff --git a/src/encoding.c b/src/encoding.c
index da5ccef..5d5f6d0 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -1,4 +1,6 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * This is a specialized constant-time base64/hex implementation that resists side-channel attacks.
  */
diff --git a/src/encoding.h b/src/encoding.h
index 1f79a2a..0b0a53e 100644
--- a/src/encoding.h
+++ b/src/encoding.h
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #ifndef ENCODING_H
 #define ENCODING_H
diff --git a/src/genkey.c b/src/genkey.c
index 9a62060..8f3433b 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <errno.h>
 #include <stdio.h>
diff --git a/src/ipc.c b/src/ipc.c
index a88672f..221cd4e 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #ifdef __linux__
 #include <libmnl/libmnl.h>
diff --git a/src/ipc.h b/src/ipc.h
index cb660bb..31ff53f 100644
--- a/src/ipc.h
+++ b/src/ipc.h
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #ifndef IPC_H
 #define IPC_H
diff --git a/src/mnlg.c b/src/mnlg.c
index 8a2b4cc..f0fdfd6 100644
--- a/src/mnlg.c
+++ b/src/mnlg.c
@@ -1,4 +1,6 @@
-/* Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
  */
diff --git a/src/mnlg.h b/src/mnlg.h
index b27a18c..70c2b03 100644
--- a/src/mnlg.h
+++ b/src/mnlg.h
@@ -1,4 +1,6 @@
-/* Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  * Original author: Jiri Pirko <jiri@mellanox.com>
  */
diff --git a/src/pubkey.c b/src/pubkey.c
index 6cced49..39461c2 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <errno.h>
 #include <stdio.h>
diff --git a/src/set.c b/src/set.c
index 57a6428..9ecf94b 100644
--- a/src/set.c
+++ b/src/set.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/src/setconf.c b/src/setconf.c
index 1857ff6..b87a13f 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <stddef.h>
 #include <stdio.h>
diff --git a/src/show.c b/src/show.c
index ebfdf5b..c5be788 100644
--- a/src/show.c
+++ b/src/show.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <arpa/inet.h>
 #include <inttypes.h>
diff --git a/src/showconf.c b/src/showconf.c
index e780d78..2e3fbd4 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <arpa/inet.h>
 #include <netinet/in.h>
diff --git a/src/subcommands.h b/src/subcommands.h
index 7bbf70a..1d977ce 100644
--- a/src/subcommands.h
+++ b/src/subcommands.h
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #ifndef SUBCOMMANDS_H
 #define SUBCOMMANDS_H
diff --git a/src/terminal.c b/src/terminal.c
index 703c75f..c9e4eb5 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <ctype.h>
 #include <stdarg.h>
diff --git a/src/terminal.h b/src/terminal.h
index 2c1fb37..68bd9a3 100644
--- a/src/terminal.h
+++ b/src/terminal.h
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #ifndef TERMINAL_H
 #define TERMINAL_H
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 42bf265..b2acbff 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -1,4 +1,5 @@
 #!/bin/bash
+# SPDX-License-Identifier: GPL-2.0
 #
 # Copyright (C) 2016-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
diff --git a/src/wg.c b/src/wg.c
index 97910ee..94f0857 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -1,4 +1,7 @@
-/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ */
 
 #include <stddef.h>
 #include <stdio.h>

commit f583209935a1dd728dc2708683e92207f53f36bb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 1 19:42:46 2017 +0100

    wg: no need to put this on the stack
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg.c b/src/wg.c
index c0171b6..97910ee 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -42,7 +42,7 @@ int main(int argc, char *argv[])
 	}
 
 	if (argc == 1) {
-		char *new_argv[] = { "show", NULL };
+		static char *new_argv[] = { "show", NULL };
 		return show_main(1, new_argv);
 	}
 

commit 8bf100a25b1211f3548f2fe40b3f01169d0c5283
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 1 19:41:16 2017 +0100

    wg: remove undocumented unused syntax
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg.c b/src/wg.c
index 9834271..c0171b6 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -34,8 +34,6 @@ static void show_usage(FILE *file)
 
 int main(int argc, char *argv[])
 {
-	char *tmp = NULL;
-
 	PROG_NAME = argv[0];
 
 	if (argc == 2 && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "help"))) {
@@ -48,20 +46,11 @@ int main(int argc, char *argv[])
 		return show_main(1, new_argv);
 	}
 
-findsubcommand:
 	for (size_t i = 0; i < sizeof(subcommands) / sizeof(subcommands[0]); ++i) {
 		if (!strcmp(argv[1], subcommands[i].subcommand))
 			return subcommands[i].function(argc - 1, argv + 1);
 	}
 
-	/* Crude way of supporting "wg wg0 show..." */
-	if (!tmp && argc >= 3) {
-		tmp = argv[1];
-		argv[1] = argv[2];
-		argv[2] = tmp;
-		goto findsubcommand;
-	}
-
 	fprintf(stderr, "Invalid subcommand: `%s'\n", argv[1]);
 	show_usage(stderr);
 	return 1;

commit bee819f2890f55fedebbc646f6d651d171ce70b2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 1 13:31:33 2017 +0100

    contrib: keygen-html for generating keys in the browser
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/keygen-html/README b/contrib/keygen-html/README
new file mode 100644
index 0000000..f1c3412
--- /dev/null
+++ b/contrib/keygen-html/README
@@ -0,0 +1,19 @@
+WireGuard Key Generation in JavaScript
+======================================
+
+Various people believe in JavaScript crypto, unfortunately. This small
+example helps them fuel their poor taste.
+
+It's possible to generate WireGuard keys (and thus configurations) in the
+browser. The webpage here simulates talking to a server to exchange keys
+and then generates a configuration file for the user to download.
+
+Bugs
+----
+
+Who knows how emscripten actually compiles this and whether or not it
+introduces interesting side-channel attacks.
+
+Secrets aren't zerored after use. Maybe you can get around this with
+some tricks taking advantage of browser allocator behavior and different
+processes, but it seems pretty hard.
diff --git a/contrib/keygen-html/curve25519_generate.js b/contrib/keygen-html/curve25519_generate.js
new file mode 100644
index 0000000..cfbf581
--- /dev/null
+++ b/contrib/keygen-html/curve25519_generate.js
@@ -0,0 +1,16 @@
+/* License: GPLv2 */ var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;if(Module["ENVIRONMENT"]){if(Module["ENVIRONMENT"]==="WEB"){ENVIRONMENT_IS_WEB=true}else if(Module["ENVIRONMENT"]==="WORKER"){ENVIRONMENT_IS_WORKER=true}else if(Module["ENVIRONMENT"]==="NODE"){ENVIRONMENT_IS_NODE=true}else if(Module["ENVIRONMENT"]==="SHELL"){ENVIRONMENT_IS_SHELL=true}else{throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.")}}else{ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER}if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=console.log;if(!Module["printErr"])Module["printErr"]=console.warn;var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=require("fs");if(!nodePath)nodePath=require("path");filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename)}return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(!Module["thisProgram"]){if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}else{Module["thisProgram"]="unknown-program"}}Module["arguments"]=process["argv"].slice(2);if(typeof module!=="undefined"){module["exports"]=Module}process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}));Module["inspect"]=(function(){return"[Emscripten Module object]"})}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined"){Module["read"]=function shell_read(f){var data=tryParseAsDataURI(f);if(data){return intArrayToString(data)}return read(f)}}else{Module["read"]=function shell_read(){throw"no read() available"}}Module["readBinary"]=function readBinary(f){var data;data=tryParseAsDataURI(f);if(data){return data}if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs}else if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof quit==="function"){Module["quit"]=(function(status,toThrow){quit(status)})}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function shell_read(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){Module["readBinary"]=function readBinary(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}}}Module["readAsync"]=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror()};xhr.onerror=onerror;xhr.send(null)};if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=function shell_print(x){console.log(x)};if(!Module["printErr"])Module["printErr"]=function shell_printErr(x){console.warn(x)}}else{var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?(function(x){dump(x)}):(function(x){})}if(typeof Module["setWindowTitle"]==="undefined"){Module["setWindowTitle"]=(function(title){document.title=title})}}else{throw new Error("Unknown runtime environment. Where are we?")}if(!Module["print"]){Module["print"]=(function(){})}if(!Module["printErr"]){Module["printErr"]=Module["print"]}if(!Module["arguments"]){Module["arguments"]=[]}if(!Module["thisProgram"]){Module["thisProgram"]="./this.program"}if(!Module["quit"]){Module["quit"]=(function(status,toThrow){throw toThrow})}Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=undefined;var Runtime={setTempRet0:(function(value){tempRet0=value;return value}),getTempRet0:(function(){return tempRet0}),stackSave:(function(){return STACKTOP}),stackRestore:(function(stackTop){STACKTOP=stackTop}),getNativeTypeSize:(function(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return Runtime.QUANTUM_SIZE}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else{return 0}}}}),getNativeFieldSize:(function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)}),STACK_ALIGN:16,prepVararg:(function(ptr,type){if(type==="double"||type==="i64"){if(ptr&7){assert((ptr&7)===4);ptr+=4}}else{assert((ptr&3)===0)}return ptr}),getAlignSize:(function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)}),dynCall:(function(sig,ptr,args){if(args&&args.length){return Module["dynCall_"+sig].apply(null,[ptr].concat(args))}else{return Module["dynCall_"+sig].call(null,ptr)}}),functionPointers:[],addFunction:(function(func){for(var i=0;i<Runtime.functionPointers.length;i++){if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=func;return 2*(1+i)}}throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."}),removeFunction:(function(index){Runtime.functionPointers[(index-2)/2]=null}),warnOnce:(function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown={};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}}),funcWrappers:{},getFuncWrapper:(function(func,sig){if(!func)return;assert(sig);if(!Runtime.funcWrappers[sig]){Runtime.funcWrappers[sig]={}}var sigCache=Runtime.funcWrappers[sig];if(!sigCache[func]){if(sig.length===1){sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func)}}else if(sig.length===2){sigCache[func]=function dynCall_wrapper(arg){return Runtime.dynCall(sig,func,[arg])}}else{sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,Array.prototype.slice.call(arguments))}}}return sigCache[func]}),getCompilerSetting:(function(name){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"}),stackAlloc:(function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+15&-16;return ret}),staticAlloc:(function(size){var ret=STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+15&-16;return ret}),dynamicAlloc:(function(size){var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=(ret+size+15|0)&-16;HEAP32[DYNAMICTOP_PTR>>2]=end;if(end>=TOTAL_MEMORY){var success=enlargeMemory();if(!success){HEAP32[DYNAMICTOP_PTR>>2]=ret;return 0}}return ret}),alignMemory:(function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:16))*(quantum?quantum:16);return ret}),makeBigInt:(function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret}),GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var ABORT=0;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}var JSfuncs={"stackSave":(function(){Runtime.stackSave()}),"stackRestore":(function(){Runtime.stackRestore()}),"arrayToC":(function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=Runtime.stackAlloc(len);stringToUTF8(str,ret,len)}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};function ccall(ident,returnType,argTypes,args,opts){var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0){Runtime.stackRestore(stack)}return ret}function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident);var numericArgs=argTypes.every((function(type){return type==="number"}));var numericRet=returnType!=="string";if(numericRet&&numericArgs){return cfunc}return(function(){return ccall(ident,returnType,argTypes,arguments)})}Module["ccall"]=ccall;Module["cwrap"]=cwrap;function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}Module["setValue"]=setValue;function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for getValue: "+type)}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[typeof _malloc==="function"?_malloc:Runtime.staticAlloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var stop;ptr=ret;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function"){curr=Runtime.getFunctionIndex(curr)}type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}Module["allocate"]=allocate;function getMemory(size){if(!staticSealed)return Runtime.staticAlloc(size);if(!runtimeInitialized)return Runtime.dynamicAlloc(size);return _malloc(size)}Module["getMemory"]=getMemory;function Pointer_stringify(ptr,length){if(length===0||!ptr)return"";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}return Module["UTF8ToString"](ptr)}Module["Pointer_stringify"]=Pointer_stringify;function AsciiToString(ptr){var str="";while(1){var ch=HEAP8[ptr++>>0];if(!ch)return str;str+=String.fromCharCode(ch)}}Module["AsciiToString"]=AsciiToString;function stringToAscii(str,outPtr){return writeAsciiToMemory(str,outPtr,false)}Module["stringToAscii"]=stringToAscii;var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx){var endPtr=idx;while(u8Array[endPtr])++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var u0,u1,u2,u3,u4,u5;var str="";while(1){u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u3=u8Array[idx++]&63;if((u0&248)==240){u0=(u0&7)<<18|u1<<12|u2<<6|u3}else{u4=u8Array[idx++]&63;if((u0&252)==248){u0=(u0&3)<<24|u1<<18|u2<<12|u3<<6|u4}else{u5=u8Array[idx++]&63;u0=(u0&1)<<30|u1<<24|u2<<18|u3<<12|u4<<6|u5}}}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}}Module["UTF8ArrayToString"]=UTF8ArrayToString;function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}Module["UTF8ToString"]=UTF8ToString;function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=2097151){if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=67108863){if(outIdx+4>=endIdx)break;outU8Array[outIdx++]=248|u>>24;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+5>=endIdx)break;outU8Array[outIdx++]=252|u>>30;outU8Array[outIdx++]=128|u>>24&63;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}Module["stringToUTF8Array"]=stringToUTF8Array;function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}Module["stringToUTF8"]=stringToUTF8;function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){++len}else if(u<=2047){len+=2}else if(u<=65535){len+=3}else if(u<=2097151){len+=4}else if(u<=67108863){len+=5}else{len+=6}}return len}Module["lengthBytesUTF8"]=lengthBytesUTF8;var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function demangle(func){var __cxa_demangle_func=Module["___cxa_demangle"]||Module["__cxa_demangle"];if(__cxa_demangle_func){try{var s=func.substr(1);var len=lengthBytesUTF8(s)+1;var buf=_malloc(len);stringToUTF8(s,buf,len);var status=_malloc(4);var ret=__cxa_demangle_func(buf,0,0,status);if(getValue(status,"i32")===0&&ret){return Pointer_stringify(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}return func}Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");return func}function demangleAll(text){var regex=/__Z[\w\d_]+/g;return text.replace(regex,(function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}Module["stackTrace"]=stackTrace;var HEAP,buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer)}var STATIC_BASE,STATICTOP,staticSealed;var STACK_BASE,STACKTOP,STACK_MAX;var DYNAMIC_BASE,DYNAMICTOP_PTR;STATIC_BASE=STATICTOP=STACK_BASE=STACKTOP=STACK_MAX=DYNAMIC_BASE=DYNAMICTOP_PTR=0;staticSealed=false;function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function enlargeMemory(){abortOnCannotGrowMemory()}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(TOTAL_MEMORY<TOTAL_STACK)Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");if(Module["buffer"]){buffer=Module["buffer"]}else{{buffer=new ArrayBuffer(TOTAL_MEMORY)}}updateGlobalBufferViews();function getTotalMemory(){return TOTAL_MEMORY}HEAP32[0]=1668509029;HEAP16[1]=25459;if(HEAPU8[2]!==115||HEAPU8[3]!==99)throw"Runtime error: expected the system to be little-endian!";Module["HEAP"]=HEAP;Module["buffer"]=buffer;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func)}else{Module["dynCall_vi"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module["addOnPreRun"]=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module["addOnInit"]=addOnInit;function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module["addOnPreMain"]=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module["addOnExit"]=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module["addOnPostRun"]=addOnPostRun;function writeStringToMemory(string,buffer,dontAddNull){Runtime.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var lastChar,end;if(dontAddNull){end=buffer+lengthBytesUTF8(string);lastChar=HEAP8[end]}stringToUTF8(string,buffer,Infinity);if(dontAddNull)HEAP8[end]=lastChar}Module["writeStringToMemory"]=writeStringToMemory;function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}Module["writeAsciiToMemory"]=writeAsciiToMemory;if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];if(!Math["clz32"])Math["clz32"]=(function(x){x=x>>>0;for(var i=0;i<32;i++){if(x&1<<31-i)return i}return 32});Math.clz32=Math["clz32"];if(!Math["trunc"])Math["trunc"]=(function(x){return x<0?Math.ceil(x):Math.floor(x)});Math.trunc=Math["trunc"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_round=Math.round;var Math_min=Math.min;var Math_clz32=Math.clz32;var Math_trunc=Math.trunc;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}Module["addRunDependency"]=addRunDependency;function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;var ASM_CONSTS=[(function(){var getRandomValue=(function(){var buf=new Uint32Array(1);window.crypto.getRandomValues(buf);return buf[0]>>>0});Module.getRandomValue=getRandomValue}),(function(){return Module.getRandomValue()})];function _emscripten_asm_const_i(code){return ASM_CONSTS[code]()}STATIC_BASE=Runtime.GLOBAL_BASE;STATICTOP=STATIC_BASE+2192;__ATINIT__.push();memoryInitializer="data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAACAAAAjAQAAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAr/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAAeyB2YXIgZ2V0UmFuZG9tVmFsdWUgPSBmdW5jdGlvbigpIHsgdmFyIGJ1ZiA9IG5ldyBVaW50MzJBcnJheSgxKTsgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmKTsgcmV0dXJuIGJ1ZlswXSA+Pj4gMDsgfTsgTW9kdWxlLmdldFJhbmRvbVZhbHVlID0gZ2V0UmFuZG9tVmFsdWU7IH0AeyByZXR1cm4gTW9kdWxlLmdldFJhbmRvbVZhbHVlKCk7IH0=";var tempDoublePtr=STATICTOP;STATICTOP+=16;function ___lock(){}var SYSCALLS={varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=Pointer_stringify(SYSCALLS.get());return ret}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0)})};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;if(!___syscall146.buffer){___syscall146.buffers=[null,[],[]];___syscall146.printChar=(function(stream,curr){var buffer=___syscall146.buffers[stream];assert(buffer);if(curr===0||curr===10){(stream===1?Module["print"]:Module["printErr"])(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}})}for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){___syscall146.printChar(stream,HEAPU8[ptr+j])}ret+=len}return ret}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___unlock(){}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}__ATEXIT__.push((function(){var fflush=Module["_fflush"];if(fflush)fflush(0);var printChar=___syscall146.printChar;if(!printChar)return;var buffers=___syscall146.buffers;if(buffers[1].length)printChar(1,10);if(buffers[2].length)printChar(2,10)}));DYNAMICTOP_PTR=allocate(1,"i32",ALLOC_STATIC);STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=Runtime.alignMemory(STACK_MAX);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;staticSealed=true;var ASSERTIONS=false;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){if(ASSERTIONS){assert(false,"Character code "+chr+" ("+String.fromCharCode(chr)+")  at offset "+i+" not in 0x00-0xFF.")}chr&=255}ret.push(String.fromCharCode(chr))}return ret.join("")}Module["intArrayFromString"]=intArrayFromString;Module["intArrayToString"]=intArrayToString;var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var decodeBase64=typeof atob==="function"?atob:(function(input){var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2)}if(enc4!==64){output=output+String.fromCharCode(chr3)}}while(i<input.length);return output});function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer.from(s,"base64")}catch(_){buf=new Buffer(s,"base64")}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i)}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){var dataURIPrefix="data:application/octet-stream;base64,";if(!(String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0)}}function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0)}}Module.asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array,"NaN":NaN,"Infinity":Infinity};Module.asmLibraryArg={"abort":abort,"assert":assert,"enlargeMemory":enlargeMemory,"getTotalMemory":getTotalMemory,"abortOnCannotGrowMemory":abortOnCannotGrowMemory,"invoke_ii":invoke_ii,"invoke_iiii":invoke_iiii,"___lock":___lock,"___setErrNo":___setErrNo,"___syscall140":___syscall140,"___syscall146":___syscall146,"___syscall54":___syscall54,"___syscall6":___syscall6,"___unlock":___unlock,"_emscripten_asm_const_i":_emscripten_asm_const_i,"_emscripten_memcpy_big":_emscripten_memcpy_big,"DYNAMICTOP_PTR":DYNAMICTOP_PTR,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX};// EMSCRIPTEN_START_ASM
+var asm=(/** @suppress {uselessCode} */ function(global,env,buffer) {
+"use asm";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.DYNAMICTOP_PTR|0;var j=env.tempDoublePtr|0;var k=env.ABORT|0;var l=env.STACKTOP|0;var m=env.STACK_MAX|0;var n=0;var o=0;var p=0;var q=0;var r=global.NaN,s=global.Infinity;var t=0,u=0,v=0,w=0,x=0.0;var y=0;var z=global.Math.floor;var A=global.Math.abs;var B=global.Math.sqrt;var C=global.Math.pow;var D=global.Math.cos;var E=global.Math.sin;var F=global.Math.tan;var G=global.Math.acos;var H=global.Math.asin;var I=global.Math.atan;var J=global.Math.atan2;var K=global.Math.exp;var L=global.Math.log;var M=global.Math.ceil;var N=global.Math.imul;var O=global.Math.min;var P=global.Math.max;var Q=global.Math.clz32;var R=env.abort;var S=env.assert;var T=env.enlargeMemory;var U=env.getTotalMemory;var V=env.abortOnCannotGrowMemory;var W=env.invoke_ii;var X=env.invoke_iiii;var Y=env.___lock;var Z=env.___setErrNo;var _=env.___syscall140;var $=env.___syscall146;var aa=env.___syscall54;var ba=env.___syscall6;var ca=env.___unlock;var da=env._emscripten_asm_const_i;var ea=env._emscripten_memcpy_big;var fa=0.0;
+// EMSCRIPTEN_START_FUNCS
+function ia(a){a=a|0;var b=0;b=l;l=l+a|0;l=l+15&-16;return b|0}function ja(){return l|0}function ka(a){a=a|0;l=a}function la(a,b){a=a|0;b=b|0;l=a;m=b}function ma(a,b){a=a|0;b=b|0;if(!n){n=a;o=b}}function na(a){a=a|0;y=a}function oa(){return y|0}function pa(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Ra=0,Sa=0,Va=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Fb=0,Gb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,Nb=0,Ob=0,Pb=0,Qb=0,Rb=0,Sb=0,Tb=0,Ub=0,Vb=0,Wb=0,Xb=0;Ob=l;l=l+2640|0;rb=Ob+2456|0;sb=Ob+2304|0;Mb=Ob+2152|0;tb=Ob+2e3|0;ub=Ob+1848|0;vb=Ob+1696|0;Nb=Ob+1544|0;Fb=Ob+1392|0;Gb=Ob+1240|0;Hb=Ob+1088|0;h=Ob+936|0;g=Ob+784|0;f=Ob+632|0;e=Ob+480|0;Ib=Ob+328|0;pb=Ob+248|0;Jb=Ob+168|0;Kb=Ob+80|0;Lb=Ob;qb=Ob+2608|0;ob=qb;da=ob+32|0;do{a[ob>>0]=a[d>>0]|0;ob=ob+1|0;d=d+1|0}while((ob|0)<(da|0));a[qb>>0]=a[qb>>0]&-8;ob=qb+31|0;a[ob>>0]=a[ob>>0]&63|64;ob=pb;c[ob>>2]=9;c[ob+4>>2]=0;ob=pb+8|0;da=ob+72|0;do{c[ob>>2]=0;ob=ob+4|0}while((ob|0)<(da|0));Wa(Fb+8|0,0,144)|0;ob=Fb;c[ob>>2]=1;c[ob+4>>2]=0;Wa(Gb+8|0,0,144)|0;ob=Gb;c[ob>>2]=1;c[ob+4>>2]=0;Wa(Hb|0,0,152)|0;Wa(h|0,0,152)|0;Wa(g+8|0,0,144)|0;ob=g;c[ob>>2]=1;c[ob+4>>2]=0;Wa(f|0,0,152)|0;Wa(e+8|0,0,144)|0;ob=e;c[ob>>2]=1;c[ob+4>>2]=0;ob=Nb+80|0;da=ob+72|0;do{c[ob>>2]=0;ob=ob+4|0}while((ob|0)<(da|0));ob=Nb;d=pb;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));oa=Mb+144|0;pa=Mb+64|0;qa=Mb+136|0;ra=Mb+56|0;wa=Mb+128|0;xa=Mb+48|0;ya=Mb+120|0;za=Mb+40|0;Aa=Mb+112|0;Ba=Mb+32|0;Ca=Mb+104|0;Da=Mb+24|0;Ea=Mb+96|0;Fa=Mb+16|0;Ga=Mb+88|0;Ha=Mb+8|0;Ia=Mb+80|0;Ja=tb+144|0;Ka=tb+64|0;La=tb+136|0;Ma=tb+56|0;Na=tb+128|0;Oa=tb+48|0;Pa=tb+120|0;Ra=tb+40|0;Sa=tb+112|0;Va=tb+32|0;Xa=tb+104|0;Ya=tb+24|0;Za=tb+96|0;_a=tb+16|0;$a=tb+88|0;ab=tb+8|0;bb=tb+80|0;fa=Mb+72|0;cb=tb+72|0;db=rb+8|0;eb=sb+8|0;fb=rb+16|0;gb=sb+16|0;hb=rb+24|0;ib=sb+24|0;jb=rb+32|0;kb=sb+32|0;lb=rb+40|0;mb=sb+40|0;nb=rb+48|0;ga=sb+48|0;ha=rb+56|0;ia=sb+56|0;ja=rb+64|0;ka=sb+64|0;la=rb+72|0;ma=sb+72|0;wb=Ib+80|0;xb=Ib+8|0;yb=Ib+16|0;zb=Ib+24|0;Ab=Ib+32|0;Bb=Ib+40|0;Cb=Ib+48|0;Db=Ib+56|0;Eb=Ib+64|0;na=Ib+72|0;m=Nb;ea=0;d=Fb;i=Hb;j=Gb;while(1){k=a[qb+(31-ea)>>0]|0;$=0;aa=e;ba=f;ca=g;g=d;e=i;f=j;_=m;while(1){Y=k&255;Z=Y>>>7;sa(f,_,Z,0);sa(e,g,Z,0);x=f;k=c[x>>2]|0;x=c[x+4>>2]|0;V=f+8|0;T=V;G=c[T>>2]|0;T=c[T+4>>2]|0;Sb=f+16|0;B=Sb;A=c[B>>2]|0;B=c[B+4>>2]|0;C=f+24|0;Pb=C;W=c[Pb>>2]|0;Pb=c[Pb+4>>2]|0;t=f+32|0;u=t;Tb=c[u>>2]|0;u=c[u+4>>2]|0;r=f+40|0;m=r;D=c[m>>2]|0;m=c[m+4>>2]|0;S=f+48|0;da=S;X=c[da>>2]|0;da=c[da+4>>2]|0;J=f+56|0;E=J;P=c[E>>2]|0;E=c[E+4>>2]|0;Ub=f+64|0;v=Ub;M=c[v>>2]|0;v=c[v+4>>2]|0;q=f+72|0;Qb=q;Rb=c[Qb>>2]|0;Qb=c[Qb+4>>2]|0;z=e;L=c[z>>2]|0;z=c[z+4>>2]|0;s=Ta(L|0,z|0,k|0,x|0)|0;o=f;c[o>>2]=s;c[o+4>>2]=y;o=e+8|0;s=o;U=c[s>>2]|0;s=c[s+4>>2]|0;I=Ta(U|0,s|0,G|0,T|0)|0;c[V>>2]=I;c[V+4>>2]=y;V=e+16|0;I=V;O=c[I>>2]|0;I=c[I+4>>2]|0;j=Ta(O|0,I|0,A|0,B|0)|0;c[Sb>>2]=j;c[Sb+4>>2]=y;Sb=e+24|0;j=Sb;i=c[j>>2]|0;j=c[j+4>>2]|0;Wb=Ta(i|0,j|0,W|0,Pb|0)|0;c[C>>2]=Wb;c[C+4>>2]=y;C=e+32|0;Wb=C;p=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;K=Ta(p|0,Wb|0,Tb|0,u|0)|0;c[t>>2]=K;c[t+4>>2]=y;t=e+40|0;K=t;Q=c[K>>2]|0;K=c[K+4>>2]|0;w=Ta(Q|0,K|0,D|0,m|0)|0;c[r>>2]=w;c[r+4>>2]=y;r=e+48|0;w=r;H=c[w>>2]|0;w=c[w+4>>2]|0;n=Ta(H|0,w|0,X|0,da|0)|0;c[S>>2]=n;c[S+4>>2]=y;S=e+56|0;n=S;F=c[n>>2]|0;n=c[n+4>>2]|0;ob=Ta(F|0,n|0,P|0,E|0)|0;c[J>>2]=ob;c[J+4>>2]=y;J=e+64|0;ob=J;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;Vb=Ta(d|0,ob|0,M|0,v|0)|0;c[Ub>>2]=Vb;c[Ub+4>>2]=y;Ub=e+72|0;Vb=Ub;R=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Xb=Ta(R|0,Vb|0,Rb|0,Qb|0)|0;c[q>>2]=Xb;c[q+4>>2]=y;z=Ua(k|0,x|0,L|0,z|0)|0;L=e;c[L>>2]=z;c[L+4>>2]=y;s=Ua(G|0,T|0,U|0,s|0)|0;c[o>>2]=s;c[o+4>>2]=y;I=Ua(A|0,B|0,O|0,I|0)|0;c[V>>2]=I;c[V+4>>2]=y;j=Ua(W|0,Pb|0,i|0,j|0)|0;c[Sb>>2]=j;c[Sb+4>>2]=y;Wb=Ua(Tb|0,u|0,p|0,Wb|0)|0;c[C>>2]=Wb;c[C+4>>2]=y;K=Ua(D|0,m|0,Q|0,K|0)|0;c[t>>2]=K;c[t+4>>2]=y;w=Ua(X|0,da|0,H|0,w|0)|0;c[r>>2]=w;c[r+4>>2]=y;n=Ua(P|0,E|0,F|0,n|0)|0;c[S>>2]=n;c[S+4>>2]=y;ob=Ua(M|0,v|0,d|0,ob|0)|0;c[J>>2]=ob;c[J+4>>2]=y;Vb=Ua(Rb|0,Qb|0,R|0,Vb|0)|0;c[Ub>>2]=Vb;c[Ub+4>>2]=y;Ub=_;Vb=c[Ub>>2]|0;Ub=c[Ub+4>>2]|0;R=_+8|0;Qb=R;Rb=c[Qb>>2]|0;Qb=c[Qb+4>>2]|0;J=_+16|0;ob=J;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;v=_+24|0;M=v;S=c[M>>2]|0;M=c[M+4>>2]|0;n=_+32|0;F=n;E=c[F>>2]|0;F=c[F+4>>2]|0;P=_+40|0;r=P;w=c[r>>2]|0;r=c[r+4>>2]|0;H=_+48|0;da=H;X=c[da>>2]|0;da=c[da+4>>2]|0;t=_+56|0;K=t;Q=c[K>>2]|0;K=c[K+4>>2]|0;m=_+64|0;D=m;C=c[D>>2]|0;D=c[D+4>>2]|0;Wb=_+72|0;p=Wb;u=c[p>>2]|0;p=c[p+4>>2]|0;Tb=g;Sb=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;j=Ta(Sb|0,Tb|0,Vb|0,Ub|0)|0;i=_;c[i>>2]=j;c[i+4>>2]=y;i=g+8|0;j=i;Pb=c[j>>2]|0;j=c[j+4>>2]|0;W=Ta(Pb|0,j|0,Rb|0,Qb|0)|0;c[R>>2]=W;c[R+4>>2]=y;R=g+16|0;W=R;V=c[W>>2]|0;W=c[W+4>>2]|0;I=Ta(V|0,W|0,d|0,ob|0)|0;c[J>>2]=I;c[J+4>>2]=y;J=g+24|0;I=J;O=c[I>>2]|0;I=c[I+4>>2]|0;B=Ta(O|0,I|0,S|0,M|0)|0;c[v>>2]=B;c[v+4>>2]=y;v=g+32|0;B=v;A=c[B>>2]|0;B=c[B+4>>2]|0;o=Ta(A|0,B|0,E|0,F|0)|0;c[n>>2]=o;c[n+4>>2]=y;n=g+40|0;o=n;s=c[o>>2]|0;o=c[o+4>>2]|0;U=Ta(s|0,o|0,w|0,r|0)|0;c[P>>2]=U;c[P+4>>2]=y;P=g+48|0;U=P;T=c[U>>2]|0;U=c[U+4>>2]|0;G=Ta(T|0,U|0,X|0,da|0)|0;c[H>>2]=G;c[H+4>>2]=y;H=g+56|0;G=H;L=c[G>>2]|0;G=c[G+4>>2]|0;z=Ta(L|0,G|0,Q|0,K|0)|0;c[t>>2]=z;c[t+4>>2]=y;t=g+64|0;z=t;x=c[z>>2]|0;z=c[z+4>>2]|0;k=Ta(x|0,z|0,C|0,D|0)|0;c[m>>2]=k;c[m+4>>2]=y;m=g+72|0;k=m;q=c[k>>2]|0;k=c[k+4>>2]|0;Xb=Ta(q|0,k|0,u|0,p|0)|0;c[Wb>>2]=Xb;c[Wb+4>>2]=y;Tb=Ua(Vb|0,Ub|0,Sb|0,Tb|0)|0;Sb=g;c[Sb>>2]=Tb;c[Sb+4>>2]=y;j=Ua(Rb|0,Qb|0,Pb|0,j|0)|0;c[i>>2]=j;c[i+4>>2]=y;W=Ua(d|0,ob|0,V|0,W|0)|0;c[R>>2]=W;c[R+4>>2]=y;I=Ua(S|0,M|0,O|0,I|0)|0;c[J>>2]=I;c[J+4>>2]=y;B=Ua(E|0,F|0,A|0,B|0)|0;c[v>>2]=B;c[v+4>>2]=y;o=Ua(w|0,r|0,s|0,o|0)|0;c[n>>2]=o;c[n+4>>2]=y;U=Ua(X|0,da|0,T|0,U|0)|0;c[P>>2]=U;c[P+4>>2]=y;G=Ua(Q|0,K|0,L|0,G|0)|0;c[H>>2]=G;c[H+4>>2]=y;z=Ua(C|0,D|0,x|0,z|0)|0;c[t>>2]=z;c[t+4>>2]=y;k=Ua(u|0,p|0,q|0,k|0)|0;c[m>>2]=k;c[m+4>>2]=y;ta(Mb,_,e);ta(tb,f,g);m=oa;k=c[m>>2]|0;m=c[m+4>>2]|0;q=pa;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=pa;c[u>>2]=t;c[u+4>>2]=y;u=qa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=ra;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=ra;c[q>>2]=p;c[q+4>>2]=y;q=wa;p=c[q>>2]|0;q=c[q+4>>2]|0;u=xa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=xa;c[m>>2]=k;c[m+4>>2]=y;m=ya;k=c[m>>2]|0;m=c[m+4>>2]|0;q=za;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=za;c[u>>2]=t;c[u+4>>2]=y;u=Aa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Ba;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=Ba;c[q>>2]=p;c[q+4>>2]=y;q=Ca;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Da;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=Da;c[m>>2]=k;c[m+4>>2]=y;m=Ea;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Fa;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=Fa;c[u>>2]=t;c[u+4>>2]=y;u=Ga;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Ha;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=Ha;c[q>>2]=p;c[q+4>>2]=y;q=Ia;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Mb;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=Mb;c[m>>2]=k;c[m+4>>2]=y;ua(Mb);m=Ja;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Ka;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=Ka;c[u>>2]=t;c[u+4>>2]=y;u=La;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Ma;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=Ma;c[q>>2]=p;c[q+4>>2]=y;q=Na;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Oa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=Oa;c[m>>2]=k;c[m+4>>2]=y;m=Pa;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Ra;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=Ra;c[u>>2]=t;c[u+4>>2]=y;u=Sa;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Va;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=Va;c[q>>2]=p;c[q+4>>2]=y;q=Xa;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Ya;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=Ya;c[m>>2]=k;c[m+4>>2]=y;m=Za;k=c[m>>2]|0;m=c[m+4>>2]|0;q=_a;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Qa(k|0,m|0,18,0)|0;t=y;m=Ta(p|0,q|0,k|0,m|0)|0;t=Ta(m|0,y|0,u|0,t|0)|0;u=_a;c[u>>2]=t;c[u+4>>2]=y;u=$a;t=c[u>>2]|0;u=c[u+4>>2]|0;m=ab;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Qa(t|0,u|0,18,0)|0;p=y;u=Ta(k|0,m|0,t|0,u|0)|0;p=Ta(u|0,y|0,q|0,p|0)|0;q=ab;c[q>>2]=p;c[q+4>>2]=y;q=bb;p=c[q>>2]|0;q=c[q+4>>2]|0;u=tb;t=c[u>>2]|0;u=c[u+4>>2]|0;m=Qa(p|0,q|0,18,0)|0;k=y;q=Ta(t|0,u|0,p|0,q|0)|0;k=Ta(q|0,y|0,m|0,k|0)|0;m=tb;c[m>>2]=k;c[m+4>>2]=y;ua(tb);m=Mb;k=c[m>>2]|0;m=c[m+4>>2]|0;q=Ha;p=c[q>>2]|0;q=c[q+4>>2]|0;u=Fa;t=c[u>>2]|0;u=c[u+4>>2]|0;z=Da;x=c[z>>2]|0;z=c[z+4>>2]|0;D=Ba;C=c[D>>2]|0;D=c[D+4>>2]|0;H=za;G=c[H>>2]|0;H=c[H+4>>2]|0;L=xa;K=c[L>>2]|0;L=c[L+4>>2]|0;Q=ra;P=c[Q>>2]|0;Q=c[Q+4>>2]|0;U=pa;T=c[U>>2]|0;U=c[U+4>>2]|0;da=fa;X=c[da>>2]|0;da=c[da+4>>2]|0;n=tb;o=c[n>>2]|0;n=c[n+4>>2]|0;s=Ta(o|0,n|0,k|0,m|0)|0;r=Mb;c[r>>2]=s;c[r+4>>2]=y;r=ab;s=c[r>>2]|0;r=c[r+4>>2]|0;w=Ta(s|0,r|0,p|0,q|0)|0;v=Ha;c[v>>2]=w;c[v+4>>2]=y;v=_a;w=c[v>>2]|0;v=c[v+4>>2]|0;B=Ta(w|0,v|0,t|0,u|0)|0;A=Fa;c[A>>2]=B;c[A+4>>2]=y;A=Ya;B=c[A>>2]|0;A=c[A+4>>2]|0;F=Ta(B|0,A|0,x|0,z|0)|0;E=Da;c[E>>2]=F;c[E+4>>2]=y;E=Va;F=c[E>>2]|0;E=c[E+4>>2]|0;J=Ta(F|0,E|0,C|0,D|0)|0;I=Ba;c[I>>2]=J;c[I+4>>2]=y;I=Ra;J=c[I>>2]|0;I=c[I+4>>2]|0;O=Ta(J|0,I|0,G|0,H|0)|0;M=za;c[M>>2]=O;c[M+4>>2]=y;M=Oa;O=c[M>>2]|0;M=c[M+4>>2]|0;S=Ta(O|0,M|0,K|0,L|0)|0;R=xa;c[R>>2]=S;c[R+4>>2]=y;R=Ma;S=c[R>>2]|0;R=c[R+4>>2]|0;W=Ta(S|0,R|0,P|0,Q|0)|0;V=ra;c[V>>2]=W;c[V+4>>2]=y;V=Ka;W=c[V>>2]|0;V=c[V+4>>2]|0;ob=Ta(W|0,V|0,T|0,U|0)|0;d=pa;c[d>>2]=ob;c[d+4>>2]=y;d=cb;ob=c[d>>2]|0;d=c[d+4>>2]|0;i=Ta(ob|0,d|0,X|0,da|0)|0;j=fa;c[j>>2]=i;c[j+4>>2]=y;n=Ua(k|0,m|0,o|0,n|0)|0;o=tb;c[o>>2]=n;c[o+4>>2]=y;r=Ua(p|0,q|0,s|0,r|0)|0;s=ab;c[s>>2]=r;c[s+4>>2]=y;v=Ua(t|0,u|0,w|0,v|0)|0;w=_a;c[w>>2]=v;c[w+4>>2]=y;A=Ua(x|0,z|0,B|0,A|0)|0;B=Ya;c[B>>2]=A;c[B+4>>2]=y;E=Ua(C|0,D|0,F|0,E|0)|0;F=Va;c[F>>2]=E;c[F+4>>2]=y;I=Ua(G|0,H|0,J|0,I|0)|0;J=Ra;c[J>>2]=I;c[J+4>>2]=y;M=Ua(K|0,L|0,O|0,M|0)|0;O=Oa;c[O>>2]=M;c[O+4>>2]=y;R=Ua(P|0,Q|0,S|0,R|0)|0;S=Ma;c[S>>2]=R;c[S+4>>2]=y;V=Ua(T|0,U|0,W|0,V|0)|0;W=Ka;c[W>>2]=V;c[W+4>>2]=y;d=Ua(X|0,da|0,ob|0,d|0)|0;ob=cb;c[ob>>2]=d;c[ob+4>>2]=y;va(vb,Mb);va(ub,tb);ta(tb,ub,pb);ob=Ja;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Ka;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Qa(d|0,ob|0,18,0)|0;V=y;ob=Ta(X|0,da|0,d|0,ob|0)|0;V=Ta(ob|0,y|0,W|0,V|0)|0;W=Ka;c[W>>2]=V;c[W+4>>2]=y;W=La;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Ma;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(V|0,W|0,18,0)|0;X=y;W=Ta(d|0,ob|0,V|0,W|0)|0;X=Ta(W|0,y|0,da|0,X|0)|0;da=Ma;c[da>>2]=X;c[da+4>>2]=y;da=Na;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Oa;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Qa(X|0,da|0,18,0)|0;d=y;da=Ta(V|0,W|0,X|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Oa;c[ob>>2]=d;c[ob+4>>2]=y;ob=Pa;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Ra;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Qa(d|0,ob|0,18,0)|0;V=y;ob=Ta(X|0,da|0,d|0,ob|0)|0;V=Ta(ob|0,y|0,W|0,V|0)|0;W=Ra;c[W>>2]=V;c[W+4>>2]=y;W=Sa;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Va;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(V|0,W|0,18,0)|0;X=y;W=Ta(d|0,ob|0,V|0,W|0)|0;X=Ta(W|0,y|0,da|0,X|0)|0;da=Va;c[da>>2]=X;c[da+4>>2]=y;da=Xa;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Ya;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Qa(X|0,da|0,18,0)|0;d=y;da=Ta(V|0,W|0,X|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ya;c[ob>>2]=d;c[ob+4>>2]=y;ob=Za;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=_a;X=c[da>>2]|0;da=c[da+4>>2]|0;W=Qa(d|0,ob|0,18,0)|0;V=y;ob=Ta(X|0,da|0,d|0,ob|0)|0;V=Ta(ob|0,y|0,W|0,V|0)|0;W=_a;c[W>>2]=V;c[W+4>>2]=y;W=$a;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(V|0,W|0,18,0)|0;X=y;W=Ta(d|0,ob|0,V|0,W|0)|0;X=Ta(W|0,y|0,da|0,X|0)|0;da=ab;c[da>>2]=X;c[da+4>>2]=y;da=bb;X=c[da>>2]|0;da=c[da+4>>2]|0;W=tb;V=c[W>>2]|0;W=c[W+4>>2]|0;ob=Qa(X|0,da|0,18,0)|0;d=y;da=Ta(V|0,W|0,X|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=tb;c[ob>>2]=d;c[ob+4>>2]=y;ua(tb);ob=h;d=vb;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));ob=ca;d=tb;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(rb,f);va(sb,e);ta(ba,rb,sb);j=ba+144|0;o=c[j>>2]|0;j=c[j+4>>2]|0;n=ba+64|0;m=n;k=c[m>>2]|0;m=c[m+4>>2]|0;d=Qa(o|0,j|0,18,0)|0;i=y;j=Ta(k|0,m|0,o|0,j|0)|0;i=Ta(j|0,y|0,d|0,i|0)|0;c[n>>2]=i;c[n+4>>2]=y;n=ba+136|0;i=c[n>>2]|0;n=c[n+4>>2]|0;d=ba+56|0;j=d;o=c[j>>2]|0;j=c[j+4>>2]|0;m=Qa(i|0,n|0,18,0)|0;k=y;n=Ta(o|0,j|0,i|0,n|0)|0;k=Ta(n|0,y|0,m|0,k|0)|0;c[d>>2]=k;c[d+4>>2]=y;d=ba+128|0;k=c[d>>2]|0;d=c[d+4>>2]|0;m=ba+48|0;n=m;i=c[n>>2]|0;n=c[n+4>>2]|0;j=Qa(k|0,d|0,18,0)|0;o=y;d=Ta(i|0,n|0,k|0,d|0)|0;o=Ta(d|0,y|0,j|0,o|0)|0;c[m>>2]=o;c[m+4>>2]=y;m=ba+120|0;o=c[m>>2]|0;m=c[m+4>>2]|0;j=ba+40|0;d=j;k=c[d>>2]|0;d=c[d+4>>2]|0;n=Qa(o|0,m|0,18,0)|0;i=y;m=Ta(k|0,d|0,o|0,m|0)|0;i=Ta(m|0,y|0,n|0,i|0)|0;c[j>>2]=i;c[j+4>>2]=y;j=ba+112|0;i=c[j>>2]|0;j=c[j+4>>2]|0;n=ba+32|0;m=n;o=c[m>>2]|0;m=c[m+4>>2]|0;d=Qa(i|0,j|0,18,0)|0;k=y;j=Ta(o|0,m|0,i|0,j|0)|0;k=Ta(j|0,y|0,d|0,k|0)|0;c[n>>2]=k;c[n+4>>2]=y;n=ba+104|0;k=c[n>>2]|0;n=c[n+4>>2]|0;d=ba+24|0;j=d;i=c[j>>2]|0;j=c[j+4>>2]|0;m=Qa(k|0,n|0,18,0)|0;o=y;n=Ta(i|0,j|0,k|0,n|0)|0;o=Ta(n|0,y|0,m|0,o|0)|0;c[d>>2]=o;c[d+4>>2]=y;d=ba+96|0;o=c[d>>2]|0;d=c[d+4>>2]|0;m=ba+16|0;n=m;k=c[n>>2]|0;n=c[n+4>>2]|0;j=Qa(o|0,d|0,18,0)|0;i=y;d=Ta(k|0,n|0,o|0,d|0)|0;i=Ta(d|0,y|0,j|0,i|0)|0;c[m>>2]=i;c[m+4>>2]=y;m=ba+88|0;i=c[m>>2]|0;m=c[m+4>>2]|0;j=ba+8|0;d=j;o=c[d>>2]|0;d=c[d+4>>2]|0;n=Qa(i|0,m|0,18,0)|0;k=y;m=Ta(o|0,d|0,i|0,m|0)|0;k=Ta(m|0,y|0,n|0,k|0)|0;c[j>>2]=k;c[j+4>>2]=y;j=ba+80|0;k=c[j>>2]|0;j=c[j+4>>2]|0;n=ba;m=c[n>>2]|0;n=c[n+4>>2]|0;i=Qa(k|0,j|0,18,0)|0;d=y;j=Ta(m|0,n|0,k|0,j|0)|0;d=Ta(j|0,y|0,i|0,d|0)|0;i=ba;c[i>>2]=d;c[i+4>>2]=y;ua(ba);i=rb;d=c[i>>2]|0;i=c[i+4>>2]|0;j=sb;j=Ua(d|0,i|0,c[j>>2]|0,c[j+4>>2]|0)|0;k=y;n=sb;c[n>>2]=j;c[n+4>>2]=k;n=db;m=c[n>>2]|0;n=c[n+4>>2]|0;o=eb;o=Ua(m|0,n|0,c[o>>2]|0,c[o+4>>2]|0)|0;p=y;r=eb;c[r>>2]=o;c[r+4>>2]=p;r=fb;q=c[r>>2]|0;r=c[r+4>>2]|0;s=gb;s=Ua(q|0,r|0,c[s>>2]|0,c[s+4>>2]|0)|0;t=y;v=gb;c[v>>2]=s;c[v+4>>2]=t;v=hb;u=c[v>>2]|0;v=c[v+4>>2]|0;w=ib;w=Ua(u|0,v|0,c[w>>2]|0,c[w+4>>2]|0)|0;x=y;A=ib;c[A>>2]=w;c[A+4>>2]=x;A=jb;z=c[A>>2]|0;A=c[A+4>>2]|0;B=kb;B=Ua(z|0,A|0,c[B>>2]|0,c[B+4>>2]|0)|0;C=y;E=kb;c[E>>2]=B;c[E+4>>2]=C;E=lb;D=c[E>>2]|0;E=c[E+4>>2]|0;F=mb;F=Ua(D|0,E|0,c[F>>2]|0,c[F+4>>2]|0)|0;G=y;I=mb;c[I>>2]=F;c[I+4>>2]=G;I=nb;H=c[I>>2]|0;I=c[I+4>>2]|0;J=ga;J=Ua(H|0,I|0,c[J>>2]|0,c[J+4>>2]|0)|0;K=y;M=ga;c[M>>2]=J;c[M+4>>2]=K;M=ha;L=c[M>>2]|0;M=c[M+4>>2]|0;O=ia;O=Ua(L|0,M|0,c[O>>2]|0,c[O+4>>2]|0)|0;P=y;R=ia;c[R>>2]=O;c[R+4>>2]=P;R=ja;Q=c[R>>2]|0;R=c[R+4>>2]|0;S=ka;S=Ua(Q|0,R|0,c[S>>2]|0,c[S+4>>2]|0)|0;T=y;V=ka;c[V>>2]=S;c[V+4>>2]=T;V=la;U=c[V>>2]|0;V=c[V+4>>2]|0;W=ma;W=Ua(U|0,V|0,c[W>>2]|0,c[W+4>>2]|0)|0;X=y;ob=ma;c[ob>>2]=W;c[ob+4>>2]=X;ob=wb;da=ob+72|0;do{c[ob>>2]=0;ob=ob+4|0}while((ob|0)<(da|0));Vb=Qa(j|0,k|0,121665,0)|0;Rb=Ib;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(o|0,p|0,121665,0)|0;Vb=xb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Qa(s|0,t|0,121665,0)|0;Rb=yb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(w|0,x|0,121665,0)|0;Vb=zb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Qa(B|0,C|0,121665,0)|0;Rb=Ab;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(F|0,G|0,121665,0)|0;Vb=Bb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Qa(J|0,K|0,121665,0)|0;Rb=Cb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(O|0,P|0,121665,0)|0;Vb=Db;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Qa(S|0,T|0,121665,0)|0;Rb=Eb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Qa(W|0,X|0,121665,0)|0;Vb=na;c[Vb>>2]=Rb;c[Vb+4>>2]=y;ua(Ib);Vb=Ib;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,d|0,i|0)|0;Rb=Ib;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=xb;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,m|0,n|0)|0;Vb=xb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=yb;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,q|0,r|0)|0;Rb=yb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=zb;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,u|0,v|0)|0;Vb=zb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Ab;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,z|0,A|0)|0;Rb=Ab;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Bb;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,D|0,E|0)|0;Vb=Bb;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Cb;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,H|0,I|0)|0;Rb=Cb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=Db;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,L|0,M|0)|0;Vb=Db;c[Vb>>2]=Rb;c[Vb+4>>2]=y;Vb=Eb;Vb=Ta(c[Vb>>2]|0,c[Vb+4>>2]|0,Q|0,R|0)|0;Rb=Eb;c[Rb>>2]=Vb;c[Rb+4>>2]=y;Rb=na;Rb=Ta(c[Rb>>2]|0,c[Rb+4>>2]|0,U|0,V|0)|0;Vb=na;c[Vb>>2]=Rb;c[Vb+4>>2]=y;ta(aa,sb,Ib);Vb=aa+144|0;Rb=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Tb=aa+64|0;Sb=Tb;Ub=c[Sb>>2]|0;Sb=c[Sb+4>>2]|0;Wb=Qa(Rb|0,Vb|0,18,0)|0;Xb=y;Vb=Ta(Ub|0,Sb|0,Rb|0,Vb|0)|0;Xb=Ta(Vb|0,y|0,Wb|0,Xb|0)|0;c[Tb>>2]=Xb;c[Tb+4>>2]=y;Tb=aa+136|0;Xb=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Wb=aa+56|0;Vb=Wb;Rb=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Sb=Qa(Xb|0,Tb|0,18,0)|0;Ub=y;Tb=Ta(Rb|0,Vb|0,Xb|0,Tb|0)|0;Ub=Ta(Tb|0,y|0,Sb|0,Ub|0)|0;c[Wb>>2]=Ub;c[Wb+4>>2]=y;Wb=aa+128|0;Ub=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;Sb=aa+48|0;Tb=Sb;Xb=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Vb=Qa(Ub|0,Wb|0,18,0)|0;Rb=y;Wb=Ta(Xb|0,Tb|0,Ub|0,Wb|0)|0;Rb=Ta(Wb|0,y|0,Vb|0,Rb|0)|0;c[Sb>>2]=Rb;c[Sb+4>>2]=y;Sb=aa+120|0;Rb=c[Sb>>2]|0;Sb=c[Sb+4>>2]|0;Vb=aa+40|0;Wb=Vb;Ub=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;Tb=Qa(Rb|0,Sb|0,18,0)|0;Xb=y;Sb=Ta(Ub|0,Wb|0,Rb|0,Sb|0)|0;Xb=Ta(Sb|0,y|0,Tb|0,Xb|0)|0;c[Vb>>2]=Xb;c[Vb+4>>2]=y;Vb=aa+112|0;Xb=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Tb=aa+32|0;Sb=Tb;Rb=c[Sb>>2]|0;Sb=c[Sb+4>>2]|0;Wb=Qa(Xb|0,Vb|0,18,0)|0;Ub=y;Vb=Ta(Rb|0,Sb|0,Xb|0,Vb|0)|0;Ub=Ta(Vb|0,y|0,Wb|0,Ub|0)|0;c[Tb>>2]=Ub;c[Tb+4>>2]=y;Tb=aa+104|0;Ub=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Wb=aa+24|0;Vb=Wb;Xb=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Sb=Qa(Ub|0,Tb|0,18,0)|0;Rb=y;Tb=Ta(Xb|0,Vb|0,Ub|0,Tb|0)|0;Rb=Ta(Tb|0,y|0,Sb|0,Rb|0)|0;c[Wb>>2]=Rb;c[Wb+4>>2]=y;Wb=aa+96|0;Rb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;Sb=aa+16|0;Tb=Sb;Ub=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Vb=Qa(Rb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(Ub|0,Tb|0,Rb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,Vb|0,Xb|0)|0;c[Sb>>2]=Xb;c[Sb+4>>2]=y;Sb=aa+88|0;Xb=c[Sb>>2]|0;Sb=c[Sb+4>>2]|0;Vb=aa+8|0;Wb=Vb;Rb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;Tb=Qa(Xb|0,Sb|0,18,0)|0;Ub=y;Sb=Ta(Rb|0,Wb|0,Xb|0,Sb|0)|0;Ub=Ta(Sb|0,y|0,Tb|0,Ub|0)|0;c[Vb>>2]=Ub;c[Vb+4>>2]=y;Vb=aa+80|0;Ub=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;Tb=aa;Sb=c[Tb>>2]|0;Tb=c[Tb+4>>2]|0;Xb=Qa(Ub|0,Vb|0,18,0)|0;Wb=y;Vb=Ta(Sb|0,Tb|0,Ub|0,Vb|0)|0;Wb=Ta(Vb|0,y|0,Xb|0,Wb|0)|0;Xb=aa;c[Xb>>2]=Wb;c[Xb+4>>2]=y;ua(aa);sa(ba,h,Z,0);sa(aa,ca,Z,0);$=$+1|0;if(($|0)==8)break;else{Ub=_;Vb=g;Wb=f;Xb=e;k=Y<<1&255;_=h;f=ba;e=aa;g=ca;h=Ub;ca=Vb;ba=Wb;aa=Xb}}ea=ea+1|0;if((ea|0)==32)break;else{m=h;h=_;d=ca;i=aa;j=ba}}ob=Jb;d=ba;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));ob=Kb;d=aa;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(rb,Kb);va(Hb,rb);va(Gb,Hb);ta(Ib,Gb,Kb);e=Ib+144|0;j=e;i=c[j>>2]|0;j=c[j+4>>2]|0;h=Eb;g=c[h>>2]|0;h=c[h+4>>2]|0;f=Qa(i|0,j|0,18,0)|0;k=y;j=Ta(g|0,h|0,i|0,j|0)|0;k=Ta(j|0,y|0,f|0,k|0)|0;f=Eb;c[f>>2]=k;c[f+4>>2]=y;f=Ib+136|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;i=Db;h=c[i>>2]|0;i=c[i+4>>2]|0;g=Qa(j|0,k|0,18,0)|0;m=y;k=Ta(h|0,i|0,j|0,k|0)|0;m=Ta(k|0,y|0,g|0,m|0)|0;g=Db;c[g>>2]=m;c[g+4>>2]=y;g=Ib+128|0;m=g;k=c[m>>2]|0;m=c[m+4>>2]|0;j=Cb;i=c[j>>2]|0;j=c[j+4>>2]|0;h=Qa(k|0,m|0,18,0)|0;da=y;m=Ta(i|0,j|0,k|0,m|0)|0;da=Ta(m|0,y|0,h|0,da|0)|0;h=Cb;c[h>>2]=da;c[h+4>>2]=y;h=Ib+120|0;da=h;m=c[da>>2]|0;da=c[da+4>>2]|0;k=Bb;j=c[k>>2]|0;k=c[k+4>>2]|0;i=Qa(m|0,da|0,18,0)|0;d=y;da=Ta(j|0,k|0,m|0,da|0)|0;d=Ta(da|0,y|0,i|0,d|0)|0;i=Bb;c[i>>2]=d;c[i+4>>2]=y;i=Ib+112|0;d=i;da=c[d>>2]|0;d=c[d+4>>2]|0;m=Ab;k=c[m>>2]|0;m=c[m+4>>2]|0;j=Qa(da|0,d|0,18,0)|0;ob=y;d=Ta(k|0,m|0,da|0,d|0)|0;ob=Ta(d|0,y|0,j|0,ob|0)|0;j=Ab;c[j>>2]=ob;c[j+4>>2]=y;j=Ib+104|0;ob=j;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=zb;m=c[da>>2]|0;da=c[da+4>>2]|0;k=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(m|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,k|0,Vb|0)|0;k=zb;c[k>>2]=Vb;c[k+4>>2]=y;k=Ib+96|0;Vb=k;ob=c[Vb>>2]|0;Vb=c[Vb+4>>2]|0;d=yb;da=c[d>>2]|0;d=c[d+4>>2]|0;m=Qa(ob|0,Vb|0,18,0)|0;Wb=y;Vb=Ta(da|0,d|0,ob|0,Vb|0)|0;Wb=Ta(Vb|0,y|0,m|0,Wb|0)|0;m=yb;c[m>>2]=Wb;c[m+4>>2]=y;m=Ib+88|0;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=sb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));ta(Ib,sb,rb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Mb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,Mb);ta(Ib,Gb,sb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=tb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,tb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);ta(Ib,Gb,tb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=ub;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,ub);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);ta(Ib,Hb,ub);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=vb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,vb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);ta(Ib,Hb,vb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Gb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);ta(Ib,Gb,ub);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Nb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,Nb);va(Hb,Gb);d=2;do{va(Gb,Hb);va(Hb,Gb);d=d+2|0}while((d|0)<50);ta(Ib,Hb,Nb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Fb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Hb,Fb);va(Gb,Hb);d=2;do{va(Hb,Gb);va(Gb,Hb);d=d+2|0}while((d|0)<100);ta(Ib,Gb,Fb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Hb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Gb,Hb);va(Hb,Gb);d=2;do{va(Gb,Hb);va(Hb,Gb);d=d+2|0}while((d|0)<50);ta(Ib,Hb,Nb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Gb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);va(Gb,Hb);va(Hb,Gb);ta(Ib,Hb,Mb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Lb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));ta(Ib,Jb,Lb);ob=e;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Eb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Eb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=f;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Db;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Db;c[da>>2]=Xb;c[da+4>>2]=y;da=g;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Cb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Cb;c[ob>>2]=d;c[ob+4>>2]=y;ob=h;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Bb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=Bb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=i;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Ab;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=Ab;c[da>>2]=Xb;c[da+4>>2]=y;da=j;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=zb;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=zb;c[ob>>2]=d;c[ob+4>>2]=y;ob=k;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=yb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Qa(d|0,ob|0,18,0)|0;Vb=y;ob=Ta(Xb|0,da|0,d|0,ob|0)|0;Vb=Ta(ob|0,y|0,Wb|0,Vb|0)|0;Wb=yb;c[Wb>>2]=Vb;c[Wb+4>>2]=y;Wb=m;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=xb;d=c[ob>>2]|0;ob=c[ob+4>>2]|0;da=Qa(Vb|0,Wb|0,18,0)|0;Xb=y;Wb=Ta(d|0,ob|0,Vb|0,Wb|0)|0;Xb=Ta(Wb|0,y|0,da|0,Xb|0)|0;da=xb;c[da>>2]=Xb;c[da+4>>2]=y;da=wb;Xb=c[da>>2]|0;da=c[da+4>>2]|0;Wb=Ib;Vb=c[Wb>>2]|0;Wb=c[Wb+4>>2]|0;ob=Qa(Xb|0,da|0,18,0)|0;d=y;da=Ta(Vb|0,Wb|0,Xb|0,da|0)|0;d=Ta(da|0,y|0,ob|0,d|0)|0;ob=Ib;c[ob>>2]=d;c[ob+4>>2]=y;ua(Ib);ob=Kb;d=Ib;da=ob+80|0;do{c[ob>>2]=c[d>>2];ob=ob+4|0;d=d+4|0}while((ob|0)<(da|0));Nb=c[Kb>>2]|0;Pb=(Nb>>31&Nb)>>26;Wb=Pb+(c[Kb+8>>2]|0)|0;Db=(Wb>>31&Wb)>>25;Qb=Db+(c[Kb+16>>2]|0)|0;Xb=(Qb>>31&Qb)>>26;Rb=Xb+(c[Kb+24>>2]|0)|0;Cb=(Rb>>31&Rb)>>25;Sb=Cb+(c[Kb+32>>2]|0)|0;Jb=(Sb>>31&Sb)>>26;Tb=Jb+(c[Kb+40>>2]|0)|0;Ib=(Tb>>31&Tb)>>25;Ub=Ib+(c[Kb+48>>2]|0)|0;Hb=(Ub>>31&Ub)>>26;Vb=Hb+(c[Kb+56>>2]|0)|0;Mb=(Vb>>31&Vb)>>25;Lb=Mb+(c[Kb+64>>2]|0)|0;Gb=(Lb>>31&Lb)>>26;Fb=Gb+(c[Kb+72>>2]|0)|0;Eb=(Fb>>31&Fb)>>25;Nb=(N(Pb,-67108864)|0)+Nb+(Eb*19|0)|0;Pb=(Nb>>31&Nb)>>26;Wb=(N(Db,-33554432)|0)+Wb+Pb|0;Db=(Wb>>31&Wb)>>25;Qb=(N(Xb,-67108864)|0)+Qb+Db|0;Xb=(Qb>>31&Qb)>>26;Rb=(N(Cb,-33554432)|0)+Rb+Xb|0;Kb=(Rb>>31&Rb)>>25;Sb=(N(Jb,-67108864)|0)+Sb+Kb|0;Jb=(Sb>>31&Sb)>>26;Tb=(N(Ib,-33554432)|0)+Tb+Jb|0;Ib=(Tb>>31&Tb)>>25;Ub=(N(Hb,-67108864)|0)+Ub+Ib|0;Hb=(Ub>>31&Ub)>>26;Vb=(N(Mb,-33554432)|0)+Vb+Hb|0;Mb=(Vb>>31&Vb)>>25;Lb=(N(Gb,-67108864)|0)+Lb+Mb|0;Gb=(Lb>>31&Lb)>>26;Fb=(N(Eb,-33554432)|0)+Fb+Gb|0;Eb=(Fb>>31&Fb)>>25;Nb=(N(Pb,-67108864)|0)+Nb+(Eb*19|0)|0;Pb=(Nb>>31&Nb)>>26;Nb=(N(Pb,-67108864)|0)+Nb|0;Pb=(N(Db,-33554432)|0)+Wb+Pb+(Nb>>26)|0;Qb=(N(Xb,-67108864)|0)+Qb+(Pb>>25)|0;Rb=(N(Kb,-33554432)|0)+Rb+(Qb>>26)|0;Sb=(N(Jb,-67108864)|0)+Sb+(Rb>>25)|0;Tb=(N(Ib,-33554432)|0)+Tb+(Sb>>26)|0;Ub=(N(Hb,-67108864)|0)+Ub+(Tb>>25)|0;Vb=(N(Mb,-33554432)|0)+Vb+(Ub>>26)|0;Lb=(N(Gb,-67108864)|0)+Lb+(Vb>>25)|0;Fb=(N(Eb,-33554432)|0)+Fb+(Lb>>26)|0;Eb=(Fb>>25)*19|0;Gb=Eb+(Nb&67108863)>>26;Mb=Gb+(Pb&33554431)>>25;Pb=Gb+Pb|0;Gb=Mb+(Qb&67108863)>>26;Qb=Mb+Qb|0;Mb=Gb+(Rb&33554431)>>25;Rb=Gb+Rb|0;Gb=Mb+(Sb&67108863)>>26;Sb=Mb+Sb|0;Mb=Gb+(Tb&33554431)>>25;Tb=Gb+Tb|0;Gb=Mb+(Ub&67108863)>>26;Ub=Mb+Ub|0;Mb=Gb+(Vb&33554431)>>25;Vb=Gb+Vb|0;Gb=Mb+(Lb&67108863)>>26;Lb=Mb+Lb|0;Mb=Gb+Fb|0;Nb=((Gb+(Fb&33554431)>>25)*19|0)+(Eb+Nb&67108863)|0;Eb=(Pb|-33554432)&Pb<<16;Eb=Eb<<8&Eb;Eb=Eb<<4&Eb;Eb=Eb<<2&Eb;Fb=(Qb|-67108864)&Qb<<16;Fb=Fb<<8&Fb;Fb=Fb<<4&Fb;Fb=Fb<<2&Fb;Gb=(Rb|-33554432)&Rb<<16;Gb=Gb<<8&Gb;Gb=Gb<<4&Gb;Gb=Gb<<2&Gb;Hb=(Sb|-67108864)&Sb<<16;Hb=Hb<<8&Hb;Hb=Hb<<4&Hb;Hb=Hb<<2&Hb;Ib=(Tb|-33554432)&Tb<<16;Ib=Ib<<8&Ib;Ib=Ib<<4&Ib;Ib=Ib<<2&Ib;Jb=(Ub|-67108864)&Ub<<16;Jb=Jb<<8&Jb;Jb=Jb<<4&Jb;Jb=Jb<<2&Jb;Kb=(Vb|-33554432)&Vb<<16;Kb=Kb<<8&Kb;Kb=Kb<<4&Kb;Kb=Kb<<2&Kb;Xb=(Lb|-67108864)&Lb<<16;Xb=Xb<<8&Xb;Xb=Xb<<4&Xb;Xb=Xb<<2&Xb;Wb=(Mb|-33554432)&Mb<<16;Wb=Wb<<8&Wb;Wb=Wb<<4&Wb;Wb=Wb<<2&Wb;Wb=(Eb<<1&Eb&Fb&Fb<<1&Gb&Gb<<1&Hb&Hb<<1&Ib&Ib<<1)>>31&~(Nb+-67108845>>31)&(Jb<<1&Jb)>>31&(Kb<<1&Kb)>>31&(Xb<<1&Xb)>>31&(Wb<<1&Wb)>>31;Nb=Nb-(Wb&67108845)|0;Xb=Wb&33554431;Pb=(Pb&33554431)-Xb|0;Wb=Wb&67108863;Qb=(Qb&67108863)-Wb|0;Rb=(Rb&33554431)-Xb|0;Sb=(Sb&67108863)-Wb|0;Tb=(Tb&33554431)-Xb|0;Ub=(Ub&67108863)-Wb|0;Vb=(Vb&33554431)-Xb|0;Wb=(Lb&67108863)-Wb|0;Xb=(Mb&33554431)-Xb|0;a[b>>0]=Nb;a[b+1>>0]=Nb>>>8;a[b+2>>0]=Nb>>>16;a[b+3>>0]=Pb<<2|Nb>>>24;a[b+4>>0]=Pb>>>6;a[b+5>>0]=Pb>>>14;a[b+6>>0]=Qb<<3|Pb>>>22;a[b+7>>0]=Qb>>>5;a[b+8>>0]=Qb>>>13;a[b+9>>0]=Rb<<5|Qb>>>21;a[b+10>>0]=Rb>>>3;a[b+11>>0]=Rb>>>11;a[b+12>>0]=Sb<<6|Rb>>>19;a[b+13>>0]=Sb>>>2;a[b+14>>0]=Sb>>>10;a[b+15>>0]=Sb>>>18;a[b+16>>0]=Tb;a[b+17>>0]=Tb>>>8;a[b+18>>0]=Tb>>>16;a[b+19>>0]=Ub<<1|Tb>>>24;a[b+20>>0]=Ub>>>7;a[b+21>>0]=Ub>>>15;a[b+22>>0]=Vb<<3|Ub>>>23;a[b+23>>0]=Vb>>>5;a[b+24>>0]=Vb>>>13;a[b+25>>0]=Wb<<4|Vb>>>21;a[b+26>>0]=Wb>>>4;a[b+27>>0]=Wb>>>12;a[b+28>>0]=Xb<<6|Wb>>>20;a[b+29>>0]=Xb>>>2;a[b+30>>0]=Xb>>>10;a[b+31>>0]=Xb>>>18;l=Ob;return}function qa(b){b=b|0;var c=0;da(0)|0;c=0;do{a[b+c>>0]=da(1)|0;c=c+1|0}while((c|0)!=32);a[b>>0]=a[b>>0]&-8;b=b+31|0;a[b>>0]=a[b>>0]&63|64;return}function ra(b,c){b=b|0;c=c|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;f=0;g=a[c>>0]|0;h=c;e=b;while(1){i=a[h+2>>0]|0;j=d[h+1>>0]|0;k=j>>>4|(g&255)<<4&48;j=j<<2&60|(i&255)>>>6;l=(g&255)>>>2&255;a[e>>0]=l+65+((25-l|0)>>>8&6)-((51-l|0)>>>8&75)-((61-l|0)>>>8&15)+((62-l|0)>>>8&3);a[e+1>>0]=k+65+((25-k|0)>>>8&6)-((51-k|0)>>>8&75)-((61-k|0)>>>8&15)+((62-k|0)>>>8&3);a[e+2>>0]=j+65+((25-j|0)>>>8&6)-((51-j|0)>>>8&75)-((61-j|0)>>>8&15)+((62-j|0)>>>8&3);i=i&63;a[e+3>>0]=i+65+((25-i|0)>>>8&6)-((51-i|0)>>>8&75)-((61-i|0)>>>8&15)+((62-i|0)>>>8&3);e=f+1|0;h=c+(e*3|0)|0;g=a[h>>0]|0;if((e|0)==10)break;else{f=e;e=b+(e<<2)|0}}l=d[c+31>>0]|0;k=l>>>4|(g&255)<<4&48;l=l<<2&60;j=(g&255)>>>2&255;a[b+40>>0]=j+65+((25-j|0)>>>8&6)-((51-j|0)>>>8&75)-((61-j|0)>>>8&15)+((62-j|0)>>>8&3);a[b+41>>0]=k+65+((25-k|0)>>>8&6)-((51-k|0)>>>8&75)-((61-k|0)>>>8&15)+((62-k|0)>>>8&3);a[b+42>>0]=((25-l|0)>>>8&6)+(l|65)-((51-l|0)>>>8&75);a[b+43>>0]=61;a[b+44>>0]=0;return}function sa(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0;d=Ua(0,0,d|0,e|0)|0;i=y;g=a;e=c[g>>2]|0;g=c[g+4>>2]|0;f=b;h=(c[f>>2]^e)&d;f=(c[f+4>>2]^g)&i;e=Ra(0,h^e|0,32)|0;g=a;c[g>>2]=e;c[g+4>>2]=y;g=b;h=Ra(0,c[g>>2]^h|0,32)|0;g=b;c[g>>2]=h;c[g+4>>2]=y;g=a+8|0;h=g;f=c[h>>2]|0;h=c[h+4>>2]|0;e=b+8|0;j=e;k=(c[j>>2]^f)&d;j=(c[j+4>>2]^h)&i;f=Ra(0,k^f|0,32)|0;c[g>>2]=f;c[g+4>>2]=y;g=e;k=Ra(0,c[g>>2]^k|0,32)|0;c[e>>2]=k;c[e+4>>2]=y;e=a+16|0;k=e;g=c[k>>2]|0;k=c[k+4>>2]|0;j=b+16|0;f=j;h=(c[f>>2]^g)&d;f=(c[f+4>>2]^k)&i;g=Ra(0,h^g|0,32)|0;c[e>>2]=g;c[e+4>>2]=y;e=j;h=Ra(0,c[e>>2]^h|0,32)|0;c[j>>2]=h;c[j+4>>2]=y;j=a+24|0;h=j;e=c[h>>2]|0;h=c[h+4>>2]|0;f=b+24|0;g=f;k=(c[g>>2]^e)&d;g=(c[g+4>>2]^h)&i;e=Ra(0,k^e|0,32)|0;c[j>>2]=e;c[j+4>>2]=y;j=f;k=Ra(0,c[j>>2]^k|0,32)|0;c[f>>2]=k;c[f+4>>2]=y;f=a+32|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;g=b+32|0;e=g;h=(c[e>>2]^j)&d;e=(c[e+4>>2]^k)&i;j=Ra(0,h^j|0,32)|0;c[f>>2]=j;c[f+4>>2]=y;f=g;h=Ra(0,c[f>>2]^h|0,32)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+40|0;h=g;f=c[h>>2]|0;h=c[h+4>>2]|0;e=b+40|0;j=e;k=(c[j>>2]^f)&d;j=(c[j+4>>2]^h)&i;f=Ra(0,k^f|0,32)|0;c[g>>2]=f;c[g+4>>2]=y;g=e;k=Ra(0,c[g>>2]^k|0,32)|0;c[e>>2]=k;c[e+4>>2]=y;e=a+48|0;k=e;g=c[k>>2]|0;k=c[k+4>>2]|0;j=b+48|0;f=j;h=(c[f>>2]^g)&d;f=(c[f+4>>2]^k)&i;g=Ra(0,h^g|0,32)|0;c[e>>2]=g;c[e+4>>2]=y;e=j;h=Ra(0,c[e>>2]^h|0,32)|0;c[j>>2]=h;c[j+4>>2]=y;j=a+56|0;h=j;e=c[h>>2]|0;h=c[h+4>>2]|0;f=b+56|0;g=f;k=(c[g>>2]^e)&d;g=(c[g+4>>2]^h)&i;e=Ra(0,k^e|0,32)|0;c[j>>2]=e;c[j+4>>2]=y;j=f;k=Ra(0,c[j>>2]^k|0,32)|0;c[f>>2]=k;c[f+4>>2]=y;f=a+64|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;g=b+64|0;e=g;h=(c[e>>2]^j)&d;e=(c[e+4>>2]^k)&i;j=Ra(0,h^j|0,32)|0;c[f>>2]=j;c[f+4>>2]=y;f=g;h=Ra(0,c[f>>2]^h|0,32)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+72|0;h=g;f=c[h>>2]|0;h=c[h+4>>2]|0;e=b+72|0;a=e;d=(c[a>>2]^f)&d;a=(c[a+4>>2]^h)&i;f=Ra(0,d^f|0,32)|0;b=g;c[b>>2]=f;c[b+4>>2]=y;b=e;d=Ra(0,c[b>>2]^d|0,32)|0;c[e>>2]=d;c[e+4>>2]=y;return}function ta(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0;h=Ra(0,c[b>>2]|0,32)|0;n=y;w=Ra(0,c[d>>2]|0,32)|0;n=Qa(w|0,y|0,h|0,n|0)|0;h=a;c[h>>2]=n;c[h+4>>2]=y;h=Ra(0,c[b>>2]|0,32)|0;n=y;w=d+8|0;s=Ra(0,c[w>>2]|0,32)|0;n=Qa(s|0,y|0,h|0,n|0)|0;h=y;s=b+8|0;r=Ra(0,c[s>>2]|0,32)|0;p=y;v=Ra(0,c[d>>2]|0,32)|0;p=Qa(v|0,y|0,r|0,p|0)|0;h=Ta(p|0,y|0,n|0,h|0)|0;n=a+8|0;c[n>>2]=h;c[n+4>>2]=y;n=Ra(0,c[s>>2]|0,31)|0;h=y;p=Ra(0,c[w>>2]|0,32)|0;h=Qa(p|0,y|0,n|0,h|0)|0;n=y;p=Ra(0,c[b>>2]|0,32)|0;r=y;v=d+16|0;l=Ra(0,c[v>>2]|0,32)|0;r=Qa(l|0,y|0,p|0,r|0)|0;n=Ta(r|0,y|0,h|0,n|0)|0;h=y;r=b+16|0;p=Ra(0,c[r>>2]|0,32)|0;l=y;u=Ra(0,c[d>>2]|0,32)|0;l=Qa(u|0,y|0,p|0,l|0)|0;l=Ta(n|0,h|0,l|0,y|0)|0;h=a+16|0;c[h>>2]=l;c[h+4>>2]=y;h=Ra(0,c[s>>2]|0,32)|0;l=y;n=Ra(0,c[v>>2]|0,32)|0;l=Qa(n|0,y|0,h|0,l|0)|0;h=y;n=Ra(0,c[r>>2]|0,32)|0;p=y;u=Ra(0,c[w>>2]|0,32)|0;p=Qa(u|0,y|0,n|0,p|0)|0;h=Ta(p|0,y|0,l|0,h|0)|0;l=y;p=Ra(0,c[b>>2]|0,32)|0;n=y;u=d+24|0;g=Ra(0,c[u>>2]|0,32)|0;n=Qa(g|0,y|0,p|0,n|0)|0;n=Ta(h|0,l|0,n|0,y|0)|0;l=y;h=b+24|0;p=Ra(0,c[h>>2]|0,32)|0;g=y;j=Ra(0,c[d>>2]|0,32)|0;g=Qa(j|0,y|0,p|0,g|0)|0;g=Ta(n|0,l|0,g|0,y|0)|0;l=a+24|0;c[l>>2]=g;c[l+4>>2]=y;l=Ra(0,c[r>>2]|0,32)|0;g=y;n=Ra(0,c[v>>2]|0,32)|0;g=Qa(n|0,y|0,l|0,g|0)|0;l=y;n=Ra(0,c[s>>2]|0,32)|0;p=y;j=Ra(0,c[u>>2]|0,32)|0;p=Qa(j|0,y|0,n|0,p|0)|0;n=y;j=Ra(0,c[h>>2]|0,32)|0;q=y;o=Ra(0,c[w>>2]|0,32)|0;q=Qa(o|0,y|0,j|0,q|0)|0;n=Ta(q|0,y|0,p|0,n|0)|0;n=Sa(n|0,y|0,1)|0;l=Ta(n|0,y|0,g|0,l|0)|0;g=y;n=Ra(0,c[b>>2]|0,32)|0;p=y;q=d+32|0;j=Ra(0,c[q>>2]|0,32)|0;p=Qa(j|0,y|0,n|0,p|0)|0;p=Ta(l|0,g|0,p|0,y|0)|0;g=y;l=b+32|0;n=Ra(0,c[l>>2]|0,32)|0;j=y;o=Ra(0,c[d>>2]|0,32)|0;j=Qa(o|0,y|0,n|0,j|0)|0;j=Ta(p|0,g|0,j|0,y|0)|0;g=a+32|0;c[g>>2]=j;c[g+4>>2]=y;g=Ra(0,c[r>>2]|0,32)|0;j=y;p=Ra(0,c[u>>2]|0,32)|0;j=Qa(p|0,y|0,g|0,j|0)|0;g=y;p=Ra(0,c[h>>2]|0,32)|0;n=y;o=Ra(0,c[v>>2]|0,32)|0;n=Qa(o|0,y|0,p|0,n|0)|0;g=Ta(n|0,y|0,j|0,g|0)|0;j=y;n=Ra(0,c[s>>2]|0,32)|0;p=y;o=Ra(0,c[q>>2]|0,32)|0;p=Qa(o|0,y|0,n|0,p|0)|0;p=Ta(g|0,j|0,p|0,y|0)|0;j=y;g=Ra(0,c[l>>2]|0,32)|0;n=y;o=Ra(0,c[w>>2]|0,32)|0;n=Qa(o|0,y|0,g|0,n|0)|0;n=Ta(p|0,j|0,n|0,y|0)|0;j=y;p=Ra(0,c[b>>2]|0,32)|0;g=y;o=d+40|0;t=Ra(0,c[o>>2]|0,32)|0;g=Qa(t|0,y|0,p|0,g|0)|0;g=Ta(n|0,j|0,g|0,y|0)|0;j=y;n=b+40|0;p=Ra(0,c[n>>2]|0,32)|0;t=y;k=Ra(0,c[d>>2]|0,32)|0;t=Qa(k|0,y|0,p|0,t|0)|0;t=Ta(g|0,j|0,t|0,y|0)|0;j=a+40|0;c[j>>2]=t;c[j+4>>2]=y;j=Ra(0,c[h>>2]|0,32)|0;t=y;g=Ra(0,c[u>>2]|0,32)|0;t=Qa(g|0,y|0,j|0,t|0)|0;j=y;g=Ra(0,c[s>>2]|0,32)|0;p=y;k=Ra(0,c[o>>2]|0,32)|0;p=Qa(k|0,y|0,g|0,p|0)|0;j=Ta(p|0,y|0,t|0,j|0)|0;t=y;p=Ra(0,c[n>>2]|0,32)|0;g=y;k=Ra(0,c[w>>2]|0,32)|0;g=Qa(k|0,y|0,p|0,g|0)|0;g=Ta(j|0,t|0,g|0,y|0)|0;g=Sa(g|0,y|0,1)|0;t=y;j=Ra(0,c[r>>2]|0,32)|0;p=y;k=Ra(0,c[q>>2]|0,32)|0;p=Qa(k|0,y|0,j|0,p|0)|0;p=Ta(g|0,t|0,p|0,y|0)|0;t=y;g=Ra(0,c[l>>2]|0,32)|0;j=y;k=Ra(0,c[v>>2]|0,32)|0;j=Qa(k|0,y|0,g|0,j|0)|0;j=Ta(p|0,t|0,j|0,y|0)|0;t=y;p=Ra(0,c[b>>2]|0,32)|0;g=y;k=d+48|0;x=Ra(0,c[k>>2]|0,32)|0;g=Qa(x|0,y|0,p|0,g|0)|0;g=Ta(j|0,t|0,g|0,y|0)|0;t=y;j=b+48|0;p=Ra(0,c[j>>2]|0,32)|0;x=y;m=Ra(0,c[d>>2]|0,32)|0;x=Qa(m|0,y|0,p|0,x|0)|0;x=Ta(g|0,t|0,x|0,y|0)|0;t=a+48|0;c[t>>2]=x;c[t+4>>2]=y;t=Ra(0,c[h>>2]|0,32)|0;x=y;g=Ra(0,c[q>>2]|0,32)|0;x=Qa(g|0,y|0,t|0,x|0)|0;t=y;g=Ra(0,c[l>>2]|0,32)|0;p=y;m=Ra(0,c[u>>2]|0,32)|0;p=Qa(m|0,y|0,g|0,p|0)|0;t=Ta(p|0,y|0,x|0,t|0)|0;x=y;p=Ra(0,c[r>>2]|0,32)|0;g=y;m=Ra(0,c[o>>2]|0,32)|0;g=Qa(m|0,y|0,p|0,g|0)|0;g=Ta(t|0,x|0,g|0,y|0)|0;x=y;t=Ra(0,c[n>>2]|0,32)|0;p=y;m=Ra(0,c[v>>2]|0,32)|0;p=Qa(m|0,y|0,t|0,p|0)|0;p=Ta(g|0,x|0,p|0,y|0)|0;x=y;g=Ra(0,c[s>>2]|0,32)|0;t=y;m=Ra(0,c[k>>2]|0,32)|0;t=Qa(m|0,y|0,g|0,t|0)|0;t=Ta(p|0,x|0,t|0,y|0)|0;x=y;p=Ra(0,c[j>>2]|0,32)|0;g=y;m=Ra(0,c[w>>2]|0,32)|0;g=Qa(m|0,y|0,p|0,g|0)|0;g=Ta(t|0,x|0,g|0,y|0)|0;x=y;t=Ra(0,c[b>>2]|0,32)|0;p=y;m=d+56|0;z=Ra(0,c[m>>2]|0,32)|0;p=Qa(z|0,y|0,t|0,p|0)|0;p=Ta(g|0,x|0,p|0,y|0)|0;x=y;g=b+56|0;t=Ra(0,c[g>>2]|0,32)|0;z=y;i=Ra(0,c[d>>2]|0,32)|0;z=Qa(i|0,y|0,t|0,z|0)|0;z=Ta(p|0,x|0,z|0,y|0)|0;x=a+56|0;c[x>>2]=z;c[x+4>>2]=y;x=Ra(0,c[l>>2]|0,32)|0;z=y;p=Ra(0,c[q>>2]|0,32)|0;z=Qa(p|0,y|0,x|0,z|0)|0;x=y;p=Ra(0,c[h>>2]|0,32)|0;t=y;i=Ra(0,c[o>>2]|0,32)|0;t=Qa(i|0,y|0,p|0,t|0)|0;p=y;i=Ra(0,c[n>>2]|0,32)|0;f=y;e=Ra(0,c[u>>2]|0,32)|0;f=Qa(e|0,y|0,i|0,f|0)|0;p=Ta(f|0,y|0,t|0,p|0)|0;t=y;f=Ra(0,c[s>>2]|0,32)|0;i=y;e=Ra(0,c[m>>2]|0,32)|0;i=Qa(e|0,y|0,f|0,i|0)|0;i=Ta(p|0,t|0,i|0,y|0)|0;t=y;p=Ra(0,c[g>>2]|0,32)|0;f=y;e=Ra(0,c[w>>2]|0,32)|0;f=Qa(e|0,y|0,p|0,f|0)|0;f=Ta(i|0,t|0,f|0,y|0)|0;f=Sa(f|0,y|0,1)|0;x=Ta(f|0,y|0,z|0,x|0)|0;z=y;f=Ra(0,c[r>>2]|0,32)|0;t=y;i=Ra(0,c[k>>2]|0,32)|0;t=Qa(i|0,y|0,f|0,t|0)|0;t=Ta(x|0,z|0,t|0,y|0)|0;z=y;x=Ra(0,c[j>>2]|0,32)|0;f=y;i=Ra(0,c[v>>2]|0,32)|0;f=Qa(i|0,y|0,x|0,f|0)|0;f=Ta(t|0,z|0,f|0,y|0)|0;z=y;t=Ra(0,c[b>>2]|0,32)|0;x=y;i=d+64|0;p=Ra(0,c[i>>2]|0,32)|0;x=Qa(p|0,y|0,t|0,x|0)|0;x=Ta(f|0,z|0,x|0,y|0)|0;z=y;f=b+64|0;t=Ra(0,c[f>>2]|0,32)|0;p=y;e=Ra(0,c[d>>2]|0,32)|0;p=Qa(e|0,y|0,t|0,p|0)|0;p=Ta(x|0,z|0,p|0,y|0)|0;z=a+64|0;c[z>>2]=p;c[z+4>>2]=y;z=Ra(0,c[l>>2]|0,32)|0;p=y;x=Ra(0,c[o>>2]|0,32)|0;p=Qa(x|0,y|0,z|0,p|0)|0;z=y;x=Ra(0,c[n>>2]|0,32)|0;t=y;e=Ra(0,c[q>>2]|0,32)|0;t=Qa(e|0,y|0,x|0,t|0)|0;z=Ta(t|0,y|0,p|0,z|0)|0;p=y;t=Ra(0,c[h>>2]|0,32)|0;x=y;e=Ra(0,c[k>>2]|0,32)|0;x=Qa(e|0,y|0,t|0,x|0)|0;x=Ta(z|0,p|0,x|0,y|0)|0;p=y;z=Ra(0,c[j>>2]|0,32)|0;t=y;e=Ra(0,c[u>>2]|0,32)|0;t=Qa(e|0,y|0,z|0,t|0)|0;t=Ta(x|0,p|0,t|0,y|0)|0;p=y;x=Ra(0,c[r>>2]|0,32)|0;z=y;e=Ra(0,c[m>>2]|0,32)|0;z=Qa(e|0,y|0,x|0,z|0)|0;z=Ta(t|0,p|0,z|0,y|0)|0;p=y;t=Ra(0,c[g>>2]|0,32)|0;x=y;e=Ra(0,c[v>>2]|0,32)|0;x=Qa(e|0,y|0,t|0,x|0)|0;x=Ta(z|0,p|0,x|0,y|0)|0;p=y;z=Ra(0,c[s>>2]|0,32)|0;t=y;e=Ra(0,c[i>>2]|0,32)|0;t=Qa(e|0,y|0,z|0,t|0)|0;t=Ta(x|0,p|0,t|0,y|0)|0;p=y;x=Ra(0,c[f>>2]|0,32)|0;z=y;e=Ra(0,c[w>>2]|0,32)|0;z=Qa(e|0,y|0,x|0,z|0)|0;z=Ta(t|0,p|0,z|0,y|0)|0;p=y;t=Ra(0,c[b>>2]|0,32)|0;x=y;e=d+72|0;A=Ra(0,c[e>>2]|0,32)|0;x=Qa(A|0,y|0,t|0,x|0)|0;x=Ta(z|0,p|0,x|0,y|0)|0;p=y;b=b+72|0;z=Ra(0,c[b>>2]|0,32)|0;t=y;d=Ra(0,c[d>>2]|0,32)|0;t=Qa(d|0,y|0,z|0,t|0)|0;t=Ta(x|0,p|0,t|0,y|0)|0;d=a+72|0;c[d>>2]=t;c[d+4>>2]=y;d=Ra(0,c[n>>2]|0,32)|0;t=y;p=Ra(0,c[o>>2]|0,32)|0;t=Qa(p|0,y|0,d|0,t|0)|0;d=y;p=Ra(0,c[h>>2]|0,32)|0;x=y;z=Ra(0,c[m>>2]|0,32)|0;x=Qa(z|0,y|0,p|0,x|0)|0;d=Ta(x|0,y|0,t|0,d|0)|0;t=y;x=Ra(0,c[g>>2]|0,32)|0;p=y;z=Ra(0,c[u>>2]|0,32)|0;p=Qa(z|0,y|0,x|0,p|0)|0;p=Ta(d|0,t|0,p|0,y|0)|0;t=y;d=Ra(0,c[s>>2]|0,32)|0;s=y;x=Ra(0,c[e>>2]|0,32)|0;s=Qa(x|0,y|0,d|0,s|0)|0;s=Ta(p|0,t|0,s|0,y|0)|0;t=y;p=Ra(0,c[b>>2]|0,32)|0;d=y;w=Ra(0,c[w>>2]|0,32)|0;d=Qa(w|0,y|0,p|0,d|0)|0;d=Ta(s|0,t|0,d|0,y|0)|0;d=Sa(d|0,y|0,1)|0;t=y;s=Ra(0,c[l>>2]|0,32)|0;p=y;w=Ra(0,c[k>>2]|0,32)|0;p=Qa(w|0,y|0,s|0,p|0)|0;p=Ta(d|0,t|0,p|0,y|0)|0;t=y;d=Ra(0,c[j>>2]|0,32)|0;s=y;w=Ra(0,c[q>>2]|0,32)|0;s=Qa(w|0,y|0,d|0,s|0)|0;s=Ta(p|0,t|0,s|0,y|0)|0;t=y;p=Ra(0,c[r>>2]|0,32)|0;d=y;w=Ra(0,c[i>>2]|0,32)|0;d=Qa(w|0,y|0,p|0,d|0)|0;d=Ta(s|0,t|0,d|0,y|0)|0;t=y;s=Ra(0,c[f>>2]|0,32)|0;p=y;w=Ra(0,c[v>>2]|0,32)|0;p=Qa(w|0,y|0,s|0,p|0)|0;p=Ta(d|0,t|0,p|0,y|0)|0;t=a+80|0;c[t>>2]=p;c[t+4>>2]=y;t=Ra(0,c[n>>2]|0,32)|0;p=y;d=Ra(0,c[k>>2]|0,32)|0;p=Qa(d|0,y|0,t|0,p|0)|0;t=y;d=Ra(0,c[j>>2]|0,32)|0;s=y;w=Ra(0,c[o>>2]|0,32)|0;s=Qa(w|0,y|0,d|0,s|0)|0;t=Ta(s|0,y|0,p|0,t|0)|0;p=y;s=Ra(0,c[l>>2]|0,32)|0;d=y;w=Ra(0,c[m>>2]|0,32)|0;d=Qa(w|0,y|0,s|0,d|0)|0;d=Ta(t|0,p|0,d|0,y|0)|0;p=y;t=Ra(0,c[g>>2]|0,32)|0;s=y;w=Ra(0,c[q>>2]|0,32)|0;s=Qa(w|0,y|0,t|0,s|0)|0;s=Ta(d|0,p|0,s|0,y|0)|0;p=y;d=Ra(0,c[h>>2]|0,32)|0;t=y;w=Ra(0,c[i>>2]|0,32)|0;t=Qa(w|0,y|0,d|0,t|0)|0;t=Ta(s|0,p|0,t|0,y|0)|0;p=y;s=Ra(0,c[f>>2]|0,32)|0;d=y;w=Ra(0,c[u>>2]|0,32)|0;d=Qa(w|0,y|0,s|0,d|0)|0;d=Ta(t|0,p|0,d|0,y|0)|0;p=y;r=Ra(0,c[r>>2]|0,32)|0;t=y;s=Ra(0,c[e>>2]|0,32)|0;t=Qa(s|0,y|0,r|0,t|0)|0;t=Ta(d|0,p|0,t|0,y|0)|0;p=y;d=Ra(0,c[b>>2]|0,32)|0;r=y;v=Ra(0,c[v>>2]|0,32)|0;r=Qa(v|0,y|0,d|0,r|0)|0;r=Ta(t|0,p|0,r|0,y|0)|0;p=a+88|0;c[p>>2]=r;c[p+4>>2]=y;p=Ra(0,c[j>>2]|0,32)|0;r=y;t=Ra(0,c[k>>2]|0,32)|0;r=Qa(t|0,y|0,p|0,r|0)|0;p=y;t=Ra(0,c[n>>2]|0,32)|0;d=y;v=Ra(0,c[m>>2]|0,32)|0;d=Qa(v|0,y|0,t|0,d|0)|0;t=y;v=Ra(0,c[g>>2]|0,32)|0;s=y;w=Ra(0,c[o>>2]|0,32)|0;s=Qa(w|0,y|0,v|0,s|0)|0;t=Ta(s|0,y|0,d|0,t|0)|0;d=y;h=Ra(0,c[h>>2]|0,32)|0;s=y;v=Ra(0,c[e>>2]|0,32)|0;s=Qa(v|0,y|0,h|0,s|0)|0;s=Ta(t|0,d|0,s|0,y|0)|0;d=y;t=Ra(0,c[b>>2]|0,32)|0;h=y;u=Ra(0,c[u>>2]|0,32)|0;h=Qa(u|0,y|0,t|0,h|0)|0;h=Ta(s|0,d|0,h|0,y|0)|0;h=Sa(h|0,y|0,1)|0;p=Ta(h|0,y|0,r|0,p|0)|0;r=y;h=Ra(0,c[l>>2]|0,32)|0;d=y;s=Ra(0,c[i>>2]|0,32)|0;d=Qa(s|0,y|0,h|0,d|0)|0;d=Ta(p|0,r|0,d|0,y|0)|0;r=y;p=Ra(0,c[f>>2]|0,32)|0;h=y;s=Ra(0,c[q>>2]|0,32)|0;h=Qa(s|0,y|0,p|0,h|0)|0;h=Ta(d|0,r|0,h|0,y|0)|0;r=a+96|0;c[r>>2]=h;c[r+4>>2]=y;r=Ra(0,c[j>>2]|0,32)|0;h=y;d=Ra(0,c[m>>2]|0,32)|0;h=Qa(d|0,y|0,r|0,h|0)|0;r=y;d=Ra(0,c[g>>2]|0,32)|0;p=y;s=Ra(0,c[k>>2]|0,32)|0;p=Qa(s|0,y|0,d|0,p|0)|0;r=Ta(p|0,y|0,h|0,r|0)|0;h=y;p=Ra(0,c[n>>2]|0,32)|0;d=y;s=Ra(0,c[i>>2]|0,32)|0;d=Qa(s|0,y|0,p|0,d|0)|0;d=Ta(r|0,h|0,d|0,y|0)|0;h=y;r=Ra(0,c[f>>2]|0,32)|0;p=y;s=Ra(0,c[o>>2]|0,32)|0;p=Qa(s|0,y|0,r|0,p|0)|0;p=Ta(d|0,h|0,p|0,y|0)|0;h=y;l=Ra(0,c[l>>2]|0,32)|0;d=y;r=Ra(0,c[e>>2]|0,32)|0;d=Qa(r|0,y|0,l|0,d|0)|0;d=Ta(p|0,h|0,d|0,y|0)|0;h=y;p=Ra(0,c[b>>2]|0,32)|0;l=y;q=Ra(0,c[q>>2]|0,32)|0;l=Qa(q|0,y|0,p|0,l|0)|0;l=Ta(d|0,h|0,l|0,y|0)|0;h=a+104|0;c[h>>2]=l;c[h+4>>2]=y;h=Ra(0,c[g>>2]|0,32)|0;l=y;d=Ra(0,c[m>>2]|0,32)|0;l=Qa(d|0,y|0,h|0,l|0)|0;h=y;d=Ra(0,c[n>>2]|0,32)|0;n=y;p=Ra(0,c[e>>2]|0,32)|0;n=Qa(p|0,y|0,d|0,n|0)|0;h=Ta(n|0,y|0,l|0,h|0)|0;l=y;n=Ra(0,c[b>>2]|0,32)|0;d=y;o=Ra(0,c[o>>2]|0,32)|0;d=Qa(o|0,y|0,n|0,d|0)|0;d=Ta(h|0,l|0,d|0,y|0)|0;d=Sa(d|0,y|0,1)|0;l=y;h=Ra(0,c[j>>2]|0,32)|0;n=y;o=Ra(0,c[i>>2]|0,32)|0;n=Qa(o|0,y|0,h|0,n|0)|0;n=Ta(d|0,l|0,n|0,y|0)|0;l=y;d=Ra(0,c[f>>2]|0,32)|0;h=y;o=Ra(0,c[k>>2]|0,32)|0;h=Qa(o|0,y|0,d|0,h|0)|0;h=Ta(n|0,l|0,h|0,y|0)|0;l=a+112|0;c[l>>2]=h;c[l+4>>2]=y;l=Ra(0,c[g>>2]|0,32)|0;h=y;n=Ra(0,c[i>>2]|0,32)|0;h=Qa(n|0,y|0,l|0,h|0)|0;l=y;n=Ra(0,c[f>>2]|0,32)|0;d=y;o=Ra(0,c[m>>2]|0,32)|0;d=Qa(o|0,y|0,n|0,d|0)|0;l=Ta(d|0,y|0,h|0,l|0)|0;h=y;d=Ra(0,c[j>>2]|0,32)|0;j=y;n=Ra(0,c[e>>2]|0,32)|0;j=Qa(n|0,y|0,d|0,j|0)|0;j=Ta(l|0,h|0,j|0,y|0)|0;h=y;l=Ra(0,c[b>>2]|0,32)|0;d=y;k=Ra(0,c[k>>2]|0,32)|0;d=Qa(k|0,y|0,l|0,d|0)|0;d=Ta(j|0,h|0,d|0,y|0)|0;h=a+120|0;c[h>>2]=d;c[h+4>>2]=y;h=Ra(0,c[f>>2]|0,32)|0;d=y;j=Ra(0,c[i>>2]|0,32)|0;d=Qa(j|0,y|0,h|0,d|0)|0;h=y;g=Ra(0,c[g>>2]|0,32)|0;j=y;l=Ra(0,c[e>>2]|0,32)|0;j=Qa(l|0,y|0,g|0,j|0)|0;g=y;l=Ra(0,c[b>>2]|0,32)|0;k=y;m=Ra(0,c[m>>2]|0,32)|0;k=Qa(m|0,y|0,l|0,k|0)|0;g=Ta(k|0,y|0,j|0,g|0)|0;g=Sa(g|0,y|0,1)|0;h=Ta(g|0,y|0,d|0,h|0)|0;d=a+128|0;c[d>>2]=h;c[d+4>>2]=y;f=Ra(0,c[f>>2]|0,32)|0;d=y;h=Ra(0,c[e>>2]|0,32)|0;d=Qa(h|0,y|0,f|0,d|0)|0;f=y;h=Ra(0,c[b>>2]|0,32)|0;g=y;i=Ra(0,c[i>>2]|0,32)|0;g=Qa(i|0,y|0,h|0,g|0)|0;f=Ta(g|0,y|0,d|0,f|0)|0;d=a+136|0;c[d>>2]=f;c[d+4>>2]=y;d=Ra(0,c[b>>2]|0,31)|0;b=y;e=Ra(0,c[e>>2]|0,32)|0;b=Qa(e|0,y|0,d|0,b|0)|0;d=a+144|0;c[d>>2]=b;c[d+4>>2]=y;return}function ua(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;f=a+80|0;d=f;c[d>>2]=0;c[d+4>>2]=0;d=a;e=c[d>>2]|0;d=c[d+4>>2]|0;i=Ta(d>>31>>>6|0,0,e|0,d|0)|0;i=Ra(i|0,y|0,26)|0;g=y;b=Sa(i|0,g|0,26)|0;b=Ua(e|0,d|0,b|0,y|0)|0;d=a;c[d>>2]=b;c[d+4>>2]=y;d=a+8|0;b=d;b=Ta(i|0,g|0,c[b>>2]|0,c[b+4>>2]|0)|0;g=y;i=Ta(g>>31>>>7|0,0,b|0,g|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(b|0,g|0,j|0,y|0)|0;g=d;c[g>>2]=j;c[g+4>>2]=y;g=a+16|0;j=g;j=Ta(i|0,e|0,c[j>>2]|0,c[j+4>>2]|0)|0;e=y;i=Ta(e>>31>>>6|0,0,j|0,e|0)|0;i=Ra(i|0,y|0,26)|0;b=y;h=Sa(i|0,b|0,26)|0;h=Ua(j|0,e|0,h|0,y|0)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+24|0;h=g;h=Ta(i|0,b|0,c[h>>2]|0,c[h+4>>2]|0)|0;b=y;i=Ta(b>>31>>>7|0,0,h|0,b|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(h|0,b|0,j|0,y|0)|0;c[g>>2]=j;c[g+4>>2]=y;g=a+32|0;j=g;j=Ta(i|0,e|0,c[j>>2]|0,c[j+4>>2]|0)|0;e=y;i=Ta(e>>31>>>6|0,0,j|0,e|0)|0;i=Ra(i|0,y|0,26)|0;b=y;h=Sa(i|0,b|0,26)|0;h=Ua(j|0,e|0,h|0,y|0)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+40|0;h=g;h=Ta(i|0,b|0,c[h>>2]|0,c[h+4>>2]|0)|0;b=y;i=Ta(b>>31>>>7|0,0,h|0,b|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(h|0,b|0,j|0,y|0)|0;c[g>>2]=j;c[g+4>>2]=y;g=a+48|0;j=g;j=Ta(i|0,e|0,c[j>>2]|0,c[j+4>>2]|0)|0;e=y;i=Ta(e>>31>>>6|0,0,j|0,e|0)|0;i=Ra(i|0,y|0,26)|0;b=y;h=Sa(i|0,b|0,26)|0;h=Ua(j|0,e|0,h|0,y|0)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+56|0;h=g;h=Ta(i|0,b|0,c[h>>2]|0,c[h+4>>2]|0)|0;b=y;i=Ta(b>>31>>>7|0,0,h|0,b|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(h|0,b|0,j|0,y|0)|0;c[g>>2]=j;c[g+4>>2]=y;g=a+64|0;j=g;j=Ta(i|0,e|0,c[j>>2]|0,c[j+4>>2]|0)|0;e=y;i=Ta(e>>31>>>6|0,0,j|0,e|0)|0;i=Ra(i|0,y|0,26)|0;b=y;h=Sa(i|0,b|0,26)|0;h=Ua(j|0,e|0,h|0,y|0)|0;c[g>>2]=h;c[g+4>>2]=y;g=a+72|0;h=g;h=Ta(i|0,b|0,c[h>>2]|0,c[h+4>>2]|0)|0;b=y;i=Ta(b>>31>>>7|0,0,h|0,b|0)|0;i=Ra(i|0,y|0,25)|0;e=y;j=Sa(i|0,e|0,25)|0;j=Ua(h|0,b|0,j|0,y|0)|0;c[g>>2]=j;c[g+4>>2]=y;g=f;g=Ta(i|0,e|0,c[g>>2]|0,c[g+4>>2]|0)|0;e=y;i=a;j=c[i>>2]|0;i=c[i+4>>2]|0;b=Qa(g|0,e|0,18,0)|0;h=y;e=Ta(j|0,i|0,g|0,e|0)|0;h=Ta(e|0,y|0,b|0,h|0)|0;b=y;c[f>>2]=0;c[f+4>>2]=0;f=Ta(b>>31>>>6|0,0,h|0,b|0)|0;f=Ra(f|0,y|0,26)|0;e=y;g=Sa(f|0,e|0,26)|0;g=Ua(h|0,b|0,g|0,y|0)|0;b=a;c[b>>2]=g;c[b+4>>2]=y;b=d;b=Ta(f|0,e|0,c[b>>2]|0,c[b+4>>2]|0)|0;a=d;c[a>>2]=b;c[a+4>>2]=y;return}function va(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0;e=l;l=l+160|0;d=e;u=c[b>>2]|0;R=Ra(0,u|0,32)|0;N=y;A=Qa(R|0,N|0,R|0,N|0)|0;E=d;c[E>>2]=A;c[E+4>>2]=y;u=Ra(0,u|0,31)|0;E=y;A=b+8|0;F=c[A>>2]|0;g=Ra(0,F|0,32)|0;x=y;z=Qa(g|0,x|0,u|0,E|0)|0;h=d+8|0;k=h;c[k>>2]=z;c[k+4>>2]=y;k=Qa(g|0,x|0,g|0,x|0)|0;z=y;i=b+16|0;f=Ra(0,c[i>>2]|0,32)|0;H=y;q=Qa(f|0,H|0,R|0,N|0)|0;z=Ta(q|0,y|0,k|0,z|0)|0;z=Sa(z|0,y|0,1)|0;k=d+16|0;q=k;c[q>>2]=z;c[q+4>>2]=y;q=Qa(f|0,H|0,g|0,x|0)|0;z=y;G=b+24|0;P=Ra(0,c[G>>2]|0,32)|0;Q=y;t=Qa(P|0,Q|0,R|0,N|0)|0;z=Ta(t|0,y|0,q|0,z|0)|0;z=Sa(z|0,y|0,1)|0;q=d+24|0;t=q;c[t>>2]=z;c[t+4>>2]=y;t=Qa(f|0,H|0,f|0,H|0)|0;z=y;m=Ra(0,F|0,30)|0;m=Qa(P|0,Q|0,m|0,y|0)|0;z=Ta(m|0,y|0,t|0,z|0)|0;t=y;m=b+32|0;D=Ra(0,c[m>>2]|0,32)|0;r=y;E=Qa(D|0,r|0,u|0,E|0)|0;E=Ta(z|0,t|0,E|0,y|0)|0;t=d+32|0;z=t;c[z>>2]=E;c[z+4>>2]=y;z=Qa(P|0,Q|0,f|0,H|0)|0;E=y;u=Qa(D|0,r|0,g|0,x|0)|0;E=Ta(u|0,y|0,z|0,E|0)|0;z=y;u=b+40|0;v=Ra(0,c[u>>2]|0,32)|0;j=y;M=Qa(v|0,j|0,R|0,N|0)|0;M=Ta(E|0,z|0,M|0,y|0)|0;M=Sa(M|0,y|0,1)|0;z=d+40|0;E=z;c[E>>2]=M;c[E+4>>2]=y;E=Qa(P|0,Q|0,P|0,Q|0)|0;M=y;C=Qa(D|0,r|0,f|0,H|0)|0;M=Ta(C|0,y|0,E|0,M|0)|0;E=y;C=b+48|0;p=Ra(0,c[C>>2]|0,32)|0;o=y;J=Qa(p|0,o|0,R|0,N|0)|0;J=Ta(M|0,E|0,J|0,y|0)|0;E=y;F=Ra(0,F|0,31)|0;F=Qa(v|0,j|0,F|0,y|0)|0;F=Ta(J|0,E|0,F|0,y|0)|0;F=Sa(F|0,y|0,1)|0;E=d+48|0;J=E;c[J>>2]=F;c[J+4>>2]=y;J=Qa(D|0,r|0,P|0,Q|0)|0;F=y;M=Qa(v|0,j|0,f|0,H|0)|0;F=Ta(M|0,y|0,J|0,F|0)|0;J=y;M=Qa(p|0,o|0,g|0,x|0)|0;M=Ta(F|0,J|0,M|0,y|0)|0;J=y;F=b+56|0;s=Ra(0,c[F>>2]|0,32)|0;n=y;B=Qa(s|0,n|0,R|0,N|0)|0;B=Ta(M|0,J|0,B|0,y|0)|0;B=Sa(B|0,y|0,1)|0;J=d+56|0;M=J;c[M>>2]=B;c[M+4>>2]=y;M=Qa(D|0,r|0,D|0,r|0)|0;B=y;K=Qa(p|0,o|0,f|0,H|0)|0;O=y;L=b+64|0;I=Ra(0,c[L>>2]|0,32)|0;w=y;N=Qa(I|0,w|0,R|0,N|0)|0;O=Ta(N|0,y|0,K|0,O|0)|0;K=y;x=Qa(s|0,n|0,g|0,x|0)|0;g=y;N=Qa(v|0,j|0,P|0,Q|0)|0;g=Ta(N|0,y|0,x|0,g|0)|0;g=Sa(g|0,y|0,1)|0;g=Ta(O|0,K|0,g|0,y|0)|0;g=Sa(g|0,y|0,1)|0;B=Ta(g|0,y|0,M|0,B|0)|0;M=d+64|0;g=M;c[g>>2]=B;c[g+4>>2]=y;g=Qa(v|0,j|0,D|0,r|0)|0;B=y;Q=Qa(p|0,o|0,P|0,Q|0)|0;B=Ta(Q|0,y|0,g|0,B|0)|0;g=y;H=Qa(s|0,n|0,f|0,H|0)|0;H=Ta(B|0,g|0,H|0,y|0)|0;g=y;A=Ra(0,c[A>>2]|0,32)|0;B=y;f=Qa(I|0,w|0,A|0,B|0)|0;f=Ta(H|0,g|0,f|0,y|0)|0;g=y;H=Ra(0,c[b>>2]|0,32)|0;Q=y;P=c[b+72>>2]|0;K=Ra(0,P|0,32)|0;O=y;Q=Qa(K|0,O|0,H|0,Q|0)|0;Q=Ta(f|0,g|0,Q|0,y|0)|0;Q=Sa(Q|0,y|0,1)|0;g=d+72|0;c[g>>2]=Q;c[g+4>>2]=y;g=Qa(v|0,j|0,v|0,j|0)|0;Q=y;b=Qa(p|0,o|0,D|0,r|0)|0;Q=Ta(b|0,y|0,g|0,Q|0)|0;g=y;b=Ra(0,c[i>>2]|0,32)|0;i=y;r=Qa(I|0,w|0,b|0,i|0)|0;r=Ta(Q|0,g|0,r|0,y|0)|0;g=y;G=Ra(0,c[G>>2]|0,32)|0;Q=y;D=Qa(s|0,n|0,G|0,Q|0)|0;f=y;B=Qa(K|0,O|0,A|0,B|0)|0;f=Ta(B|0,y|0,D|0,f|0)|0;f=Sa(f|0,y|0,1)|0;f=Ta(r|0,g|0,f|0,y|0)|0;f=Sa(f|0,y|0,1)|0;g=d+80|0;r=g;c[r>>2]=f;c[r+4>>2]=y;j=Qa(p|0,o|0,v|0,j|0)|0;v=y;m=Ra(0,c[m>>2]|0,32)|0;r=y;f=Qa(s|0,n|0,m|0,r|0)|0;v=Ta(f|0,y|0,j|0,v|0)|0;j=y;f=Qa(I|0,w|0,G|0,Q|0)|0;f=Ta(v|0,j|0,f|0,y|0)|0;j=y;i=Qa(K|0,O|0,b|0,i|0)|0;i=Ta(f|0,j|0,i|0,y|0)|0;j=y;f=Sa(i|0,j|0,1)|0;b=y;v=d+88|0;c[v>>2]=f;c[v+4>>2]=b;o=Qa(p|0,o|0,p|0,o|0)|0;p=y;v=Qa(I|0,w|0,m|0,r|0)|0;D=y;u=c[u>>2]|0;B=Ra(0,u|0,32)|0;A=y;H=Qa(s|0,n|0,B|0,A|0)|0;x=y;Q=Qa(K|0,O|0,G|0,Q|0)|0;x=Ta(Q|0,y|0,H|0,x|0)|0;x=Sa(x|0,y|0,1)|0;D=Ta(x|0,y|0,v|0,D|0)|0;D=Sa(D|0,y|0,1)|0;p=Ta(D|0,y|0,o|0,p|0)|0;o=y;D=d+96|0;c[D>>2]=p;c[D+4>>2]=o;C=Ra(0,c[C>>2]|0,32)|0;D=y;n=Qa(s|0,n|0,C|0,D|0)|0;s=y;A=Qa(I|0,w|0,B|0,A|0)|0;s=Ta(A|0,y|0,n|0,s|0)|0;n=y;r=Qa(K|0,O|0,m|0,r|0)|0;r=Ta(s|0,n|0,r|0,y|0)|0;n=y;s=Sa(r|0,n|0,1)|0;m=y;A=d+104|0;c[A>>2]=s;c[A+4>>2]=m;F=c[F>>2]|0;A=Ra(0,F|0,32)|0;B=y;v=Qa(A|0,B|0,A|0,B|0)|0;x=y;w=Qa(I|0,w|0,C|0,D|0)|0;x=Ta(w|0,y|0,v|0,x|0)|0;v=y;u=Ra(0,u|0,31)|0;u=Qa(K|0,O|0,u|0,y|0)|0;u=Ta(x|0,v|0,u|0,y|0)|0;v=y;x=Sa(u|0,v|0,1)|0;w=y;I=d+112|0;c[I>>2]=x;c[I+4>>2]=w;L=c[L>>2]|0;I=Ra(0,L|0,32)|0;H=y;B=Qa(I|0,H|0,A|0,B|0)|0;A=y;D=Qa(K|0,O|0,C|0,D|0)|0;A=Ta(D|0,y|0,B|0,A|0)|0;B=y;D=Sa(A|0,B|0,1)|0;C=y;Q=d+120|0;c[Q>>2]=D;c[Q+4>>2]=C;H=Qa(I|0,H|0,I|0,H|0)|0;I=y;F=Ra(0,F|0,30)|0;F=Qa(K|0,O|0,F|0,y|0)|0;I=Ta(F|0,y|0,H|0,I|0)|0;H=y;F=d+128|0;c[F>>2]=I;c[F+4>>2]=H;L=Ra(0,L|0,31)|0;L=Qa(K|0,O|0,L|0,y|0)|0;F=y;Q=d+136|0;c[Q>>2]=L;c[Q+4>>2]=F;P=Ra(0,P|0,31)|0;O=Qa(P|0,y|0,K|0,O|0)|0;K=y;P=d+144|0;c[P>>2]=O;c[P+4>>2]=K;P=M;Q=c[P>>2]|0;P=c[P+4>>2]|0;G=Qa(O|0,K|0,18,0)|0;N=y;K=Ta(Q|0,P|0,O|0,K|0)|0;N=Ta(K|0,y|0,G|0,N|0)|0;c[M>>2]=N;c[M+4>>2]=y;M=J;N=c[M>>2]|0;M=c[M+4>>2]|0;G=Qa(L|0,F|0,18,0)|0;K=y;F=Ta(N|0,M|0,L|0,F|0)|0;K=Ta(F|0,y|0,G|0,K|0)|0;c[J>>2]=K;c[J+4>>2]=y;J=E;K=c[J>>2]|0;J=c[J+4>>2]|0;G=Qa(I|0,H|0,18,0)|0;F=y;H=Ta(K|0,J|0,I|0,H|0)|0;F=Ta(H|0,y|0,G|0,F|0)|0;c[E>>2]=F;c[E+4>>2]=y;E=z;F=c[E>>2]|0;E=c[E+4>>2]|0;B=Qa(A|0,B|0,36,0)|0;A=y;C=Ta(F|0,E|0,D|0,C|0)|0;A=Ta(C|0,y|0,B|0,A|0)|0;c[z>>2]=A;c[z+4>>2]=y;z=t;A=c[z>>2]|0;z=c[z+4>>2]|0;v=Qa(u|0,v|0,36,0)|0;u=y;w=Ta(A|0,z|0,x|0,w|0)|0;u=Ta(w|0,y|0,v|0,u|0)|0;c[t>>2]=u;c[t+4>>2]=y;t=q;u=c[t>>2]|0;t=c[t+4>>2]|0;n=Qa(r|0,n|0,36,0)|0;r=y;m=Ta(u|0,t|0,s|0,m|0)|0;r=Ta(m|0,y|0,n|0,r|0)|0;c[q>>2]=r;c[q+4>>2]=y;q=k;r=c[q>>2]|0;q=c[q+4>>2]|0;n=Qa(p|0,o|0,18,0)|0;m=y;o=Ta(r|0,q|0,p|0,o|0)|0;m=Ta(o|0,y|0,n|0,m|0)|0;c[k>>2]=m;c[k+4>>2]=y;k=h;m=c[k>>2]|0;k=c[k+4>>2]|0;j=Qa(i|0,j|0,36,0)|0;i=y;b=Ta(m|0,k|0,f|0,b|0)|0;i=Ta(b|0,y|0,j|0,i|0)|0;c[h>>2]=i;c[h+4>>2]=y;h=c[g>>2]|0;g=c[g+4>>2]|0;i=d;j=c[i>>2]|0;i=c[i+4>>2]|0;b=Qa(h|0,g|0,18,0)|0;f=y;g=Ta(j|0,i|0,h|0,g|0)|0;f=Ta(g|0,y|0,b|0,f|0)|0;b=d;c[b>>2]=f;c[b+4>>2]=y;ua(d);b=d;d=a+80|0;do{c[a>>2]=c[b>>2];a=a+4|0;b=b+4|0}while((a|0)<(d|0));l=e;return}function wa(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;x=l;l=l+16|0;o=x;do if(a>>>0<245){k=a>>>0<11?16:a+11&-8;a=k>>>3;n=c[146]|0;d=n>>>a;if(d&3|0){b=(d&1^1)+a|0;a=624+(b<<1<<2)|0;d=a+8|0;e=c[d>>2]|0;f=e+8|0;g=c[f>>2]|0;if((a|0)==(g|0))c[146]=n&~(1<<b);else{c[g+12>>2]=a;c[d>>2]=g}w=b<<3;c[e+4>>2]=w|3;w=e+w+4|0;c[w>>2]=c[w>>2]|1;w=f;l=x;return w|0}m=c[148]|0;if(k>>>0>m>>>0){if(d|0){b=2<<a;b=d<<a&(b|0-b);b=(b&0-b)+-1|0;h=b>>>12&16;b=b>>>h;d=b>>>5&8;b=b>>>d;f=b>>>2&4;b=b>>>f;a=b>>>1&2;b=b>>>a;e=b>>>1&1;e=(d|h|f|a|e)+(b>>>e)|0;b=624+(e<<1<<2)|0;a=b+8|0;f=c[a>>2]|0;h=f+8|0;d=c[h>>2]|0;if((b|0)==(d|0)){a=n&~(1<<e);c[146]=a}else{c[d+12>>2]=b;c[a>>2]=d;a=n}g=(e<<3)-k|0;c[f+4>>2]=k|3;e=f+k|0;c[e+4>>2]=g|1;c[e+g>>2]=g;if(m|0){f=c[151]|0;b=m>>>3;d=624+(b<<1<<2)|0;b=1<<b;if(!(a&b)){c[146]=a|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=f;c[b+12>>2]=f;c[f+8>>2]=b;c[f+12>>2]=d}c[148]=g;c[151]=e;w=h;l=x;return w|0}i=c[147]|0;if(i){d=(i&0-i)+-1|0;h=d>>>12&16;d=d>>>h;g=d>>>5&8;d=d>>>g;j=d>>>2&4;d=d>>>j;e=d>>>1&2;d=d>>>e;a=d>>>1&1;a=c[888+((g|h|j|e|a)+(d>>>a)<<2)>>2]|0;d=(c[a+4>>2]&-8)-k|0;e=c[a+16+(((c[a+16>>2]|0)==0&1)<<2)>>2]|0;if(!e){j=a;g=d}else{do{h=(c[e+4>>2]&-8)-k|0;j=h>>>0<d>>>0;d=j?h:d;a=j?e:a;e=c[e+16+(((c[e+16>>2]|0)==0&1)<<2)>>2]|0}while((e|0)!=0);j=a;g=d}h=j+k|0;if(j>>>0<h>>>0){f=c[j+24>>2]|0;b=c[j+12>>2]|0;do if((b|0)==(j|0)){a=j+20|0;b=c[a>>2]|0;if(!b){a=j+16|0;b=c[a>>2]|0;if(!b){d=0;break}}while(1){d=b+20|0;e=c[d>>2]|0;if(e|0){b=e;a=d;continue}d=b+16|0;e=c[d>>2]|0;if(!e)break;else{b=e;a=d}}c[a>>2]=0;d=b}else{d=c[j+8>>2]|0;c[d+12>>2]=b;c[b+8>>2]=d;d=b}while(0);do if(f|0){b=c[j+28>>2]|0;a=888+(b<<2)|0;if((j|0)==(c[a>>2]|0)){c[a>>2]=d;if(!d){c[147]=i&~(1<<b);break}}else{c[f+16+(((c[f+16>>2]|0)!=(j|0)&1)<<2)>>2]=d;if(!d)break}c[d+24>>2]=f;b=c[j+16>>2]|0;if(b|0){c[d+16>>2]=b;c[b+24>>2]=d}b=c[j+20>>2]|0;if(b|0){c[d+20>>2]=b;c[b+24>>2]=d}}while(0);if(g>>>0<16){w=g+k|0;c[j+4>>2]=w|3;w=j+w+4|0;c[w>>2]=c[w>>2]|1}else{c[j+4>>2]=k|3;c[h+4>>2]=g|1;c[h+g>>2]=g;if(m|0){e=c[151]|0;b=m>>>3;d=624+(b<<1<<2)|0;b=1<<b;if(!(n&b)){c[146]=n|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=e;c[b+12>>2]=e;c[e+8>>2]=b;c[e+12>>2]=d}c[148]=g;c[151]=h}w=j+8|0;l=x;return w|0}else n=k}else n=k}else n=k}else if(a>>>0<=4294967231){a=a+11|0;k=a&-8;j=c[147]|0;if(j){e=0-k|0;a=a>>>8;if(a)if(k>>>0>16777215)i=31;else{n=(a+1048320|0)>>>16&8;v=a<<n;m=(v+520192|0)>>>16&4;v=v<<m;i=(v+245760|0)>>>16&2;i=14-(m|n|i)+(v<<i>>>15)|0;i=k>>>(i+7|0)&1|i<<1}else i=0;d=c[888+(i<<2)>>2]|0;a:do if(!d){d=0;a=0;v=57}else{a=0;h=k<<((i|0)==31?0:25-(i>>>1)|0);g=0;while(1){f=(c[d+4>>2]&-8)-k|0;if(f>>>0<e>>>0)if(!f){a=d;e=0;f=d;v=61;break a}else{a=d;e=f}f=c[d+20>>2]|0;d=c[d+16+(h>>>31<<2)>>2]|0;g=(f|0)==0|(f|0)==(d|0)?g:f;f=(d|0)==0;if(f){d=g;v=57;break}else h=h<<((f^1)&1)}}while(0);if((v|0)==57){if((d|0)==0&(a|0)==0){a=2<<i;a=j&(a|0-a);if(!a){n=k;break}n=(a&0-a)+-1|0;h=n>>>12&16;n=n>>>h;g=n>>>5&8;n=n>>>g;i=n>>>2&4;n=n>>>i;m=n>>>1&2;n=n>>>m;d=n>>>1&1;a=0;d=c[888+((g|h|i|m|d)+(n>>>d)<<2)>>2]|0}if(!d){i=a;h=e}else{f=d;v=61}}if((v|0)==61)while(1){v=0;d=(c[f+4>>2]&-8)-k|0;n=d>>>0<e>>>0;d=n?d:e;a=n?f:a;f=c[f+16+(((c[f+16>>2]|0)==0&1)<<2)>>2]|0;if(!f){i=a;h=d;break}else{e=d;v=61}}if((i|0)!=0?h>>>0<((c[148]|0)-k|0)>>>0:0){g=i+k|0;if(i>>>0>=g>>>0){w=0;l=x;return w|0}f=c[i+24>>2]|0;b=c[i+12>>2]|0;do if((b|0)==(i|0)){a=i+20|0;b=c[a>>2]|0;if(!b){a=i+16|0;b=c[a>>2]|0;if(!b){b=0;break}}while(1){d=b+20|0;e=c[d>>2]|0;if(e|0){b=e;a=d;continue}d=b+16|0;e=c[d>>2]|0;if(!e)break;else{b=e;a=d}}c[a>>2]=0}else{w=c[i+8>>2]|0;c[w+12>>2]=b;c[b+8>>2]=w}while(0);do if(f){a=c[i+28>>2]|0;d=888+(a<<2)|0;if((i|0)==(c[d>>2]|0)){c[d>>2]=b;if(!b){e=j&~(1<<a);c[147]=e;break}}else{c[f+16+(((c[f+16>>2]|0)!=(i|0)&1)<<2)>>2]=b;if(!b){e=j;break}}c[b+24>>2]=f;a=c[i+16>>2]|0;if(a|0){c[b+16>>2]=a;c[a+24>>2]=b}a=c[i+20>>2]|0;if(a){c[b+20>>2]=a;c[a+24>>2]=b;e=j}else e=j}else e=j;while(0);do if(h>>>0>=16){c[i+4>>2]=k|3;c[g+4>>2]=h|1;c[g+h>>2]=h;b=h>>>3;if(h>>>0<256){d=624+(b<<1<<2)|0;a=c[146]|0;b=1<<b;if(!(a&b)){c[146]=a|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=g;c[b+12>>2]=g;c[g+8>>2]=b;c[g+12>>2]=d;break}b=h>>>8;if(b)if(h>>>0>16777215)b=31;else{v=(b+1048320|0)>>>16&8;w=b<<v;u=(w+520192|0)>>>16&4;w=w<<u;b=(w+245760|0)>>>16&2;b=14-(u|v|b)+(w<<b>>>15)|0;b=h>>>(b+7|0)&1|b<<1}else b=0;d=888+(b<<2)|0;c[g+28>>2]=b;a=g+16|0;c[a+4>>2]=0;c[a>>2]=0;a=1<<b;if(!(e&a)){c[147]=e|a;c[d>>2]=g;c[g+24>>2]=d;c[g+12>>2]=g;c[g+8>>2]=g;break}a=h<<((b|0)==31?0:25-(b>>>1)|0);d=c[d>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(h|0)){v=97;break}e=d+16+(a>>>31<<2)|0;b=c[e>>2]|0;if(!b){v=96;break}else{a=a<<1;d=b}}if((v|0)==96){c[e>>2]=g;c[g+24>>2]=d;c[g+12>>2]=g;c[g+8>>2]=g;break}else if((v|0)==97){v=d+8|0;w=c[v>>2]|0;c[w+12>>2]=g;c[v>>2]=g;c[g+8>>2]=w;c[g+12>>2]=d;c[g+24>>2]=0;break}}else{w=h+k|0;c[i+4>>2]=w|3;w=i+w+4|0;c[w>>2]=c[w>>2]|1}while(0);w=i+8|0;l=x;return w|0}else n=k}else n=k}else n=-1;while(0);d=c[148]|0;if(d>>>0>=n>>>0){b=d-n|0;a=c[151]|0;if(b>>>0>15){w=a+n|0;c[151]=w;c[148]=b;c[w+4>>2]=b|1;c[w+b>>2]=b;c[a+4>>2]=n|3}else{c[148]=0;c[151]=0;c[a+4>>2]=d|3;w=a+d+4|0;c[w>>2]=c[w>>2]|1}w=a+8|0;l=x;return w|0}h=c[149]|0;if(h>>>0>n>>>0){u=h-n|0;c[149]=u;w=c[152]|0;v=w+n|0;c[152]=v;c[v+4>>2]=u|1;c[w+4>>2]=n|3;w=w+8|0;l=x;return w|0}if(!(c[264]|0)){c[266]=4096;c[265]=4096;c[267]=-1;c[268]=-1;c[269]=0;c[257]=0;a=o&-16^1431655768;c[o>>2]=a;c[264]=a;a=4096}else a=c[266]|0;i=n+48|0;j=n+47|0;g=a+j|0;f=0-a|0;k=g&f;if(k>>>0<=n>>>0){w=0;l=x;return w|0}a=c[256]|0;if(a|0?(m=c[254]|0,o=m+k|0,o>>>0<=m>>>0|o>>>0>a>>>0):0){w=0;l=x;return w|0}b:do if(!(c[257]&4)){d=c[152]|0;c:do if(d){e=1032;while(1){a=c[e>>2]|0;if(a>>>0<=d>>>0?(r=e+4|0,(a+(c[r>>2]|0)|0)>>>0>d>>>0):0)break;a=c[e+8>>2]|0;if(!a){v=118;break c}else e=a}b=g-h&f;if(b>>>0<2147483647){a=Xa(b|0)|0;if((a|0)==((c[e>>2]|0)+(c[r>>2]|0)|0)){if((a|0)!=(-1|0)){h=b;g=a;v=135;break b}}else{e=a;v=126}}else b=0}else v=118;while(0);do if((v|0)==118){d=Xa(0)|0;if((d|0)!=(-1|0)?(b=d,p=c[265]|0,q=p+-1|0,b=((q&b|0)==0?0:(q+b&0-p)-b|0)+k|0,p=c[254]|0,q=b+p|0,b>>>0>n>>>0&b>>>0<2147483647):0){r=c[256]|0;if(r|0?q>>>0<=p>>>0|q>>>0>r>>>0:0){b=0;break}a=Xa(b|0)|0;if((a|0)==(d|0)){h=b;g=d;v=135;break b}else{e=a;v=126}}else b=0}while(0);do if((v|0)==126){d=0-b|0;if(!(i>>>0>b>>>0&(b>>>0<2147483647&(e|0)!=(-1|0))))if((e|0)==(-1|0)){b=0;break}else{h=b;g=e;v=135;break b}a=c[266]|0;a=j-b+a&0-a;if(a>>>0>=2147483647){h=b;g=e;v=135;break b}if((Xa(a|0)|0)==(-1|0)){Xa(d|0)|0;b=0;break}else{h=a+b|0;g=e;v=135;break b}}while(0);c[257]=c[257]|4;v=133}else{b=0;v=133}while(0);if(((v|0)==133?k>>>0<2147483647:0)?(u=Xa(k|0)|0,r=Xa(0)|0,s=r-u|0,t=s>>>0>(n+40|0)>>>0,!((u|0)==(-1|0)|t^1|u>>>0<r>>>0&((u|0)!=(-1|0)&(r|0)!=(-1|0))^1)):0){h=t?s:b;g=u;v=135}if((v|0)==135){b=(c[254]|0)+h|0;c[254]=b;if(b>>>0>(c[255]|0)>>>0)c[255]=b;j=c[152]|0;do if(j){b=1032;while(1){a=c[b>>2]|0;d=b+4|0;e=c[d>>2]|0;if((g|0)==(a+e|0)){v=145;break}f=c[b+8>>2]|0;if(!f)break;else b=f}if(((v|0)==145?(c[b+12>>2]&8|0)==0:0)?j>>>0<g>>>0&j>>>0>=a>>>0:0){c[d>>2]=e+h;w=j+8|0;w=(w&7|0)==0?0:0-w&7;v=j+w|0;w=(c[149]|0)+(h-w)|0;c[152]=v;c[149]=w;c[v+4>>2]=w|1;c[v+w+4>>2]=40;c[153]=c[268];break}if(g>>>0<(c[150]|0)>>>0)c[150]=g;d=g+h|0;b=1032;while(1){if((c[b>>2]|0)==(d|0)){v=153;break}a=c[b+8>>2]|0;if(!a)break;else b=a}if((v|0)==153?(c[b+12>>2]&8|0)==0:0){c[b>>2]=g;m=b+4|0;c[m>>2]=(c[m>>2]|0)+h;m=g+8|0;m=g+((m&7|0)==0?0:0-m&7)|0;b=d+8|0;b=d+((b&7|0)==0?0:0-b&7)|0;k=m+n|0;i=b-m-n|0;c[m+4>>2]=n|3;do if((b|0)!=(j|0)){if((b|0)==(c[151]|0)){w=(c[148]|0)+i|0;c[148]=w;c[151]=k;c[k+4>>2]=w|1;c[k+w>>2]=w;break}a=c[b+4>>2]|0;if((a&3|0)==1){h=a&-8;e=a>>>3;d:do if(a>>>0<256){a=c[b+8>>2]|0;d=c[b+12>>2]|0;if((d|0)==(a|0)){c[146]=c[146]&~(1<<e);break}else{c[a+12>>2]=d;c[d+8>>2]=a;break}}else{g=c[b+24>>2]|0;a=c[b+12>>2]|0;do if((a|0)==(b|0)){e=b+16|0;d=e+4|0;a=c[d>>2]|0;if(!a){a=c[e>>2]|0;if(!a){a=0;break}else d=e}while(1){e=a+20|0;f=c[e>>2]|0;if(f|0){a=f;d=e;continue}e=a+16|0;f=c[e>>2]|0;if(!f)break;else{a=f;d=e}}c[d>>2]=0}else{w=c[b+8>>2]|0;c[w+12>>2]=a;c[a+8>>2]=w}while(0);if(!g)break;d=c[b+28>>2]|0;e=888+(d<<2)|0;do if((b|0)!=(c[e>>2]|0)){c[g+16+(((c[g+16>>2]|0)!=(b|0)&1)<<2)>>2]=a;if(!a)break d}else{c[e>>2]=a;if(a|0)break;c[147]=c[147]&~(1<<d);break d}while(0);c[a+24>>2]=g;d=b+16|0;e=c[d>>2]|0;if(e|0){c[a+16>>2]=e;c[e+24>>2]=a}d=c[d+4>>2]|0;if(!d)break;c[a+20>>2]=d;c[d+24>>2]=a}while(0);b=b+h|0;f=h+i|0}else f=i;b=b+4|0;c[b>>2]=c[b>>2]&-2;c[k+4>>2]=f|1;c[k+f>>2]=f;b=f>>>3;if(f>>>0<256){d=624+(b<<1<<2)|0;a=c[146]|0;b=1<<b;if(!(a&b)){c[146]=a|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=k;c[b+12>>2]=k;c[k+8>>2]=b;c[k+12>>2]=d;break}b=f>>>8;do if(!b)b=0;else{if(f>>>0>16777215){b=31;break}v=(b+1048320|0)>>>16&8;w=b<<v;u=(w+520192|0)>>>16&4;w=w<<u;b=(w+245760|0)>>>16&2;b=14-(u|v|b)+(w<<b>>>15)|0;b=f>>>(b+7|0)&1|b<<1}while(0);e=888+(b<<2)|0;c[k+28>>2]=b;a=k+16|0;c[a+4>>2]=0;c[a>>2]=0;a=c[147]|0;d=1<<b;if(!(a&d)){c[147]=a|d;c[e>>2]=k;c[k+24>>2]=e;c[k+12>>2]=k;c[k+8>>2]=k;break}a=f<<((b|0)==31?0:25-(b>>>1)|0);d=c[e>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(f|0)){v=194;break}e=d+16+(a>>>31<<2)|0;b=c[e>>2]|0;if(!b){v=193;break}else{a=a<<1;d=b}}if((v|0)==193){c[e>>2]=k;c[k+24>>2]=d;c[k+12>>2]=k;c[k+8>>2]=k;break}else if((v|0)==194){v=d+8|0;w=c[v>>2]|0;c[w+12>>2]=k;c[v>>2]=k;c[k+8>>2]=w;c[k+12>>2]=d;c[k+24>>2]=0;break}}else{w=(c[149]|0)+i|0;c[149]=w;c[152]=k;c[k+4>>2]=w|1}while(0);w=m+8|0;l=x;return w|0}b=1032;while(1){a=c[b>>2]|0;if(a>>>0<=j>>>0?(w=a+(c[b+4>>2]|0)|0,w>>>0>j>>>0):0)break;b=c[b+8>>2]|0}f=w+-47|0;a=f+8|0;a=f+((a&7|0)==0?0:0-a&7)|0;f=j+16|0;a=a>>>0<f>>>0?j:a;b=a+8|0;d=g+8|0;d=(d&7|0)==0?0:0-d&7;v=g+d|0;d=h+-40-d|0;c[152]=v;c[149]=d;c[v+4>>2]=d|1;c[v+d+4>>2]=40;c[153]=c[268];d=a+4|0;c[d>>2]=27;c[b>>2]=c[258];c[b+4>>2]=c[259];c[b+8>>2]=c[260];c[b+12>>2]=c[261];c[258]=g;c[259]=h;c[261]=0;c[260]=b;b=a+24|0;do{v=b;b=b+4|0;c[b>>2]=7}while((v+8|0)>>>0<w>>>0);if((a|0)!=(j|0)){g=a-j|0;c[d>>2]=c[d>>2]&-2;c[j+4>>2]=g|1;c[a>>2]=g;b=g>>>3;if(g>>>0<256){d=624+(b<<1<<2)|0;a=c[146]|0;b=1<<b;if(!(a&b)){c[146]=a|b;b=d;a=d+8|0}else{a=d+8|0;b=c[a>>2]|0}c[a>>2]=j;c[b+12>>2]=j;c[j+8>>2]=b;c[j+12>>2]=d;break}b=g>>>8;if(b)if(g>>>0>16777215)d=31;else{v=(b+1048320|0)>>>16&8;w=b<<v;u=(w+520192|0)>>>16&4;w=w<<u;d=(w+245760|0)>>>16&2;d=14-(u|v|d)+(w<<d>>>15)|0;d=g>>>(d+7|0)&1|d<<1}else d=0;e=888+(d<<2)|0;c[j+28>>2]=d;c[j+20>>2]=0;c[f>>2]=0;b=c[147]|0;a=1<<d;if(!(b&a)){c[147]=b|a;c[e>>2]=j;c[j+24>>2]=e;c[j+12>>2]=j;c[j+8>>2]=j;break}a=g<<((d|0)==31?0:25-(d>>>1)|0);d=c[e>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(g|0)){v=216;break}e=d+16+(a>>>31<<2)|0;b=c[e>>2]|0;if(!b){v=215;break}else{a=a<<1;d=b}}if((v|0)==215){c[e>>2]=j;c[j+24>>2]=d;c[j+12>>2]=j;c[j+8>>2]=j;break}else if((v|0)==216){v=d+8|0;w=c[v>>2]|0;c[w+12>>2]=j;c[v>>2]=j;c[j+8>>2]=w;c[j+12>>2]=d;c[j+24>>2]=0;break}}}else{w=c[150]|0;if((w|0)==0|g>>>0<w>>>0)c[150]=g;c[258]=g;c[259]=h;c[261]=0;c[155]=c[264];c[154]=-1;b=0;do{w=624+(b<<1<<2)|0;c[w+12>>2]=w;c[w+8>>2]=w;b=b+1|0}while((b|0)!=32);w=g+8|0;w=(w&7|0)==0?0:0-w&7;v=g+w|0;w=h+-40-w|0;c[152]=v;c[149]=w;c[v+4>>2]=w|1;c[v+w+4>>2]=40;c[153]=c[268]}while(0);b=c[149]|0;if(b>>>0>n>>>0){u=b-n|0;c[149]=u;w=c[152]|0;v=w+n|0;c[152]=v;c[v+4>>2]=u|1;c[w+4>>2]=n|3;w=w+8|0;l=x;return w|0}}c[(Ca()|0)>>2]=12;w=0;l=x;return w|0}function xa(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;if(!a)return;d=a+-8|0;f=c[150]|0;a=c[a+-4>>2]|0;b=a&-8;j=d+b|0;do if(!(a&1)){e=c[d>>2]|0;if(!(a&3))return;h=d+(0-e)|0;g=e+b|0;if(h>>>0<f>>>0)return;if((h|0)==(c[151]|0)){a=j+4|0;b=c[a>>2]|0;if((b&3|0)!=3){i=h;b=g;break}c[148]=g;c[a>>2]=b&-2;c[h+4>>2]=g|1;c[h+g>>2]=g;return}d=e>>>3;if(e>>>0<256){a=c[h+8>>2]|0;b=c[h+12>>2]|0;if((b|0)==(a|0)){c[146]=c[146]&~(1<<d);i=h;b=g;break}else{c[a+12>>2]=b;c[b+8>>2]=a;i=h;b=g;break}}f=c[h+24>>2]|0;a=c[h+12>>2]|0;do if((a|0)==(h|0)){d=h+16|0;b=d+4|0;a=c[b>>2]|0;if(!a){a=c[d>>2]|0;if(!a){a=0;break}else b=d}while(1){d=a+20|0;e=c[d>>2]|0;if(e|0){a=e;b=d;continue}d=a+16|0;e=c[d>>2]|0;if(!e)break;else{a=e;b=d}}c[b>>2]=0}else{i=c[h+8>>2]|0;c[i+12>>2]=a;c[a+8>>2]=i}while(0);if(f){b=c[h+28>>2]|0;d=888+(b<<2)|0;if((h|0)==(c[d>>2]|0)){c[d>>2]=a;if(!a){c[147]=c[147]&~(1<<b);i=h;b=g;break}}else{c[f+16+(((c[f+16>>2]|0)!=(h|0)&1)<<2)>>2]=a;if(!a){i=h;b=g;break}}c[a+24>>2]=f;b=h+16|0;d=c[b>>2]|0;if(d|0){c[a+16>>2]=d;c[d+24>>2]=a}b=c[b+4>>2]|0;if(b){c[a+20>>2]=b;c[b+24>>2]=a;i=h;b=g}else{i=h;b=g}}else{i=h;b=g}}else{i=d;h=d}while(0);if(h>>>0>=j>>>0)return;a=j+4|0;e=c[a>>2]|0;if(!(e&1))return;if(!(e&2)){a=c[151]|0;if((j|0)==(c[152]|0)){j=(c[149]|0)+b|0;c[149]=j;c[152]=i;c[i+4>>2]=j|1;if((i|0)!=(a|0))return;c[151]=0;c[148]=0;return}if((j|0)==(a|0)){j=(c[148]|0)+b|0;c[148]=j;c[151]=h;c[i+4>>2]=j|1;c[h+j>>2]=j;return}f=(e&-8)+b|0;d=e>>>3;do if(e>>>0<256){b=c[j+8>>2]|0;a=c[j+12>>2]|0;if((a|0)==(b|0)){c[146]=c[146]&~(1<<d);break}else{c[b+12>>2]=a;c[a+8>>2]=b;break}}else{g=c[j+24>>2]|0;a=c[j+12>>2]|0;do if((a|0)==(j|0)){d=j+16|0;b=d+4|0;a=c[b>>2]|0;if(!a){a=c[d>>2]|0;if(!a){d=0;break}else b=d}while(1){d=a+20|0;e=c[d>>2]|0;if(e|0){a=e;b=d;continue}d=a+16|0;e=c[d>>2]|0;if(!e)break;else{a=e;b=d}}c[b>>2]=0;d=a}else{d=c[j+8>>2]|0;c[d+12>>2]=a;c[a+8>>2]=d;d=a}while(0);if(g|0){a=c[j+28>>2]|0;b=888+(a<<2)|0;if((j|0)==(c[b>>2]|0)){c[b>>2]=d;if(!d){c[147]=c[147]&~(1<<a);break}}else{c[g+16+(((c[g+16>>2]|0)!=(j|0)&1)<<2)>>2]=d;if(!d)break}c[d+24>>2]=g;a=j+16|0;b=c[a>>2]|0;if(b|0){c[d+16>>2]=b;c[b+24>>2]=d}a=c[a+4>>2]|0;if(a|0){c[d+20>>2]=a;c[a+24>>2]=d}}}while(0);c[i+4>>2]=f|1;c[h+f>>2]=f;if((i|0)==(c[151]|0)){c[148]=f;return}}else{c[a>>2]=e&-2;c[i+4>>2]=b|1;c[h+b>>2]=b;f=b}a=f>>>3;if(f>>>0<256){d=624+(a<<1<<2)|0;b=c[146]|0;a=1<<a;if(!(b&a)){c[146]=b|a;a=d;b=d+8|0}else{b=d+8|0;a=c[b>>2]|0}c[b>>2]=i;c[a+12>>2]=i;c[i+8>>2]=a;c[i+12>>2]=d;return}a=f>>>8;if(a)if(f>>>0>16777215)a=31;else{h=(a+1048320|0)>>>16&8;j=a<<h;g=(j+520192|0)>>>16&4;j=j<<g;a=(j+245760|0)>>>16&2;a=14-(g|h|a)+(j<<a>>>15)|0;a=f>>>(a+7|0)&1|a<<1}else a=0;e=888+(a<<2)|0;c[i+28>>2]=a;c[i+20>>2]=0;c[i+16>>2]=0;b=c[147]|0;d=1<<a;do if(b&d){b=f<<((a|0)==31?0:25-(a>>>1)|0);d=c[e>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(f|0)){a=73;break}e=d+16+(b>>>31<<2)|0;a=c[e>>2]|0;if(!a){a=72;break}else{b=b<<1;d=a}}if((a|0)==72){c[e>>2]=i;c[i+24>>2]=d;c[i+12>>2]=i;c[i+8>>2]=i;break}else if((a|0)==73){h=d+8|0;j=c[h>>2]|0;c[j+12>>2]=i;c[h>>2]=i;c[i+8>>2]=j;c[i+12>>2]=d;c[i+24>>2]=0;break}}else{c[147]=b|d;c[e>>2]=i;c[i+24>>2]=e;c[i+12>>2]=i;c[i+8>>2]=i}while(0);j=(c[154]|0)+-1|0;c[154]=j;if(!j)a=1040;else return;while(1){a=c[a>>2]|0;if(!a)break;else a=a+8|0}c[154]=-1;return}function ya(a){a=a|0;var b=0,d=0;b=l;l=l+16|0;d=b;c[d>>2]=Fa(c[a+60>>2]|0)|0;a=Ba(ba(6,d|0)|0)|0;l=b;return a|0}function za(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0;n=l;l=l+48|0;k=n+16|0;g=n;f=n+32|0;i=a+28|0;e=c[i>>2]|0;c[f>>2]=e;j=a+20|0;e=(c[j>>2]|0)-e|0;c[f+4>>2]=e;c[f+8>>2]=b;c[f+12>>2]=d;e=e+d|0;h=a+60|0;c[g>>2]=c[h>>2];c[g+4>>2]=f;c[g+8>>2]=2;g=Ba($(146,g|0)|0)|0;a:do if((e|0)!=(g|0)){b=2;while(1){if((g|0)<0)break;e=e-g|0;p=c[f+4>>2]|0;o=g>>>0>p>>>0;f=o?f+8|0:f;b=(o<<31>>31)+b|0;p=g-(o?p:0)|0;c[f>>2]=(c[f>>2]|0)+p;o=f+4|0;c[o>>2]=(c[o>>2]|0)-p;c[k>>2]=c[h>>2];c[k+4>>2]=f;c[k+8>>2]=b;g=Ba($(146,k|0)|0)|0;if((e|0)==(g|0)){m=3;break a}}c[a+16>>2]=0;c[i>>2]=0;c[j>>2]=0;c[a>>2]=c[a>>2]|32;if((b|0)==2)d=0;else d=d-(c[f+4>>2]|0)|0}else m=3;while(0);if((m|0)==3){p=c[a+44>>2]|0;c[a+16>>2]=p+(c[a+48>>2]|0);c[i>>2]=p;c[j>>2]=p}l=n;return d|0}function Aa(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;f=l;l=l+32|0;g=f;e=f+20|0;c[g>>2]=c[a+60>>2];c[g+4>>2]=0;c[g+8>>2]=b;c[g+12>>2]=e;c[g+16>>2]=d;if((Ba(_(140,g|0)|0)|0)<0){c[e>>2]=-1;a=-1}else a=c[e>>2]|0;l=f;return a|0}function Ba(a){a=a|0;if(a>>>0>4294963200){c[(Ca()|0)>>2]=0-a;a=-1}return a|0}function Ca(){return (Da()|0)+64|0}function Da(){return Ea()|0}function Ea(){return 8}function Fa(a){a=a|0;return a|0}function Ga(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0;g=l;l=l+32|0;f=g;c[b+36>>2]=3;if((c[b>>2]&64|0)==0?(c[f>>2]=c[b+60>>2],c[f+4>>2]=21523,c[f+8>>2]=g+16,aa(54,f|0)|0):0)a[b+75>>0]=-1;f=za(b,d,e)|0;l=g;return f|0}function Ha(){return 1080}function Ia(a){a=a|0;return 0}function Ja(a){a=a|0;return}function Ka(){Y(1144);return 1152}function La(){ca(1144);return}function Ma(a){a=a|0;var b=0,d=0;do if(a){if((c[a+76>>2]|0)<=-1){b=Na(a)|0;break}d=(Ia(a)|0)==0;b=Na(a)|0;if(!d)Ja(a)}else{if(!(c[94]|0))b=0;else b=Ma(c[94]|0)|0;a=c[(Ka()|0)>>2]|0;if(a)do{if((c[a+76>>2]|0)>-1)d=Ia(a)|0;else d=0;if((c[a+20>>2]|0)>>>0>(c[a+28>>2]|0)>>>0)b=Na(a)|0|b;if(d|0)Ja(a);a=c[a+56>>2]|0}while((a|0)!=0);La()}while(0);return b|0}function Na(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;b=a+20|0;h=a+28|0;if((c[b>>2]|0)>>>0>(c[h>>2]|0)>>>0?(ha[c[a+36>>2]&3](a,0,0)|0,(c[b>>2]|0)==0):0)a=-1;else{d=a+4|0;e=c[d>>2]|0;f=a+8|0;g=c[f>>2]|0;if(e>>>0<g>>>0)ha[c[a+40>>2]&3](a,e-g|0,1)|0;c[a+16>>2]=0;c[h>>2]=0;c[b>>2]=0;c[f>>2]=0;c[d>>2]=0;a=0}return a|0}function Oa(){}function Pa(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;e=b&65535;c=N(e,f)|0;d=a>>>16;a=(c>>>16)+(N(e,d)|0)|0;e=b>>>16;b=N(e,f)|0;return (y=(a>>>16)+(N(e,d)|0)+(((a&65535)+b|0)>>>16)|0,a+b<<16|c&65535|0)|0}function Qa(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;c=Pa(e,f)|0;a=y;return (y=(N(b,f)|0)+(N(d,e)|0)+a|a&0,c|0|0)|0}function Ra(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){y=b>>c;return a>>>c|(b&(1<<c)-1)<<32-c}y=(b|0)<0?-1:0;return b>>c-32|0}function Sa(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){y=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}y=a<<c-32;return 0}function Ta(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return (y=b+d+(c>>>0<a>>>0|0)>>>0,c|0)|0}function Ua(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;d=b-d-(c>>>0>a>>>0|0)>>>0;return (y=d,a-c>>>0|0)|0}function Va(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;if((e|0)>=8192)return ea(b|0,d|0,e|0)|0;h=b|0;g=b+e|0;if((b&3)==(d&3)){while(b&3){if(!e)return h|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}e=g&-4|0;f=e-64|0;while((b|0)<=(f|0)){c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[b+28>>2]=c[d+28>>2];c[b+32>>2]=c[d+32>>2];c[b+36>>2]=c[d+36>>2];c[b+40>>2]=c[d+40>>2];c[b+44>>2]=c[d+44>>2];c[b+48>>2]=c[d+48>>2];c[b+52>>2]=c[d+52>>2];c[b+56>>2]=c[d+56>>2];c[b+60>>2]=c[d+60>>2];b=b+64|0;d=d+64|0}while((b|0)<(e|0)){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0}}else{e=g-4|0;while((b|0)<(e|0)){a[b>>0]=a[d>>0]|0;a[b+1>>0]=a[d+1>>0]|0;a[b+2>>0]=a[d+2>>0]|0;a[b+3>>0]=a[d+3>>0]|0;b=b+4|0;d=d+4|0}}while((b|0)<(g|0)){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0}return h|0}function Wa(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=b+e|0;d=d&255;if((e|0)>=67){while(b&3){a[b>>0]=d;b=b+1|0}f=h&-4|0;g=f-64|0;i=d|d<<8|d<<16|d<<24;while((b|0)<=(g|0)){c[b>>2]=i;c[b+4>>2]=i;c[b+8>>2]=i;c[b+12>>2]=i;c[b+16>>2]=i;c[b+20>>2]=i;c[b+24>>2]=i;c[b+28>>2]=i;c[b+32>>2]=i;c[b+36>>2]=i;c[b+40>>2]=i;c[b+44>>2]=i;c[b+48>>2]=i;c[b+52>>2]=i;c[b+56>>2]=i;c[b+60>>2]=i;b=b+64|0}while((b|0)<(f|0)){c[b>>2]=i;b=b+4|0}}while((b|0)<(h|0)){a[b>>0]=d;b=b+1|0}return h-e|0}function Xa(a){a=a|0;var b=0,d=0;d=a+15&-16|0;b=c[i>>2]|0;a=b+d|0;if((d|0)>0&(a|0)<(b|0)|(a|0)<0){V()|0;Z(12);return -1}c[i>>2]=a;if((a|0)>(U()|0)?(T()|0)==0:0){c[i>>2]=b;Z(12);return -1}return b|0}function Ya(a,b){a=a|0;b=b|0;return ga[a&1](b|0)|0}function Za(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return ha[a&3](b|0,c|0,d|0)|0}function _a(a){a=a|0;R(0);return 0}function $a(a,b,c){a=a|0;b=b|0;c=c|0;R(1);return 0}
+
+// EMSCRIPTEN_END_FUNCS
+var ga=[_a,ya];var ha=[$a,Ga,Aa,za];return{___errno_location:Ca,___muldi3:Qa,_bitshift64Ashr:Ra,_bitshift64Shl:Sa,_curve25519_generate_private:qa,_curve25519_generate_public:pa,_emscripten_get_global_libc:Ha,_fflush:Ma,_free:xa,_i64Add:Ta,_i64Subtract:Ua,_key_to_base64:ra,_malloc:wa,_memcpy:Va,_memset:Wa,_sbrk:Xa,dynCall_ii:Ya,dynCall_iiii:Za,establishStackSpace:la,getTempRet0:oa,runPostSets:Oa,setTempRet0:na,setThrew:ma,stackAlloc:ia,stackRestore:ka,stackSave:ja}})
+
+
+// EMSCRIPTEN_END_ASM
+(Module.asmGlobalArg,Module.asmLibraryArg,buffer);var ___errno_location=Module["___errno_location"]=asm["___errno_location"];var ___muldi3=Module["___muldi3"]=asm["___muldi3"];var _bitshift64Ashr=Module["_bitshift64Ashr"]=asm["_bitshift64Ashr"];var _bitshift64Shl=Module["_bitshift64Shl"]=asm["_bitshift64Shl"];var _curve25519_generate_private=Module["_curve25519_generate_private"]=asm["_curve25519_generate_private"];var _curve25519_generate_public=Module["_curve25519_generate_public"]=asm["_curve25519_generate_public"];var _emscripten_get_global_libc=Module["_emscripten_get_global_libc"]=asm["_emscripten_get_global_libc"];var _fflush=Module["_fflush"]=asm["_fflush"];var _free=Module["_free"]=asm["_free"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _i64Subtract=Module["_i64Subtract"]=asm["_i64Subtract"];var _key_to_base64=Module["_key_to_base64"]=asm["_key_to_base64"];var _malloc=Module["_malloc"]=asm["_malloc"];var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _memset=Module["_memset"]=asm["_memset"];var _sbrk=Module["_sbrk"]=asm["_sbrk"];var establishStackSpace=Module["establishStackSpace"]=asm["establishStackSpace"];var getTempRet0=Module["getTempRet0"]=asm["getTempRet0"];var runPostSets=Module["runPostSets"]=asm["runPostSets"];var setTempRet0=Module["setTempRet0"]=asm["setTempRet0"];var setThrew=Module["setThrew"]=asm["setThrew"];var stackAlloc=Module["stackAlloc"]=asm["stackAlloc"];var stackRestore=Module["stackRestore"]=asm["stackRestore"];var stackSave=Module["stackSave"]=asm["stackSave"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];Runtime.stackAlloc=Module["stackAlloc"];Runtime.stackSave=Module["stackSave"];Runtime.stackRestore=Module["stackRestore"];Runtime.establishStackSpace=Module["establishStackSpace"];Runtime.setTempRet0=Module["setTempRet0"];Runtime.getTempRet0=Module["getTempRet0"];Module["asm"]=asm;if(memoryInitializer){if(typeof Module["locateFile"]==="function"){memoryInitializer=Module["locateFile"](memoryInitializer)}else if(Module["memoryInitializerPrefixURL"]){memoryInitializer=Module["memoryInitializerPrefixURL"]+memoryInitializer}if(ENVIRONMENT_IS_NODE||ENVIRONMENT_IS_SHELL){var data=Module["readBinary"](memoryInitializer);HEAPU8.set(data,Runtime.GLOBAL_BASE)}else{addRunDependency("memory initializer");var applyMemoryInitializer=(function(data){if(data.byteLength)data=new Uint8Array(data);HEAPU8.set(data,Runtime.GLOBAL_BASE);if(Module["memoryInitializerRequest"])delete Module["memoryInitializerRequest"].response;removeRunDependency("memory initializer")});function doBrowserLoad(){Module["readAsync"](memoryInitializer,applyMemoryInitializer,(function(){throw"could not load memory initializer "+memoryInitializer}))}var memoryInitializerBytes=tryParseAsDataURI(memoryInitializer);if(memoryInitializerBytes){applyMemoryInitializer(memoryInitializerBytes.buffer)}else if(Module["memoryInitializerRequest"]){function useRequest(){var request=Module["memoryInitializerRequest"];var response=request.response;if(request.status!==200&&request.status!==0){var data=tryParseAsDataURI(Module["memoryInitializerRequestURL"]);if(data){response=data.buffer}else{console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: "+request.status+", retrying "+memoryInitializer);doBrowserLoad();return}}applyMemoryInitializer(response)}if(Module["memoryInitializerRequest"].response){setTimeout(useRequest,0)}else{Module["memoryInitializerRequest"].addEventListener("load",useRequest)}}else{doBrowserLoad()}}}function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;var preloadStartTime=null;var calledMain=false;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"])run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};Module["callMain"]=Module.callMain=function callMain(args){args=args||[];ensureInitRuntime();var argc=args.length+1;function pad(){for(var i=0;i<4-1;i++){argv.push(0)}}var argv=[allocate(intArrayFromString(Module["thisProgram"]),"i8",ALLOC_NORMAL)];pad();for(var i=0;i<argc-1;i=i+1){argv.push(allocate(intArrayFromString(args[i]),"i8",ALLOC_NORMAL));pad()}argv.push(0);argv=allocate(argv,"i32",ALLOC_NORMAL);try{var ret=Module["_main"](argc,argv,0);exit(ret,true)}catch(e){if(e instanceof ExitStatus){return}else if(e=="SimulateInfiniteLoop"){Module["noExitRuntime"]=true;return}else{var toLog=e;if(e&&typeof e==="object"&&e.stack){toLog=[e,e.stack]}Module.printErr("exception thrown: "+toLog);Module["quit"](1,e)}}finally{calledMain=true}};function run(args){args=args||Module["arguments"];if(preloadStartTime===null)preloadStartTime=Date.now();if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(Module["_main"]&&shouldRunNow)Module["callMain"](args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}Module["run"]=Module.run=run;function exit(status,implicit){if(implicit&&Module["noExitRuntime"]){return}if(Module["noExitRuntime"]){}else{ABORT=true;EXITSTATUS=status;STACKTOP=initialStackTop;exitRuntime();if(Module["onExit"])Module["onExit"](status)}if(ENVIRONMENT_IS_NODE){process["exit"](status)}Module["quit"](status,new ExitStatus(status))}Module["exit"]=Module.exit=exit;var abortDecorators=[];function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}if(what!==undefined){Module.print(what);Module.printErr(what);what=JSON.stringify(what)}else{what=""}ABORT=true;EXITSTATUS=1;var extra="\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";var output="abort("+what+") at "+stackTrace()+extra;if(abortDecorators){abortDecorators.forEach((function(decorator){output=decorator(output,what)}))}throw output}Module["abort"]=Module.abort=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"]){shouldRunNow=false}run()
+
+
+
+
diff --git a/contrib/keygen-html/keygen.html b/contrib/keygen-html/keygen.html
new file mode 100644
index 0000000..a6c7392
--- /dev/null
+++ b/contrib/keygen-html/keygen.html
@@ -0,0 +1,71 @@
+<script src="curve25519_generate.js"></script>
+<script>
+// License: GPLv2
+function generateWireguardKeypair()
+{
+	var privateKey = Module._malloc(32);
+	var publicKey = Module._malloc(32);
+	Module._curve25519_generate_private(privateKey);
+	Module._curve25519_generate_public(publicKey, privateKey);
+	var privateBase64 = Module._malloc(45);
+	var publicBase64 = Module._malloc(45);
+	Module._key_to_base64(privateBase64, privateKey);
+	Module._key_to_base64(publicBase64, publicKey);
+	Module._free(privateKey);
+	Module._free(publicKey);
+	var keypair = {
+		publicKey: Module.Pointer_stringify(publicBase64),
+		privateKey: Module.Pointer_stringify(privateBase64)
+	};
+	Module._free(privateBase64);
+	Module._free(publicBase64);
+	return keypair;
+}
+
+function sendPubkeyToServer(pubkey, username, password)
+{
+	alert("Sending " + username + ":" + password + " to server for new pubkey " + pubkey + "...");
+
+	// send info to server
+
+	var serverResponse = {
+		publicKey: "6spHEFoJrp9pijbxjJoS6fHjZaAWQqtdFFO/OtpVe3w=",
+		allowedIPs: [ "0.0.0.0/0", "::/0" ],
+		endpoint: "demo.wireguard.com:63321",
+		address: [ "192.168.18.42/32", "fd08:1234:1111::77/128" ],
+		dns: [ "8.8.8.8", "8.8.4.4" ]
+	}
+
+	return serverResponse;
+}
+
+function downloadNewConfiguration()
+{
+	var keypair = generateWireguardKeypair();
+	var serverResponse = sendPubkeyToServer(keypair.publicKey, "zx2c4", "supersecretpassword");
+
+	var config = [];
+	config.push("[Interface]");
+	config.push("PrivateKey = " + keypair.privateKey);
+	config.push("Address = " + serverResponse.address.join(", "));
+	config.push("DNS = " + serverResponse.dns.join(", "));
+	config.push("");
+	config.push("[Peer]");
+	config.push("PublicKey = " + serverResponse.publicKey);
+	config.push("AllowedIPs = " + serverResponse.allowedIPs.join(", "));
+	config.push("Endpoint = " + serverResponse.endpoint);
+	config.push("");
+	config = config.join("\n");
+
+	var blob = new Blob([config], { type: "text/plain" });
+	var a = document.createElement("a");
+	a.download = "demo0.conf";
+	a.href = URL.createObjectURL(blob);
+	a.style.display = "none";
+	document.body.appendChild(a);
+	a.click();
+	document.body.removeChild(a);
+}
+</script>
+
+<a href="javascript:downloadNewConfiguration()">Download a WireGuard configuration file</a>
diff --git a/contrib/keygen-html/src/curve25519_generate.c b/contrib/keygen-html/src/curve25519_generate.c
new file mode 100644
index 0000000..df3db05
--- /dev/null
+++ b/contrib/keygen-html/src/curve25519_generate.c
@@ -0,0 +1,914 @@
+/* License: GPLv2 */
+/* Build with emcc -O3 --memory-init-file 0 -o curve25519_generate.js curve25519_generate.c */
+
+#include <emscripten.h>
+
+typedef unsigned long long uint64_t;
+typedef long long int64_t;
+typedef int int32_t;
+typedef unsigned int uint32_t;
+typedef unsigned char uint8_t;
+typedef int64_t limb;
+
+/* Field element representation:
+ *
+ * Field elements are written as an array of signed, 64-bit limbs, least
+ * significant first. The value of the field element is:
+ *   x[0] + 2^26x[1] + x^51x[2] + 2^102x[3] + ...
+ *
+ * i.e. the limbs are 26, 25, 26, 25, ... bits wide.
+ */
+
+/* Sum two numbers: output += in */
+static void fsum(limb *output, const limb *in)
+{
+	unsigned int i;
+
+	for (i = 0; i < 10; i += 2) {
+		output[0 + i] = output[0 + i] + in[0 + i];
+		output[1 + i] = output[1 + i] + in[1 + i];
+	}
+}
+
+/* Find the difference of two numbers: output = in - output
+ * (note the order of the arguments!).
+ */
+static void fdifference(limb *output, const limb *in)
+{
+	unsigned int i;
+
+	for (i = 0; i < 10; ++i) {
+		output[i] = in[i] - output[i];
+	}
+}
+
+/* Multiply a number by a scalar: output = in * scalar */
+static void fscalar_product(limb *output, const limb *in, const limb scalar)
+{
+	unsigned int i;
+
+	for (i = 0; i < 10; ++i) {
+		output[i] = in[i] * scalar;
+	}
+}
+
+/* Multiply two numbers: output = in2 * in
+ *
+ * output must be distinct to both inputs. The inputs are reduced coefficient
+ * form, the output is not.
+ *
+ * output[x] <= 14 * the largest product of the input limbs.
+ */
+static void fproduct(limb *output, const limb *in2, const limb *in)
+{
+	output[0] =	   ((limb) ((int32_t) in2[0])) * ((int32_t) in[0]);
+	output[1] =	   ((limb) ((int32_t) in2[0])) * ((int32_t) in[1]) +
+						((limb) ((int32_t) in2[1])) * ((int32_t) in[0]);
+	output[2] =  2 *  ((limb) ((int32_t) in2[1])) * ((int32_t) in[1]) +
+						((limb) ((int32_t) in2[0])) * ((int32_t) in[2]) +
+						((limb) ((int32_t) in2[2])) * ((int32_t) in[0]);
+	output[3] =	   ((limb) ((int32_t) in2[1])) * ((int32_t) in[2]) +
+						((limb) ((int32_t) in2[2])) * ((int32_t) in[1]) +
+						((limb) ((int32_t) in2[0])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in2[3])) * ((int32_t) in[0]);
+	output[4] =	   ((limb) ((int32_t) in2[2])) * ((int32_t) in[2]) +
+					   2 * (((limb) ((int32_t) in2[1])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in2[3])) * ((int32_t) in[1])) +
+						((limb) ((int32_t) in2[0])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in2[4])) * ((int32_t) in[0]);
+	output[5] =	   ((limb) ((int32_t) in2[2])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in2[3])) * ((int32_t) in[2]) +
+						((limb) ((int32_t) in2[1])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in2[4])) * ((int32_t) in[1]) +
+						((limb) ((int32_t) in2[0])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in2[5])) * ((int32_t) in[0]);
+	output[6] =  2 * (((limb) ((int32_t) in2[3])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in2[1])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in2[5])) * ((int32_t) in[1])) +
+						((limb) ((int32_t) in2[2])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in2[4])) * ((int32_t) in[2]) +
+						((limb) ((int32_t) in2[0])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in2[6])) * ((int32_t) in[0]);
+	output[7] =	   ((limb) ((int32_t) in2[3])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in2[4])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in2[2])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in2[5])) * ((int32_t) in[2]) +
+						((limb) ((int32_t) in2[1])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in2[6])) * ((int32_t) in[1]) +
+						((limb) ((int32_t) in2[0])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in2[7])) * ((int32_t) in[0]);
+	output[8] =	   ((limb) ((int32_t) in2[4])) * ((int32_t) in[4]) +
+					   2 * (((limb) ((int32_t) in2[3])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in2[5])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in2[1])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in2[7])) * ((int32_t) in[1])) +
+						((limb) ((int32_t) in2[2])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in2[6])) * ((int32_t) in[2]) +
+						((limb) ((int32_t) in2[0])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in2[8])) * ((int32_t) in[0]);
+	output[9] =	   ((limb) ((int32_t) in2[4])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in2[5])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in2[3])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in2[6])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in2[2])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in2[7])) * ((int32_t) in[2]) +
+						((limb) ((int32_t) in2[1])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in2[8])) * ((int32_t) in[1]) +
+						((limb) ((int32_t) in2[0])) * ((int32_t) in[9]) +
+						((limb) ((int32_t) in2[9])) * ((int32_t) in[0]);
+	output[10] = 2 * (((limb) ((int32_t) in2[5])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in2[3])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in2[7])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in2[1])) * ((int32_t) in[9]) +
+						((limb) ((int32_t) in2[9])) * ((int32_t) in[1])) +
+						((limb) ((int32_t) in2[4])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in2[6])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in2[2])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in2[8])) * ((int32_t) in[2]);
+	output[11] =	  ((limb) ((int32_t) in2[5])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in2[6])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in2[4])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in2[7])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in2[3])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in2[8])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in2[2])) * ((int32_t) in[9]) +
+						((limb) ((int32_t) in2[9])) * ((int32_t) in[2]);
+	output[12] =	  ((limb) ((int32_t) in2[6])) * ((int32_t) in[6]) +
+					   2 * (((limb) ((int32_t) in2[5])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in2[7])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in2[3])) * ((int32_t) in[9]) +
+						((limb) ((int32_t) in2[9])) * ((int32_t) in[3])) +
+						((limb) ((int32_t) in2[4])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in2[8])) * ((int32_t) in[4]);
+	output[13] =	  ((limb) ((int32_t) in2[6])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in2[7])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in2[5])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in2[8])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in2[4])) * ((int32_t) in[9]) +
+						((limb) ((int32_t) in2[9])) * ((int32_t) in[4]);
+	output[14] = 2 * (((limb) ((int32_t) in2[7])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in2[5])) * ((int32_t) in[9]) +
+						((limb) ((int32_t) in2[9])) * ((int32_t) in[5])) +
+						((limb) ((int32_t) in2[6])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in2[8])) * ((int32_t) in[6]);
+	output[15] =	  ((limb) ((int32_t) in2[7])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in2[8])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in2[6])) * ((int32_t) in[9]) +
+						((limb) ((int32_t) in2[9])) * ((int32_t) in[6]);
+	output[16] =	  ((limb) ((int32_t) in2[8])) * ((int32_t) in[8]) +
+					   2 * (((limb) ((int32_t) in2[7])) * ((int32_t) in[9]) +
+						((limb) ((int32_t) in2[9])) * ((int32_t) in[7]));
+	output[17] =	  ((limb) ((int32_t) in2[8])) * ((int32_t) in[9]) +
+						((limb) ((int32_t) in2[9])) * ((int32_t) in[8]);
+	output[18] = 2 *  ((limb) ((int32_t) in2[9])) * ((int32_t) in[9]);
+}
+
+/* Reduce a long form to a short form by taking the input mod 2^255 - 19.
+ *
+ * On entry: |output[i]| < 14*2^54
+ * On exit: |output[0..8]| < 280*2^54
+ */
+static void freduce_degree(limb *output)
+{
+	/* Each of these shifts and adds ends up multiplying the value by 19.
+	 *
+	 * For output[0..8], the absolute entry value is < 14*2^54 and we add, at
+	 * most, 19*14*2^54 thus, on exit, |output[0..8]| < 280*2^54.
+	 */
+	output[8] += output[18] << 4;
+	output[8] += output[18] << 1;
+	output[8] += output[18];
+	output[7] += output[17] << 4;
+	output[7] += output[17] << 1;
+	output[7] += output[17];
+	output[6] += output[16] << 4;
+	output[6] += output[16] << 1;
+	output[6] += output[16];
+	output[5] += output[15] << 4;
+	output[5] += output[15] << 1;
+	output[5] += output[15];
+	output[4] += output[14] << 4;
+	output[4] += output[14] << 1;
+	output[4] += output[14];
+	output[3] += output[13] << 4;
+	output[3] += output[13] << 1;
+	output[3] += output[13];
+	output[2] += output[12] << 4;
+	output[2] += output[12] << 1;
+	output[2] += output[12];
+	output[1] += output[11] << 4;
+	output[1] += output[11] << 1;
+	output[1] += output[11];
+	output[0] += output[10] << 4;
+	output[0] += output[10] << 1;
+	output[0] += output[10];
+}
+
+#if (-1 & 3) != 3
+#error "This code only works on a two's complement system"
+#endif
+
+/* return v / 2^26, using only shifts and adds.
+ *
+ * On entry: v can take any value.
+ */
+static inline limb div_by_2_26(const limb v)
+{
+	/* High word of v; no shift needed. */
+	const uint32_t highword = (uint32_t) (((uint64_t) v) >> 32);
+	/* Set to all 1s if v was negative; else set to 0s. */
+	const int32_t sign = ((int32_t) highword) >> 31;
+	/* Set to 0x3ffffff if v was negative; else set to 0. */
+	const int32_t roundoff = ((uint32_t) sign) >> 6;
+	/* Should return v / (1<<26) */
+	return (v + roundoff) >> 26;
+}
+
+/* return v / (2^25), using only shifts and adds.
+ *
+ * On entry: v can take any value.
+ */
+static inline limb div_by_2_25(const limb v)
+{
+	/* High word of v; no shift needed*/
+	const uint32_t highword = (uint32_t) (((uint64_t) v) >> 32);
+	/* Set to all 1s if v was negative; else set to 0s. */
+	const int32_t sign = ((int32_t) highword) >> 31;
+	/* Set to 0x1ffffff if v was negative; else set to 0. */
+	const int32_t roundoff = ((uint32_t) sign) >> 7;
+	/* Should return v / (1<<25) */
+	return (v + roundoff) >> 25;
+}
+
+/* Reduce all coefficients of the short form input so that |x| < 2^26.
+ *
+ * On entry: |output[i]| < 280*2^54
+ */
+static void freduce_coefficients(limb *output)
+{
+	unsigned int i;
+
+	output[10] = 0;
+
+	for (i = 0; i < 10; i += 2) {
+		limb over = div_by_2_26(output[i]);
+		/* The entry condition (that |output[i]| < 280*2^54) means that over is, at
+		 * most, 280*2^28 in the first iteration of this loop. This is added to the
+		 * next limb and we can approximate the resulting bound of that limb by
+		 * 281*2^54.
+		 */
+		output[i] -= over << 26;
+		output[i+1] += over;
+
+		/* For the first iteration, |output[i+1]| < 281*2^54, thus |over| <
+		 * 281*2^29. When this is added to the next limb, the resulting bound can
+		 * be approximated as 281*2^54.
+		 *
+		 * For subsequent iterations of the loop, 281*2^54 remains a conservative
+		 * bound and no overflow occurs.
+		 */
+		over = div_by_2_25(output[i+1]);
+		output[i+1] -= over << 25;
+		output[i+2] += over;
+	}
+	/* Now |output[10]| < 281*2^29 and all other coefficients are reduced. */
+	output[0] += output[10] << 4;
+	output[0] += output[10] << 1;
+	output[0] += output[10];
+
+	output[10] = 0;
+
+	/* Now output[1..9] are reduced, and |output[0]| < 2^26 + 19*281*2^29
+	 * So |over| will be no more than 2^16.
+	 */
+	{
+		limb over = div_by_2_26(output[0]);
+
+		output[0] -= over << 26;
+		output[1] += over;
+	}
+
+	/* Now output[0,2..9] are reduced, and |output[1]| < 2^25 + 2^16 < 2^26. The
+	 * bound on |output[1]| is sufficient to meet our needs.
+	 */
+}
+
+/* A helpful wrapper around fproduct: output = in * in2.
+ *
+ * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27.
+ *
+ * output must be distinct to both inputs. The output is reduced degree
+ * (indeed, one need only provide storage for 10 limbs) and |output[i]| < 2^26.
+ */
+static void fmul(limb *output, const limb *in, const limb *in2)
+{
+	limb t[19];
+
+	fproduct(t, in, in2);
+	/* |t[i]| < 14*2^54 */
+	freduce_degree(t);
+	freduce_coefficients(t);
+	/* |t[i]| < 2^26 */
+	__builtin_memcpy(output, t, sizeof(limb) * 10);
+}
+
+/* Square a number: output = in**2
+ *
+ * output must be distinct from the input. The inputs are reduced coefficient
+ * form, the output is not.
+ *
+ * output[x] <= 14 * the largest product of the input limbs.
+ */
+static void fsquare_inner(limb *output, const limb *in)
+{
+	output[0] =	   ((limb) ((int32_t) in[0])) * ((int32_t) in[0]);
+	output[1] =  2 *  ((limb) ((int32_t) in[0])) * ((int32_t) in[1]);
+	output[2] =  2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[1]) +
+						((limb) ((int32_t) in[0])) * ((int32_t) in[2]));
+	output[3] =  2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[2]) +
+						((limb) ((int32_t) in[0])) * ((int32_t) in[3]));
+	output[4] =	   ((limb) ((int32_t) in[2])) * ((int32_t) in[2]) +
+					   4 *  ((limb) ((int32_t) in[1])) * ((int32_t) in[3]) +
+					   2 *  ((limb) ((int32_t) in[0])) * ((int32_t) in[4]);
+	output[5] =  2 * (((limb) ((int32_t) in[2])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in[1])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in[0])) * ((int32_t) in[5]));
+	output[6] =  2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[3]) +
+						((limb) ((int32_t) in[2])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in[0])) * ((int32_t) in[6]) +
+					   2 *  ((limb) ((int32_t) in[1])) * ((int32_t) in[5]));
+	output[7] =  2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[4]) +
+						((limb) ((int32_t) in[2])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in[1])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in[0])) * ((int32_t) in[7]));
+	output[8] =	   ((limb) ((int32_t) in[4])) * ((int32_t) in[4]) +
+					   2 * (((limb) ((int32_t) in[2])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in[0])) * ((int32_t) in[8]) +
+					   2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in[3])) * ((int32_t) in[5])));
+	output[9] =  2 * (((limb) ((int32_t) in[4])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in[3])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in[2])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in[1])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in[0])) * ((int32_t) in[9]));
+	output[10] = 2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[5]) +
+						((limb) ((int32_t) in[4])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in[2])) * ((int32_t) in[8]) +
+					   2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in[1])) * ((int32_t) in[9])));
+	output[11] = 2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[6]) +
+						((limb) ((int32_t) in[4])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in[3])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in[2])) * ((int32_t) in[9]));
+	output[12] =	  ((limb) ((int32_t) in[6])) * ((int32_t) in[6]) +
+					   2 * (((limb) ((int32_t) in[4])) * ((int32_t) in[8]) +
+					   2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in[3])) * ((int32_t) in[9])));
+	output[13] = 2 * (((limb) ((int32_t) in[6])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in[5])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in[4])) * ((int32_t) in[9]));
+	output[14] = 2 * (((limb) ((int32_t) in[7])) * ((int32_t) in[7]) +
+						((limb) ((int32_t) in[6])) * ((int32_t) in[8]) +
+					   2 *  ((limb) ((int32_t) in[5])) * ((int32_t) in[9]));
+	output[15] = 2 * (((limb) ((int32_t) in[7])) * ((int32_t) in[8]) +
+						((limb) ((int32_t) in[6])) * ((int32_t) in[9]));
+	output[16] =	  ((limb) ((int32_t) in[8])) * ((int32_t) in[8]) +
+					   4 *  ((limb) ((int32_t) in[7])) * ((int32_t) in[9]);
+	output[17] = 2 *  ((limb) ((int32_t) in[8])) * ((int32_t) in[9]);
+	output[18] = 2 *  ((limb) ((int32_t) in[9])) * ((int32_t) in[9]);
+}
+
+/* fsquare sets output = in^2.
+ *
+ * On entry: The |in| argument is in reduced coefficients form and |in[i]| <
+ * 2^27.
+ *
+ * On exit: The |output| argument is in reduced coefficients form (indeed, one
+ * need only provide storage for 10 limbs) and |out[i]| < 2^26.
+ */
+static void fsquare(limb *output, const limb *in)
+{
+	limb t[19];
+
+	fsquare_inner(t, in);
+	/* |t[i]| < 14*2^54 because the largest product of two limbs will be <
+	 * 2^(27+27) and fsquare_inner adds together, at most, 14 of those
+	 * products.
+	 */
+	freduce_degree(t);
+	freduce_coefficients(t);
+	/* |t[i]| < 2^26 */
+	__builtin_memcpy(output, t, sizeof(limb) * 10);
+}
+
+/* Take a little-endian, 32-byte number and expand it into polynomial form */
+static void fexpand(limb *output, const uint8_t *input)
+{
+#define F(n, start, shift, mask) \
+	output[n] = ((((limb) input[start + 0]) | \
+			  ((limb) input[start + 1]) << 8 | \
+			  ((limb) input[start + 2]) << 16 | \
+			  ((limb) input[start + 3]) << 24) >> shift) & mask;
+	F(0, 0, 0, 0x3ffffff);
+	F(1, 3, 2, 0x1ffffff);
+	F(2, 6, 3, 0x3ffffff);
+	F(3, 9, 5, 0x1ffffff);
+	F(4, 12, 6, 0x3ffffff);
+	F(5, 16, 0, 0x1ffffff);
+	F(6, 19, 1, 0x3ffffff);
+	F(7, 22, 3, 0x1ffffff);
+	F(8, 25, 4, 0x3ffffff);
+	F(9, 28, 6, 0x1ffffff);
+#undef F
+}
+
+#if (-32 >> 1) != -16
+#error "This code only works when >> does sign-extension on negative numbers"
+#endif
+
+/* int32_t_eq returns 0xffffffff iff a == b and zero otherwise. */
+static int32_t int32_t_eq(int32_t a, int32_t b)
+{
+	a = ~(a ^ b);
+	a &= a << 16;
+	a &= a << 8;
+	a &= a << 4;
+	a &= a << 2;
+	a &= a << 1;
+	return a >> 31;
+}
+
+/* int32_t_gte returns 0xffffffff if a >= b and zero otherwise, where a and b are
+ * both non-negative.
+ */
+static int32_t int32_t_gte(int32_t a, int32_t b)
+{
+	a -= b;
+	/* a >= 0 iff a >= b. */
+	return ~(a >> 31);
+}
+
+/* Take a fully reduced polynomial form number and contract it into a
+ * little-endian, 32-byte array.
+ *
+ * On entry: |input_limbs[i]| < 2^26
+ */
+static void fcontract(uint8_t *output, limb *input_limbs)
+{
+	int i;
+	int j;
+	int32_t input[10];
+	int32_t mask;
+
+	/* |input_limbs[i]| < 2^26, so it's valid to convert to an int32_t. */
+	for (i = 0; i < 10; i++) {
+		input[i] = input_limbs[i];
+	}
+
+	for (j = 0; j < 2; ++j) {
+		for (i = 0; i < 9; ++i) {
+			if ((i & 1) == 1) {
+				/* This calculation is a time-invariant way to make input[i]
+				 * non-negative by borrowing from the next-larger limb.
+				 */
+				const int32_t mask = input[i] >> 31;
+				const int32_t carry = -((input[i] & mask) >> 25);
+
+				input[i] = input[i] + (carry << 25);
+				input[i+1] = input[i+1] - carry;
+			} else {
+				const int32_t mask = input[i] >> 31;
+				const int32_t carry = -((input[i] & mask) >> 26);
+
+				input[i] = input[i] + (carry << 26);
+				input[i+1] = input[i+1] - carry;
+			}
+		}
+
+		/* There's no greater limb for input[9] to borrow from, but we can multiply
+		 * by 19 and borrow from input[0], which is valid mod 2^255-19.
+		 */
+		{
+			const int32_t mask = input[9] >> 31;
+			const int32_t carry = -((input[9] & mask) >> 25);
+
+			input[9] = input[9] + (carry << 25);
+			input[0] = input[0] - (carry * 19);
+		}
+
+		/* After the first iteration, input[1..9] are non-negative and fit within
+		 * 25 or 26 bits, depending on position. However, input[0] may be
+		 * negative.
+		 */
+	}
+
+	/* The first borrow-propagation pass above ended with every limb
+		 except (possibly) input[0] non-negative.
+		 If input[0] was negative after the first pass, then it was because of a
+		 carry from input[9]. On entry, input[9] < 2^26 so the carry was, at most,
+		 one, since (2**26-1) >> 25 = 1. Thus input[0] >= -19.
+		 In the second pass, each limb is decreased by at most one. Thus the second
+		 borrow-propagation pass could only have wrapped around to decrease
+		 input[0] again if the first pass left input[0] negative *and* input[1]
+		 through input[9] were all zero.  In that case, input[1] is now 2^25 - 1,
+		 and this last borrow-propagation step will leave input[1] non-negative. */
+	{
+		const int32_t mask = input[0] >> 31;
+		const int32_t carry = -((input[0] & mask) >> 26);
+
+		input[0] = input[0] + (carry << 26);
+		input[1] = input[1] - carry;
+	}
+
+	/* All input[i] are now non-negative. However, there might be values between
+	 * 2^25 and 2^26 in a limb which is, nominally, 25 bits wide.
+	 */
+	for (j = 0; j < 2; j++) {
+		for (i = 0; i < 9; i++) {
+			if ((i & 1) == 1) {
+				const int32_t carry = input[i] >> 25;
+
+				input[i] &= 0x1ffffff;
+				input[i+1] += carry;
+			} else {
+				const int32_t carry = input[i] >> 26;
+
+				input[i] &= 0x3ffffff;
+				input[i+1] += carry;
+			}
+		}
+
+		{
+			const int32_t carry = input[9] >> 25;
+
+			input[9] &= 0x1ffffff;
+			input[0] += 19*carry;
+		}
+	}
+
+	/* If the first carry-chain pass, just above, ended up with a carry from
+	 * input[9], and that caused input[0] to be out-of-bounds, then input[0] was
+	 * < 2^26 + 2*19, because the carry was, at most, two.
+	 *
+	 * If the second pass carried from input[9] again then input[0] is < 2*19 and
+	 * the input[9] -> input[0] carry didn't push input[0] out of bounds.
+	 */
+
+	/* It still remains the case that input might be between 2^255-19 and 2^255.
+	 * In this case, input[1..9] must take their maximum value and input[0] must
+	 * be >= (2^255-19) & 0x3ffffff, which is 0x3ffffed.
+	 */
+	mask = int32_t_gte(input[0], 0x3ffffed);
+	for (i = 1; i < 10; i++) {
+		if ((i & 1) == 1) {
+			mask &= int32_t_eq(input[i], 0x1ffffff);
+		} else {
+			mask &= int32_t_eq(input[i], 0x3ffffff);
+		}
+	}
+
+	/* mask is either 0xffffffff (if input >= 2^255-19) and zero otherwise. Thus
+	 * this conditionally subtracts 2^255-19.
+	 */
+	input[0] -= mask & 0x3ffffed;
+
+	for (i = 1; i < 10; i++) {
+		if ((i & 1) == 1) {
+			input[i] -= mask & 0x1ffffff;
+		} else {
+			input[i] -= mask & 0x3ffffff;
+		}
+	}
+
+	input[1] <<= 2;
+	input[2] <<= 3;
+	input[3] <<= 5;
+	input[4] <<= 6;
+	input[6] <<= 1;
+	input[7] <<= 3;
+	input[8] <<= 4;
+	input[9] <<= 6;
+#define F(i, s) \
+	output[s+0] |=  input[i] & 0xff; \
+	output[s+1]  = (input[i] >> 8) & 0xff; \
+	output[s+2]  = (input[i] >> 16) & 0xff; \
+	output[s+3]  = (input[i] >> 24) & 0xff;
+	output[0] = 0;
+	output[16] = 0;
+	F(0, 0);
+	F(1, 3);
+	F(2, 6);
+	F(3, 9);
+	F(4, 12);
+	F(5, 16);
+	F(6, 19);
+	F(7, 22);
+	F(8, 25);
+	F(9, 28);
+#undef F
+}
+
+/* Input: Q, Q', Q-Q'
+ * Output: 2Q, Q+Q'
+ *
+ *   x2 z3: long form
+ *   x3 z3: long form
+ *   x z: short form, destroyed
+ *   xprime zprime: short form, destroyed
+ *   qmqp: short form, preserved
+ *
+ * On entry and exit, the absolute value of the limbs of all inputs and outputs
+ * are < 2^26.
+ */
+static void fmonty(limb *x2, limb *z2,  /* output 2Q */
+		   limb *x3, limb *z3,  /* output Q + Q' */
+		   limb *x, limb *z,	/* input Q */
+		   limb *xprime, limb *zprime,  /* input Q' */
+
+		   const limb *qmqp /* input Q - Q' */)
+{
+	limb origx[10], origxprime[10], zzz[19], xx[19], zz[19], xxprime[19],
+				zzprime[19], zzzprime[19], xxxprime[19];
+
+	__builtin_memcpy(origx, x, 10 * sizeof(limb));
+	fsum(x, z);
+	/* |x[i]| < 2^27 */
+	fdifference(z, origx);  /* does x - z */
+	/* |z[i]| < 2^27 */
+
+	__builtin_memcpy(origxprime, xprime, sizeof(limb) * 10);
+	fsum(xprime, zprime);
+	/* |xprime[i]| < 2^27 */
+	fdifference(zprime, origxprime);
+	/* |zprime[i]| < 2^27 */
+	fproduct(xxprime, xprime, z);
+	/* |xxprime[i]| < 14*2^54: the largest product of two limbs will be <
+	 * 2^(27+27) and fproduct adds together, at most, 14 of those products.
+	 * (Approximating that to 2^58 doesn't work out.)
+	 */
+	fproduct(zzprime, x, zprime);
+	/* |zzprime[i]| < 14*2^54 */
+	freduce_degree(xxprime);
+	freduce_coefficients(xxprime);
+	/* |xxprime[i]| < 2^26 */
+	freduce_degree(zzprime);
+	freduce_coefficients(zzprime);
+	/* |zzprime[i]| < 2^26 */
+	__builtin_memcpy(origxprime, xxprime, sizeof(limb) * 10);
+	fsum(xxprime, zzprime);
+	/* |xxprime[i]| < 2^27 */
+	fdifference(zzprime, origxprime);
+	/* |zzprime[i]| < 2^27 */
+	fsquare(xxxprime, xxprime);
+	/* |xxxprime[i]| < 2^26 */
+	fsquare(zzzprime, zzprime);
+	/* |zzzprime[i]| < 2^26 */
+	fproduct(zzprime, zzzprime, qmqp);
+	/* |zzprime[i]| < 14*2^52 */
+	freduce_degree(zzprime);
+	freduce_coefficients(zzprime);
+	/* |zzprime[i]| < 2^26 */
+	__builtin_memcpy(x3, xxxprime, sizeof(limb) * 10);
+	__builtin_memcpy(z3, zzprime, sizeof(limb) * 10);
+
+	fsquare(xx, x);
+	/* |xx[i]| < 2^26 */
+	fsquare(zz, z);
+	/* |zz[i]| < 2^26 */
+	fproduct(x2, xx, zz);
+	/* |x2[i]| < 14*2^52 */
+	freduce_degree(x2);
+	freduce_coefficients(x2);
+	/* |x2[i]| < 2^26 */
+	fdifference(zz, xx);  // does zz = xx - zz
+	/* |zz[i]| < 2^27 */
+	__builtin_memset(zzz + 10, 0, sizeof(limb) * 9);
+	fscalar_product(zzz, zz, 121665);
+	/* |zzz[i]| < 2^(27+17) */
+	/* No need to call freduce_degree here:
+		 fscalar_product doesn't increase the degree of its input. */
+	freduce_coefficients(zzz);
+	/* |zzz[i]| < 2^26 */
+	fsum(zzz, xx);
+	/* |zzz[i]| < 2^27 */
+	fproduct(z2, zz, zzz);
+	/* |z2[i]| < 14*2^(26+27) */
+	freduce_degree(z2);
+	freduce_coefficients(z2);
+	/* |z2|i| < 2^26 */
+}
+
+/* Conditionally swap two reduced-form limb arrays if 'iswap' is 1, but leave
+ * them unchanged if 'iswap' is 0.  Runs in data-invariant time to avoid
+ * side-channel attacks.
+ *
+ * NOTE that this function requires that 'iswap' be 1 or 0; other values give
+ * wrong results.  Also, the two limb arrays must be in reduced-coefficient,
+ * reduced-degree form: the values in a[10..19] or b[10..19] aren't swapped,
+ * and all all values in a[0..9],b[0..9] must have magnitude less than
+ * INT32_MAX.
+ */
+static void swap_conditional(limb a[static 19], limb b[static 19], limb iswap)
+{
+	unsigned int i;
+	const int32_t swap = (int32_t) -iswap;
+
+	for (i = 0; i < 10; ++i) {
+		const int32_t x = swap & (((int32_t)a[i]) ^ ((int32_t)b[i]));
+
+		a[i] = ((int32_t)a[i]) ^ x;
+		b[i] = ((int32_t)b[i]) ^ x;
+	}
+}
+
+/* Calculates nQ where Q is the x-coordinate of a point on the curve
+ *
+ *   resultx/resultz: the x coordinate of the resulting curve point (short form)
+ *   n: a little endian, 32-byte number
+ *   q: a point of the curve (short form)
+ */
+static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
+{
+	limb a[19] = {0}, b[19] = {1}, c[19] = {1}, d[19] = {0};
+	limb *nqpqx = a, *nqpqz = b, *nqx = c, *nqz = d, *t;
+	limb e[19] = {0}, f[19] = {1}, g[19] = {0}, h[19] = {1};
+	limb *nqpqx2 = e, *nqpqz2 = f, *nqx2 = g, *nqz2 = h;
+
+	unsigned int i, j;
+
+	__builtin_memcpy(nqpqx, q, sizeof(limb) * 10);
+
+	for (i = 0; i < 32; ++i) {
+		uint8_t byte = n[31 - i];
+
+		for (j = 0; j < 8; ++j) {
+			const limb bit = byte >> 7;
+
+			swap_conditional(nqx, nqpqx, bit);
+			swap_conditional(nqz, nqpqz, bit);
+			fmonty(nqx2, nqz2,
+				   nqpqx2, nqpqz2,
+				   nqx, nqz,
+				   nqpqx, nqpqz,
+				   q);
+			swap_conditional(nqx2, nqpqx2, bit);
+			swap_conditional(nqz2, nqpqz2, bit);
+
+			t = nqx;
+			nqx = nqx2;
+			nqx2 = t;
+			t = nqz;
+			nqz = nqz2;
+			nqz2 = t;
+			t = nqpqx;
+			nqpqx = nqpqx2;
+			nqpqx2 = t;
+			t = nqpqz;
+			nqpqz = nqpqz2;
+			nqpqz2 = t;
+
+			byte <<= 1;
+		}
+	}
+
+	__builtin_memcpy(resultx, nqx, sizeof(limb) * 10);
+	__builtin_memcpy(resultz, nqz, sizeof(limb) * 10);
+}
+
+static void crecip(limb *out, const limb *z)
+{
+	limb z2[10];
+	limb z9[10];
+	limb z11[10];
+	limb z2_5_0[10];
+	limb z2_10_0[10];
+	limb z2_20_0[10];
+	limb z2_50_0[10];
+	limb z2_100_0[10];
+	limb t0[10];
+	limb t1[10];
+	int i;
+
+	/* 2 */ fsquare(z2, z);
+	/* 4 */ fsquare(t1, z2);
+	/* 8 */ fsquare(t0, t1);
+	/* 9 */ fmul(z9, t0, z);
+	/* 11 */ fmul(z11, z9, z2);
+	/* 22 */ fsquare(t0, z11);
+	/* 2^5 - 2^0 = 31 */ fmul(z2_5_0, t0, z9);
+
+	/* 2^6 - 2^1 */ fsquare(t0, z2_5_0);
+	/* 2^7 - 2^2 */ fsquare(t1, t0);
+	/* 2^8 - 2^3 */ fsquare(t0, t1);
+	/* 2^9 - 2^4 */ fsquare(t1, t0);
+	/* 2^10 - 2^5 */ fsquare(t0, t1);
+	/* 2^10 - 2^0 */ fmul(z2_10_0, t0, z2_5_0);
+
+	/* 2^11 - 2^1 */ fsquare(t0, z2_10_0);
+	/* 2^12 - 2^2 */ fsquare(t1, t0);
+	/* 2^20 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
+	/* 2^20 - 2^0 */ fmul(z2_20_0, t1, z2_10_0);
+
+	/* 2^21 - 2^1 */ fsquare(t0, z2_20_0);
+	/* 2^22 - 2^2 */ fsquare(t1, t0);
+	/* 2^40 - 2^20 */ for (i = 2; i < 20; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
+	/* 2^40 - 2^0 */ fmul(t0, t1, z2_20_0);
+
+	/* 2^41 - 2^1 */ fsquare(t1, t0);
+	/* 2^42 - 2^2 */ fsquare(t0, t1);
+	/* 2^50 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t1, t0); fsquare(t0, t1); }
+	/* 2^50 - 2^0 */ fmul(z2_50_0, t0, z2_10_0);
+
+	/* 2^51 - 2^1 */ fsquare(t0, z2_50_0);
+	/* 2^52 - 2^2 */ fsquare(t1, t0);
+	/* 2^100 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
+	/* 2^100 - 2^0 */ fmul(z2_100_0, t1, z2_50_0);
+
+	/* 2^101 - 2^1 */ fsquare(t1, z2_100_0);
+	/* 2^102 - 2^2 */ fsquare(t0, t1);
+	/* 2^200 - 2^100 */ for (i = 2; i < 100; i += 2) { fsquare(t1, t0); fsquare(t0, t1); }
+	/* 2^200 - 2^0 */ fmul(t1, t0, z2_100_0);
+
+	/* 2^201 - 2^1 */ fsquare(t0, t1);
+	/* 2^202 - 2^2 */ fsquare(t1, t0);
+	/* 2^250 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
+	/* 2^250 - 2^0 */ fmul(t0, t1, z2_50_0);
+
+	/* 2^251 - 2^1 */ fsquare(t1, t0);
+	/* 2^252 - 2^2 */ fsquare(t0, t1);
+	/* 2^253 - 2^3 */ fsquare(t1, t0);
+	/* 2^254 - 2^4 */ fsquare(t0, t1);
+	/* 2^255 - 2^5 */ fsquare(t1, t0);
+	/* 2^255 - 21 */ fmul(out, t1, z11);
+}
+
+static inline void curve25519_normalize_secret(uint8_t secret[static 32])
+{
+	secret[0] &= 248;
+	secret[31] &= 127;
+	secret[31] |= 64;
+}
+static inline void curve25519(uint8_t mypublic[static 32], const uint8_t secret[static 32], const uint8_t basepoint[static 32])
+{
+	limb bp[10], x[10], z[11], zmone[10];
+	uint8_t e[32];
+
+	__builtin_memcpy(e, secret, 32);
+	curve25519_normalize_secret(e);
+
+	fexpand(bp, basepoint);
+	cmult(x, z, e, bp);
+	crecip(zmone, z);
+	fmul(z, x, zmone);
+	fcontract(mypublic, z);
+}
+
+EMSCRIPTEN_KEEPALIVE void curve25519_generate_public(uint8_t public[static 32], const uint8_t private[static 32])
+{
+	static const uint8_t basepoint[32] = { 9 };
+
+	curve25519(public, private, basepoint);
+}
+
+EMSCRIPTEN_KEEPALIVE void curve25519_generate_private(uint8_t private[static 32])
+{
+	int i;
+
+	EM_ASM({
+		/* Same trick as libsodium */
+		var getRandomValue = function() {
+			var buf = new Uint32Array(1);
+			window.crypto.getRandomValues(buf);
+			return buf[0] >>> 0;
+		};
+		Module.getRandomValue = getRandomValue;
+	});
+	
+	for (i = 0; i < 32; ++i)
+		private[i] = EM_ASM_INT_V({ return Module.getRandomValue(); });
+	curve25519_normalize_secret(private);
+}
+
+static inline void encode_base64(char dest[4], const uint8_t src[3])
+{
+	const uint8_t input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
+
+	for (unsigned int i = 0; i < 4; ++i)
+		dest[i] = input[i] + 'A'
+			  + (((25 - input[i]) >> 8) & 6)
+			  - (((51 - input[i]) >> 8) & 75)
+			  - (((61 - input[i]) >> 8) & 15)
+			  + (((62 - input[i]) >> 8) & 3);
+
+}
+
+EMSCRIPTEN_KEEPALIVE void key_to_base64(char base64[static 45], const uint8_t key[static 32])
+{
+	unsigned int i;
+
+	for (i = 0; i < 32 / 3; ++i)
+		encode_base64(&base64[i * 4], &key[i * 3]);
+	encode_base64(&base64[i * 4], (const uint8_t[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
+	base64[45 - 2] = '=';
+	base64[45 - 1] = '\0';
+}

commit 30cf5eb8830ddcdb7c6ffdf52de0b6ad481c5de3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Nov 23 01:17:25 2017 +0100

    wg: fix removing preshared keys
    
    Also clean up related logic quite a bit and add unit tests.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 84038c8..6ff0376 100644
--- a/src/config.c
+++ b/src/config.c
@@ -105,11 +105,59 @@ static inline bool parse_key(uint8_t key[static WG_KEY_LEN], const char *value)
 {
 	if (!key_from_base64(key, value)) {
 		fprintf(stderr, "Key is not the correct length or format: `%s'\n", value);
+		memset(key, 0, WG_KEY_LEN);
 		return false;
 	}
 	return true;
 }
 
+static bool parse_keyfile(uint8_t key[static WG_KEY_LEN], const char *path)
+{
+	FILE *f;
+	int c;
+	char dst[WG_KEY_LEN_BASE64];
+	bool ret = false;
+
+	f = fopen(path, "r");
+	if (!f) {
+		perror("fopen");
+		return false;
+	}
+
+	if (fread(dst, WG_KEY_LEN_BASE64 - 1, 1, f) != 1) {
+		if (errno) {
+			perror("fread");
+			goto out;
+		}
+		/* If we're at the end and we didn't read anything, we're /dev/null or an empty file. */
+		if (!ferror(f) && feof(f) && !ftell(f)) {
+			memset(key, 0, WG_KEY_LEN);
+			ret = true;
+			goto out;
+		}
+
+		fprintf(stderr, "Invalid length key in key file\n");
+		goto out;
+	}
+	dst[WG_KEY_LEN_BASE64 - 1] = '\0';
+
+	while ((c = getc(f)) != EOF) {
+		if (!isspace(c)) {
+			fprintf(stderr, "Found trailing character in key file: `%c'\n", c);
+			goto out;
+		}
+	}
+	if (ferror(f) && errno) {
+		perror("getc");
+		goto out;
+	}
+	ret = parse_key(key, dst);
+
+out:
+	fclose(f);
+	return ret;
+}
+
 static inline bool parse_ip(struct wgallowedip *allowedip, const char *value)
 {
 	allowedip->family = AF_UNSPEC;
@@ -335,9 +383,7 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 			ret = parse_fwmark(&ctx->device->fwmark, &ctx->device->flags, value);
 		else if (key_match("PrivateKey")) {
 			ret = parse_key(ctx->device->private_key, value);
-			if (!ret)
-				memset(ctx->device->private_key, 0, WG_KEY_LEN);
-			else
+			if (ret)
 				ctx->device->flags |= WGDEVICE_HAS_PRIVATE_KEY;
 		} else
 			goto error;
@@ -354,9 +400,7 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 			ret = parse_persistent_keepalive(&ctx->last_peer->persistent_keepalive_interval, &ctx->last_peer->flags, value);
 		else if (key_match("PresharedKey")) {
 			ret = parse_key(ctx->last_peer->preshared_key, value);
-			if (!ret)
-				memset(ctx->last_peer->preshared_key, 0, WG_KEY_LEN);
-			else if (!key_is_zero(ctx->last_peer->preshared_key))
+			if (ret)
 				ctx->last_peer->flags |= WGPEER_HAS_PRESHARED_KEY;
 		} else
 			goto error;
@@ -429,54 +473,6 @@ err:
 	return NULL;
 }
 
-static bool read_keyfile(char dst[WG_KEY_LEN_BASE64], const char *path)
-{
-	FILE *f;
-	int c;
-	bool ret = false;
-
-	f = fopen(path, "r");
-	if (!f) {
-		perror("fopen");
-		return false;
-	}
-
-	if (fread(dst, WG_KEY_LEN_BASE64 - 1, 1, f) != 1) {
-		if (errno) {
-			perror("fread");
-			goto out;
-		}
-		/* If we're at the end and we didn't read anything, we're /dev/null. */
-		if (!ferror(f) && feof(f) && !ftell(f)) {
-			static const uint8_t zeros[WG_KEY_LEN] = { 0 };
-
-			key_to_base64(dst, zeros);
-			ret = true;
-			goto out;
-		}
-
-		fprintf(stderr, "Invalid length key in key file\n");
-		goto out;
-	}
-	dst[WG_KEY_LEN_BASE64 - 1] = '\0';
-
-	while ((c = getc(f)) != EOF) {
-		if (!isspace(c)) {
-			fprintf(stderr, "Found trailing character in key file: `%c'\n", c);
-			goto out;
-		}
-	}
-	if (ferror(f) && errno) {
-		perror("getc");
-		goto out;
-	}
-	ret = true;
-
-out:
-	fclose(f);
-	return ret;
-}
-
 static char *strip_spaces(const char *in)
 {
 	char *out;
@@ -517,14 +513,9 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 			argv += 2;
 			argc -= 2;
 		} else if (!strcmp(argv[0], "private-key") && argc >= 2 && !peer) {
-			char key_line[WG_KEY_LEN_BASE64];
-
-			if (read_keyfile(key_line, argv[1])) {
-				if (!parse_key(device->private_key, key_line))
-					goto error;
-				device->flags |= WGDEVICE_HAS_PRIVATE_KEY;
-			} else
+			if (!parse_keyfile(device->private_key, argv[1]))
 				goto error;
+			device->flags |= WGDEVICE_HAS_PRIVATE_KEY;
 			argv += 2;
 			argc -= 2;
 		} else if (!strcmp(argv[0], "peer") && argc >= 2) {
@@ -542,6 +533,7 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 			peer = new_peer;
 			if (!parse_key(peer->public_key, argv[1]))
 				goto error;
+			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
 			argv += 2;
 			argc -= 2;
 		} else if (!strcmp(argv[0], "remove") && argc >= 1 && peer) {
@@ -571,15 +563,9 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 			argv += 2;
 			argc -= 2;
 		} else if (!strcmp(argv[0], "preshared-key") && argc >= 2 && peer) {
-			char key_line[WG_KEY_LEN_BASE64];
-
-			if (read_keyfile(key_line, argv[1])) {
-				if (!parse_key(peer->preshared_key, key_line))
-					goto error;
-				if (!key_is_zero(peer->preshared_key))
-					peer->flags |= WGPEER_HAS_PRESHARED_KEY;
-			} else
+			if (!parse_keyfile(peer->preshared_key, argv[1]))
 				goto error;
+			peer->flags |= WGPEER_HAS_PRESHARED_KEY;
 			argv += 2;
 			argc -= 2;
 		} else {

commit bc1f6be5dbcfe60cec053825b5efe73cff729844
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Nov 22 16:49:56 2017 +0100

    global: switch from timeval to timespec
    
    This gets us nanoseconds instead of microseconds, which is better, and
    we can do this pretty much without freaking out existing userspace,
    which doesn't actually make use of the nano/micro seconds field:
    
    zx2c4@thinkpad ~ $ cat a.c
    void main()
    {
            puts(sizeof(struct timeval) == sizeof(struct timespec) ? "success" : "failure");
    }
    zx2c4@thinkpad ~ $ gcc a.c -m64 && ./a.out
    success
    zx2c4@thinkpad ~ $ gcc a.c -m32 && ./a.out
    success
    
    This doesn't solve y2038 problem, but timespec64 isn't yet a thing in
    userspace.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/containers.h b/src/containers.h
index 58d0657..31eabea 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -6,9 +6,9 @@
 
 #include <stdint.h>
 #include <stdlib.h>
+#include <time.h>
 #include <net/if.h>
 #include <netinet/in.h>
-#include <sys/time.h>
 #include <sys/socket.h>
 
 #include "../uapi/wireguard.h"
@@ -43,7 +43,7 @@ struct wgpeer {
 		struct sockaddr_in6 addr6;
 	} endpoint;
 
-	struct timeval last_handshake_time;
+	struct timespec last_handshake_time;
 	uint64_t rx_bytes, tx_bytes;
 	uint16_t persistent_keepalive_interval;
 
diff --git a/src/ipc.c b/src/ipc.c
index 2d24287..a88672f 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -427,7 +427,7 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 		} else if (peer && !strcmp(key, "last_handshake_time_sec"))
 			peer->last_handshake_time.tv_sec = NUM(0xffffffffffffffffULL);
 		else if (peer && !strcmp(key, "last_handshake_time_nsec"))
-			peer->last_handshake_time.tv_usec = NUM(0xffffffffffffffffULL) / 1000;
+			peer->last_handshake_time.tv_nsec = NUM(0xffffffffffffffffULL);
 		else if (peer && !strcmp(key, "rx_bytes"))
 			peer->rx_bytes = NUM(0xffffffffffffffffULL);
 		else if (peer && !strcmp(key, "tx_bytes"))
diff --git a/src/show.c b/src/show.c
index 6ae5830..ebfdf5b 100644
--- a/src/show.c
+++ b/src/show.c
@@ -24,13 +24,13 @@ static int peer_cmp(const void *first, const void *second)
 	time_t diff;
 	const struct wgpeer *a = *(const void **)first, *b = *(const void **)second;
 
-	if (!a->last_handshake_time.tv_sec && !a->last_handshake_time.tv_usec && (b->last_handshake_time.tv_sec || b->last_handshake_time.tv_usec))
+	if (!a->last_handshake_time.tv_sec && !a->last_handshake_time.tv_nsec && (b->last_handshake_time.tv_sec || b->last_handshake_time.tv_nsec))
 		return 1;
-	if (!b->last_handshake_time.tv_sec && !b->last_handshake_time.tv_usec && (a->last_handshake_time.tv_sec || a->last_handshake_time.tv_usec))
+	if (!b->last_handshake_time.tv_sec && !b->last_handshake_time.tv_nsec && (a->last_handshake_time.tv_sec || a->last_handshake_time.tv_nsec))
 		return -1;
 	diff = a->last_handshake_time.tv_sec - b->last_handshake_time.tv_sec;
 	if (!diff)
-		diff = a->last_handshake_time.tv_usec - b->last_handshake_time.tv_usec;
+		diff = a->last_handshake_time.tv_nsec - b->last_handshake_time.tv_nsec;
 	if (diff < 0)
 		return 1;
 	if (diff > 0)
@@ -149,7 +149,7 @@ static size_t pretty_time(char *buf, const size_t len, unsigned long long left)
 	return offset;
 }
 
-static char *ago(const struct timeval *t)
+static char *ago(const struct timespec *t)
 {
 	static char buf[1024];
 	size_t offset;

commit 08ce3b2426b4d268c8c16135249daef44e23cd25
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Nov 17 13:39:02 2017 +0100

    wg: tighten up strtoul parsing
    
    Reported-by: Cedric Buxin <cedric.buxin@izri.org>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 540b800..84038c8 100644
--- a/src/config.c
+++ b/src/config.c
@@ -83,16 +83,22 @@ static inline bool parse_fwmark(uint32_t *fwmark, uint32_t *flags, const char *v
 		return true;
 	}
 
-	if (value[0] == '0' && value[1] == 'x') {
-		value += 2;
+	if (!isdigit(value[0]))
+		goto err;
+
+	if (strlen(value) > 2 && value[0] == '0' && value[1] == 'x')
 		base = 16;
-	}
+
 	ret = strtoul(value, &end, base);
-	if (!*value || *end || ret > UINT32_MAX)
-		return false;
+	if (*end || ret > UINT32_MAX)
+		goto err;
+
 	*fwmark = ret;
 	*flags |= WGDEVICE_HAS_FWMARK;
 	return true;
+err:
+	fprintf(stderr, "Fwmark is neither 0/off nor 0-0xffffffff: `%s'\n", value);
+	return false;
 }
 
 static inline bool parse_key(uint8_t key[static WG_KEY_LEN], const char *value)
@@ -206,22 +212,26 @@ static inline bool parse_persistent_keepalive(uint16_t *interval, uint32_t *flag
 		return true;
 	}
 
+	if (!isdigit(value[0]))
+		goto err;
+
 	ret = strtoul(value, &end, 10);
-	if (!*value || *value == '-' || *end || ret > 65535) {
-		fprintf(stderr, "The persistent keepalive interval must be 0/off or 1-65535. Found: `%s'\n", value);
-		return false;
-	}
+	if (*end || ret > 65535)
+		goto err;
 
 	*interval = (uint16_t)ret;
 	*flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
 	return true;
+err:
+	fprintf(stderr, "Persistent keepalive interval is neither 0/off nor 1-65535: `%s'\n", value);
+	return false;
 }
 
 
 static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **last_allowedip, const char *value)
 {
 	struct wgallowedip *allowedip = *last_allowedip, *new_allowedip;
-	char *mask, *mutable = strdup(value), *sep;
+	char *mask, *mutable = strdup(value), *sep, *saved_entry;
 
 	if (!mutable) {
 		perror("strdup");
@@ -234,41 +244,57 @@ static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **la
 	}
 	sep = mutable;
 	while ((mask = strsep(&sep, ","))) {
-		unsigned long cidr = ULONG_MAX;
-		char *end, *ip = strsep(&mask, "/");
+		unsigned long cidr;
+		char *end, *ip;
+
+		saved_entry = strdup(mask);
+		ip = strsep(&mask, "/");
 
 		new_allowedip = calloc(1, sizeof(struct wgallowedip));
 		if (!new_allowedip) {
 			perror("calloc");
+			free(saved_entry);
 			free(mutable);
 			return false;
 		}
-		if (allowedip)
-			allowedip->next_allowedip = new_allowedip;
-		else
-			peer->first_allowedip = new_allowedip;
-		allowedip = new_allowedip;
 
-		if (!parse_ip(allowedip, ip)) {
+		if (!parse_ip(new_allowedip, ip)) {
+			free(saved_entry);
 			free(mutable);
 			return false;
 		}
-		if (mask && *mask) {
+
+		if (mask) {
+			if (!isdigit(mask[0]))
+				goto err;
 			cidr = strtoul(mask, &end, 10);
-			if (*end)
-				cidr = ULONG_MAX;
-		}
-		if (allowedip->family == AF_INET)
-			cidr = cidr > 32 ? 32 : cidr;
-		else if (allowedip->family == AF_INET6)
-			cidr = cidr > 128 ? 128 : cidr;
+			if (*end || (cidr > 32 && new_allowedip->family == AF_INET) || (cidr > 128 && new_allowedip->family == AF_INET6))
+				goto err;
+		} else if (new_allowedip->family == AF_INET)
+			cidr = 32;
+		else if (new_allowedip->family == AF_INET6)
+			cidr = 128;
 		else
-			continue;
-		allowedip->cidr = cidr;
+			goto err;
+		new_allowedip->cidr = cidr;
+
+		if (allowedip)
+			allowedip->next_allowedip = new_allowedip;
+		else
+			peer->first_allowedip = new_allowedip;
+		allowedip = new_allowedip;
+		free(saved_entry);
 	}
 	free(mutable);
 	*last_allowedip = allowedip;
 	return true;
+
+err:
+	free(new_allowedip);
+	free(mutable);
+	fprintf(stderr, "AllowedIP is not in the correct format: `%s'\n", saved_entry);
+	free(saved_entry);
+	return false;
 }
 
 static bool process_line(struct config_ctx *ctx, const char *line)
diff --git a/src/ipc.c b/src/ipc.c
index 0f87d24..2d24287 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -16,6 +16,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <ctype.h>
 #include <unistd.h>
 #include <time.h>
 #include <dirent.h>
@@ -280,7 +281,7 @@ static int userspace_set_device(struct wgdevice *dev)
 #define NUM(max) ({ \
 	unsigned long long num; \
 	char *end; \
-	if (!strlen(value)) \
+	if (!isdigit(value[0])) \
 		break; \
 	num = strtoull(value, &end, 10); \
 	if (*end || num > max) \
@@ -398,11 +399,10 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			peer->flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
 		} else if (peer && !strcmp(key, "allowed_ip")) {
 			struct wgallowedip *new_allowedip;
-			char *end, *cidr = strchr(value, '/');
+			char *end, *mask = value, *ip = strsep(&mask, "/");
 
-			if (!cidr || strlen(cidr) <= 1)
+			if (!mask || !isdigit(mask[0]))
 				break;
-			*cidr++ = '\0';
 			new_allowedip = calloc(1, sizeof(struct wgallowedip));
 			if (!new_allowedip) {
 				ret = -ENOMEM;
@@ -414,14 +414,14 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 				peer->first_allowedip = new_allowedip;
 			allowedip = new_allowedip;
 			allowedip->family = AF_UNSPEC;
-			if (strchr(value, ':')) {
-				if (inet_pton(AF_INET6, value, &allowedip->ip6) == 1)
+			if (strchr(ip, ':')) {
+				if (inet_pton(AF_INET6, ip, &allowedip->ip6) == 1)
 					allowedip->family = AF_INET6;
 			} else {
-				if (inet_pton(AF_INET, value, &allowedip->ip4) == 1)
+				if (inet_pton(AF_INET, ip, &allowedip->ip4) == 1)
 					allowedip->family = AF_INET;
 			}
-			allowedip->cidr = strtoul(cidr, &end, 10);
+			allowedip->cidr = strtoul(mask, &end, 10);
 			if (*end || allowedip->family == AF_UNSPEC || (allowedip->family == AF_INET6 && allowedip->cidr > 128) || (allowedip->family == AF_INET && allowedip->cidr > 32))
 				break;
 		} else if (peer && !strcmp(key, "last_handshake_time_sec"))

commit be4597e10f6d6a0c6f0fb927d60a8d8f76960c97
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Nov 12 00:49:34 2017 +0900

    wg-quick: document localhost exception and v6 rule
    
    Reported-by: Hermann Lienstromberg <nurtic-vibe@grmml.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index 053d3e1..fd1d23f 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -137,9 +137,9 @@ Building on the last example, one might attempt the so-called ``kill-switch'', i
 to prevent the flow of unencrypted packets through the non-WireGuard interfaces, by adding the following
 two lines `PostUp` and `PreDown` lines to the `[Interface]` section:
 
-    \fBPostUp = iptables -I OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -j REJECT\fP
+    \fBPostUp = iptables -I OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT\fP
 .br
-    \fBPreDown = iptables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -j REJECT\fP
+    \fBPreDown = iptables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT\fP
 .br
 
 The `PostUp' and `PreDown' fields have been added to specify an
@@ -148,7 +148,8 @@ command which, when used with interfaces that have a peer that specifies 0.0.0.0
 `AllowedIPs', works together with wg-quick's fwmark usage in order to drop all packets that
 are either not coming out of the tunnel encrypted or not going through the tunnel itself. (Note
 that this continues to allow most DHCP traffic through, since most DHCP clients make use of PF_PACKET
-sockets, which bypass Netfilter.)
+sockets, which bypass Netfilter.) When IPv6 is in use, additional similar lines could be added using
+.BR ip6tables (8).
 
 Or, perhaps it is desirable to store private keys in encrypted form, such as through use of
 .BR pass (1):

commit e77a77a805fcf4e27c8604fd322d30fd27ff2f54
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Nov 11 12:30:21 2017 +0900

    wg: allow for NULL keys everywhere
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 5b25b46..540b800 100644
--- a/src/config.c
+++ b/src/config.c
@@ -318,9 +318,11 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 	} else if (ctx->is_peer_section) {
 		if (key_match("Endpoint"))
 			ret = parse_endpoint(&ctx->last_peer->endpoint.addr, value);
-		else if (key_match("PublicKey"))
+		else if (key_match("PublicKey")) {
 			ret = parse_key(ctx->last_peer->public_key, value);
-		else if (key_match("AllowedIPs"))
+			if (ret)
+				ctx->last_peer->flags |= WGPEER_HAS_PUBLIC_KEY;
+		} else if (key_match("AllowedIPs"))
 			ret = parse_allowedips(ctx->last_peer, &ctx->last_allowedip, value);
 		else if (key_match("PersistentKeepalive"))
 			ret = parse_persistent_keepalive(&ctx->last_peer->persistent_keepalive_interval, &ctx->last_peer->flags, value);
@@ -328,7 +330,7 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 			ret = parse_key(ctx->last_peer->preshared_key, value);
 			if (!ret)
 				memset(ctx->last_peer->preshared_key, 0, WG_KEY_LEN);
-			else
+			else if (!key_is_zero(ctx->last_peer->preshared_key))
 				ctx->last_peer->flags |= WGPEER_HAS_PRESHARED_KEY;
 		} else
 			goto error;
@@ -390,7 +392,7 @@ struct wgdevice *config_read_finish(struct config_ctx *ctx)
 	struct wgpeer *peer;
 
 	for_each_wgpeer(ctx->device, peer) {
-		if (key_is_zero(peer->public_key)) {
+		if (!(peer->flags & WGPEER_HAS_PUBLIC_KEY)) {
 			fprintf(stderr, "A peer is missing a public key\n");
 			goto err;
 		}
@@ -548,7 +550,8 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 			if (read_keyfile(key_line, argv[1])) {
 				if (!parse_key(peer->preshared_key, key_line))
 					goto error;
-				peer->flags |= WGPEER_HAS_PRESHARED_KEY;
+				if (!key_is_zero(peer->preshared_key))
+					peer->flags |= WGPEER_HAS_PRESHARED_KEY;
 			} else
 				goto error;
 			argv += 2;
diff --git a/src/containers.h b/src/containers.h
index c35465e..58d0657 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -26,8 +26,9 @@ struct wgallowedip {
 enum {
 	WGPEER_REMOVE_ME = 1U << 0,
 	WGPEER_REPLACE_ALLOWEDIPS = 1U << 1,
-	WGPEER_HAS_PRESHARED_KEY = 1U << 2,
-	WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL = 1U << 3
+	WGPEER_HAS_PUBLIC_KEY = 1U << 2,
+	WGPEER_HAS_PRESHARED_KEY = 1U << 3,
+	WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL = 1U << 4
 };
 
 struct wgpeer {
@@ -53,8 +54,9 @@ struct wgpeer {
 enum {
 	WGDEVICE_REPLACE_PEERS = 1U << 0,
 	WGDEVICE_HAS_PRIVATE_KEY = 1U << 1,
-	WGDEVICE_HAS_LISTEN_PORT = 1U << 2,
-	WGDEVICE_HAS_FWMARK = 1U << 3
+	WGDEVICE_HAS_PUBLIC_KEY = 1U << 2,
+	WGDEVICE_HAS_LISTEN_PORT = 1U << 3,
+	WGDEVICE_HAS_FWMARK = 1U << 4
 };
 
 struct wgdevice {
diff --git a/src/ipc.c b/src/ipc.c
index d67ada2..0f87d24 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -328,7 +328,7 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			if (!key_from_hex(dev->private_key, value))
 				break;
 			curve25519_generate_public(dev->public_key, dev->private_key);
-			dev->flags |= WGDEVICE_HAS_PRIVATE_KEY;
+			dev->flags |= WGDEVICE_HAS_PRIVATE_KEY | WGDEVICE_HAS_PUBLIC_KEY;
 		} else if (!peer && !strcmp(key, "listen_port")) {
 			dev->listen_port = NUM(0xffffU);
 			dev->flags |= WGDEVICE_HAS_LISTEN_PORT;
@@ -350,10 +350,12 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			peer = new_peer;
 			if (!key_from_hex(peer->public_key, value))
 				break;
+			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
 		} else if (peer && !strcmp(key, "preshared_key")) {
 			if (!key_from_hex(peer->preshared_key, value))
 				break;
-			peer->flags |= WGPEER_HAS_PRESHARED_KEY;
+			if (!key_is_zero(peer->preshared_key))
+				peer->flags |= WGPEER_HAS_PRESHARED_KEY;
 		} else if (peer && !strcmp(key, "endpoint")) {
 			char *begin, *end;
 			struct addrinfo *resolved;
@@ -744,12 +746,17 @@ static int parse_peer(const struct nlattr *attr, void *data)
 	case WGPEER_A_UNSPEC:
 		break;
 	case WGPEER_A_PUBLIC_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(peer->public_key))
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->public_key)) {
 			memcpy(peer->public_key, mnl_attr_get_payload(attr), sizeof(peer->public_key));
+			peer->flags |= WGPEER_HAS_PUBLIC_KEY;
+		}
 		break;
 	case WGPEER_A_PRESHARED_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(peer->preshared_key))
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->preshared_key)) {
 			memcpy(peer->preshared_key, mnl_attr_get_payload(attr), sizeof(peer->preshared_key));
+			if (!key_is_zero(peer->preshared_key))
+				peer->flags |= WGPEER_HAS_PRESHARED_KEY;
+		}
 		break;
 	case WGPEER_A_ENDPOINT: {
 		struct sockaddr *addr;
@@ -807,7 +814,7 @@ static int parse_peers(const struct nlattr *attr, void *data)
 	ret = mnl_attr_parse_nested(attr, parse_peer, new_peer);
 	if (!ret)
 		return ret;
-	if (key_is_zero(new_peer->public_key))
+	if (!(new_peer->flags & WGPEER_HAS_PUBLIC_KEY))
 		return MNL_CB_ERROR;
 	return MNL_CB_OK;
 }
@@ -828,12 +835,16 @@ static int parse_device(const struct nlattr *attr, void *data)
 			strncpy(device->name, mnl_attr_get_str(attr), sizeof(device->name) - 1);
 		break;
 	case WGDEVICE_A_PRIVATE_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(device->private_key))
+		if (mnl_attr_get_payload_len(attr) == sizeof(device->private_key)) {
 			memcpy(device->private_key, mnl_attr_get_payload(attr), sizeof(device->private_key));
+			device->flags |= WGDEVICE_HAS_PRIVATE_KEY;
+		}
 		break;
 	case WGDEVICE_A_PUBLIC_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(device->public_key))
+		if (mnl_attr_get_payload_len(attr) == sizeof(device->public_key)) {
 			memcpy(device->public_key, mnl_attr_get_payload(attr), sizeof(device->public_key));
+			device->flags |= WGDEVICE_HAS_PUBLIC_KEY;
+		}
 		break;
 	case WGDEVICE_A_LISTEN_PORT:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
diff --git a/src/show.c b/src/show.c
index 05777b1..6ae5830 100644
--- a/src/show.c
+++ b/src/show.c
@@ -67,12 +67,17 @@ static char *key(const uint8_t key[static WG_KEY_LEN])
 {
 	static char base64[WG_KEY_LEN_BASE64];
 
-	if (key_is_zero(key))
-		return "(none)";
 	key_to_base64(base64, key);
 	return base64;
 }
 
+static char *maybe_key(const uint8_t maybe_key[static WG_KEY_LEN], bool have_it)
+{
+	if (!have_it)
+		return "(none)";
+	return key(maybe_key);
+}
+
 static char *masked_key(const uint8_t masked_key[static WG_KEY_LEN])
 {
 	const char *var = getenv("WG_HIDE_KEYS");
@@ -201,9 +206,9 @@ static void pretty_print(struct wgdevice *device)
 
 	terminal_printf(TERMINAL_RESET);
 	terminal_printf(TERMINAL_FG_GREEN TERMINAL_BOLD "interface" TERMINAL_RESET ": " TERMINAL_FG_GREEN "%s" TERMINAL_RESET "\n", device->name);
-	if (!key_is_zero(device->public_key))
+	if (device->flags & WGDEVICE_HAS_PUBLIC_KEY)
 		terminal_printf("  " TERMINAL_BOLD "public key" TERMINAL_RESET ": %s\n", key(device->public_key));
-	if (!key_is_zero(device->private_key))
+	if (device->flags & WGDEVICE_HAS_PRIVATE_KEY)
 		terminal_printf("  " TERMINAL_BOLD "private key" TERMINAL_RESET ": %s\n", masked_key(device->private_key));
 	if (device->listen_port)
 		terminal_printf("  " TERMINAL_BOLD "listening port" TERMINAL_RESET ": %u\n", device->listen_port);
@@ -215,7 +220,7 @@ static void pretty_print(struct wgdevice *device)
 	}
 	for_each_wgpeer(device, peer) {
 		terminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD "peer" TERMINAL_RESET ": " TERMINAL_FG_YELLOW "%s" TERMINAL_RESET "\n", key(peer->public_key));
-		if (!key_is_zero(peer->preshared_key))
+		if (peer->flags & WGPEER_HAS_PRESHARED_KEY)
 			terminal_printf("  " TERMINAL_BOLD "preshared key" TERMINAL_RESET ": %s\n", masked_key(peer->preshared_key));
 		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
 			terminal_printf("  " TERMINAL_BOLD "endpoint" TERMINAL_RESET ": %s\n", endpoint(&peer->endpoint.addr));
@@ -246,8 +251,8 @@ static void dump_print(struct wgdevice *device, bool with_interface)
 
 	if (with_interface)
 		printf("%s\t", device->name);
-	printf("%s\t", key(device->private_key));
-	printf("%s\t", key(device->public_key));
+	printf("%s\t", maybe_key(device->private_key, device->flags & WGDEVICE_HAS_PRIVATE_KEY));
+	printf("%s\t", maybe_key(device->public_key, device->flags & WGDEVICE_HAS_PUBLIC_KEY));
 	printf("%u\t", device->listen_port);
 	if (device->fwmark)
 		printf("0x%x\n", device->fwmark);
@@ -257,7 +262,7 @@ static void dump_print(struct wgdevice *device, bool with_interface)
 		if (with_interface)
 			printf("%s\t", device->name);
 		printf("%s\t", key(peer->public_key));
-		printf("%s\t", key(peer->preshared_key));
+		printf("%s\t", maybe_key(peer->preshared_key, peer->flags & WGPEER_HAS_PRESHARED_KEY));
 		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
 			printf("%s\t", endpoint(&peer->endpoint.addr));
 		else
@@ -284,11 +289,11 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 	if (!strcmp(param, "public-key")) {
 		if (with_interface)
 			printf("%s\t", device->name);
-		printf("%s\n", key(device->public_key));
+		printf("%s\n", maybe_key(device->public_key, device->flags & WGDEVICE_HAS_PUBLIC_KEY));
 	} else if (!strcmp(param, "private-key")) {
 		if (with_interface)
 			printf("%s\t", device->name);
-		printf("%s\n", key(device->private_key));
+		printf("%s\n", maybe_key(device->private_key, device->flags & WGDEVICE_HAS_PRIVATE_KEY));
 	} else if (!strcmp(param, "listen-port")) {
 		if (with_interface)
 			printf("%s\t", device->name);
@@ -347,7 +352,7 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 			if (with_interface)
 				printf("%s\t", device->name);
 			printf("%s\t", key(peer->public_key));
-			printf("%s\n", key(peer->preshared_key));
+			printf("%s\n", maybe_key(peer->preshared_key, peer->flags & WGPEER_HAS_PRESHARED_KEY));
 		}
 	} else if (!strcmp(param, "peers")) {
 		for_each_wgpeer(device, peer) {
diff --git a/src/showconf.c b/src/showconf.c
index 2843910..e780d78 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -38,7 +38,7 @@ int showconf_main(int argc, char *argv[])
 		printf("ListenPort = %u\n", device->listen_port);
 	if (device->fwmark)
 		printf("FwMark = 0x%x\n", device->fwmark);
-	if (!key_is_zero(device->private_key)) {
+	if (device->flags & WGDEVICE_HAS_PRIVATE_KEY) {
 		key_to_base64(base64, device->private_key);
 		printf("PrivateKey = %s\n", base64);
 	}
@@ -46,7 +46,7 @@ int showconf_main(int argc, char *argv[])
 	for_each_wgpeer(device, peer) {
 		key_to_base64(base64, peer->public_key);
 		printf("[Peer]\nPublicKey = %s\n", base64);
-		if (!key_is_zero(peer->preshared_key)) {
+		if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
 			key_to_base64(base64, peer->preshared_key);
 			printf("PresharedKey = %s\n", base64);
 		}

commit e7923ba7755a3d1ad937e1695036300d89fb6f37
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Nov 10 17:30:24 2017 +0900

    wg: remove ioctl cruft
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/containers.h b/src/containers.h
index 2d0195d..c35465e 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -57,10 +57,6 @@ enum {
 	WGDEVICE_HAS_FWMARK = 1U << 3
 };
 
-enum {
-	WG_API_VERSION_MAGIC = 0xbeef0003
-};
-
 struct wgdevice {
 	char name[IFNAMSIZ];
 	uint32_t ifindex;

commit e0775354bde9b8d977f4fd7980492886981621c9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Nov 9 14:12:06 2017 +0900

    wg-quick: allow for tabs in keys
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/reresolve-dns/reresolve-dns.sh b/contrib/reresolve-dns/reresolve-dns.sh
index d63f5fa..abd5cbf 100755
--- a/contrib/reresolve-dns/reresolve-dns.sh
+++ b/contrib/reresolve-dns/reresolve-dns.sh
@@ -10,30 +10,30 @@ CONFIG_FILE="$1"
 INTERFACE="${BASH_REMATCH[1]}"
 
 process_peer() {
-        [[ $PEER_SECTION -ne 1 || -z $PUBLIC_KEY || -z $ENDPOINT ]] && return 0
-        [[ $(wg show "$INTERFACE" latest-handshakes) =~ ^${PUBLIC_KEY//+/\\+}\  ([0-9]+)$ ]] || return 0
-        (( ($(date +%s) - ${BASH_REMATCH[1]}) > 135 )) || return 0
-        wg set "$INTERFACE" peer "$PUBLIC_KEY" endpoint "$ENDPOINT"
-        reset_peer_section
+	[[ $PEER_SECTION -ne 1 || -z $PUBLIC_KEY || -z $ENDPOINT ]] && return 0
+	[[ $(wg show "$INTERFACE" latest-handshakes) =~ ^${PUBLIC_KEY//+/\\+}\	([0-9]+)$ ]] || return 0
+	(( ($(date +%s) - ${BASH_REMATCH[1]}) > 135 )) || return 0
+	wg set "$INTERFACE" peer "$PUBLIC_KEY" endpoint "$ENDPOINT"
+	reset_peer_section
 }
 
 reset_peer_section() {
-        PEER_SECTION=0
-        PUBLIC_KEY=""
-        ENDPOINT=""
+	PEER_SECTION=0
+	PUBLIC_KEY=""
+	ENDPOINT=""
 }
 
 reset_peer_section
 while read -r line || [[ -n $line ]]; do
-        key="${line%%=*}"; key="${key##*( )}"; key="${key%%*( )}"
-        value="${line#*=}"; value="${value##*( )}"; value="${value%%*( )}"
-        [[ $key == "["* ]] && { process_peer; reset_peer_section; }
-        [[ $key == "[Peer]" ]] && PEER_SECTION=1
-        if [[ $PEER_SECTION -eq 1 ]]; then
-                case "$key" in
-                PublicKey) PUBLIC_KEY="$value"; continue ;;
-                Endpoint) ENDPOINT="$value"; continue ;;
-                esac
-        fi
+	key="${line%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
+	value="${line#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
+	[[ $key == "["* ]] && { process_peer; reset_peer_section; }
+	[[ $key == "[Peer]" ]] && PEER_SECTION=1
+	if [[ $PEER_SECTION -eq 1 ]]; then
+		case "$key" in
+		PublicKey) PUBLIC_KEY="$value"; continue ;;
+		Endpoint) ENDPOINT="$value"; continue ;;
+		esac
+	fi
 done < "$CONFIG_FILE"
 process_peer
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index f69061a..42bf265 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -35,8 +35,8 @@ parse_options() {
 	INTERFACE="${BASH_REMATCH[1]}"
 	shopt -s nocasematch
 	while read -r line || [[ -n $line ]]; do
-		key="${line%%=*}"; key="${key##*( )}"; key="${key%%*( )}"
-		value="${line#*=}"; value="${value##*( )}"; value="${value%%*( )}"
+		key="${line%%=*}"; key="${key##*([[:space:]])}"; key="${key%%*([[:space:]])}"
+		value="${line#*=}"; value="${value##*([[:space:]])}"; value="${value%%*([[:space:]])}"
 		[[ $key == "["* ]] && interface_section=0
 		[[ $key == "[Interface]" ]] && interface_section=1
 		if [[ $interface_section -eq 1 ]]; then

commit d8ad40da252c4216ad750736081003ad9f417536
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Nov 8 18:40:07 2017 +0900

    wg-quick: stat the correct enclosing folder of config file
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 88e671f..f69061a 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -30,7 +30,8 @@ parse_options() {
 	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,16}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
 	[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,16})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
-	((($(stat -c '0%#a' "$CONFIG_FILE") & $(stat -c '0%#a' "/etc/wireguard") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
+	CONFIG_FILE="$(readlink -f "$CONFIG_FILE")"
+	((($(stat -c '0%#a' "$CONFIG_FILE") & $(stat -c '0%#a' "${CONFIG_FILE%/*}") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
 	INTERFACE="${BASH_REMATCH[1]}"
 	shopt -s nocasematch
 	while read -r line || [[ -n $line ]]; do

commit 753dc179b64690d032dbdbb61ab0bf6d77aa9208
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 31 19:47:39 2017 +0100

    wg-quick: save all hooks on save
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 7dc8be1..88e671f 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -177,7 +177,7 @@ set_config() {
 }
 
 save_config() {
-	local old_umask new_config current_config address
+	local old_umask new_config current_config address cmd
 	[[ $(ip -all -brief address show dev "$INTERFACE") =~ ^$INTERFACE\ +\ [A-Z]+\ +(.+)$ ]] || true
 	new_config=$'[Interface]\n'
 	for address in ${BASH_REMATCH[1]}; do
@@ -188,10 +188,18 @@ save_config() {
 	done < <(resolvconf -l "tun.$INTERFACE" 2>/dev/null)
 	[[ -n $MTU && $(ip link show dev "$INTERFACE") =~ mtu\ ([0-9]+) ]] && new_config+="MTU = ${BASH_REMATCH[1]}"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
-	[[ -z $PRE_UP ]] || new_config+="PreUp = $PRE_UP"$'\n'
-	[[ -z $POST_UP ]] || new_config+="PostUp = $POST_UP"$'\n'
-	[[ -z $PRE_DOWN ]] || new_config+="PreDown = $PRE_DOWN"$'\n'
-	[[ -z $POST_DOWN ]] || new_config+="PostDown = $POST_DOWN"$'\n'
+	for cmd in "${PRE_UP[@]}"; do
+		new_config+="PreUp = $cmd"$'\n'
+	done
+	for cmd in "${POST_UP[@]}"; do
+		new_config+="PostUp = $cmd"$'\n'
+	done
+	for cmd in "${PRE_DOWN[@]}"; do
+		new_config+="PreDown = $cmd"$'\n'
+	done
+	for cmd in "${POST_DOWN[@]}"; do
+		new_config+="PostDown = $cmd"$'\n'
+	done
 	old_umask="$(umask)"
 	umask 077
 	current_config="$(cmd wg showconf "$INTERFACE")"

commit 6e313371cccc13c742a4ed3daaa4d826937f6596
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 31 18:13:31 2017 +0100

    wg-quick: fsync the temporary file before renaming
    
    This ensures that on an unclean shutdown, we either see the old content
    or the new content, but not empty content.
    
    Suggested-by: Ka Ho Ng <ngkaho1234@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index da4c0d4..7dc8be1 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -197,6 +197,7 @@ save_config() {
 	current_config="$(cmd wg showconf "$INTERFACE")"
 	trap 'rm -f "$CONFIG_FILE.tmp"; exit' INT TERM EXIT
 	echo "${current_config/\[Interface\]$'\n'/$new_config}" > "$CONFIG_FILE.tmp" || die "Could not write configuration file"
+	sync "$CONFIG_FILE.tmp"
 	mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || die "Could not move configuration file"
 	trap - INT TERM EXIT
 	umask "$old_umask"

commit eb181e811c674080a6cf54bd8ab260dd65ce0b3f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 31 17:51:38 2017 +0100

    wg-quick: allow for saving existing interface
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index 2839cc9..053d3e1 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -9,6 +9,8 @@ wg-quick - set up a WireGuard interface simply
 .I up
 |
 .I down
+|
+.I save
 ] [
 .I CONFIG_FILE
 |
@@ -24,7 +26,8 @@ Use \fIup\fP to add and set up an interface, and use \fIdown\fP to tear down and
 an interface. Running \fIup\fP adds a WireGuard interface, brings up the interface with the
 supplied IP addresses, sets up mtu and routes, and optionally runs pre/post up scripts. Running \fIdown\fP
 optionally saves the current configuration, removes the WireGuard interface, and optionally
-runs pre/post down scripts.
+runs pre/post down scripts. Running \fIsave\fP saves the configuration of an existing
+interface without bringing the interface down.
 
 \fICONFIG_FILE\fP is a configuration file, whose filename is the interface name
 followed by `.conf'. Otherwise, \fIINTERFACE\fP is an interface name, with configuration
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 17fe672..da4c0d4 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -213,7 +213,7 @@ execute_hooks() {
 
 cmd_usage() {
 	cat >&2 <<-_EOF
-	Usage: $PROGRAM [ up | down ] [ CONFIG_FILE | INTERFACE ]
+	Usage: $PROGRAM [ up | down | save ] [ CONFIG_FILE | INTERFACE ]
 
 	  CONFIG_FILE is a configuration file, whose filename is the interface name
 	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
@@ -264,6 +264,11 @@ cmd_down() {
 	execute_hooks "${POST_DOWN[@]}"
 }
 
+cmd_save() {
+	[[ " $(wg show interfaces) " == *" $INTERFACE "* ]] || die "\`$INTERFACE' is not a WireGuard interface"
+	save_config
+}
+
 # ~~ function override insertion point ~~
 
 if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
@@ -276,6 +281,10 @@ elif [[ $# -eq 2 && $1 == down ]]; then
 	auto_su
 	parse_options "$2"
 	cmd_down
+elif [[ $# -eq 2 && $1 == save ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_save
 else
 	cmd_usage
 	exit 1

commit 225882ccc447af850f966f1dceec947b0a142086
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 31 16:15:19 2017 +0100

    contrib: add reresolve-dns
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/reresolve-dns/README b/contrib/reresolve-dns/README
new file mode 100644
index 0000000..f228caa
--- /dev/null
+++ b/contrib/reresolve-dns/README
@@ -0,0 +1,9 @@
+reresolve-dns
+=============
+
+Run this script from cron every thirty seconds or so, and it will ensure
+that if, when using a dynamic DNS service, the DNS entry for a hosts
+changes, the kernel will get the update to the DNS entry.
+
+This works by parsing configuration files, and simply running:
+    $ wg set wg0 peer ... endpoint ...
diff --git a/contrib/reresolve-dns/reresolve-dns.sh b/contrib/reresolve-dns/reresolve-dns.sh
new file mode 100755
index 0000000..d63f5fa
--- /dev/null
+++ b/contrib/reresolve-dns/reresolve-dns.sh
@@ -0,0 +1,39 @@
+#!/bin/bash
+set -e
+shopt -s nocasematch
+shopt -s extglob
+export LC_ALL=C
+
+CONFIG_FILE="$1"
+[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,16}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
+[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,16})\.conf$ ]]
+INTERFACE="${BASH_REMATCH[1]}"
+
+process_peer() {
+        [[ $PEER_SECTION -ne 1 || -z $PUBLIC_KEY || -z $ENDPOINT ]] && return 0
+        [[ $(wg show "$INTERFACE" latest-handshakes) =~ ^${PUBLIC_KEY//+/\\+}\  ([0-9]+)$ ]] || return 0
+        (( ($(date +%s) - ${BASH_REMATCH[1]}) > 135 )) || return 0
+        wg set "$INTERFACE" peer "$PUBLIC_KEY" endpoint "$ENDPOINT"
+        reset_peer_section
+}
+
+reset_peer_section() {
+        PEER_SECTION=0
+        PUBLIC_KEY=""
+        ENDPOINT=""
+}
+
+reset_peer_section
+while read -r line || [[ -n $line ]]; do
+        key="${line%%=*}"; key="${key##*( )}"; key="${key%%*( )}"
+        value="${line#*=}"; value="${value##*( )}"; value="${value%%*( )}"
+        [[ $key == "["* ]] && { process_peer; reset_peer_section; }
+        [[ $key == "[Peer]" ]] && PEER_SECTION=1
+        if [[ $PEER_SECTION -eq 1 ]]; then
+                case "$key" in
+                PublicKey) PUBLIC_KEY="$value"; continue ;;
+                Endpoint) ENDPOINT="$value"; continue ;;
+                esac
+        fi
+done < "$CONFIG_FILE"
+process_peer

commit 2207025c2f887c0d55a9c3c5048f3b9313310190
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 31 14:55:17 2017 +0100

    wg: correct type for CTRL_ATTR_FAMILY_ID
    
    Suggested-by: Jrg Thalheim <joerg@thalheim.io>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/mnlg.c b/src/mnlg.c
index 9135651..8a2b4cc 100644
--- a/src/mnlg.c
+++ b/src/mnlg.c
@@ -19,14 +19,14 @@
 struct mnlg_socket {
 	struct mnl_socket *nl;
 	char *buf;
-	uint32_t id;
+	uint16_t id;
 	uint8_t version;
 	unsigned int seq;
 	unsigned int portid;
 };
 
 static struct nlmsghdr *__mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
-					   uint16_t flags, uint32_t id,
+					   uint16_t flags, uint16_t id,
 					   uint8_t version)
 {
 	struct nlmsghdr *nlh;
@@ -206,7 +206,7 @@ int mnlg_socket_group_add(struct mnlg_socket *nlg, const char *group_name)
 
 	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
 				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
-	mnl_attr_put_u32(nlh, CTRL_ATTR_FAMILY_ID, nlg->id);
+	mnl_attr_put_u16(nlh, CTRL_ATTR_FAMILY_ID, nlg->id);
 
 	err = mnlg_socket_send(nlg, nlh);
 	if (err < 0)
@@ -248,7 +248,7 @@ static int get_family_id_attr_cb(const struct nlattr *attr, void *data)
 
 static int get_family_id_cb(const struct nlmsghdr *nlh, void *data)
 {
-	uint32_t *p_id = data;
+	uint16_t *p_id = data;
 	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
 
 	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_family_id_attr_cb, tb);

commit d30d9630b6465982ee1ee2eba325f48f65fb5079
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 31 11:38:09 2017 +0100

    wg-quick: allow for the hatchet, but not by default
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/dns-hatchet/README b/contrib/dns-hatchet/README
new file mode 100644
index 0000000..edb60ce
--- /dev/null
+++ b/contrib/dns-hatchet/README
@@ -0,0 +1,8 @@
+The DNS Hatchet
+===============
+
+This is a workaround for distributions without resolvconf or any proper
+mechanism of setting the DNS. Running 'apply.sh` in this directory will
+insert 'hatchet.bash` into the right place in 'wg-quick.bash`. It is
+recommended that distributions without any resolvconf available run this
+before calling 'make install` in their packaging scripts.
diff --git a/contrib/dns-hatchet/apply.sh b/contrib/dns-hatchet/apply.sh
new file mode 100755
index 0000000..ce35ecd
--- /dev/null
+++ b/contrib/dns-hatchet/apply.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+ME="$(readlink -f "$(dirname "$(readlink -f "$0")")")"
+TOOLS="$ME/../../../src/tools"
+
+sed -i "/~~ function override insertion point ~~/r $ME/hatchet.bash" "$TOOLS/wg-quick.bash"
diff --git a/contrib/dns-hatchet/hatchet.bash b/contrib/dns-hatchet/hatchet.bash
new file mode 100644
index 0000000..793684c
--- /dev/null
+++ b/contrib/dns-hatchet/hatchet.bash
@@ -0,0 +1,39 @@
+set_dns() {
+	[[ ${#DNS[@]} -gt 0 ]] || return 0
+
+	if [[ $(resolvconf --version 2>/dev/null) == openresolv\ * ]]; then
+		printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "$INTERFACE" -m 0 -x
+	else
+		echo "[#] mount \`${DNS[*]}' /etc/resolv.conf" >&2
+		[[ -e /etc/resolv.conf ]] || touch /etc/resolv.conf
+		{ cat <<-_EOF
+			# This file was generated by wg-quick(8) for use with
+			# the WireGuard interface $INTERFACE. It cannot be
+			# removed or altered directly. You may remove this file
+			# by running \`wg-quick down $INTERFACE', or if that
+			# poses problems, run \`umount /etc/resolv.conf'.
+
+		_EOF
+		printf 'nameserver %s\n' "${DNS[@]}"
+		} | unshare -m --propagation shared bash -c "$(cat <<-_EOF
+			set -e
+			mount --make-private /dev/shm
+			mount -t tmpfs none /dev/shm
+			cat > /dev/shm/resolv.conf
+			mount -o remount,ro /dev/shm
+			mount -o bind,ro /dev/shm/resolv.conf /etc/resolv.conf
+		_EOF
+		)"
+	fi
+	HAVE_SET_DNS=1
+}
+
+unset_dns() {
+	[[ ${#DNS[@]} -gt 0 ]] || return 0
+
+	if [[ $(resolvconf --version 2>/dev/null) == openresolv\ * ]]; then
+		cmd resolvconf -d "$INTERFACE"
+	else
+		cmd umount /etc/resolv.conf
+	fi
+}
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index b98a18b..17fe672 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -264,6 +264,8 @@ cmd_down() {
 	execute_hooks "${POST_DOWN[@]}"
 }
 
+# ~~ function override insertion point ~~
+
 if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
 	cmd_usage
 elif [[ $# -eq 2 && $1 == up ]]; then

commit 9bcb48eacd198ae4b0faee462941dda2dd71a4dd
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Oct 26 22:49:46 2017 +0200

    wg-quick: remember to rewind DNS settings on failure
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index def78af..b98a18b 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -83,6 +83,7 @@ add_if() {
 
 del_if() {
 	local fwmark
+	[[ $HAVE_SET_DNS -eq 0 ]] || unset_dns
 	fwmark="$(wg show "$INTERFACE" fwmark)"
 	DEFAULT_TABLE=0
 	[[ $fwmark != off ]] && DEFAULT_TABLE=$(( fwmark ))
@@ -130,12 +131,16 @@ set_mtu() {
 	cmd ip link set mtu $(( mtu - 80 )) dev "$INTERFACE"
 }
 
+HAVE_SET_DNS=0
 set_dns() {
-	[[ ${#DNS[@]} -eq 0 ]] || printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "tun.$INTERFACE" -m 0 -x
+	[[ ${#DNS[@]} -gt 0 ]] || return 0
+	printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "tun.$INTERFACE" -m 0 -x
+	HAVE_SET_DNS=1
 }
 
 unset_dns() {
-	[[ ${#DNS[@]} -eq 0 ]] || cmd resolvconf -d "tun.$INTERFACE"
+	[[ ${#DNS[@]} -gt 0 ]] || return 0
+	cmd resolvconf -d "tun.$INTERFACE"
 }
 
 add_route() {
@@ -254,8 +259,8 @@ cmd_down() {
 	[[ " $(wg show interfaces) " == *" $INTERFACE "* ]] || die "\`$INTERFACE' is not a WireGuard interface"
 	execute_hooks "${PRE_DOWN[@]}"
 	[[ $SAVE_CONFIG -eq 0 ]] || save_config
-	unset_dns
 	del_if
+	unset_dns
 	execute_hooks "${POST_DOWN[@]}"
 }
 

commit 17f9548182b08e6a1e8eaddcc8ab1057f799be51
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Oct 25 21:55:17 2017 +0200

    wg-quick: allow specifiying multiple hooks
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index b39eff8..2839cc9 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -80,7 +80,8 @@ PreUp, PostUp, PreDown, PostDown \(em script snippets which will be executed by
 .BR bash (1)
 before/after setting up/tearing down the interface, most commonly used
 to configure custom DNS options or firewall rules. The special string `%i'
-is expanded to \fIINTERFACE\fP.
+is expanded to \fIINTERFACE\fP. Each one may be specified multiple times, in which case
+the commands are executed in order.
 .IP \(bu
 SaveConfig \(em if set to `true', the configuration is saved from the current state of the
 interface upon shutdown.
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 015df85..def78af 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -15,10 +15,10 @@ INTERFACE=""
 ADDRESSES=( )
 MTU=""
 DNS=( )
-PRE_UP=""
-POST_UP=""
-PRE_DOWN=""
-POST_DOWN=""
+PRE_UP=( )
+POST_UP=( )
+PRE_DOWN=( )
+POST_DOWN=( )
 SAVE_CONFIG=0
 CONFIG_FILE=""
 PROGRAM="${0##*/}"
@@ -43,10 +43,10 @@ parse_options() {
 			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
 			MTU) MTU="$value"; continue ;;
 			DNS) DNS+=( ${value//,/ } ); continue ;;
-			PreUp) PRE_UP="$value"; continue ;;
-			PreDown) PRE_DOWN="$value"; continue ;;
-			PostUp) POST_UP="$value"; continue ;;
-			PostDown) POST_DOWN="$value"; continue ;;
+			PreUp) PRE_UP+=( "$value" ); continue ;;
+			PreDown) PRE_DOWN+=( "$value" ); continue ;;
+			PostUp) POST_UP+=( "$value" ); continue ;;
+			PostDown) POST_DOWN+=( "$value" ); continue ;;
 			SaveConfig) read_bool SAVE_CONFIG "$value"; continue ;;
 			esac
 		fi
@@ -197,11 +197,13 @@ save_config() {
 	umask "$old_umask"
 }
 
-execute_hook() {
-	[[ -n $1 ]] || return 0
-	local hook="${1//%i/$INTERFACE}"
-	echo "[#] $hook" >&2
-	(eval "$hook")
+execute_hooks() {
+	local hook
+	for hook in "$@"; do
+		hook="${hook//%i/$INTERFACE}"
+		echo "[#] $hook" >&2
+		(eval "$hook")
+	done
 }
 
 cmd_usage() {
@@ -232,7 +234,7 @@ cmd_up() {
 	local i
 	[[ -z $(ip link show dev "$INTERFACE" 2>/dev/null) ]] || die "\`$INTERFACE' already exists"
 	trap 'del_if; exit' INT TERM EXIT
-	execute_hook "$PRE_UP"
+	execute_hooks "${PRE_UP[@]}"
 	add_if
 	set_config
 	for i in "${ADDRESSES[@]}"; do
@@ -244,17 +246,17 @@ cmd_up() {
 	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
 		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"
 	done
-	execute_hook "$POST_UP"
+	execute_hooks "${POST_UP[@]}"
 	trap - INT TERM EXIT
 }
 
 cmd_down() {
 	[[ " $(wg show interfaces) " == *" $INTERFACE "* ]] || die "\`$INTERFACE' is not a WireGuard interface"
-	execute_hook "$PRE_DOWN"
+	execute_hooks "${PRE_DOWN[@]}"
 	[[ $SAVE_CONFIG -eq 0 ]] || save_config
 	unset_dns
 	del_if
-	execute_hook "$POST_DOWN"
+	execute_hooks "${POST_DOWN[@]}"
 }
 
 if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then

commit b1dd8d711ed745b66761af4aae5dc6cc3390556b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Oct 25 17:56:08 2017 +0200

    global: style nits
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 8fe3e1c..5b25b46 100644
--- a/src/config.c
+++ b/src/config.c
@@ -222,6 +222,7 @@ static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **la
 {
 	struct wgallowedip *allowedip = *last_allowedip, *new_allowedip;
 	char *mask, *mutable = strdup(value), *sep;
+
 	if (!mutable) {
 		perror("strdup");
 		return false;
@@ -235,6 +236,7 @@ static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **la
 	while ((mask = strsep(&sep, ","))) {
 		unsigned long cidr = ULONG_MAX;
 		char *end, *ip = strsep(&mask, "/");
+
 		new_allowedip = calloc(1, sizeof(struct wgallowedip));
 		if (!new_allowedip) {
 			perror("calloc");
@@ -281,6 +283,7 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 	}
 	if (!strcasecmp(line, "[Peer]")) {
 		struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
+
 		if (!new_peer) {
 			perror("calloc");
 			return false;
@@ -345,6 +348,7 @@ bool config_read_line(struct config_ctx *ctx, const char *input)
 	size_t len = strlen(input), cleaned_len = 0;
 	char *line = calloc(len + 1, sizeof(char));
 	bool ret = true;
+
 	if (!line) {
 		perror("calloc");
 		ret = false;
@@ -384,6 +388,7 @@ bool config_read_init(struct config_ctx *ctx, bool append)
 struct wgdevice *config_read_finish(struct config_ctx *ctx)
 {
 	struct wgpeer *peer;
+
 	for_each_wgpeer(ctx->device, peer) {
 		if (key_is_zero(peer->public_key)) {
 			fprintf(stderr, "A peer is missing a public key\n");
@@ -416,6 +421,7 @@ static bool read_keyfile(char dst[WG_KEY_LEN_BASE64], const char *path)
 		/* If we're at the end and we didn't read anything, we're /dev/null. */
 		if (!ferror(f) && feof(f) && !ftell(f)) {
 			static const uint8_t zeros[WG_KEY_LEN] = { 0 };
+
 			key_to_base64(dst, zeros);
 			ret = true;
 			goto out;
@@ -466,6 +472,7 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 	struct wgdevice *device = calloc(1, sizeof(struct wgdevice));
 	struct wgpeer *peer = NULL;
 	struct wgallowedip *allowedip = NULL;
+
 	if (!device) {
 		perror("calloc");
 		return false;
@@ -483,6 +490,7 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 			argc -= 2;
 		} else if (!strcmp(argv[0], "private-key") && argc >= 2 && !peer) {
 			char key_line[WG_KEY_LEN_BASE64];
+
 			if (read_keyfile(key_line, argv[1])) {
 				if (!parse_key(device->private_key, key_line))
 					goto error;
@@ -493,6 +501,7 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 			argc -= 2;
 		} else if (!strcmp(argv[0], "peer") && argc >= 2) {
 			struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
+
 			allowedip = NULL;
 			if (!new_peer) {
 				perror("calloc");
@@ -518,6 +527,7 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 			argc -= 2;
 		} else if (!strcmp(argv[0], "allowed-ips") && argc >= 2 && peer) {
 			char *line = strip_spaces(argv[1]);
+
 			if (!line)
 				goto error;
 			if (!parse_allowedips(peer, &allowedip, line)) {
@@ -534,6 +544,7 @@ struct wgdevice *config_read_cmd(char *argv[], int argc)
 			argc -= 2;
 		} else if (!strcmp(argv[0], "preshared-key") && argc >= 2 && peer) {
 			char key_line[WG_KEY_LEN_BASE64];
+
 			if (read_keyfile(key_line, argv[1])) {
 				if (!parse_key(peer->preshared_key, key_line))
 					goto error;
diff --git a/src/curve25519.c b/src/curve25519.c
index 29a4531..71bd095 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -107,7 +107,7 @@ static __always_inline void fscalar_product(felem output, const felem in, const
 static __always_inline void fmul(felem output, const felem in2, const felem in)
 {
 	uint128_t t[5];
-	limb r0,r1,r2,r3,r4,s0,s1,s2,s3,s4,c;
+	limb r0, r1, r2, r3, r4, s0, s1, s2, s3, s4, c;
 
 	r0 = in[0];
 	r1 = in[1];
@@ -156,8 +156,8 @@ static __always_inline void fmul(felem output, const felem in2, const felem in)
 static __always_inline void fsquare_times(felem output, const felem in, limb count)
 {
 	uint128_t t[5];
-	limb r0,r1,r2,r3,r4,c;
-	limb d0,d1,d2,d4,d419;
+	limb r0, r1, r2, r3, r4, c;
+	limb d0, d1, d2, d4, d419;
 
 	r0 = in[0];
 	r1 = in[1];
@@ -186,7 +186,7 @@ static __always_inline void fsquare_times(felem output, const felem in, limb cou
 		r0 +=   c * 19; c = r0 >> 51; r0 = r0 & 0x7ffffffffffffUL;
 		r1 +=   c;      c = r1 >> 51; r1 = r1 & 0x7ffffffffffffUL;
 		r2 +=   c;
-	} while(--count);
+	} while (--count);
 
 	output[0] = r0;
 	output[1] = r1;
@@ -302,6 +302,7 @@ static void fmonty(limb *x2, limb *z2, /* output 2Q */
 			 limb *x3, limb *z3, /* output Q + Q' */
 			 limb *x, limb *z,   /* input Q */
 			 limb *xprime, limb *zprime, /* input Q' */
+
 			 const limb *qmqp /* input Q - Q' */)
 {
 	limb origx[5], origxprime[5], zzz[5], xx[5], zz[5], xxprime[5], zzprime[5], zzzprime[5];
@@ -339,11 +340,12 @@ static void fmonty(limb *x2, limb *z2, /* output 2Q */
  */
 static void swap_conditional(limb a[static 5], limb b[static 5], limb iswap)
 {
-	unsigned i;
+	unsigned int i;
 	const limb swap = -iswap;
 
 	for (i = 0; i < 5; ++i) {
 		const limb x = swap & (a[i] ^ b[i]);
+
 		a[i] ^= x;
 		b[i] ^= x;
 	}
@@ -362,12 +364,13 @@ static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
 	limb e[5] = {0}, f[5] = {1}, g[5] = {0}, h[5] = {1};
 	limb *nqpqx2 = e, *nqpqz2 = f, *nqx2 = g, *nqz2 = h;
 
-	unsigned i, j;
+	unsigned int i, j;
 
 	memcpy(nqpqx, q, sizeof(limb) * 5);
 
 	for (i = 0; i < 32; ++i) {
 		uint8_t byte = n[31 - i];
+
 		for (j = 0; j < 8; ++j) {
 			const limb bit = byte >> 7;
 
@@ -404,7 +407,7 @@ static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
 
 static void crecip(felem out, const felem z)
 {
-	felem a,t0,b,c;
+	felem a, t0, b, c;
 
 	/* 2 */ fsquare_times(a, z, 1); // a = 2
 	/* 8 */ fsquare_times(t0, a, 2);
@@ -454,12 +457,14 @@ typedef int64_t limb;
  * significant first. The value of the field element is:
  *   x[0] + 2^26x[1] + x^51x[2] + 2^102x[3] + ...
  *
- * i.e. the limbs are 26, 25, 26, 25, ... bits wide. */
+ * i.e. the limbs are 26, 25, 26, 25, ... bits wide.
+ */
 
 /* Sum two numbers: output += in */
 static void fsum(limb *output, const limb *in)
 {
-	unsigned i;
+	unsigned int i;
+
 	for (i = 0; i < 10; i += 2) {
 		output[0 + i] = output[0 + i] + in[0 + i];
 		output[1 + i] = output[1 + i] + in[1 + i];
@@ -467,10 +472,12 @@ static void fsum(limb *output, const limb *in)
 }
 
 /* Find the difference of two numbers: output = in - output
- * (note the order of the arguments!). */
+ * (note the order of the arguments!).
+ */
 static void fdifference(limb *output, const limb *in)
 {
-	unsigned i;
+	unsigned int i;
+
 	for (i = 0; i < 10; ++i) {
 		output[i] = in[i] - output[i];
 	}
@@ -479,7 +486,8 @@ static void fdifference(limb *output, const limb *in)
 /* Multiply a number by a scalar: output = in * scalar */
 static void fscalar_product(limb *output, const limb *in, const limb scalar)
 {
-	unsigned i;
+	unsigned int i;
+
 	for (i = 0; i < 10; ++i) {
 		output[i] = in[i] * scalar;
 	}
@@ -490,7 +498,8 @@ static void fscalar_product(limb *output, const limb *in, const limb scalar)
  * output must be distinct to both inputs. The inputs are reduced coefficient
  * form, the output is not.
  *
- * output[x] <= 14 * the largest product of the input limbs. */
+ * output[x] <= 14 * the largest product of the input limbs.
+ */
 static void fproduct(limb *output, const limb *in2, const limb *in)
 {
 	output[0] =       ((limb) ((int32_t) in2[0])) * ((int32_t) in[0]);
@@ -598,13 +607,15 @@ static void fproduct(limb *output, const limb *in2, const limb *in)
 /* Reduce a long form to a short form by taking the input mod 2^255 - 19.
  *
  * On entry: |output[i]| < 14*2^54
- * On exit: |output[0..8]| < 280*2^54 */
+ * On exit: |output[0..8]| < 280*2^54
+ */
 static void freduce_degree(limb *output)
 {
 	/* Each of these shifts and adds ends up multiplying the value by 19.
 	 *
 	 * For output[0..8], the absolute entry value is < 14*2^54 and we add, at
-	 * most, 19*14*2^54 thus, on exit, |output[0..8]| < 280*2^54. */
+	 * most, 19*14*2^54 thus, on exit, |output[0..8]| < 280*2^54.
+	 */
 	output[8] += output[18] << 4;
 	output[8] += output[18] << 1;
 	output[8] += output[18];
@@ -640,7 +651,8 @@ static void freduce_degree(limb *output)
 
 /* return v / 2^26, using only shifts and adds.
  *
- * On entry: v can take any value. */
+ * On entry: v can take any value.
+ */
 static inline limb div_by_2_26(const limb v)
 {
 	/* High word of v; no shift needed. */
@@ -655,7 +667,8 @@ static inline limb div_by_2_26(const limb v)
 
 /* return v / (2^25), using only shifts and adds.
  *
- * On entry: v can take any value. */
+ * On entry: v can take any value.
+ */
 static inline limb div_by_2_25(const limb v)
 {
 	/* High word of v; no shift needed*/
@@ -670,10 +683,11 @@ static inline limb div_by_2_25(const limb v)
 
 /* Reduce all coefficients of the short form input so that |x| < 2^26.
  *
- * On entry: |output[i]| < 280*2^54 */
+ * On entry: |output[i]| < 280*2^54
+ */
 static void freduce_coefficients(limb *output)
 {
-	unsigned i;
+	unsigned int i;
 
 	output[10] = 0;
 
@@ -682,7 +696,8 @@ static void freduce_coefficients(limb *output)
 		/* The entry condition (that |output[i]| < 280*2^54) means that over is, at
 		 * most, 280*2^28 in the first iteration of this loop. This is added to the
 		 * next limb and we can approximate the resulting bound of that limb by
-		 * 281*2^54. */
+		 * 281*2^54.
+		 */
 		output[i] -= over << 26;
 		output[i+1] += over;
 
@@ -691,7 +706,8 @@ static void freduce_coefficients(limb *output)
 		 * be approximated as 281*2^54.
 		 *
 		 * For subsequent iterations of the loop, 281*2^54 remains a conservative
-		 * bound and no overflow occurs. */
+		 * bound and no overflow occurs.
+		 */
 		over = div_by_2_25(output[i+1]);
 		output[i+1] -= over << 25;
 		output[i+2] += over;
@@ -704,15 +720,18 @@ static void freduce_coefficients(limb *output)
 	output[10] = 0;
 
 	/* Now output[1..9] are reduced, and |output[0]| < 2^26 + 19*281*2^29
-	 * So |over| will be no more than 2^16. */
+	 * So |over| will be no more than 2^16.
+	 */
 	{
 		limb over = div_by_2_26(output[0]);
+
 		output[0] -= over << 26;
 		output[1] += over;
 	}
 
 	/* Now output[0,2..9] are reduced, and |output[1]| < 2^25 + 2^16 < 2^26. The
-	 * bound on |output[1]| is sufficient to meet our needs. */
+	 * bound on |output[1]| is sufficient to meet our needs.
+	 */
 }
 
 /* A helpful wrapper around fproduct: output = in * in2.
@@ -720,10 +739,12 @@ static void freduce_coefficients(limb *output)
  * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27.
  *
  * output must be distinct to both inputs. The output is reduced degree
- * (indeed, one need only provide storage for 10 limbs) and |output[i]| < 2^26. */
+ * (indeed, one need only provide storage for 10 limbs) and |output[i]| < 2^26.
+ */
 static void fmul(limb *output, const limb *in, const limb *in2)
 {
 	limb t[19];
+
 	fproduct(t, in, in2);
 	/* |t[i]| < 14*2^54 */
 	freduce_degree(t);
@@ -737,7 +758,8 @@ static void fmul(limb *output, const limb *in, const limb *in2)
  * output must be distinct from the input. The inputs are reduced coefficient
  * form, the output is not.
  *
- * output[x] <= 14 * the largest product of the input limbs. */
+ * output[x] <= 14 * the largest product of the input limbs.
+ */
 static void fsquare_inner(limb *output, const limb *in)
 {
 	output[0] =       ((limb) ((int32_t) in[0])) * ((int32_t) in[0]);
@@ -803,14 +825,17 @@ static void fsquare_inner(limb *output, const limb *in)
  * 2^27.
  *
  * On exit: The |output| argument is in reduced coefficients form (indeed, one
- * need only provide storage for 10 limbs) and |out[i]| < 2^26. */
+ * need only provide storage for 10 limbs) and |out[i]| < 2^26.
+ */
 static void fsquare(limb *output, const limb *in)
 {
 	limb t[19];
+
 	fsquare_inner(t, in);
 	/* |t[i]| < 14*2^54 because the largest product of two limbs will be <
 	 * 2^(27+27) and fsquare_inner adds together, at most, 14 of those
-	 * products. */
+	 * products.
+	 */
 	freduce_degree(t);
 	freduce_coefficients(t);
 	/* |t[i]| < 2^26 */
@@ -820,7 +845,7 @@ static void fsquare(limb *output, const limb *in)
 /* Take a little-endian, 32-byte number and expand it into polynomial form */
 static void fexpand(limb *output, const uint8_t *input)
 {
-#define F(n,start,shift,mask) \
+#define F(n, start, shift, mask) \
 	output[n] = ((((limb) input[start + 0]) | \
 		      ((limb) input[start + 1]) << 8 | \
 		      ((limb) input[start + 2]) << 16 | \
@@ -855,7 +880,8 @@ static int32_t int32_t_eq(int32_t a, int32_t b)
 }
 
 /* int32_t_gte returns 0xffffffff if a >= b and zero otherwise, where a and b are
- * both non-negative. */
+ * both non-negative.
+ */
 static int32_t int32_t_gte(int32_t a, int32_t b)
 {
 	a -= b;
@@ -866,7 +892,8 @@ static int32_t int32_t_gte(int32_t a, int32_t b)
 /* Take a fully reduced polynomial form number and contract it into a
  * little-endian, 32-byte array.
  *
- * On entry: |input_limbs[i]| < 2^26 */
+ * On entry: |input_limbs[i]| < 2^26
+ */
 static void fcontract(uint8_t *output, limb *input_limbs)
 {
 	int i;
@@ -883,31 +910,37 @@ static void fcontract(uint8_t *output, limb *input_limbs)
 		for (i = 0; i < 9; ++i) {
 			if ((i & 1) == 1) {
 				/* This calculation is a time-invariant way to make input[i]
-				 * non-negative by borrowing from the next-larger limb. */
+				 * non-negative by borrowing from the next-larger limb.
+				 */
 				const int32_t mask = input[i] >> 31;
 				const int32_t carry = -((input[i] & mask) >> 25);
+
 				input[i] = input[i] + (carry << 25);
 				input[i+1] = input[i+1] - carry;
 			} else {
 				const int32_t mask = input[i] >> 31;
 				const int32_t carry = -((input[i] & mask) >> 26);
+
 				input[i] = input[i] + (carry << 26);
 				input[i+1] = input[i+1] - carry;
 			}
 		}
 
 		/* There's no greater limb for input[9] to borrow from, but we can multiply
-		 * by 19 and borrow from input[0], which is valid mod 2^255-19. */
+		 * by 19 and borrow from input[0], which is valid mod 2^255-19.
+		 */
 		{
 			const int32_t mask = input[9] >> 31;
 			const int32_t carry = -((input[9] & mask) >> 25);
+
 			input[9] = input[9] + (carry << 25);
 			input[0] = input[0] - (carry * 19);
 		}
 
 		/* After the first iteration, input[1..9] are non-negative and fit within
 		 * 25 or 26 bits, depending on position. However, input[0] may be
-		 * negative. */
+		 * negative.
+		 */
 	}
 
 	/* The first borrow-propagation pass above ended with every limb
@@ -923,20 +956,24 @@ static void fcontract(uint8_t *output, limb *input_limbs)
 	{
 		const int32_t mask = input[0] >> 31;
 		const int32_t carry = -((input[0] & mask) >> 26);
+
 		input[0] = input[0] + (carry << 26);
 		input[1] = input[1] - carry;
 	}
 
 	/* All input[i] are now non-negative. However, there might be values between
-	 * 2^25 and 2^26 in a limb which is, nominally, 25 bits wide. */
+	 * 2^25 and 2^26 in a limb which is, nominally, 25 bits wide.
+	 */
 	for (j = 0; j < 2; j++) {
 		for (i = 0; i < 9; i++) {
 			if ((i & 1) == 1) {
 				const int32_t carry = input[i] >> 25;
+
 				input[i] &= 0x1ffffff;
 				input[i+1] += carry;
 			} else {
 				const int32_t carry = input[i] >> 26;
+
 				input[i] &= 0x3ffffff;
 				input[i+1] += carry;
 			}
@@ -944,6 +981,7 @@ static void fcontract(uint8_t *output, limb *input_limbs)
 
 		{
 			const int32_t carry = input[9] >> 25;
+
 			input[9] &= 0x1ffffff;
 			input[0] += 19*carry;
 		}
@@ -954,11 +992,13 @@ static void fcontract(uint8_t *output, limb *input_limbs)
 	 * < 2^26 + 2*19, because the carry was, at most, two.
 	 *
 	 * If the second pass carried from input[9] again then input[0] is < 2*19 and
-	 * the input[9] -> input[0] carry didn't push input[0] out of bounds. */
+	 * the input[9] -> input[0] carry didn't push input[0] out of bounds.
+	 */
 
 	/* It still remains the case that input might be between 2^255-19 and 2^255.
 	 * In this case, input[1..9] must take their maximum value and input[0] must
-	 * be >= (2^255-19) & 0x3ffffff, which is 0x3ffffed. */
+	 * be >= (2^255-19) & 0x3ffffff, which is 0x3ffffed.
+	 */
 	mask = int32_t_gte(input[0], 0x3ffffed);
 	for (i = 1; i < 10; i++) {
 		if ((i & 1) == 1) {
@@ -969,7 +1009,8 @@ static void fcontract(uint8_t *output, limb *input_limbs)
 	}
 
 	/* mask is either 0xffffffff (if input >= 2^255-19) and zero otherwise. Thus
-	 * this conditionally subtracts 2^255-19. */
+	 * this conditionally subtracts 2^255-19.
+	 */
 	input[0] -= mask & 0x3ffffed;
 
 	for (i = 1; i < 10; i++) {
@@ -995,16 +1036,16 @@ static void fcontract(uint8_t *output, limb *input_limbs)
 	output[s+3]  = (input[i] >> 24) & 0xff;
 	output[0] = 0;
 	output[16] = 0;
-	F(0,0);
-	F(1,3);
-	F(2,6);
-	F(3,9);
-	F(4,12);
-	F(5,16);
-	F(6,19);
-	F(7,22);
-	F(8,25);
-	F(9,28);
+	F(0, 0);
+	F(1, 3);
+	F(2, 6);
+	F(3, 9);
+	F(4, 12);
+	F(5, 16);
+	F(6, 19);
+	F(7, 22);
+	F(8, 25);
+	F(9, 28);
 #undef F
 }
 
@@ -1018,11 +1059,13 @@ static void fcontract(uint8_t *output, limb *input_limbs)
  *   qmqp: short form, preserved
  *
  * On entry and exit, the absolute value of the limbs of all inputs and outputs
- * are < 2^26. */
+ * are < 2^26.
+ */
 static void fmonty(limb *x2, limb *z2,  /* output 2Q */
 		   limb *x3, limb *z3,  /* output Q + Q' */
 		   limb *x, limb *z,    /* input Q */
 		   limb *xprime, limb *zprime,  /* input Q' */
+
 		   const limb *qmqp /* input Q - Q' */)
 {
 	limb origx[10], origxprime[10], zzz[19], xx[19], zz[19], xxprime[19],
@@ -1042,7 +1085,8 @@ static void fmonty(limb *x2, limb *z2,  /* output 2Q */
 	fproduct(xxprime, xprime, z);
 	/* |xxprime[i]| < 14*2^54: the largest product of two limbs will be <
 	 * 2^(27+27) and fproduct adds together, at most, 14 of those products.
-	 * (Approximating that to 2^58 doesn't work out.) */
+	 * (Approximating that to 2^58 doesn't work out.)
+	 */
 	fproduct(zzprime, x, zprime);
 	/* |zzprime[i]| < 14*2^54 */
 	freduce_degree(xxprime);
@@ -1103,14 +1147,16 @@ static void fmonty(limb *x2, limb *z2,  /* output 2Q */
  * wrong results.  Also, the two limb arrays must be in reduced-coefficient,
  * reduced-degree form: the values in a[10..19] or b[10..19] aren't swapped,
  * and all all values in a[0..9],b[0..9] must have magnitude less than
- * INT32_MAX. */
+ * INT32_MAX.
+ */
 static void swap_conditional(limb a[static 19], limb b[static 19], limb iswap)
 {
-	unsigned i;
+	unsigned int i;
 	const int32_t swap = (int32_t) -iswap;
 
 	for (i = 0; i < 10; ++i) {
-		const int32_t x = swap & ( ((int32_t)a[i]) ^ ((int32_t)b[i]) );
+		const int32_t x = swap & (((int32_t)a[i]) ^ ((int32_t)b[i]));
+
 		a[i] = ((int32_t)a[i]) ^ x;
 		b[i] = ((int32_t)b[i]) ^ x;
 	}
@@ -1120,7 +1166,8 @@ static void swap_conditional(limb a[static 19], limb b[static 19], limb iswap)
  *
  *   resultx/resultz: the x coordinate of the resulting curve point (short form)
  *   n: a little endian, 32-byte number
- *   q: a point of the curve (short form) */
+ *   q: a point of the curve (short form)
+ */
 static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
 {
 	limb a[19] = {0}, b[19] = {1}, c[19] = {1}, d[19] = {0};
@@ -1128,12 +1175,13 @@ static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
 	limb e[19] = {0}, f[19] = {1}, g[19] = {0}, h[19] = {1};
 	limb *nqpqx2 = e, *nqpqz2 = f, *nqx2 = g, *nqz2 = h;
 
-	unsigned i, j;
+	unsigned int i, j;
 
 	memcpy(nqpqx, q, sizeof(limb) * 10);
 
 	for (i = 0; i < 32; ++i) {
 		uint8_t byte = n[31 - i];
+
 		for (j = 0; j < 8; ++j) {
 			const limb bit = byte >> 7;
 
@@ -1182,57 +1230,57 @@ static void crecip(limb *out, const limb *z)
 	limb t1[10];
 	int i;
 
-	/* 2 */ fsquare(z2,z);
-	/* 4 */ fsquare(t1,z2);
-	/* 8 */ fsquare(t0,t1);
-	/* 9 */ fmul(z9,t0,z);
-	/* 11 */ fmul(z11,z9,z2);
-	/* 22 */ fsquare(t0,z11);
-	/* 2^5 - 2^0 = 31 */ fmul(z2_5_0,t0,z9);
-
-	/* 2^6 - 2^1 */ fsquare(t0,z2_5_0);
-	/* 2^7 - 2^2 */ fsquare(t1,t0);
-	/* 2^8 - 2^3 */ fsquare(t0,t1);
-	/* 2^9 - 2^4 */ fsquare(t1,t0);
-	/* 2^10 - 2^5 */ fsquare(t0,t1);
-	/* 2^10 - 2^0 */ fmul(z2_10_0,t0,z2_5_0);
-
-	/* 2^11 - 2^1 */ fsquare(t0,z2_10_0);
-	/* 2^12 - 2^2 */ fsquare(t1,t0);
-	/* 2^20 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t0,t1); fsquare(t1,t0); }
-	/* 2^20 - 2^0 */ fmul(z2_20_0,t1,z2_10_0);
-
-	/* 2^21 - 2^1 */ fsquare(t0,z2_20_0);
-	/* 2^22 - 2^2 */ fsquare(t1,t0);
-	/* 2^40 - 2^20 */ for (i = 2; i < 20; i += 2) { fsquare(t0,t1); fsquare(t1,t0); }
-	/* 2^40 - 2^0 */ fmul(t0,t1,z2_20_0);
-
-	/* 2^41 - 2^1 */ fsquare(t1,t0);
-	/* 2^42 - 2^2 */ fsquare(t0,t1);
-	/* 2^50 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t1,t0); fsquare(t0,t1); }
-	/* 2^50 - 2^0 */ fmul(z2_50_0,t0,z2_10_0);
-
-	/* 2^51 - 2^1 */ fsquare(t0,z2_50_0);
-	/* 2^52 - 2^2 */ fsquare(t1,t0);
-	/* 2^100 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0,t1); fsquare(t1,t0); }
-	/* 2^100 - 2^0 */ fmul(z2_100_0,t1,z2_50_0);
-
-	/* 2^101 - 2^1 */ fsquare(t1,z2_100_0);
-	/* 2^102 - 2^2 */ fsquare(t0,t1);
-	/* 2^200 - 2^100 */ for (i = 2; i < 100; i += 2) { fsquare(t1,t0); fsquare(t0,t1); }
-	/* 2^200 - 2^0 */ fmul(t1,t0,z2_100_0);
-
-	/* 2^201 - 2^1 */ fsquare(t0,t1);
-	/* 2^202 - 2^2 */ fsquare(t1,t0);
-	/* 2^250 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0,t1); fsquare(t1,t0); }
-	/* 2^250 - 2^0 */ fmul(t0,t1,z2_50_0);
-
-	/* 2^251 - 2^1 */ fsquare(t1,t0);
-	/* 2^252 - 2^2 */ fsquare(t0,t1);
-	/* 2^253 - 2^3 */ fsquare(t1,t0);
-	/* 2^254 - 2^4 */ fsquare(t0,t1);
-	/* 2^255 - 2^5 */ fsquare(t1,t0);
-	/* 2^255 - 21 */ fmul(out,t1,z11);
+	/* 2 */ fsquare(z2, z);
+	/* 4 */ fsquare(t1, z2);
+	/* 8 */ fsquare(t0, t1);
+	/* 9 */ fmul(z9, t0, z);
+	/* 11 */ fmul(z11, z9, z2);
+	/* 22 */ fsquare(t0, z11);
+	/* 2^5 - 2^0 = 31 */ fmul(z2_5_0, t0, z9);
+
+	/* 2^6 - 2^1 */ fsquare(t0, z2_5_0);
+	/* 2^7 - 2^2 */ fsquare(t1, t0);
+	/* 2^8 - 2^3 */ fsquare(t0, t1);
+	/* 2^9 - 2^4 */ fsquare(t1, t0);
+	/* 2^10 - 2^5 */ fsquare(t0, t1);
+	/* 2^10 - 2^0 */ fmul(z2_10_0, t0, z2_5_0);
+
+	/* 2^11 - 2^1 */ fsquare(t0, z2_10_0);
+	/* 2^12 - 2^2 */ fsquare(t1, t0);
+	/* 2^20 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
+	/* 2^20 - 2^0 */ fmul(z2_20_0, t1, z2_10_0);
+
+	/* 2^21 - 2^1 */ fsquare(t0, z2_20_0);
+	/* 2^22 - 2^2 */ fsquare(t1, t0);
+	/* 2^40 - 2^20 */ for (i = 2; i < 20; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
+	/* 2^40 - 2^0 */ fmul(t0, t1, z2_20_0);
+
+	/* 2^41 - 2^1 */ fsquare(t1, t0);
+	/* 2^42 - 2^2 */ fsquare(t0, t1);
+	/* 2^50 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t1, t0); fsquare(t0, t1); }
+	/* 2^50 - 2^0 */ fmul(z2_50_0, t0, z2_10_0);
+
+	/* 2^51 - 2^1 */ fsquare(t0, z2_50_0);
+	/* 2^52 - 2^2 */ fsquare(t1, t0);
+	/* 2^100 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
+	/* 2^100 - 2^0 */ fmul(z2_100_0, t1, z2_50_0);
+
+	/* 2^101 - 2^1 */ fsquare(t1, z2_100_0);
+	/* 2^102 - 2^2 */ fsquare(t0, t1);
+	/* 2^200 - 2^100 */ for (i = 2; i < 100; i += 2) { fsquare(t1, t0); fsquare(t0, t1); }
+	/* 2^200 - 2^0 */ fmul(t1, t0, z2_100_0);
+
+	/* 2^201 - 2^1 */ fsquare(t0, t1);
+	/* 2^202 - 2^2 */ fsquare(t1, t0);
+	/* 2^250 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0, t1); fsquare(t1, t0); }
+	/* 2^250 - 2^0 */ fmul(t0, t1, z2_50_0);
+
+	/* 2^251 - 2^1 */ fsquare(t1, t0);
+	/* 2^252 - 2^2 */ fsquare(t0, t1);
+	/* 2^253 - 2^3 */ fsquare(t1, t0);
+	/* 2^254 - 2^4 */ fsquare(t0, t1);
+	/* 2^255 - 2^5 */ fsquare(t1, t0);
+	/* 2^255 - 21 */ fmul(out, t1, z11);
 }
 
 void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE])
@@ -1254,5 +1302,6 @@ void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t se
 void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE])
 {
 	static const uint8_t basepoint[CURVE25519_POINT_SIZE] = { 9 };
+
 	curve25519(pub, secret, basepoint);
 }
diff --git a/src/encoding.c b/src/encoding.c
index c407b57..da5ccef 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -9,6 +9,7 @@
 static inline void encode_base64(char dest[4], const uint8_t src[3])
 {
 	const uint8_t input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
+
 	for (unsigned int i = 0; i < 4; ++i)
 		dest[i] = input[i] + 'A'
 			  + (((25 - input[i]) >> 8) & 6)
@@ -21,6 +22,7 @@ static inline void encode_base64(char dest[4], const uint8_t src[3])
 void key_to_base64(char base64[static WG_KEY_LEN_BASE64], const uint8_t key[static WG_KEY_LEN])
 {
 	unsigned int i;
+
 	for (i = 0; i < WG_KEY_LEN / 3; ++i)
 		encode_base64(&base64[i * 4], &key[i * 3]);
 	encode_base64(&base64[i * 4], (const uint8_t[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
@@ -31,6 +33,7 @@ void key_to_base64(char base64[static WG_KEY_LEN_BASE64], const uint8_t key[stat
 static inline int decode_base64(const char src[4])
 {
 	int val = 0;
+
 	for (unsigned int i = 0; i < 4; ++i)
 		val |= (-1
 			    + ((((('A' - 1) - src[i]) & (src[i] - ('Z' + 1))) >> 8) & (src[i] - 64))
@@ -46,6 +49,7 @@ bool key_from_base64(uint8_t key[static WG_KEY_LEN], const char *base64)
 {
 	unsigned int i;
 	int val;
+
 	if (strlen(base64) != WG_KEY_LEN_BASE64 - 1 || base64[WG_KEY_LEN_BASE64 - 2] != '=')
 		return false;
 
@@ -68,6 +72,7 @@ bool key_from_base64(uint8_t key[static WG_KEY_LEN], const char *base64)
 void key_to_hex(char hex[static WG_KEY_LEN_HEX], const uint8_t key[static WG_KEY_LEN])
 {
 	unsigned int i;
+
 	for (i = 0; i < WG_KEY_LEN; ++i) {
 		hex[i * 2] = 87U + (key[i] >> 4) + ((((key[i] >> 4) - 10U) >> 8) & ~38U);
 		hex[i * 2 + 1] = 87U + (key[i] & 0xf) + ((((key[i] & 0xf) - 10U) >> 8) & ~38U);
@@ -103,6 +108,7 @@ bool key_from_hex(uint8_t key[static WG_KEY_LEN], const char *hex)
 bool key_is_zero(const uint8_t key[static WG_KEY_LEN])
 {
 	volatile uint8_t acc = 0;
+
 	for (unsigned int i = 0; i < WG_KEY_LEN; ++i) {
 		acc |= key[i];
 		__asm__ ("" : "=r" (acc) : "0" (acc));
diff --git a/src/ipc.c b/src/ipc.c
index 66a5720..d67ada2 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -337,6 +337,7 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			dev->flags |= WGDEVICE_HAS_FWMARK;
 		} else if (!strcmp(key, "public_key")) {
 			struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
+
 			if (!new_peer) {
 				ret = -ENOMEM;
 				goto err;
@@ -396,6 +397,7 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 		} else if (peer && !strcmp(key, "allowed_ip")) {
 			struct wgallowedip *new_allowedip;
 			char *end, *cidr = strchr(value, '/');
+
 			if (!cidr || strlen(cidr) <= 1)
 				break;
 			*cidr++ = '\0';
@@ -450,6 +452,7 @@ err:
 static int parse_linkinfo(const struct nlattr *attr, void *data)
 {
 	struct inflatable_buffer *buffer = data;
+
 	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp("wireguard", mnl_attr_get_str(attr)))
 		buffer->good = true;
 	return MNL_CB_OK;
@@ -458,6 +461,7 @@ static int parse_linkinfo(const struct nlattr *attr, void *data)
 static int parse_infomsg(const struct nlattr *attr, void *data)
 {
 	struct inflatable_buffer *buffer = data;
+
 	if (mnl_attr_get_type(attr) == IFLA_LINKINFO)
 		return mnl_attr_parse_nested(attr, parse_linkinfo, data);
 	else if (mnl_attr_get_type(attr) == IFLA_IFNAME)
@@ -565,6 +569,7 @@ again:
 
 	if (!peer) {
 		uint32_t flags = 0;
+
 		if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY)
 			mnl_attr_put(nlh, WGDEVICE_A_PRIVATE_KEY, sizeof(dev->private_key), dev->private_key);
 		if (dev->flags & WGDEVICE_HAS_LISTEN_PORT)
@@ -582,6 +587,7 @@ again:
 	peers_nest = mnl_attr_nest_start(nlh, WGDEVICE_A_PEERS);
 	for (i = 0, peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
 		uint32_t flags = 0;
+
 		peer_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, i++);
 		if (!peer_nest)
 			goto toobig_peers;
@@ -747,6 +753,7 @@ static int parse_peer(const struct nlattr *attr, void *data)
 		break;
 	case WGPEER_A_ENDPOINT: {
 		struct sockaddr *addr;
+
 		if (mnl_attr_get_payload_len(attr) < sizeof(*addr))
 			break;
 		addr = mnl_attr_get_payload(attr);
diff --git a/src/mnlg.c b/src/mnlg.c
index ff70bdc..9135651 100644
--- a/src/mnlg.c
+++ b/src/mnlg.c
@@ -1,6 +1,7 @@
 /* Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
- * Original author: Jiri Pirko <jiri@mellanox.com> */
+ * Original author: Jiri Pirko <jiri@mellanox.com>
+ */
 
 #ifdef __linux__
 
@@ -113,7 +114,7 @@ int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data)
 		if (err <= 0)
 			break;
 		err = mnl_cb_run2(nlg->buf, err, nlg->seq, nlg->portid,
-				  data_cb, data, mnlg_cb_array, sizeof(mnlg_cb_array) / sizeof(mnlg_cb_array[0]));
+				  data_cb, data, mnlg_cb_array, MNL_ARRAY_SIZE(mnlg_cb_array));
 	} while (err > 0);
 
 	return err;
diff --git a/src/mnlg.h b/src/mnlg.h
index 46c53ba..b27a18c 100644
--- a/src/mnlg.h
+++ b/src/mnlg.h
@@ -1,6 +1,7 @@
 /* Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
- * Original author: Jiri Pirko <jiri@mellanox.com> */
+ * Original author: Jiri Pirko <jiri@mellanox.com>
+ */
 
 #ifndef MNLG_H
 #define MNLG_H
diff --git a/src/show.c b/src/show.c
index d315ee8..05777b1 100644
--- a/src/show.c
+++ b/src/show.c
@@ -23,6 +23,7 @@ static int peer_cmp(const void *first, const void *second)
 {
 	time_t diff;
 	const struct wgpeer *a = *(const void **)first, *b = *(const void **)second;
+
 	if (!a->last_handshake_time.tv_sec && !a->last_handshake_time.tv_usec && (b->last_handshake_time.tv_sec || b->last_handshake_time.tv_usec))
 		return 1;
 	if (!b->last_handshake_time.tv_sec && !b->last_handshake_time.tv_usec && (a->last_handshake_time.tv_sec || a->last_handshake_time.tv_usec))
@@ -65,6 +66,7 @@ static void sort_peers(struct wgdevice *device)
 static char *key(const uint8_t key[static WG_KEY_LEN])
 {
 	static char base64[WG_KEY_LEN_BASE64];
+
 	if (key_is_zero(key))
 		return "(none)";
 	key_to_base64(base64, key);
@@ -74,6 +76,7 @@ static char *key(const uint8_t key[static WG_KEY_LEN])
 static char *masked_key(const uint8_t masked_key[static WG_KEY_LEN])
 {
 	const char *var = getenv("WG_HIDE_KEYS");
+
 	if (var && !strcmp(var, "never"))
 		return key(masked_key);
 	return "(hidden)";
@@ -82,6 +85,7 @@ static char *masked_key(const uint8_t masked_key[static WG_KEY_LEN])
 static char *ip(const struct wgallowedip *ip)
 {
 	static char buf[INET6_ADDRSTRLEN + 1];
+
 	memset(buf, 0, INET6_ADDRSTRLEN + 1);
 	if (ip->family == AF_INET)
 		inet_ntop(AF_INET, &ip->ip4, buf, INET6_ADDRSTRLEN);
@@ -161,6 +165,7 @@ static char *ago(const struct timeval *t)
 static char *every(uint16_t seconds)
 {
 	static char buf[1024] = "every ";
+
 	pretty_time(buf + strlen("every "), sizeof(buf) - strlen("every ") - 1, seconds);
 	return buf;
 }
@@ -170,7 +175,7 @@ static char *bytes(uint64_t b)
 	static char buf[1024];
 
 	if (b < 1024ULL)
-		snprintf(buf, sizeof(buf) - 1, "%u " TERMINAL_FG_CYAN "B" TERMINAL_RESET, (unsigned)b);
+		snprintf(buf, sizeof(buf) - 1, "%u " TERMINAL_FG_CYAN "B" TERMINAL_RESET, (unsigned int)b);
 	else if (b < 1024ULL * 1024ULL)
 		snprintf(buf, sizeof(buf) - 1, "%.2f " TERMINAL_FG_CYAN "KiB" TERMINAL_RESET, (double)b / 1024);
 	else if (b < 1024ULL * 1024ULL * 1024ULL)
@@ -183,7 +188,7 @@ static char *bytes(uint64_t b)
 	return buf;
 }
 
-static const char *COMMAND_NAME = NULL;
+static const char *COMMAND_NAME;
 static void show_usage(void)
 {
 	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | listen-port | fwmark | peers | preshared-keys | endpoints | allowed-ips | latest-handshakes | transfer | persistent-keepalive | dump]\n", PROG_NAME, COMMAND_NAME);
@@ -275,6 +280,7 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 {
 	struct wgpeer *peer;
 	struct wgallowedip *allowedip;
+
 	if (!strcmp(param, "public-key")) {
 		if (with_interface)
 			printf("%s\t", device->name);
@@ -362,6 +368,7 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 int show_main(int argc, char *argv[])
 {
 	int ret = 0;
+
 	COMMAND_NAME = argv[0];
 
 	if (argc > 3) {
@@ -371,6 +378,7 @@ int show_main(int argc, char *argv[])
 
 	if (argc == 1 || !strcmp(argv[1], "all")) {
 		char *interfaces = ipc_list_devices(), *interface;
+
 		if (!interfaces) {
 			perror("Unable to get devices");
 			return 1;
@@ -378,6 +386,7 @@ int show_main(int argc, char *argv[])
 		interface = interfaces;
 		for (size_t len = 0; (len = strlen(interface)); interface += len + 1) {
 			struct wgdevice *device = NULL;
+
 			if (ipc_get_device(&device, interface) < 0) {
 				perror("Unable to get device");
 				continue;
@@ -398,6 +407,7 @@ int show_main(int argc, char *argv[])
 		free(interfaces);
 	} else if (!strcmp(argv[1], "interfaces")) {
 		char *interfaces, *interface;
+
 		if (argc > 2) {
 			show_usage();
 			return 1;
@@ -415,6 +425,7 @@ int show_main(int argc, char *argv[])
 		show_usage();
 	else {
 		struct wgdevice *device = NULL;
+
 		if (ipc_get_device(&device, argv[1]) < 0) {
 			perror("Unable to get device");
 			return 1;
diff --git a/src/showconf.c b/src/showconf.c
index adc3789..2843910 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -72,6 +72,7 @@ int showconf_main(int argc, char *argv[])
 			char host[4096 + 1];
 			char service[512 + 1];
 			socklen_t addr_len = 0;
+
 			if (peer->endpoint.addr.sa_family == AF_INET)
 				addr_len = sizeof(struct sockaddr_in);
 			else if (peer->endpoint.addr.sa_family == AF_INET6)
diff --git a/src/terminal.c b/src/terminal.c
index e5b5edb..703c75f 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -13,6 +13,7 @@ static bool color_mode(FILE *file)
 {
 	static int mode = -1;
 	const char *var;
+
 	if (mode != -1)
 		return mode;
 	var = getenv("WG_COLOR_MODE");
@@ -64,6 +65,7 @@ static void filter_ansi(FILE *file, const char *fmt, va_list args)
 void terminal_printf(const char *fmt, ...)
 {
 	va_list args;
+
 	va_start(args, fmt);
 	filter_ansi(stdout, fmt, args);
 	va_end(args);
@@ -72,6 +74,7 @@ void terminal_printf(const char *fmt, ...)
 void terminal_fprintf(FILE *file, const char *fmt, ...)
 {
 	va_list args;
+
 	va_start(args, fmt);
 	filter_ansi(file, fmt, args);
 	va_end(args);
diff --git a/src/wg.c b/src/wg.c
index c340d66..9834271 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -35,6 +35,7 @@ static void show_usage(FILE *file)
 int main(int argc, char *argv[])
 {
 	char *tmp = NULL;
+
 	PROG_NAME = argv[0];
 
 	if (argc == 2 && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "help"))) {

commit d9d0a2cbed18e44dee398128007ac8b7b9f7a16a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Oct 25 17:13:46 2017 +0200

    global: infuriating kernel iterator style
    
    One types:
    
       for (i = 0 ...
    
    So one should also type:
    
      for_each_obj (obj ...
    
    But the upstream kernel style guidelines are insane, and so we must
    instead do:
    
      for_each_obj(obj ...
    
    Ugly, but one must choose his battles wisely.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index ec16e26..8fe3e1c 100644
--- a/src/config.c
+++ b/src/config.c
@@ -384,7 +384,7 @@ bool config_read_init(struct config_ctx *ctx, bool append)
 struct wgdevice *config_read_finish(struct config_ctx *ctx)
 {
 	struct wgpeer *peer;
-	for_each_wgpeer (ctx->device, peer) {
+	for_each_wgpeer(ctx->device, peer) {
 		if (key_is_zero(peer->public_key)) {
 			fprintf(stderr, "A peer is missing a public key\n");
 			goto err;
diff --git a/src/ipc.c b/src/ipc.c
index 72bbd38..66a5720 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -227,7 +227,7 @@ static int userspace_set_device(struct wgdevice *dev)
 	if (dev->flags & WGDEVICE_REPLACE_PEERS)
 		fprintf(f, "replace_peers=true\n");
 
-	for_each_wgpeer (dev, peer) {
+	for_each_wgpeer(dev, peer) {
 		key_to_hex(hex, peer->public_key);
 		fprintf(f, "public_key=%s\n", hex);
 		if (peer->flags & WGPEER_REMOVE_ME) {
@@ -255,7 +255,7 @@ static int userspace_set_device(struct wgdevice *dev)
 			fprintf(f, "persistent_keepalive_interval=%u\n", peer->persistent_keepalive_interval);
 		if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
 			fprintf(f, "replace_allowed_ips=true\n");
-		for_each_wgallowedip (peer, allowedip) {
+		for_each_wgallowedip(peer, allowedip) {
 			if (allowedip->family == AF_INET) {
 				if (!inet_ntop(AF_INET, &allowedip->ip4, ip, INET6_ADDRSTRLEN))
 					continue;
diff --git a/src/show.c b/src/show.c
index 4203494..d315ee8 100644
--- a/src/show.c
+++ b/src/show.c
@@ -43,14 +43,14 @@ static void sort_peers(struct wgdevice *device)
 	size_t peer_count = 0, i = 0;
 	struct wgpeer *peer, **peers;
 
-	for_each_wgpeer (device, peer)
+	for_each_wgpeer(device, peer)
 		++peer_count;
 	if (!peer_count)
 		return;
 	peers = calloc(peer_count, sizeof(struct wgpeer *));
 	if (!peers)
 		return;
-	for_each_wgpeer (device, peer)
+	for_each_wgpeer(device, peer)
 		peers[i++] = peer;
 	qsort(peers, peer_count, sizeof(struct wgpeer *), peer_cmp);
 	device->first_peer = peers[0];
@@ -208,7 +208,7 @@ static void pretty_print(struct wgdevice *device)
 		sort_peers(device);
 		terminal_printf("\n");
 	}
-	for_each_wgpeer (device, peer) {
+	for_each_wgpeer(device, peer) {
 		terminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD "peer" TERMINAL_RESET ": " TERMINAL_FG_YELLOW "%s" TERMINAL_RESET "\n", key(peer->public_key));
 		if (!key_is_zero(peer->preshared_key))
 			terminal_printf("  " TERMINAL_BOLD "preshared key" TERMINAL_RESET ": %s\n", masked_key(peer->preshared_key));
@@ -216,7 +216,7 @@ static void pretty_print(struct wgdevice *device)
 			terminal_printf("  " TERMINAL_BOLD "endpoint" TERMINAL_RESET ": %s\n", endpoint(&peer->endpoint.addr));
 		terminal_printf("  " TERMINAL_BOLD "allowed ips" TERMINAL_RESET ": ");
 		if (peer->first_allowedip) {
-			for_each_wgallowedip (peer, allowedip)
+			for_each_wgallowedip(peer, allowedip)
 				terminal_printf("%s" TERMINAL_FG_CYAN "/" TERMINAL_RESET "%u%s", ip(allowedip), allowedip->cidr, allowedip->next_allowedip ? ", " : "\n");
 		} else
 			terminal_printf("(none)\n");
@@ -248,7 +248,7 @@ static void dump_print(struct wgdevice *device, bool with_interface)
 		printf("0x%x\n", device->fwmark);
 	else
 		printf("off\n");
-	for_each_wgpeer (device, peer) {
+	for_each_wgpeer(device, peer) {
 		if (with_interface)
 			printf("%s\t", device->name);
 		printf("%s\t", key(peer->public_key));
@@ -258,7 +258,7 @@ static void dump_print(struct wgdevice *device, bool with_interface)
 		else
 			printf("(none)\t");
 		if (peer->first_allowedip) {
-			for_each_wgallowedip (peer, allowedip)
+			for_each_wgallowedip(peer, allowedip)
 				printf("%s/%u%c", ip(allowedip), allowedip->cidr, allowedip->next_allowedip ? ',' : '\t');
 		} else
 			printf("(none)\t");
@@ -297,7 +297,7 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 	} else if (!strcmp(param, "endpoints")) {
 		if (with_interface)
 			printf("%s\t", device->name);
-		for_each_wgpeer (device, peer) {
+		for_each_wgpeer(device, peer) {
 			printf("%s\t", key(peer->public_key));
 			if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
 				printf("%s\n", endpoint(&peer->endpoint.addr));
@@ -305,30 +305,30 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 				printf("(none)\n");
 		}
 	} else if (!strcmp(param, "allowed-ips")) {
-		for_each_wgpeer (device, peer) {
+		for_each_wgpeer(device, peer) {
 			if (with_interface)
 				printf("%s\t", device->name);
 			printf("%s\t", key(peer->public_key));
 			if (peer->first_allowedip) {
-				for_each_wgallowedip (peer, allowedip)
+				for_each_wgallowedip(peer, allowedip)
 					printf("%s/%u%c", ip(allowedip), allowedip->cidr, allowedip->next_allowedip ? ' ' : '\n');
 			} else
 				printf("(none)\n");
 		}
 	} else if (!strcmp(param, "latest-handshakes")) {
-		for_each_wgpeer (device, peer) {
+		for_each_wgpeer(device, peer) {
 			if (with_interface)
 				printf("%s\t", device->name);
 			printf("%s\t%llu\n", key(peer->public_key), (unsigned long long)peer->last_handshake_time.tv_sec);
 		}
 	} else if (!strcmp(param, "transfer")) {
-		for_each_wgpeer (device, peer) {
+		for_each_wgpeer(device, peer) {
 			if (with_interface)
 				printf("%s\t", device->name);
 			printf("%s\t%" PRIu64 "\t%" PRIu64 "\n", key(peer->public_key), (uint64_t)peer->rx_bytes, (uint64_t)peer->tx_bytes);
 		}
 	} else if (!strcmp(param, "persistent-keepalive")) {
-		for_each_wgpeer (device, peer) {
+		for_each_wgpeer(device, peer) {
 			if (with_interface)
 				printf("%s\t", device->name);
 			if (peer->persistent_keepalive_interval)
@@ -337,14 +337,14 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 				printf("%s\toff\n", key(peer->public_key));
 		}
 	} else if (!strcmp(param, "preshared-keys")) {
-		for_each_wgpeer (device, peer) {
+		for_each_wgpeer(device, peer) {
 			if (with_interface)
 				printf("%s\t", device->name);
 			printf("%s\t", key(peer->public_key));
 			printf("%s\n", key(peer->preshared_key));
 		}
 	} else if (!strcmp(param, "peers")) {
-		for_each_wgpeer (device, peer) {
+		for_each_wgpeer(device, peer) {
 			if (with_interface)
 				printf("%s\t", device->name);
 			printf("%s\n", key(peer->public_key));
diff --git a/src/showconf.c b/src/showconf.c
index 51f9a6f..adc3789 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -43,7 +43,7 @@ int showconf_main(int argc, char *argv[])
 		printf("PrivateKey = %s\n", base64);
 	}
 	printf("\n");
-	for_each_wgpeer (device, peer) {
+	for_each_wgpeer(device, peer) {
 		key_to_base64(base64, peer->public_key);
 		printf("[Peer]\nPublicKey = %s\n", base64);
 		if (!key_is_zero(peer->preshared_key)) {
@@ -52,7 +52,7 @@ int showconf_main(int argc, char *argv[])
 		}
 		if (peer->first_allowedip)
 			printf("AllowedIPs = ");
-		for_each_wgallowedip (peer, allowedip) {
+		for_each_wgallowedip(peer, allowedip) {
 			if (allowedip->family == AF_INET) {
 				if (!inet_ntop(AF_INET, &allowedip->ip4, ip, INET6_ADDRSTRLEN))
 					continue;

commit fe703c0cf5531f299682e9b0a96e650541629ecd
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 17 19:20:52 2017 +0200

    wg: account for padding being in zero attribute
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index f9270bc..72bbd38 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -683,6 +683,8 @@ static int parse_allowedip(const struct nlattr *attr, void *data)
 	struct wgallowedip *allowedip = data;
 
 	switch (mnl_attr_get_type(attr)) {
+	case WGALLOWEDIP_A_UNSPEC:
+		break;
 	case WGALLOWEDIP_A_FAMILY:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
 			allowedip->family = mnl_attr_get_u16(attr);
@@ -733,6 +735,8 @@ static int parse_peer(const struct nlattr *attr, void *data)
 	struct wgpeer *peer = data;
 
 	switch (mnl_attr_get_type(attr)) {
+	case WGPEER_A_UNSPEC:
+		break;
 	case WGPEER_A_PUBLIC_KEY:
 		if (mnl_attr_get_payload_len(attr) == sizeof(peer->public_key))
 			memcpy(peer->public_key, mnl_attr_get_payload(attr), sizeof(peer->public_key));
@@ -806,6 +810,8 @@ static int parse_device(const struct nlattr *attr, void *data)
 	struct wgdevice *device = data;
 
 	switch (mnl_attr_get_type(attr)) {
+	case WGDEVICE_A_UNSPEC:
+		break;
 	case WGDEVICE_A_IFINDEX:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
 			device->ifindex = mnl_attr_get_u32(attr);

commit 88b1d35ec049fb5f045f4805444ea212e058299b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 17 18:48:41 2017 +0200

    wg: newline after warning
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index deb46ab..f9270bc 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -97,7 +97,7 @@ static void warn_unrecognized(const char *which)
 	if (once)
 		return;
 	once = true;
-	fprintf(stderr, "Warning: one or more unrecognized %s attributes", which);
+	fprintf(stderr, "Warning: one or more unrecognized %s attributes\n", which);
 }
 
 static FILE *userspace_interface_file(const char *interface)

commit 06e7bdf2a56e5be71e56ded610d9222f3a3b841b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 16 22:18:29 2017 +0200

    wg: style
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index db19362..deb46ab 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -555,7 +555,7 @@ static int kernel_set_device(struct wgdevice *dev)
 	struct nlmsghdr *nlh;
 	struct mnlg_socket *nlg;
 
-	nlg= mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
+	nlg = mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
 	if (!nlg)
 		return -errno;
 

commit 6f9b135966206803df877d9e0c447455ec6e6516
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 16 03:28:24 2017 +0200

    wg: add pass example to wg-quick man page
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index be6137c..b39eff8 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -130,32 +130,13 @@ The peer's allowed IPs entry implies that this interface should be configured as
 which this script does.
 
 Building on the last example, one might attempt the so-called ``kill-switch'', in order
-to prevent the flow of unencrypted packets through the non-WireGuard interfaces:
+to prevent the flow of unencrypted packets through the non-WireGuard interfaces, by adding the following
+two lines `PostUp` and `PreDown` lines to the `[Interface]` section:
 
-    [Interface] 
-.br
-    Address = 10.200.100.8/24
-.br
-    DNS = 10.200.100.1
-.br
-    PrivateKey = oK56DE9Ue9zK76rAc8pBl6opph+1v36lm7cXXsQKrQM= 
-.br
     \fBPostUp = iptables -I OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -j REJECT\fP
 .br
     \fBPreDown = iptables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -j REJECT\fP
 .br
-     
-.br
-    [Peer] 
-.br
-    PublicKey = GtL7fZc/bLnqZldpVofMCD6hDjrK28SsdLxevJ+qtKU= 
-.br
-    PresharedKey = /UwcSPg38hW/D9Y3tcS1FOV0K1wuURMbS0sesJEP5ak= 
-.br
-    AllowedIPs = 0.0.0.0/0 
-.br
-    Endpoint = demo.wireguard.com:51820 
-.br
 
 The `PostUp' and `PreDown' fields have been added to specify an
 .BR iptables (8)
@@ -165,7 +146,13 @@ are either not coming out of the tunnel encrypted or not going through the tunne
 that this continues to allow most DHCP traffic through, since most DHCP clients make use of PF_PACKET
 sockets, which bypass Netfilter.)
 
-Here is a more complicated example, fit for usage on a server:
+Or, perhaps it is desirable to store private keys in encrypted form, such as through use of
+.BR pass (1):
+
+    \fBPostUp = wg set %i private-key <(pass WireGuard/private-keys/%i)\fP
+.br
+
+For use on a server, the following is a more complicated example involving multiple peers:
     
     [Interface]
 .br

commit 65db14706bd895ecb34106a719c499ef2d75f166
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 16 03:17:12 2017 +0200

    wg: don't insist on having a private key
    
    This lets us do flexible things from wg-quick such as:
    
    PostUp = wg set %i private-key <(pass WireGuard/private-keys/%i)
    
    It also was never a very sensible policy to enforce.
    
    Suggested-by: Luis Ressel <aranea@aixah.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 30e004c..ec16e26 100644
--- a/src/config.c
+++ b/src/config.c
@@ -384,11 +384,6 @@ bool config_read_init(struct config_ctx *ctx, bool append)
 struct wgdevice *config_read_finish(struct config_ctx *ctx)
 {
 	struct wgpeer *peer;
-	if (ctx->device->flags & WGDEVICE_REPLACE_PEERS && key_is_zero(ctx->device->private_key)) {
-		fprintf(stderr, "No private key is configured\n");
-		goto err;
-	}
-
 	for_each_wgpeer (ctx->device, peer) {
 		if (key_is_zero(peer->public_key)) {
 			fprintf(stderr, "A peer is missing a public key\n");

commit 085796b2107a4acc2dc3b7caa4eecede88af2c06
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Oct 15 22:52:38 2017 +0200

    wg: retry resolution except when fatal
    
    The reference to this is <https://sourceware.org/glibc/wiki/NameResolver>,
    which mentions:
    
    "From the perspective of the application that calls getaddrinfo() it
    perhaps doesn't matter that much since EAI_FAIL, EAI_NONAME and
    EAI_NODATA are all permanent failure codes and the causes are all
    permanent failures in the sense that there is no point in retrying
    later."
    
    This should cover more early-boot situations.
    
    While we're at it, we clean up the logic a bit so that we don't have a
    retry message on the final non-retrying attempt. We also peer into errno
    when receiving EAI_SYSTEM, to report to the user what actually happened.
    
    Also, fix the quoting back tick front tick mess.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 9f3f990..30e004c 100644
--- a/src/config.c
+++ b/src/config.c
@@ -51,7 +51,7 @@ static inline bool parse_port(uint16_t *port, uint32_t *flags, const char *value
 
 	ret = getaddrinfo(NULL, value, &hints, &resolved);
 	if (ret) {
-		fprintf(stderr, "%s: `%s`\n", gai_strerror(ret), value);
+		fprintf(stderr, "%s: `%s'\n", ret == EAI_SYSTEM ? strerror(errno) : gai_strerror(ret), value);
 		return false;
 	}
 
@@ -63,7 +63,7 @@ static inline bool parse_port(uint16_t *port, uint32_t *flags, const char *value
 		*port = ntohs(((struct sockaddr_in6 *)resolved->ai_addr)->sin6_port);
 		ret = 0;
 	} else
-		fprintf(stderr, "Neither IPv4 nor IPv6 address found: `%s`\n", value);
+		fprintf(stderr, "Neither IPv4 nor IPv6 address found: `%s'\n", value);
 
 	freeaddrinfo(resolved);
 	if (!ret)
@@ -98,7 +98,7 @@ static inline bool parse_fwmark(uint32_t *fwmark, uint32_t *flags, const char *v
 static inline bool parse_key(uint8_t key[static WG_KEY_LEN], const char *value)
 {
 	if (!key_from_base64(key, value)) {
-		fprintf(stderr, "Key is not the correct length or format: `%s`\n", value);
+		fprintf(stderr, "Key is not the correct length or format: `%s'\n", value);
 		return false;
 	}
 	return true;
@@ -115,7 +115,7 @@ static inline bool parse_ip(struct wgallowedip *allowedip, const char *value)
 			allowedip->family = AF_INET;
 	}
 	if (allowedip->family == AF_UNSPEC) {
-		fprintf(stderr, "Unable to parse IP address: `%s`\n", value);
+		fprintf(stderr, "Unable to parse IP address: `%s'\n", value);
 		return false;
 	}
 	return true;
@@ -146,13 +146,13 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 		end = strchr(mutable, ']');
 		if (!end) {
 			free(mutable);
-			fprintf(stderr, "Unable to find matching brace of endpoint: `%s`\n", value);
+			fprintf(stderr, "Unable to find matching brace of endpoint: `%s'\n", value);
 			return false;
 		}
 		*end++ = '\0';
 		if (*end++ != ':' || !*end) {
 			free(mutable);
-			fprintf(stderr, "Unable to find port of endpoint: `%s`\n", value);
+			fprintf(stderr, "Unable to find port of endpoint: `%s'\n", value);
 			return false;
 		}
 	} else {
@@ -160,32 +160,34 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 		end = strrchr(mutable, ':');
 		if (!end || !*(end + 1)) {
 			free(mutable);
-			fprintf(stderr, "Unable to find port of endpoint: `%s`\n", value);
+			fprintf(stderr, "Unable to find port of endpoint: `%s'\n", value);
 			return false;
 		}
 		*end++ = '\0';
 	}
 
-	for (unsigned int timeout = 1000000; timeout < 90000000; timeout = timeout * 3 / 2) {
+	for (unsigned int timeout = 1000000;;) {
 		ret = getaddrinfo(begin, end, &hints, &resolved);
-		if (ret != EAI_AGAIN)
+		if (!ret)
 			break;
-		fprintf(stderr, "%s: `%s`. Trying again in %.2f seconds...\n", gai_strerror(ret), value, timeout / 1000000.0);
+		timeout = timeout * 3 / 2;
+		/* The set of return codes that are "permanent failures". All other possibilities are potentially transient. */
+		if (ret == EAI_NONAME || ret == EAI_FAIL || ret == EAI_NODATA || timeout >= 90000000) {
+			free(mutable);
+			fprintf(stderr, "%s: `%s'\n", ret == EAI_SYSTEM ? strerror(errno) : gai_strerror(ret), value);
+			return false;
+		}
+		fprintf(stderr, "%s: `%s'. Trying again in %.2f seconds...\n", ret == EAI_SYSTEM ? strerror(errno) : gai_strerror(ret), value, timeout / 1000000.0);
 		usleep(timeout);
 	}
 
-	if (ret != 0) {
-		free(mutable);
-		fprintf(stderr, "%s: `%s`\n", gai_strerror(ret), value);
-		return false;
-	}
 	if ((resolved->ai_family == AF_INET && resolved->ai_addrlen == sizeof(struct sockaddr_in)) ||
 	    (resolved->ai_family == AF_INET6 && resolved->ai_addrlen == sizeof(struct sockaddr_in6)))
 		memcpy(endpoint, resolved->ai_addr, resolved->ai_addrlen);
 	else {
 		freeaddrinfo(resolved);
 		free(mutable);
-		fprintf(stderr, "Neither IPv4 nor IPv6 address found: `%s`\n", value);
+		fprintf(stderr, "Neither IPv4 nor IPv6 address found: `%s'\n", value);
 		return false;
 	}
 	freeaddrinfo(resolved);
@@ -206,7 +208,7 @@ static inline bool parse_persistent_keepalive(uint16_t *interval, uint32_t *flag
 
 	ret = strtoul(value, &end, 10);
 	if (!*value || *value == '-' || *end || ret > 65535) {
-		fprintf(stderr, "The persistent keepalive interval must be 0/off or 1-65535. Found: `%s`\n", value);
+		fprintf(stderr, "The persistent keepalive interval must be 0/off or 1-65535. Found: `%s'\n", value);
 		return false;
 	}
 
@@ -431,7 +433,7 @@ static bool read_keyfile(char dst[WG_KEY_LEN_BASE64], const char *path)
 
 	while ((c = getc(f)) != EOF) {
 		if (!isspace(c)) {
-			fprintf(stderr, "Found trailing character in key file: `%c`\n", c);
+			fprintf(stderr, "Found trailing character in key file: `%c'\n", c);
 			goto out;
 		}
 	}
diff --git a/src/show.c b/src/show.c
index 476d002..4203494 100644
--- a/src/show.c
+++ b/src/show.c
@@ -352,7 +352,7 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 	} else if (!strcmp(param, "dump"))
 		dump_print(device, with_interface);
 	else {
-		fprintf(stderr, "Invalid parameter: `%s`\n", param);
+		fprintf(stderr, "Invalid parameter: `%s'\n", param);
 		show_usage();
 		return false;
 	}
diff --git a/src/wg.c b/src/wg.c
index e1d9a60..c340d66 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -14,7 +14,7 @@ static const struct {
 	const char *description;
 } subcommands[] = {
 	{ "show", show_main, "Shows the current configuration and device information" },
-	{ "showconf", showconf_main, "Shows the current configuration of a given WireGuard interface, for use with `setconf`" },
+	{ "showconf", showconf_main, "Shows the current configuration of a given WireGuard interface, for use with `setconf'" },
 	{ "set", set_main, "Change the current configuration, add peers, remove peers, or change peers" },
 	{ "setconf", setconf_main, "Applies a configuration file to a WireGuard interface" },
 	{ "addconf", setconf_main, "Appends a configuration file to a WireGuard interface" },
@@ -61,7 +61,7 @@ findsubcommand:
 		goto findsubcommand;
 	}
 
-	fprintf(stderr, "Invalid subcommand: `%s`\n", argv[1]);
+	fprintf(stderr, "Invalid subcommand: `%s'\n", argv[1]);
 	show_usage(stderr);
 	return 1;
 }

commit 7fe7f81088d9ff3fb392c12ca970e79cc78e1061
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Oct 15 21:29:01 2017 +0200

    wg: encoding: be more paranoid
    
    Needless, but overkill can be fun.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/encoding.c b/src/encoding.c
index 3d5e94b..c407b57 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -102,10 +102,10 @@ bool key_from_hex(uint8_t key[static WG_KEY_LEN], const char *hex)
 
 bool key_is_zero(const uint8_t key[static WG_KEY_LEN])
 {
-	uint8_t acc = 0;
+	volatile uint8_t acc = 0;
 	for (unsigned int i = 0; i < WG_KEY_LEN; ++i) {
 		acc |= key[i];
 		__asm__ ("" : "=r" (acc) : "0" (acc));
 	}
-	return acc == 0;
+	return 1 & ((acc - 1) >> 8);
 }

commit eb68ad072290491f473ac969a3125188c03ce791
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Oct 14 05:17:40 2017 +0200

    Makefile: even prettier output
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 01f873c..bd727d4 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -48,10 +48,10 @@ endif
 
 ifneq ($(V),1)
 BUILT_IN_LINK.o := $(LINK.o)
-LINK.o = @echo "  LD  $@";
+LINK.o = @echo "  LD      $$(pwd)/$@";
 LINK.o += $(BUILT_IN_LINK.o)
 BUILT_IN_COMPILE.c := $(COMPILE.c)
-COMPILE.c = @echo "  CC  $@";
+COMPILE.c = @echo "  CC      $$(pwd)/$@";
 COMPILE.c += $(BUILT_IN_COMPILE.c)
 endif
 
@@ -59,7 +59,7 @@ wg: $(patsubst %.c,%.o,$(wildcard *.c))
 
 ifneq ($(V),1)
 clean:
-	@echo "  RM  " 'wg *.o *.d'
+	@echo "  CLEAN   $$(pwd)/{wg,*.o,*.d}"
 	@$(RM) wg *.o *.d
 else
 clean:

commit d7b3f0fcaf5f7667d97b428efb0a763b555bef0f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Oct 11 01:55:45 2017 +0200

    wg: man: include kill-switch documentation using fwmark
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index f27a270..be6137c 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -129,6 +129,42 @@ indicates that a DNS server for the interface should be configured via
 The peer's allowed IPs entry implies that this interface should be configured as the default gateway,
 which this script does.
 
+Building on the last example, one might attempt the so-called ``kill-switch'', in order
+to prevent the flow of unencrypted packets through the non-WireGuard interfaces:
+
+    [Interface] 
+.br
+    Address = 10.200.100.8/24
+.br
+    DNS = 10.200.100.1
+.br
+    PrivateKey = oK56DE9Ue9zK76rAc8pBl6opph+1v36lm7cXXsQKrQM= 
+.br
+    \fBPostUp = iptables -I OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -j REJECT\fP
+.br
+    \fBPreDown = iptables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -j REJECT\fP
+.br
+     
+.br
+    [Peer] 
+.br
+    PublicKey = GtL7fZc/bLnqZldpVofMCD6hDjrK28SsdLxevJ+qtKU= 
+.br
+    PresharedKey = /UwcSPg38hW/D9Y3tcS1FOV0K1wuURMbS0sesJEP5ak= 
+.br
+    AllowedIPs = 0.0.0.0/0 
+.br
+    Endpoint = demo.wireguard.com:51820 
+.br
+
+The `PostUp' and `PreDown' fields have been added to specify an
+.BR iptables (8)
+command which, when used with interfaces that have a peer that specifies 0.0.0.0/0 as part of the
+`AllowedIPs', works together with wg-quick's fwmark usage in order to drop all packets that
+are either not coming out of the tunnel encrypted or not going through the tunnel itself. (Note
+that this continues to allow most DHCP traffic through, since most DHCP clients make use of PF_PACKET
+sockets, which bypass Netfilter.)
+
 Here is a more complicated example, fit for usage on a server:
     
     [Interface]

commit 4e0e99c74d3cd22139d620b9fe21dd3453936e1a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 10 17:17:43 2017 +0200

    wg: store tail pointer to make coalescing peers fast
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/containers.h b/src/containers.h
index 4c80a77..2d0195d 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -46,7 +46,7 @@ struct wgpeer {
 	uint64_t rx_bytes, tx_bytes;
 	uint16_t persistent_keepalive_interval;
 
-	struct wgallowedip *first_allowedip;
+	struct wgallowedip *first_allowedip, *last_allowedip;
 	struct wgpeer *next_peer;
 };
 
@@ -73,7 +73,7 @@ struct wgdevice {
 	uint32_t fwmark;
 	uint16_t listen_port;
 
-	struct wgpeer *first_peer;
+	struct wgpeer *first_peer, *last_peer;
 };
 
 #define for_each_wgpeer(__dev, __peer) for ((__peer) = (__dev)->first_peer; (__peer); (__peer) = (__peer)->next_peer)
diff --git a/src/ipc.c b/src/ipc.c
index 521a904..db19362 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -678,30 +678,24 @@ out:
 	return ret;
 }
 
-struct get_device_ctx {
-	struct wgdevice *device;
-	struct wgpeer *peer;
-	struct wgallowedip *allowedip;
-};
-
 static int parse_allowedip(const struct nlattr *attr, void *data)
 {
-	struct get_device_ctx *ctx = data;
+	struct wgallowedip *allowedip = data;
 
 	switch (mnl_attr_get_type(attr)) {
 	case WGALLOWEDIP_A_FAMILY:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
-			ctx->allowedip->family = mnl_attr_get_u16(attr);
+			allowedip->family = mnl_attr_get_u16(attr);
 		break;
 	case WGALLOWEDIP_A_IPADDR:
-		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->allowedip->ip4))
-			memcpy(&ctx->allowedip->ip4, mnl_attr_get_payload(attr), sizeof(ctx->allowedip->ip4));
-		else if (mnl_attr_get_payload_len(attr) == sizeof(ctx->allowedip->ip6))
-			memcpy(&ctx->allowedip->ip6, mnl_attr_get_payload(attr), sizeof(ctx->allowedip->ip6));
+		if (mnl_attr_get_payload_len(attr) == sizeof(allowedip->ip4))
+			memcpy(&allowedip->ip4, mnl_attr_get_payload(attr), sizeof(allowedip->ip4));
+		else if (mnl_attr_get_payload_len(attr) == sizeof(allowedip->ip6))
+			memcpy(&allowedip->ip6, mnl_attr_get_payload(attr), sizeof(allowedip->ip6));
 		break;
 	case WGALLOWEDIP_A_CIDR_MASK:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U8))
-			ctx->allowedip->cidr = mnl_attr_get_u8(attr);
+			allowedip->cidr = mnl_attr_get_u8(attr);
 		break;
 	default:
 		warn_unrecognized("netlink");
@@ -712,68 +706,70 @@ static int parse_allowedip(const struct nlattr *attr, void *data)
 
 static int parse_allowedips(const struct nlattr *attr, void *data)
 {
-	struct get_device_ctx *ctx = data;
+	struct wgpeer *peer = data;
 	struct wgallowedip *new_allowedip = calloc(1, sizeof(struct wgallowedip));
 	int ret;
+
 	if (!new_allowedip) {
 		perror("calloc");
 		return MNL_CB_ERROR;
 	}
-	if (ctx->allowedip)
-		ctx->allowedip->next_allowedip = new_allowedip;
-	else
-		ctx->peer->first_allowedip = new_allowedip;
-	ctx->allowedip = new_allowedip;
-	ret = mnl_attr_parse_nested(attr, parse_allowedip, ctx);
+	if (!peer->first_allowedip)
+		peer->first_allowedip = peer->last_allowedip = new_allowedip;
+	else {
+		peer->last_allowedip->next_allowedip = new_allowedip;
+		peer->last_allowedip = new_allowedip;
+	}
+	ret = mnl_attr_parse_nested(attr, parse_allowedip, new_allowedip);
 	if (!ret)
 		return ret;
-	if (!((ctx->allowedip->family == AF_INET && ctx->allowedip->cidr <= 32) || (ctx->allowedip->family == AF_INET6 && ctx->allowedip->cidr <= 128)))
+	if (!((new_allowedip->family == AF_INET && new_allowedip->cidr <= 32) || (new_allowedip->family == AF_INET6 && new_allowedip->cidr <= 128)))
 		return MNL_CB_ERROR;
 	return MNL_CB_OK;
 }
 
 static int parse_peer(const struct nlattr *attr, void *data)
 {
-	struct get_device_ctx *ctx = data;
+	struct wgpeer *peer = data;
 
 	switch (mnl_attr_get_type(attr)) {
 	case WGPEER_A_PUBLIC_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->public_key))
-			memcpy(ctx->peer->public_key, mnl_attr_get_payload(attr), sizeof(ctx->peer->public_key));
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->public_key))
+			memcpy(peer->public_key, mnl_attr_get_payload(attr), sizeof(peer->public_key));
 		break;
 	case WGPEER_A_PRESHARED_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->preshared_key))
-			memcpy(ctx->peer->preshared_key, mnl_attr_get_payload(attr), sizeof(ctx->peer->preshared_key));
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->preshared_key))
+			memcpy(peer->preshared_key, mnl_attr_get_payload(attr), sizeof(peer->preshared_key));
 		break;
 	case WGPEER_A_ENDPOINT: {
 		struct sockaddr *addr;
 		if (mnl_attr_get_payload_len(attr) < sizeof(*addr))
 			break;
 		addr = mnl_attr_get_payload(attr);
-		if (addr->sa_family == AF_INET && mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->endpoint.addr4))
-			memcpy(&ctx->peer->endpoint.addr4, addr, sizeof(ctx->peer->endpoint.addr4));
-		else if (addr->sa_family == AF_INET6 && mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->endpoint.addr6))
-			memcpy(&ctx->peer->endpoint.addr6, addr, sizeof(ctx->peer->endpoint.addr6));
+		if (addr->sa_family == AF_INET && mnl_attr_get_payload_len(attr) == sizeof(peer->endpoint.addr4))
+			memcpy(&peer->endpoint.addr4, addr, sizeof(peer->endpoint.addr4));
+		else if (addr->sa_family == AF_INET6 && mnl_attr_get_payload_len(attr) == sizeof(peer->endpoint.addr6))
+			memcpy(&peer->endpoint.addr6, addr, sizeof(peer->endpoint.addr6));
 		break;
 	}
 	case WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
-			ctx->peer->persistent_keepalive_interval = mnl_attr_get_u16(attr);
+			peer->persistent_keepalive_interval = mnl_attr_get_u16(attr);
 		break;
 	case WGPEER_A_LAST_HANDSHAKE_TIME:
-		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->last_handshake_time))
-			memcpy(&ctx->peer->last_handshake_time, mnl_attr_get_payload(attr), sizeof(ctx->peer->last_handshake_time));
+		if (mnl_attr_get_payload_len(attr) == sizeof(peer->last_handshake_time))
+			memcpy(&peer->last_handshake_time, mnl_attr_get_payload(attr), sizeof(peer->last_handshake_time));
 		break;
 	case WGPEER_A_RX_BYTES:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
-			ctx->peer->rx_bytes = mnl_attr_get_u64(attr);
+			peer->rx_bytes = mnl_attr_get_u64(attr);
 		break;
 	case WGPEER_A_TX_BYTES:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
-			ctx->peer->tx_bytes = mnl_attr_get_u64(attr);
+			peer->tx_bytes = mnl_attr_get_u64(attr);
 		break;
 	case WGPEER_A_ALLOWEDIPS:
-		return mnl_attr_parse_nested(attr, parse_allowedips, ctx);
+		return mnl_attr_parse_nested(attr, parse_allowedips, peer);
 	default:
 		warn_unrecognized("netlink");
 	}
@@ -783,58 +779,59 @@ static int parse_peer(const struct nlattr *attr, void *data)
 
 static int parse_peers(const struct nlattr *attr, void *data)
 {
-	struct get_device_ctx *ctx = data;
+	struct wgdevice *device = data;
 	struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
 	int ret;
+
 	if (!new_peer) {
 		perror("calloc");
 		return MNL_CB_ERROR;
 	}
-	if (ctx->peer)
-		ctx->peer->next_peer = new_peer;
-	else
-		ctx->device->first_peer = new_peer;
-	ctx->peer = new_peer;
-	ctx->allowedip = NULL;
-	ret = mnl_attr_parse_nested(attr, parse_peer, ctx);
+	if (!device->first_peer)
+		device->first_peer = device->last_peer = new_peer;
+	else {
+		device->last_peer->next_peer = new_peer;
+		device->last_peer = new_peer;
+	}
+	ret = mnl_attr_parse_nested(attr, parse_peer, new_peer);
 	if (!ret)
 		return ret;
-	if (key_is_zero(ctx->peer->public_key))
+	if (key_is_zero(new_peer->public_key))
 		return MNL_CB_ERROR;
 	return MNL_CB_OK;
 }
 
 static int parse_device(const struct nlattr *attr, void *data)
 {
-	struct get_device_ctx *ctx = data;
+	struct wgdevice *device = data;
 
 	switch (mnl_attr_get_type(attr)) {
 	case WGDEVICE_A_IFINDEX:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
-			ctx->device->ifindex = mnl_attr_get_u32(attr);
+			device->ifindex = mnl_attr_get_u32(attr);
 		break;
 	case WGDEVICE_A_IFNAME:
 		if (!mnl_attr_validate(attr, MNL_TYPE_STRING))
-			strncpy(ctx->device->name, mnl_attr_get_str(attr), sizeof(ctx->device->name) - 1);
+			strncpy(device->name, mnl_attr_get_str(attr), sizeof(device->name) - 1);
 		break;
 	case WGDEVICE_A_PRIVATE_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->device->private_key))
-			memcpy(ctx->device->private_key, mnl_attr_get_payload(attr), sizeof(ctx->device->private_key));
+		if (mnl_attr_get_payload_len(attr) == sizeof(device->private_key))
+			memcpy(device->private_key, mnl_attr_get_payload(attr), sizeof(device->private_key));
 		break;
 	case WGDEVICE_A_PUBLIC_KEY:
-		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->device->public_key))
-			memcpy(ctx->device->public_key, mnl_attr_get_payload(attr), sizeof(ctx->device->public_key));
+		if (mnl_attr_get_payload_len(attr) == sizeof(device->public_key))
+			memcpy(device->public_key, mnl_attr_get_payload(attr), sizeof(device->public_key));
 		break;
 	case WGDEVICE_A_LISTEN_PORT:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
-			ctx->device->listen_port = mnl_attr_get_u16(attr);
+			device->listen_port = mnl_attr_get_u16(attr);
 		break;
 	case WGDEVICE_A_FWMARK:
 		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
-			ctx->device->fwmark = mnl_attr_get_u32(attr);
+			device->fwmark = mnl_attr_get_u32(attr);
 		break;
 	case WGDEVICE_A_PEERS:
-		return mnl_attr_parse_nested(attr, parse_peers, ctx);
+		return mnl_attr_parse_nested(attr, parse_peers, device);
 	default:
 		warn_unrecognized("netlink");
 	}
@@ -849,42 +846,41 @@ static int read_device_cb(const struct nlmsghdr *nlh, void *data)
 
 static void coalesce_peers(struct wgdevice *device)
 {
-	struct wgallowedip *allowedip;
 	struct wgpeer *old_next_peer, *peer = device->first_peer;
+
 	while (peer && peer->next_peer) {
 		if (memcmp(peer->public_key, peer->next_peer->public_key, WG_KEY_LEN)) {
 			peer = peer->next_peer;
 			continue;
 		}
-		/* TODO: It would be more efficient to store the tail, rather than having to seek to the end each time. */
-		for (allowedip = peer->first_allowedip; allowedip && allowedip->next_allowedip; allowedip = allowedip->next_allowedip);
-
-		if (!allowedip)
+		if (!peer->first_allowedip) {
 			peer->first_allowedip = peer->next_peer->first_allowedip;
-		else
-			allowedip->next_allowedip = peer->next_peer->first_allowedip;
+			peer->last_allowedip = peer->next_peer->last_allowedip;
+		} else {
+			peer->last_allowedip->next_allowedip = peer->next_peer->first_allowedip;
+			peer->last_allowedip = peer->next_peer->last_allowedip;
+		}
 		old_next_peer = peer->next_peer;
 		peer->next_peer = old_next_peer->next_peer;
 		free(old_next_peer);
 	}
 }
 
-static int kernel_get_device(struct wgdevice **dev, const char *interface)
+static int kernel_get_device(struct wgdevice **device, const char *interface)
 {
 	int ret = 0;
 	struct nlmsghdr *nlh;
 	struct mnlg_socket *nlg;
-	struct get_device_ctx ctx = { 0 };
 
 try_again:
-	*dev = ctx.device = calloc(1, sizeof(struct wgdevice));
-	if (!*dev)
+	*device = calloc(1, sizeof(struct wgdevice));
+	if (!*device)
 		return -errno;
 
 	nlg = mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
 	if (!nlg) {
-		free_wgdevice(*dev);
-		*dev = NULL;
+		free_wgdevice(*device);
+		*device = NULL;
 		return -errno;
 	}
 
@@ -895,20 +891,20 @@ try_again:
 		goto out;
 	}
 	errno = 0;
-	if (mnlg_socket_recv_run(nlg, read_device_cb, &ctx) < 0) {
+	if (mnlg_socket_recv_run(nlg, read_device_cb, *device) < 0) {
 		ret = errno ? -errno : -EINVAL;
 		goto out;
 	}
-	coalesce_peers(*dev);
+	coalesce_peers(*device);
 
 out:
 	if (nlg)
 		mnlg_socket_close(nlg);
 	if (ret) {
-		free_wgdevice(*dev);
+		free_wgdevice(*device);
 		if (ret == -EINTR)
 			goto try_again;
-		*dev = NULL;
+		*device = NULL;
 	}
 	errno = -ret;
 	return ret;

commit e13b1e719b741d62380bc9f26d46ae0d7c43c6ef
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 9 13:27:00 2017 +0200

    wg: warn once on unrecognized items
    
    DaveM suggests we do in fact do this. Others on the same thread weren't
    happy about the length of the proposed message, so we also give a bit of
    a less dramatic warning.
    
    This reverts commit a2cc976a3b572cf308cc2d97c080eacac60416fe.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/containers.h b/src/containers.h
index 2261b07..4c80a77 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -63,6 +63,7 @@ enum {
 
 struct wgdevice {
 	char name[IFNAMSIZ];
+	uint32_t ifindex;
 
 	uint32_t flags;
 
diff --git a/src/ipc.c b/src/ipc.c
index a460d28..521a904 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -91,6 +91,15 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
+static void warn_unrecognized(const char *which)
+{
+	static bool once = false;
+	if (once)
+		return;
+	once = true;
+	fprintf(stderr, "Warning: one or more unrecognized %s attributes", which);
+}
+
 static FILE *userspace_interface_file(const char *interface)
 {
 	struct stat sbuf;
@@ -421,6 +430,8 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			peer->tx_bytes = NUM(0xffffffffffffffffULL);
 		else if (!strcmp(key, "errno"))
 			ret = -NUM(0x7fffffffU);
+		else
+			warn_unrecognized("daemon");
 	}
 	ret = -EPROTO;
 err:
@@ -692,6 +703,8 @@ static int parse_allowedip(const struct nlattr *attr, void *data)
 		if (!mnl_attr_validate(attr, MNL_TYPE_U8))
 			ctx->allowedip->cidr = mnl_attr_get_u8(attr);
 		break;
+	default:
+		warn_unrecognized("netlink");
 	}
 
 	return MNL_CB_OK;
@@ -761,6 +774,8 @@ static int parse_peer(const struct nlattr *attr, void *data)
 		break;
 	case WGPEER_A_ALLOWEDIPS:
 		return mnl_attr_parse_nested(attr, parse_allowedips, ctx);
+	default:
+		warn_unrecognized("netlink");
 	}
 
 	return MNL_CB_OK;
@@ -794,6 +809,10 @@ static int parse_device(const struct nlattr *attr, void *data)
 	struct get_device_ctx *ctx = data;
 
 	switch (mnl_attr_get_type(attr)) {
+	case WGDEVICE_A_IFINDEX:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
+			ctx->device->ifindex = mnl_attr_get_u32(attr);
+		break;
 	case WGDEVICE_A_IFNAME:
 		if (!mnl_attr_validate(attr, MNL_TYPE_STRING))
 			strncpy(ctx->device->name, mnl_attr_get_str(attr), sizeof(ctx->device->name) - 1);
@@ -816,6 +835,8 @@ static int parse_device(const struct nlattr *attr, void *data)
 		break;
 	case WGDEVICE_A_PEERS:
 		return mnl_attr_parse_nested(attr, parse_peers, ctx);
+	default:
+		warn_unrecognized("netlink");
 	}
 
 	return MNL_CB_OK;

commit 8774fccff32c8f5ed5527fa4e349ee534d34174c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Oct 8 16:24:37 2017 +0200

    wg: try again if dump is interrupted
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 5625526..a460d28 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -855,11 +855,12 @@ static int kernel_get_device(struct wgdevice **dev, const char *interface)
 	struct mnlg_socket *nlg;
 	struct get_device_ctx ctx = { 0 };
 
+try_again:
 	*dev = ctx.device = calloc(1, sizeof(struct wgdevice));
 	if (!*dev)
 		return -errno;
 
-	nlg= mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
+	nlg = mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
 	if (!nlg) {
 		free_wgdevice(*dev);
 		*dev = NULL;
@@ -884,6 +885,8 @@ out:
 		mnlg_socket_close(nlg);
 	if (ret) {
 		free_wgdevice(*dev);
+		if (ret == -EINTR)
+			goto try_again;
 		*dev = NULL;
 	}
 	errno = -ret;

commit 38ac0ff08e15407d49e2664926d088fbbe4ecf29
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Oct 5 20:52:19 2017 +0200

    Makefile: clang now builds the kernel, so use scan-build
    
    Also add little stub for coccinelle and clean up semicolon issue it
    found.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 1407de4..01f873c 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -80,9 +80,6 @@ install: wg
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_SYSTEMDUNITS)" = "yes" ] || exit 0; \
 	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -m 0644 -v wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
 
-check: clean
-	CFLAGS=-g scan-build --view --keep-going $(MAKE) wg
-
 help:
 	@cat INSTALL
 
diff --git a/src/config.c b/src/config.c
index 0d8daeb..9f3f990 100644
--- a/src/config.c
+++ b/src/config.c
@@ -223,7 +223,7 @@ static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **la
 	if (!mutable) {
 		perror("strdup");
 		return false;
-	};
+	}
 	peer->flags |= WGPEER_REPLACE_ALLOWEDIPS;
 	if (!strlen(value)) {
 		free(mutable);

commit e95fcccb4da85f386b57ea08756d8bf47a0cf13b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 3 17:16:37 2017 +0200

    Makefile: add non-verbose mode to tools
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 2dd7f6a..1407de4 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -36,6 +36,9 @@ CFLAGS += -std=gnu11 -D_GNU_SOURCE
 CFLAGS += -Wall -Wextra
 CFLAGS += -MMD -MP
 CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
+ifeq ($(DEBUG_TOOLS),y)
+CFLAGS += -g
+endif
 ifeq ($(shell uname -s),Linux)
 LIBMNL_CFLAGS := $(shell $(PKG_CONFIG) --cflags libmnl 2>/dev/null)
 LIBMNL_LDLIBS := $(shell $(PKG_CONFIG) --libs libmnl 2>/dev/null || echo -lmnl)
@@ -43,10 +46,25 @@ CFLAGS += $(LIBMNL_CFLAGS)
 LDLIBS += $(LIBMNL_LDLIBS)
 endif
 
+ifneq ($(V),1)
+BUILT_IN_LINK.o := $(LINK.o)
+LINK.o = @echo "  LD  $@";
+LINK.o += $(BUILT_IN_LINK.o)
+BUILT_IN_COMPILE.c := $(COMPILE.c)
+COMPILE.c = @echo "  CC  $@";
+COMPILE.c += $(BUILT_IN_COMPILE.c)
+endif
+
 wg: $(patsubst %.c,%.o,$(wildcard *.c))
 
+ifneq ($(V),1)
 clean:
-	rm -f wg *.o *.d
+	@echo "  RM  " 'wg *.o *.d'
+	@$(RM) wg *.o *.d
+else
+clean:
+	$(RM) wg *.o *.d
+endif
 
 install: wg
 	@install -v -d "$(DESTDIR)$(BINDIR)" && install -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"

commit a99b64e5a458c993814e71aba6c1e2118dc95cc3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 3 06:18:45 2017 +0200

    global: satisfy bitshift pedantry
    
    Suggested-by: Sultan Alsawaf <sultanxda@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/containers.h b/src/containers.h
index 7ce09a9..2261b07 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -24,10 +24,10 @@ struct wgallowedip {
 };
 
 enum {
-	WGPEER_REMOVE_ME = (1 << 0),
-	WGPEER_REPLACE_ALLOWEDIPS = (1 << 1),
-	WGPEER_HAS_PRESHARED_KEY = (1 << 2),
-	WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL = (1 << 3)
+	WGPEER_REMOVE_ME = 1U << 0,
+	WGPEER_REPLACE_ALLOWEDIPS = 1U << 1,
+	WGPEER_HAS_PRESHARED_KEY = 1U << 2,
+	WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL = 1U << 3
 };
 
 struct wgpeer {
@@ -51,10 +51,10 @@ struct wgpeer {
 };
 
 enum {
-	WGDEVICE_REPLACE_PEERS = (1 << 0),
-	WGDEVICE_HAS_PRIVATE_KEY = (1 << 1),
-	WGDEVICE_HAS_LISTEN_PORT = (1 << 2),
-	WGDEVICE_HAS_FWMARK = (1 << 3)
+	WGDEVICE_REPLACE_PEERS = 1U << 0,
+	WGDEVICE_HAS_PRIVATE_KEY = 1U << 1,
+	WGDEVICE_HAS_LISTEN_PORT = 1U << 2,
+	WGDEVICE_HAS_FWMARK = 1U << 3
 };
 
 enum {

commit 0b795ca5d54ccf12bc0e07807ac31395e04cf0c5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 2 16:32:20 2017 +0200

    contrib: remove worthless build artifact
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/sticky-sockets/a.out b/contrib/sticky-sockets/a.out
deleted file mode 100755
index 844d08e..0000000
Binary files a/contrib/sticky-sockets/a.out and /dev/null differ

commit 91416b0cafb94611b16bfc9726610e79894fcb3c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 2 13:05:35 2017 +0200

    wg: compile on non-Linux
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 0e61a3e..5625526 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -38,6 +38,12 @@
 
 #define SOCK_PATH RUNSTATEDIR "/wireguard/"
 #define SOCK_SUFFIX ".sock"
+#ifdef __linux__
+#define SOCKET_BUFFER_SIZE MNL_SOCKET_BUFFER_SIZE
+#else
+#define SOCKET_BUFFER_SIZE 8192
+#endif
+
 
 struct inflatable_buffer {
 	char *buffer;
@@ -478,7 +484,7 @@ static int kernel_get_wireguard_interfaces(struct inflatable_buffer *buffer)
 	struct ifinfomsg *ifm;
 
 	ret = -ENOMEM;
-	rtnl_buffer = calloc(MNL_SOCKET_BUFFER_SIZE, 1);
+	rtnl_buffer = calloc(SOCKET_BUFFER_SIZE, 1);
 	if (!rtnl_buffer)
 		goto cleanup;
 
@@ -509,7 +515,7 @@ static int kernel_get_wireguard_interfaces(struct inflatable_buffer *buffer)
 	}
 
 another:
-	if ((len = mnl_socket_recvfrom(nl, rtnl_buffer, MNL_SOCKET_BUFFER_SIZE)) < 0) {
+	if ((len = mnl_socket_recvfrom(nl, rtnl_buffer, SOCKET_BUFFER_SIZE)) < 0) {
 		ret = -errno;
 		goto cleanup;
 	}
@@ -565,10 +571,10 @@ again:
 	peers_nest = mnl_attr_nest_start(nlh, WGDEVICE_A_PEERS);
 	for (i = 0, peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
 		uint32_t flags = 0;
-		peer_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, i++);
+		peer_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, i++);
 		if (!peer_nest)
 			goto toobig_peers;
-		if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PUBLIC_KEY, sizeof(peer->public_key), peer->public_key))
+		if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PUBLIC_KEY, sizeof(peer->public_key), peer->public_key))
 			goto toobig_peers;
 		if (peer->flags & WGPEER_REMOVE_ME)
 			flags |= WGPEER_F_REMOVE_ME;
@@ -576,45 +582,45 @@ again:
 			if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
 				flags |= WGPEER_F_REPLACE_ALLOWEDIPS;
 			if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
-				if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PRESHARED_KEY, sizeof(peer->preshared_key), peer->preshared_key))
+				if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PRESHARED_KEY, sizeof(peer->preshared_key), peer->preshared_key))
 					goto toobig_peers;
 			}
 			if (peer->endpoint.addr.sa_family == AF_INET) {
-				if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr4), &peer->endpoint.addr4))
+				if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr4), &peer->endpoint.addr4))
 					goto toobig_peers;
 			} else if (peer->endpoint.addr.sa_family == AF_INET6) {
-				if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr6), &peer->endpoint.addr6))
+				if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr6), &peer->endpoint.addr6))
 					goto toobig_peers;
 			}
 			if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL) {
-				if (!mnl_attr_put_u16_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL, peer->persistent_keepalive_interval))
+				if (!mnl_attr_put_u16_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL, peer->persistent_keepalive_interval))
 					goto toobig_peers;
 			}
 		}
 		if (flags) {
-			if (!mnl_attr_put_u32_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_FLAGS, flags))
+			if (!mnl_attr_put_u32_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_FLAGS, flags))
 				goto toobig_peers;
 		}
 		if (peer->first_allowedip) {
 			if (!allowedip)
 				allowedip = peer->first_allowedip;
-			allowedips_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ALLOWEDIPS);
+			allowedips_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, WGPEER_A_ALLOWEDIPS);
 			if (!allowedips_nest)
 				goto toobig_allowedips;
 			for (j = 0; allowedip; allowedip = allowedip->next_allowedip) {
-				allowedip_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, j++);
+				allowedip_nest = mnl_attr_nest_start_check(nlh, SOCKET_BUFFER_SIZE, j++);
 				if (!allowedip_nest)
 					goto toobig_allowedips;
-				if (!mnl_attr_put_u16_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_FAMILY, allowedip->family))
+				if (!mnl_attr_put_u16_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_FAMILY, allowedip->family))
 					goto toobig_allowedips;
 				if (allowedip->family == AF_INET) {
-					if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip4), &allowedip->ip4))
+					if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip4), &allowedip->ip4))
 						goto toobig_allowedips;
 				} else if (allowedip->family == AF_INET6) {
-					if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip6), &allowedip->ip6))
+					if (!mnl_attr_put_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip6), &allowedip->ip6))
 						goto toobig_allowedips;
 				}
-				if (!mnl_attr_put_u8_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_CIDR_MASK, allowedip->cidr))
+				if (!mnl_attr_put_u8_check(nlh, SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_CIDR_MASK, allowedip->cidr))
 					goto toobig_allowedips;
 				mnl_attr_nest_end(nlh, allowedip_nest);
 				allowedip_nest = NULL;
@@ -888,7 +894,7 @@ out:
 /* first\0second\0third\0forth\0last\0\0 */
 char *ipc_list_devices(void)
 {
-	struct inflatable_buffer buffer = { .len = MNL_SOCKET_BUFFER_SIZE };
+	struct inflatable_buffer buffer = { .len = SOCKET_BUFFER_SIZE };
 	int ret;
 
 	ret = -ENOMEM;

commit 573bd7f30318578b465e9dfee721a008d474f15e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 2 03:44:06 2017 +0200

    wg: simmer down silly compilers
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index ceeb847..0e61a3e 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -90,7 +90,7 @@ static FILE *userspace_interface_file(const char *interface)
 	struct stat sbuf;
 	struct sockaddr_un addr = { .sun_family = AF_UNIX };
 	int fd = -1, ret;
-	FILE *f;
+	FILE *f = NULL;
 
 	ret = -EINVAL;
 	if (strchr(interface, '/'))

commit 53e5b4fa89f34f7c4f4bd9221fc636690e3e0cd3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Oct 2 02:51:57 2017 +0200

    wg: do not warn on unrecognized items
    
    Upstream advice is to simply be silent.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/containers.h b/src/containers.h
index b9c85e0..7ce09a9 100644
--- a/src/containers.h
+++ b/src/containers.h
@@ -63,7 +63,6 @@ enum {
 
 struct wgdevice {
 	char name[IFNAMSIZ];
-	uint32_t ifindex;
 
 	uint32_t flags;
 
diff --git a/src/ipc.c b/src/ipc.c
index 8f86eb0..ceeb847 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -85,19 +85,6 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
-static void warn_unrecognized(const char *which)
-{
-	static bool once = false;
-	if (once)
-		return;
-	once = true;
-	fprintf(stderr,
-		"Warning: this program received from your %s one or more\n"
-		"attributes that it did not recognize. It is possible that\n"
-		"this version of wg(8) is older than your %s. You may\n"
-		"want to update this program.\n", which, which);
-}
-
 static FILE *userspace_interface_file(const char *interface)
 {
 	struct stat sbuf;
@@ -428,8 +415,6 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			peer->tx_bytes = NUM(0xffffffffffffffffULL);
 		else if (!strcmp(key, "errno"))
 			ret = -NUM(0x7fffffffU);
-		else
-			warn_unrecognized("daemon");
 	}
 	ret = -EPROTO;
 err:
@@ -701,8 +686,6 @@ static int parse_allowedip(const struct nlattr *attr, void *data)
 		if (!mnl_attr_validate(attr, MNL_TYPE_U8))
 			ctx->allowedip->cidr = mnl_attr_get_u8(attr);
 		break;
-	default:
-		warn_unrecognized("kernel");
 	}
 
 	return MNL_CB_OK;
@@ -772,8 +755,6 @@ static int parse_peer(const struct nlattr *attr, void *data)
 		break;
 	case WGPEER_A_ALLOWEDIPS:
 		return mnl_attr_parse_nested(attr, parse_allowedips, ctx);
-	default:
-		warn_unrecognized("kernel");
 	}
 
 	return MNL_CB_OK;
@@ -807,10 +788,6 @@ static int parse_device(const struct nlattr *attr, void *data)
 	struct get_device_ctx *ctx = data;
 
 	switch (mnl_attr_get_type(attr)) {
-	case WGDEVICE_A_IFINDEX:
-		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
-			ctx->device->ifindex = mnl_attr_get_u32(attr);
-		break;
 	case WGDEVICE_A_IFNAME:
 		if (!mnl_attr_validate(attr, MNL_TYPE_STRING))
 			strncpy(ctx->device->name, mnl_attr_get_str(attr), sizeof(ctx->device->name) - 1);
@@ -833,8 +810,6 @@ static int parse_device(const struct nlattr *attr, void *data)
 		break;
 	case WGDEVICE_A_PEERS:
 		return mnl_attr_parse_nested(attr, parse_peers, ctx);
-	default:
-		warn_unrecognized("kernel");
 	}
 
 	return MNL_CB_OK;

commit 83caaa7a96f87dea0687003fe1cae531aec5a5b5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Oct 1 22:05:19 2017 +0200

    wg-quick: check permissions of parent directory
    
    Also prefix octal 0, in case these files are actually of modes that
    don't start with 0 by accident (such as SUID or sticky bit).
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 5295c8b..015df85 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -30,7 +30,7 @@ parse_options() {
 	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,16}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
 	[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,16})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
-	((($(stat -c '%#a' "$CONFIG_FILE") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
+	((($(stat -c '0%#a' "$CONFIG_FILE") & $(stat -c '0%#a' "/etc/wireguard") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
 	INTERFACE="${BASH_REMATCH[1]}"
 	shopt -s nocasematch
 	while read -r line || [[ -n $line ]]; do

commit cbd2b0531f116c286dd6fffcac78f1af57717037
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Oct 1 21:42:32 2017 +0200

    wg-quick: verify wireguard interface in more clever way
    
    This helps with old Debian which has ancient iproute2, as well as paving
    the path toward this script supporting userspace implementations.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index c70c078..5295c8b 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -249,7 +249,7 @@ cmd_up() {
 }
 
 cmd_down() {
-	[[ -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] || die "\`$INTERFACE' is not a WireGuard interface"
+	[[ " $(wg show interfaces) " == *" $INTERFACE "* ]] || die "\`$INTERFACE' is not a WireGuard interface"
 	execute_hook "$PRE_DOWN"
 	[[ $SAVE_CONFIG -eq 0 ]] || save_config
 	unset_dns

commit a566bde12636b6b995b800421fd8061e28554b73
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Oct 1 21:37:53 2017 +0200

    wg-quick: anchor sysctl regex to start and end
    
    This doesn't actually fix a real problem, but it is more correct than
    not having it.
    
    Suggested-by: Aaron Sigel <aaron@vtty.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index e5ae48f..c70c078 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -163,7 +163,7 @@ add_default() {
 	local key value
 	while read -r key _ value; do
 		[[ $value -eq 1 ]] && sysctl -q "$key=2"
-	done < <(sysctl -a -r 'net\.ipv4.conf\..+\.rp_filter')
+	done < <(sysctl -a -r '^net\.ipv4.conf\.[^ .=]+\.rp_filter$')
 	return 0
 }
 

commit 5b65f87e9fcad48d7a31daee986f1a0b78d9d8f9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Sep 25 04:22:09 2017 +0200

    netlink: switch from ioctl to netlink for configuration
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index af74bda..0d8daeb 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,6 +1,5 @@
 /* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
-
 #include <arpa/inet.h>
 #include <limits.h>
 #include <ctype.h>
@@ -14,36 +13,12 @@
 #include <errno.h>
 
 #include "config.h"
+#include "containers.h"
 #include "ipc.h"
 #include "encoding.h"
 
 #define COMMENT_CHAR '#'
 
-#define max(a, b) (a > b ? a : b)
-
-static inline struct wgpeer *peer_from_offset(struct wgdevice *dev, size_t offset)
-{
-	return (struct wgpeer *)((uint8_t *)dev + sizeof(struct wgdevice) + offset);
-}
-
-static int use_space(struct inflatable_device *buf, size_t space)
-{
-	size_t expand_to;
-	uint8_t *new_dev;
-
-	if (buf->len - buf->pos < space) {
-		expand_to = max(buf->len * 2, buf->len + space);
-		new_dev = realloc(buf->dev, expand_to + sizeof(struct wgdevice));
-		if (!new_dev)
-			return -errno;
-		memset(&new_dev[buf->len + sizeof(struct wgdevice)], 0, expand_to - buf->len);
-		buf->dev = (struct wgdevice *)new_dev;
-		buf->len = expand_to;
-	}
-	buf->pos += space;
-	return 0;
-}
-
 static const char *get_value(const char *line, const char *key)
 {
 	size_t linelen = strlen(line);
@@ -58,10 +33,9 @@ static const char *get_value(const char *line, const char *key)
 	return line + keylen;
 }
 
-static inline uint16_t parse_port(const char *value)
+static inline bool parse_port(uint16_t *port, uint32_t *flags, const char *value)
 {
 	int ret;
-	uint16_t port = 0;
 	struct addrinfo *resolved;
 	struct addrinfo hints = {
 		.ai_family = AF_UNSPEC,
@@ -72,27 +46,32 @@ static inline uint16_t parse_port(const char *value)
 
 	if (!strlen(value)) {
 		fprintf(stderr, "Unable to parse empty port\n");
-		return 0;
+		return false;
 	}
 
 	ret = getaddrinfo(NULL, value, &hints, &resolved);
-	if (ret != 0) {
+	if (ret) {
 		fprintf(stderr, "%s: `%s`\n", gai_strerror(ret), value);
-		return 0;
+		return false;
 	}
 
-	if (resolved->ai_family == AF_INET && resolved->ai_addrlen == sizeof(struct sockaddr_in))
-		port = ntohs(((struct sockaddr_in *)resolved->ai_addr)->sin_port);
-	else if (resolved->ai_family == AF_INET6 && resolved->ai_addrlen == sizeof(struct sockaddr_in6))
-		port = ntohs(((struct sockaddr_in6 *)resolved->ai_addr)->sin6_port);
-	else
+	ret = -1;
+	if (resolved->ai_family == AF_INET && resolved->ai_addrlen == sizeof(struct sockaddr_in)) {
+		*port = ntohs(((struct sockaddr_in *)resolved->ai_addr)->sin_port);
+		ret = 0;
+	} else if (resolved->ai_family == AF_INET6 && resolved->ai_addrlen == sizeof(struct sockaddr_in6)) {
+		*port = ntohs(((struct sockaddr_in6 *)resolved->ai_addr)->sin6_port);
+		ret = 0;
+	} else
 		fprintf(stderr, "Neither IPv4 nor IPv6 address found: `%s`\n", value);
 
 	freeaddrinfo(resolved);
-	return port;
+	if (!ret)
+		*flags |= WGDEVICE_HAS_LISTEN_PORT;
+	return ret == 0;
 }
 
-static inline bool parse_fwmark(uint32_t *fwmark, unsigned int *flags, const char *value)
+static inline bool parse_fwmark(uint32_t *fwmark, uint32_t *flags, const char *value)
 {
 	unsigned long ret;
 	char *end;
@@ -100,7 +79,7 @@ static inline bool parse_fwmark(uint32_t *fwmark, unsigned int *flags, const cha
 
 	if (!strcasecmp(value, "off")) {
 		*fwmark = 0;
-		*flags |= WGDEVICE_REMOVE_FWMARK;
+		*flags |= WGDEVICE_HAS_FWMARK;
 		return true;
 	}
 
@@ -112,8 +91,7 @@ static inline bool parse_fwmark(uint32_t *fwmark, unsigned int *flags, const cha
 	if (!*value || *end || ret > UINT32_MAX)
 		return false;
 	*fwmark = ret;
-	if (!ret)
-		*flags |= WGDEVICE_REMOVE_FWMARK;
+	*flags |= WGDEVICE_HAS_FWMARK;
 	return true;
 }
 
@@ -126,17 +104,17 @@ static inline bool parse_key(uint8_t key[static WG_KEY_LEN], const char *value)
 	return true;
 }
 
-static inline bool parse_ip(struct wgipmask *ipmask, const char *value)
+static inline bool parse_ip(struct wgallowedip *allowedip, const char *value)
 {
-	ipmask->family = AF_UNSPEC;
+	allowedip->family = AF_UNSPEC;
 	if (strchr(value, ':')) {
-		if (inet_pton(AF_INET6, value, &ipmask->ip6) == 1)
-			ipmask->family = AF_INET6;
+		if (inet_pton(AF_INET6, value, &allowedip->ip6) == 1)
+			allowedip->family = AF_INET6;
 	} else {
-		if (inet_pton(AF_INET, value, &ipmask->ip4) == 1)
-			ipmask->family = AF_INET;
+		if (inet_pton(AF_INET, value, &allowedip->ip4) == 1)
+			allowedip->family = AF_INET;
 	}
-	if (ipmask->family == AF_UNSPEC) {
+	if (allowedip->family == AF_UNSPEC) {
 		fprintf(stderr, "Unable to parse IP address: `%s`\n", value);
 		return false;
 	}
@@ -215,13 +193,14 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 	return true;
 }
 
-static inline bool parse_persistent_keepalive(__u16 *interval, const char *value)
+static inline bool parse_persistent_keepalive(uint16_t *interval, uint32_t *flags, const char *value)
 {
 	unsigned long ret;
 	char *end;
 
 	if (!strcasecmp(value, "off")) {
 		*interval = 0;
+		*flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
 		return true;
 	}
 
@@ -231,22 +210,21 @@ static inline bool parse_persistent_keepalive(__u16 *interval, const char *value
 		return false;
 	}
 
-	*interval = (__u16)ret;
+	*interval = (uint16_t)ret;
+	*flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
 	return true;
 }
 
 
-static inline bool parse_ipmasks(struct inflatable_device *buf, size_t peer_offset, const char *value)
+static inline bool parse_allowedips(struct wgpeer *peer, struct wgallowedip **last_allowedip, const char *value)
 {
-	struct wgpeer *peer;
-	struct wgipmask *ipmask;
+	struct wgallowedip *allowedip = *last_allowedip, *new_allowedip;
 	char *mask, *mutable = strdup(value), *sep;
 	if (!mutable) {
 		perror("strdup");
 		return false;
 	};
-	peer = peer_from_offset(buf->dev, peer_offset);
-	peer->flags |= WGPEER_REPLACE_IPMASKS;
+	peer->flags |= WGPEER_REPLACE_ALLOWEDIPS;
 	if (!strlen(value)) {
 		free(mutable);
 		return true;
@@ -255,15 +233,19 @@ static inline bool parse_ipmasks(struct inflatable_device *buf, size_t peer_offs
 	while ((mask = strsep(&sep, ","))) {
 		unsigned long cidr = ULONG_MAX;
 		char *end, *ip = strsep(&mask, "/");
-		if (use_space(buf, sizeof(struct wgipmask)) < 0) {
-			perror("use_space");
+		new_allowedip = calloc(1, sizeof(struct wgallowedip));
+		if (!new_allowedip) {
+			perror("calloc");
 			free(mutable);
 			return false;
 		}
-		peer = peer_from_offset(buf->dev, peer_offset);
-		ipmask = (struct wgipmask *)((uint8_t *)peer + sizeof(struct wgpeer) + (sizeof(struct wgipmask) * peer->num_ipmasks));
+		if (allowedip)
+			allowedip->next_allowedip = new_allowedip;
+		else
+			peer->first_allowedip = new_allowedip;
+		allowedip = new_allowedip;
 
-		if (!parse_ip(ipmask, ip)) {
+		if (!parse_ip(allowedip, ip)) {
 			free(mutable);
 			return false;
 		}
@@ -272,16 +254,16 @@ static inline bool parse_ipmasks(struct inflatable_device *buf, size_t peer_offs
 			if (*end)
 				cidr = ULONG_MAX;
 		}
-		if (ipmask->family == AF_INET)
+		if (allowedip->family == AF_INET)
 			cidr = cidr > 32 ? 32 : cidr;
-		else if (ipmask->family == AF_INET6)
+		else if (allowedip->family == AF_INET6)
 			cidr = cidr > 128 ? 128 : cidr;
 		else
 			continue;
-		ipmask->cidr = cidr;
-		++peer->num_ipmasks;
+		allowedip->cidr = cidr;
 	}
 	free(mutable);
+	*last_allowedip = allowedip;
 	return true;
 }
 
@@ -296,16 +278,20 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 		return true;
 	}
 	if (!strcasecmp(line, "[Peer]")) {
-		ctx->peer_offset = ctx->buf.pos;
-		if (use_space(&ctx->buf, sizeof(struct wgpeer)) < 0) {
-			perror("use_space");
+		struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
+		if (!new_peer) {
+			perror("calloc");
 			return false;
 		}
-		++ctx->buf.dev->num_peers;
+		ctx->last_allowedip = NULL;
+		if (ctx->last_peer)
+			ctx->last_peer->next_peer = new_peer;
+		else
+			ctx->device->first_peer = new_peer;
+		ctx->last_peer = new_peer;
 		ctx->is_peer_section = true;
 		ctx->is_device_section = false;
-		peer_from_offset(ctx->buf.dev, ctx->peer_offset)->flags |= WGPEER_REPLACE_IPMASKS;
-		peer_from_offset(ctx->buf.dev, ctx->peer_offset)->persistent_keepalive_interval = (__u16)-1;
+		ctx->last_peer->flags |= WGPEER_REPLACE_ALLOWEDIPS;
 		return true;
 	}
 
@@ -313,28 +299,32 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 
 	if (ctx->is_device_section) {
 		if (key_match("ListenPort"))
-			ret = !!(ctx->buf.dev->port = parse_port(value));
+			ret = parse_port(&ctx->device->listen_port, &ctx->device->flags, value);
 		else if (key_match("FwMark"))
-			ret = parse_fwmark(&ctx->buf.dev->fwmark, &ctx->buf.dev->flags, value);
+			ret = parse_fwmark(&ctx->device->fwmark, &ctx->device->flags, value);
 		else if (key_match("PrivateKey")) {
-			ret = parse_key(ctx->buf.dev->private_key, value);
+			ret = parse_key(ctx->device->private_key, value);
 			if (!ret)
-				memset(ctx->buf.dev->private_key, 0, WG_KEY_LEN);
+				memset(ctx->device->private_key, 0, WG_KEY_LEN);
+			else
+				ctx->device->flags |= WGDEVICE_HAS_PRIVATE_KEY;
 		} else
 			goto error;
 	} else if (ctx->is_peer_section) {
 		if (key_match("Endpoint"))
-			ret = parse_endpoint(&peer_from_offset(ctx->buf.dev, ctx->peer_offset)->endpoint.addr, value);
+			ret = parse_endpoint(&ctx->last_peer->endpoint.addr, value);
 		else if (key_match("PublicKey"))
-			ret = parse_key(peer_from_offset(ctx->buf.dev, ctx->peer_offset)->public_key, value);
+			ret = parse_key(ctx->last_peer->public_key, value);
 		else if (key_match("AllowedIPs"))
-			ret = parse_ipmasks(&ctx->buf, ctx->peer_offset, value);
+			ret = parse_allowedips(ctx->last_peer, &ctx->last_allowedip, value);
 		else if (key_match("PersistentKeepalive"))
-			ret = parse_persistent_keepalive(&peer_from_offset(ctx->buf.dev, ctx->peer_offset)->persistent_keepalive_interval, value);
+			ret = parse_persistent_keepalive(&ctx->last_peer->persistent_keepalive_interval, &ctx->last_peer->flags, value);
 		else if (key_match("PresharedKey")) {
-			ret = parse_key(peer_from_offset(ctx->buf.dev, ctx->peer_offset)->preshared_key, value);
+			ret = parse_key(ctx->last_peer->preshared_key, value);
 			if (!ret)
-				memset(peer_from_offset(ctx->buf.dev, ctx->peer_offset)->preshared_key, 0, WG_KEY_LEN);
+				memset(ctx->last_peer->preshared_key, 0, WG_KEY_LEN);
+			else
+				ctx->last_peer->flags |= WGPEER_HAS_PRESHARED_KEY;
 		} else
 			goto error;
 	} else
@@ -355,7 +345,8 @@ bool config_read_line(struct config_ctx *ctx, const char *input)
 	bool ret = true;
 	if (!line) {
 		perror("calloc");
-		return false;
+		ret = false;
+		goto out;
 	}
 	if (!len)
 		goto out;
@@ -370,56 +361,54 @@ bool config_read_line(struct config_ctx *ctx, const char *input)
 	ret = process_line(ctx, line);
 out:
 	free(line);
+	if (!ret)
+		free_wgdevice(ctx->device);
 	return ret;
 }
 
-bool config_read_init(struct config_ctx *ctx, struct wgdevice **device, bool append)
+bool config_read_init(struct config_ctx *ctx, bool append)
 {
 	memset(ctx, 0, sizeof(struct config_ctx));
-	ctx->device = device;
-	ctx->buf.dev = calloc(1, sizeof(struct wgdevice));
-	if (!ctx->buf.dev) {
+	ctx->device = calloc(1, sizeof(struct wgdevice));
+	if (!ctx->device) {
 		perror("calloc");
 		return false;
 	}
 	if (!append)
-		ctx->buf.dev->flags |= WGDEVICE_REPLACE_PEERS;
+		ctx->device->flags |= WGDEVICE_REPLACE_PEERS | WGDEVICE_HAS_PRIVATE_KEY | WGDEVICE_HAS_FWMARK | WGDEVICE_HAS_LISTEN_PORT;
 	return true;
 }
 
-bool config_read_finish(struct config_ctx *ctx)
+struct wgdevice *config_read_finish(struct config_ctx *ctx)
 {
-	size_t i;
 	struct wgpeer *peer;
-	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && key_is_zero(ctx->buf.dev->private_key)) {
-		fprintf(stderr, "No private key configured\n");
+	if (ctx->device->flags & WGDEVICE_REPLACE_PEERS && key_is_zero(ctx->device->private_key)) {
+		fprintf(stderr, "No private key is configured\n");
 		goto err;
 	}
-	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !ctx->buf.dev->fwmark)
-		ctx->buf.dev->flags |= WGDEVICE_REMOVE_FWMARK;
 
-	for_each_wgpeer(ctx->buf.dev, peer, i) {
+	for_each_wgpeer (ctx->device, peer) {
 		if (key_is_zero(peer->public_key)) {
 			fprintf(stderr, "A peer is missing a public key\n");
 			goto err;
 		}
 	}
-	*ctx->device = ctx->buf.dev;
-	return true;
+	return ctx->device;
 err:
-	free(ctx->buf.dev);
-	return false;
+	free_wgdevice(ctx->device);
+	return NULL;
 }
 
-static int read_keyfile(char dst[WG_KEY_LEN_BASE64], const char *path)
+static bool read_keyfile(char dst[WG_KEY_LEN_BASE64], const char *path)
 {
 	FILE *f;
-	int ret = -1, c;
+	int c;
+	bool ret = false;
 
 	f = fopen(path, "r");
 	if (!f) {
 		perror("fopen");
-		return -1;
+		return false;
 	}
 
 	if (fread(dst, WG_KEY_LEN_BASE64 - 1, 1, f) != 1) {
@@ -429,7 +418,9 @@ static int read_keyfile(char dst[WG_KEY_LEN_BASE64], const char *path)
 		}
 		/* If we're at the end and we didn't read anything, we're /dev/null. */
 		if (!ferror(f) && feof(f) && !ftell(f)) {
-			ret = 1;
+			static const uint8_t zeros[WG_KEY_LEN] = { 0 };
+			key_to_base64(dst, zeros);
+			ret = true;
 			goto out;
 		}
 
@@ -448,7 +439,7 @@ static int read_keyfile(char dst[WG_KEY_LEN_BASE64], const char *path)
 		perror("getc");
 		goto out;
 	}
-	ret = 0;
+	ret = true;
 
 out:
 	fclose(f);
@@ -473,85 +464,84 @@ static char *strip_spaces(const char *in)
 	return out;
 }
 
-bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
+struct wgdevice *config_read_cmd(char *argv[], int argc)
 {
-	struct inflatable_device buf = { 0 };
-	size_t peer_offset = 0;
-	buf.dev = calloc(1, sizeof(struct wgdevice));
-	if (!buf.dev) {
+	struct wgdevice *device = calloc(1, sizeof(struct wgdevice));
+	struct wgpeer *peer = NULL;
+	struct wgallowedip *allowedip = NULL;
+	if (!device) {
 		perror("calloc");
 		return false;
 	}
 	while (argc > 0) {
-		if (!strcmp(argv[0], "listen-port") && argc >= 2 && !buf.dev->num_peers) {
-			buf.dev->port = parse_port(argv[1]);
-			if (!buf.dev->port)
+		if (!strcmp(argv[0], "listen-port") && argc >= 2 && !peer) {
+			if (!parse_port(&device->listen_port, &device->flags, argv[1]))
 				goto error;
 			argv += 2;
 			argc -= 2;
-		} else if (!strcmp(argv[0], "fwmark") && argc >= 2 && !buf.dev->num_peers) {
-			if (!parse_fwmark(&buf.dev->fwmark, &buf.dev->flags, argv[1]))
+		} else if (!strcmp(argv[0], "fwmark") && argc >= 2 && !peer) {
+			if (!parse_fwmark(&device->fwmark, &device->flags, argv[1]))
 				goto error;
 			argv += 2;
 			argc -= 2;
-		} else if (!strcmp(argv[0], "private-key") && argc >= 2 && !buf.dev->num_peers) {
+		} else if (!strcmp(argv[0], "private-key") && argc >= 2 && !peer) {
 			char key_line[WG_KEY_LEN_BASE64];
-			int ret = read_keyfile(key_line, argv[1]);
-			if (ret == 0) {
-				if (!parse_key(buf.dev->private_key, key_line))
+			if (read_keyfile(key_line, argv[1])) {
+				if (!parse_key(device->private_key, key_line))
 					goto error;
-			} else if (ret == 1)
-				buf.dev->flags |= WGDEVICE_REMOVE_PRIVATE_KEY;
-			else
+				device->flags |= WGDEVICE_HAS_PRIVATE_KEY;
+			} else
 				goto error;
 			argv += 2;
 			argc -= 2;
 		} else if (!strcmp(argv[0], "peer") && argc >= 2) {
-			peer_offset = buf.pos;
-			if (use_space(&buf, sizeof(struct wgpeer)) < 0) {
-				perror("use_space");
+			struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
+			allowedip = NULL;
+			if (!new_peer) {
+				perror("calloc");
 				goto error;
 			}
-			peer_from_offset(buf.dev, peer_offset)->persistent_keepalive_interval = (__u16)-1;
-			++buf.dev->num_peers;
-			if (!parse_key(peer_from_offset(buf.dev, peer_offset)->public_key, argv[1]))
+			if (peer)
+				peer->next_peer = new_peer;
+			else
+				device->first_peer = new_peer;
+			peer = new_peer;
+			if (!parse_key(peer->public_key, argv[1]))
 				goto error;
 			argv += 2;
 			argc -= 2;
-		} else if (!strcmp(argv[0], "remove") && argc >= 1 && buf.dev->num_peers) {
-			peer_from_offset(buf.dev, peer_offset)->flags |= WGPEER_REMOVE_ME;
+		} else if (!strcmp(argv[0], "remove") && argc >= 1 && peer) {
+			peer->flags |= WGPEER_REMOVE_ME;
 			argv += 1;
 			argc -= 1;
-		} else if (!strcmp(argv[0], "endpoint") && argc >= 2 && buf.dev->num_peers) {
-			if (!parse_endpoint(&peer_from_offset(buf.dev, peer_offset)->endpoint.addr, argv[1]))
+		} else if (!strcmp(argv[0], "endpoint") && argc >= 2 && peer) {
+			if (!parse_endpoint(&peer->endpoint.addr, argv[1]))
 				goto error;
 			argv += 2;
 			argc -= 2;
-		} else if (!strcmp(argv[0], "allowed-ips") && argc >= 2 && buf.dev->num_peers) {
+		} else if (!strcmp(argv[0], "allowed-ips") && argc >= 2 && peer) {
 			char *line = strip_spaces(argv[1]);
 			if (!line)
 				goto error;
-			if (!parse_ipmasks(&buf, peer_offset, line)) {
+			if (!parse_allowedips(peer, &allowedip, line)) {
 				free(line);
 				goto error;
 			}
 			free(line);
 			argv += 2;
 			argc -= 2;
-		} else if (!strcmp(argv[0], "persistent-keepalive") && argc >= 2 && buf.dev->num_peers) {
-			if (!parse_persistent_keepalive(&peer_from_offset(buf.dev, peer_offset)->persistent_keepalive_interval, argv[1]))
+		} else if (!strcmp(argv[0], "persistent-keepalive") && argc >= 2 && peer) {
+			if (!parse_persistent_keepalive(&peer->persistent_keepalive_interval, &peer->flags, argv[1]))
 				goto error;
 			argv += 2;
 			argc -= 2;
-		} else if (!strcmp(argv[0], "preshared-key") && argc >= 2 && buf.dev->num_peers) {
+		} else if (!strcmp(argv[0], "preshared-key") && argc >= 2 && peer) {
 			char key_line[WG_KEY_LEN_BASE64];
-			int ret = read_keyfile(key_line, argv[1]);
-			if (ret == 0) {
-				if (!parse_key(peer_from_offset(buf.dev, peer_offset)->preshared_key, key_line))
+			if (read_keyfile(key_line, argv[1])) {
+				if (!parse_key(peer->preshared_key, key_line))
 					goto error;
-			} else if (ret == 1)
-				peer_from_offset(buf.dev, peer_offset)->flags |= WGPEER_REMOVE_PRESHARED_KEY;
-			else
+				peer->flags |= WGPEER_HAS_PRESHARED_KEY;
+			} else
 				goto error;
 			argv += 2;
 			argc -= 2;
@@ -560,9 +550,8 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 			goto error;
 		}
 	}
-	*device = buf.dev;
-	return true;
+	return device;
 error:
-	free(buf.dev);
+	free_wgdevice(device);
 	return false;
 }
diff --git a/src/config.h b/src/config.h
index 5f7761f..63a272c 100644
--- a/src/config.h
+++ b/src/config.h
@@ -4,31 +4,21 @@
 #define CONFIG_H
 
 #include <stdbool.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-#include <net/if.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include "../uapi.h"
 
-struct inflatable_device {
-	struct wgdevice *dev;
-	size_t len;
-	size_t pos;
-};
+struct wgdevice;
+struct wgpeer;
+struct wgallowedip;
 
 struct config_ctx {
-	struct inflatable_device buf;
-	size_t peer_offset;
-	struct wgdevice **device;
-	bool is_peer_section;
-	bool is_device_section;
+	struct wgdevice *device;
+	struct wgpeer *last_peer;
+	struct wgallowedip *last_allowedip;
+	bool is_peer_section, is_device_section;
 };
 
-bool config_read_cmd(struct wgdevice **dev, char *argv[], int argc);
-bool config_read_init(struct config_ctx *ctx, struct wgdevice **device, bool append);
+struct wgdevice *config_read_cmd(char *argv[], int argc);
+bool config_read_init(struct config_ctx *ctx, bool append);
 bool config_read_line(struct config_ctx *ctx, const char *line);
-bool config_read_finish(struct config_ctx *ctx);
+struct wgdevice *config_read_finish(struct config_ctx *ctx);
 
 #endif
diff --git a/src/containers.h b/src/containers.h
new file mode 100644
index 0000000..b9c85e0
--- /dev/null
+++ b/src/containers.h
@@ -0,0 +1,95 @@
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+
+#ifndef CONTAINERS_H
+#define CONTAINERS_H
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+
+#include "../uapi/wireguard.h"
+
+struct wgallowedip {
+	uint16_t family;
+	union {
+		struct in_addr ip4;
+		struct in6_addr ip6;
+	};
+	uint8_t cidr;
+	struct wgallowedip *next_allowedip;
+};
+
+enum {
+	WGPEER_REMOVE_ME = (1 << 0),
+	WGPEER_REPLACE_ALLOWEDIPS = (1 << 1),
+	WGPEER_HAS_PRESHARED_KEY = (1 << 2),
+	WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL = (1 << 3)
+};
+
+struct wgpeer {
+	uint32_t flags;
+
+	uint8_t public_key[WG_KEY_LEN];
+	uint8_t preshared_key[WG_KEY_LEN];
+
+	union {
+		struct sockaddr addr;
+		struct sockaddr_in addr4;
+		struct sockaddr_in6 addr6;
+	} endpoint;
+
+	struct timeval last_handshake_time;
+	uint64_t rx_bytes, tx_bytes;
+	uint16_t persistent_keepalive_interval;
+
+	struct wgallowedip *first_allowedip;
+	struct wgpeer *next_peer;
+};
+
+enum {
+	WGDEVICE_REPLACE_PEERS = (1 << 0),
+	WGDEVICE_HAS_PRIVATE_KEY = (1 << 1),
+	WGDEVICE_HAS_LISTEN_PORT = (1 << 2),
+	WGDEVICE_HAS_FWMARK = (1 << 3)
+};
+
+enum {
+	WG_API_VERSION_MAGIC = 0xbeef0003
+};
+
+struct wgdevice {
+	char name[IFNAMSIZ];
+	uint32_t ifindex;
+
+	uint32_t flags;
+
+	uint8_t public_key[WG_KEY_LEN];
+	uint8_t private_key[WG_KEY_LEN];
+
+	uint32_t fwmark;
+	uint16_t listen_port;
+
+	struct wgpeer *first_peer;
+};
+
+#define for_each_wgpeer(__dev, __peer) for ((__peer) = (__dev)->first_peer; (__peer); (__peer) = (__peer)->next_peer)
+#define for_each_wgallowedip(__peer, __allowedip) for ((__allowedip) = (__peer)->first_allowedip; (__allowedip); (__allowedip) = (__allowedip)->next_allowedip)
+#define max(a, b) ((a) > (b) ? (a) : (b))
+
+static inline void free_wgdevice(struct wgdevice *dev)
+{
+	if (!dev)
+		return;
+	for (struct wgpeer *peer = dev->first_peer, *np = peer ? peer->next_peer : NULL; peer; peer = np, np = peer ? peer->next_peer : NULL) {
+		for (struct wgallowedip *allowedip = peer->first_allowedip, *na = allowedip ? allowedip->next_allowedip : NULL; allowedip; allowedip = na, na = allowedip ? allowedip->next_allowedip : NULL)
+			free(allowedip);
+		free(peer);
+	}
+	free(dev);
+}
+
+#endif
diff --git a/src/encoding.h b/src/encoding.h
index 9db4c6e..1f79a2a 100644
--- a/src/encoding.h
+++ b/src/encoding.h
@@ -5,7 +5,7 @@
 
 #include <stdbool.h>
 #include <stdint.h>
-#include "../uapi.h"
+#include "containers.h"
 
 #define WG_KEY_LEN_BASE64 ((((WG_KEY_LEN) + 2) / 3) * 4 + 1)
 #define WG_KEY_LEN_HEX (WG_KEY_LEN * 2 + 1)
diff --git a/src/ipc.c b/src/ipc.c
index 45278ec..8f86eb0 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -5,6 +5,8 @@
 #include <linux/if_link.h>
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
+#include <linux/genetlink.h>
+#include "mnlg.h"
 #endif
 #include <netinet/in.h>
 #include <net/if.h>
@@ -29,9 +31,10 @@
 #include <arpa/inet.h>
 
 #include "ipc.h"
+#include "containers.h"
 #include "encoding.h"
 #include "curve25519.h"
-#include "../uapi.h"
+#include "../uapi/wireguard.h"
 
 #define SOCK_PATH RUNSTATEDIR "/wireguard/"
 #define SOCK_SUFFIX ".sock"
@@ -44,8 +47,6 @@ struct inflatable_buffer {
 	size_t pos;
 };
 
-#define max(a, b) ((a) > (b) ? (a) : (b))
-
 static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 {
 	size_t len, expand_to;
@@ -84,6 +85,19 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
+static void warn_unrecognized(const char *which)
+{
+	static bool once = false;
+	if (once)
+		return;
+	once = true;
+	fprintf(stderr,
+		"Warning: this program received from your %s one or more\n"
+		"attributes that it did not recognize. It is possible that\n"
+		"this version of wg(8) is older than your %s. You may\n"
+		"want to update this program.\n", which, which);
+}
+
 static FILE *userspace_interface_file(const char *interface)
 {
 	struct stat sbuf;
@@ -130,15 +144,28 @@ out:
 static bool userspace_has_wireguard_interface(const char *interface)
 {
 	struct stat sbuf;
-	char path[PATH_MAX] = { 0 };
+	struct sockaddr_un addr = { .sun_family = AF_UNIX };
+	int fd, ret;
 
 	if (strchr(interface, '/'))
 		return false;
-	if (snprintf(path, sizeof(path) - 1, SOCK_PATH "%s" SOCK_SUFFIX, interface) < 0)
+	if (snprintf(addr.sun_path, sizeof(addr.sun_path) - 1, SOCK_PATH "%s" SOCK_SUFFIX, interface) < 0)
+		return false;
+	if (stat(addr.sun_path, &sbuf) < 0)
+		return false;
+	if (!S_ISSOCK(sbuf.st_mode))
+		return false;
+	ret = fd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (ret < 0)
 		return false;
-	if (stat(path, &sbuf) < 0)
+	ret = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
+	if (ret < 0 && errno == ECONNREFUSED) { /* If the process is gone, we try to clean up the socket. */
+		close(fd);
+		unlink(addr.sun_path);
 		return false;
-	return S_ISSOCK(sbuf.st_mode);
+	}
+	close(fd);
+	return true;
 }
 
 static int userspace_get_wireguard_interfaces(struct inflatable_buffer *buffer)
@@ -177,42 +204,35 @@ static int userspace_set_device(struct wgdevice *dev)
 {
 	char hex[WG_KEY_LEN_HEX], ip[INET6_ADDRSTRLEN], host[4096 + 1], service[512 + 1];
 	struct wgpeer *peer;
-	struct wgipmask *ipmask;
+	struct wgallowedip *allowedip;
 	FILE *f;
 	int ret;
-	size_t i, j;
 	socklen_t addr_len;
 
-	f = userspace_interface_file(dev->interface);
+	f = userspace_interface_file(dev->name);
 	if (!f)
 		return -errno;
 	fprintf(f, "set=1\n");
 
-	if (dev->flags & WGDEVICE_REMOVE_PRIVATE_KEY)
-		fprintf(f, "private_key=\n");
-	else if (!key_is_zero(dev->private_key)) {
+	if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY) {
 		key_to_hex(hex, dev->private_key);
 		fprintf(f, "private_key=%s\n", hex);
 	}
-	if (dev->port)
-		fprintf(f, "listen_port=%u\n", dev->port);
-	if (dev->flags & WGDEVICE_REMOVE_FWMARK)
-		fprintf(f, "fwmark=\n");
-	else if (dev->fwmark)
+	if (dev->flags & WGDEVICE_HAS_LISTEN_PORT)
+		fprintf(f, "listen_port=%u\n", dev->listen_port);
+	if (dev->flags & WGDEVICE_HAS_FWMARK)
 		fprintf(f, "fwmark=%u\n", dev->fwmark);
 	if (dev->flags & WGDEVICE_REPLACE_PEERS)
 		fprintf(f, "replace_peers=true\n");
 
-	for_each_wgpeer(dev, peer, i) {
+	for_each_wgpeer (dev, peer) {
 		key_to_hex(hex, peer->public_key);
 		fprintf(f, "public_key=%s\n", hex);
 		if (peer->flags & WGPEER_REMOVE_ME) {
 			fprintf(f, "remove=true\n");
 			continue;
 		}
-		if (peer->flags & WGPEER_REMOVE_PRESHARED_KEY)
-			fprintf(f, "preshared_key=\n");
-		else if (!key_is_zero(peer->preshared_key)) {
+		if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
 			key_to_hex(hex, peer->preshared_key);
 			fprintf(f, "preshared_key=%s\n", hex);
 		}
@@ -229,20 +249,20 @@ static int userspace_set_device(struct wgdevice *dev)
 					fprintf(f, "endpoint=%s:%s\n", host, service);
 			}
 		}
-		if (peer->persistent_keepalive_interval != (uint16_t)-1)
+		if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL)
 			fprintf(f, "persistent_keepalive_interval=%u\n", peer->persistent_keepalive_interval);
-		if (peer->flags & WGPEER_REPLACE_IPMASKS)
+		if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
 			fprintf(f, "replace_allowed_ips=true\n");
-		for_each_wgipmask(peer, ipmask, j) {
-			if (ipmask->family == AF_INET) {
-				if (!inet_ntop(AF_INET, &ipmask->ip4, ip, INET6_ADDRSTRLEN))
+		for_each_wgallowedip (peer, allowedip) {
+			if (allowedip->family == AF_INET) {
+				if (!inet_ntop(AF_INET, &allowedip->ip4, ip, INET6_ADDRSTRLEN))
 					continue;
-			} else if (ipmask->family == AF_INET6) {
-				if (!inet_ntop(AF_INET6, &ipmask->ip6, ip, INET6_ADDRSTRLEN))
+			} else if (allowedip->family == AF_INET6) {
+				if (!inet_ntop(AF_INET6, &allowedip->ip6, ip, INET6_ADDRSTRLEN))
 					continue;
 			} else
 				continue;
-			fprintf(f, "allowed_ip=%s/%d\n", ip, ipmask->cidr);
+			fprintf(f, "allowed_ip=%s/%d\n", ip, allowedip->cidr);
 		}
 	}
 	fprintf(f, "\n");
@@ -255,24 +275,6 @@ static int userspace_set_device(struct wgdevice *dev)
 	return ret;
 }
 
-#define ADD(bytes) ({ \
-	if (buffer_len - buffer_end < bytes) { \
-		ptrdiff_t peer_offset = (void *)peer - (void *)*out; \
-		buffer_len = buffer_len * 2 + bytes; \
-		*out = realloc(*out, buffer_len); \
-		if (!*out) { \
-			ret = -errno; \
-			goto err; \
-		} \
-		memset((void *)*out + buffer_end, 0, buffer_len - buffer_end); \
-		if (peer) \
-			peer = (void *)*out + peer_offset; \
-		dev = *out; \
-	} \
-	buffer_end += bytes; \
-	(void *)*out + buffer_end - bytes; \
-})
-
 #define NUM(max) ({ \
 	unsigned long long num; \
 	char *end; \
@@ -288,11 +290,16 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 {
 	struct wgdevice *dev;
 	struct wgpeer *peer = NULL;
-	size_t buffer_len = 0, buffer_end = 0, line_buffer_len = 0, line_len;
+	struct wgallowedip *allowedip = NULL;
+	size_t line_buffer_len = 0, line_len;
 	char *key = NULL, *value;
 	FILE *f;
 	int ret = -EPROTO;
 
+	*out = dev = calloc(1, sizeof(struct wgdevice));
+	if (!dev)
+		return -errno;
+
 	f = userspace_interface_file(interface);
 	if (!f)
 		return -errno;
@@ -300,11 +307,8 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 	fprintf(f, "get=1\n\n");
 	fflush(f);
 
-	*out = NULL;
-	dev = ADD(sizeof(struct wgdevice));
-	dev->version_magic = WG_API_VERSION_MAGIC;
-	strncpy(dev->interface, interface, IFNAMSIZ - 1);
-	dev->interface[IFNAMSIZ - 1] = '\0';
+	strncpy(dev->name, interface, IFNAMSIZ - 1);
+	dev->name[IFNAMSIZ - 1] = '\0';
 
 	while (getline(&key, &line_buffer_len, f) > 0) {
 		line_len = strlen(key);
@@ -322,18 +326,31 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			if (!key_from_hex(dev->private_key, value))
 				break;
 			curve25519_generate_public(dev->public_key, dev->private_key);
-		} else if (!peer && !strcmp(key, "listen_port"))
-			dev->port = NUM(0xffffU);
-		else if (!peer && !strcmp(key, "fwmark"))
+			dev->flags |= WGDEVICE_HAS_PRIVATE_KEY;
+		} else if (!peer && !strcmp(key, "listen_port")) {
+			dev->listen_port = NUM(0xffffU);
+			dev->flags |= WGDEVICE_HAS_LISTEN_PORT;
+		} else if (!peer && !strcmp(key, "fwmark")) {
 			dev->fwmark = NUM(0xffffffffU);
-		else if (!strcmp(key, "public_key")) {
-			peer = ADD(sizeof(struct wgpeer));
+			dev->flags |= WGDEVICE_HAS_FWMARK;
+		} else if (!strcmp(key, "public_key")) {
+			struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
+			if (!new_peer) {
+				ret = -ENOMEM;
+				goto err;
+			}
+			allowedip = NULL;
+			if (peer)
+				peer->next_peer = new_peer;
+			else
+				dev->first_peer = new_peer;
+			peer = new_peer;
 			if (!key_from_hex(peer->public_key, value))
 				break;
-			++dev->num_peers;
 		} else if (peer && !strcmp(key, "preshared_key")) {
 			if (!key_from_hex(peer->preshared_key, value))
 				break;
+			peer->flags |= WGPEER_HAS_PRESHARED_KEY;
 		} else if (peer && !strcmp(key, "endpoint")) {
 			char *begin, *end;
 			struct addrinfo *resolved;
@@ -371,26 +388,36 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 				break;
 			}
 			freeaddrinfo(resolved);
-		} else if (peer && !strcmp(key, "persistent_keepalive_interval"))
-			peer->persistent_keepalive_interval = NUM(65535U);
-		else if (peer && !strcmp(key, "allowed_ip")) {
-			struct wgipmask *ipmask = ADD(sizeof(struct wgipmask));
+		} else if (peer && !strcmp(key, "persistent_keepalive_interval")) {
+			peer->persistent_keepalive_interval = NUM(0xffffU);
+			peer->flags |= WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL;
+		} else if (peer && !strcmp(key, "allowed_ip")) {
+			struct wgallowedip *new_allowedip;
 			char *end, *cidr = strchr(value, '/');
 			if (!cidr || strlen(cidr) <= 1)
 				break;
 			*cidr++ = '\0';
-			ipmask->family = AF_UNSPEC;
+			new_allowedip = calloc(1, sizeof(struct wgallowedip));
+			if (!new_allowedip) {
+				ret = -ENOMEM;
+				goto err;
+			}
+			if (allowedip)
+				allowedip->next_allowedip = new_allowedip;
+			else
+				peer->first_allowedip = new_allowedip;
+			allowedip = new_allowedip;
+			allowedip->family = AF_UNSPEC;
 			if (strchr(value, ':')) {
-				if (inet_pton(AF_INET6, value, &ipmask->ip6) == 1)
-					ipmask->family = AF_INET6;
+				if (inet_pton(AF_INET6, value, &allowedip->ip6) == 1)
+					allowedip->family = AF_INET6;
 			} else {
-				if (inet_pton(AF_INET, value, &ipmask->ip4) == 1)
-					ipmask->family = AF_INET;
+				if (inet_pton(AF_INET, value, &allowedip->ip4) == 1)
+					allowedip->family = AF_INET;
 			}
-			ipmask->cidr = strtoul(cidr, &end, 10);
-			if (*end || ipmask->family == AF_UNSPEC || (ipmask->family == AF_INET6 && ipmask->cidr > 128) || (ipmask->family == AF_INET && ipmask->cidr > 32))
+			allowedip->cidr = strtoul(cidr, &end, 10);
+			if (*end || allowedip->family == AF_UNSPEC || (allowedip->family == AF_INET6 && allowedip->cidr > 128) || (allowedip->family == AF_INET && allowedip->cidr > 32))
 				break;
-			++peer->num_ipmasks;
 		} else if (peer && !strcmp(key, "last_handshake_time_sec"))
 			peer->last_handshake_time.tv_sec = NUM(0xffffffffffffffffULL);
 		else if (peer && !strcmp(key, "last_handshake_time_nsec"))
@@ -402,32 +429,21 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 		else if (!strcmp(key, "errno"))
 			ret = -NUM(0x7fffffffU);
 		else
-			break;
+			warn_unrecognized("daemon");
 	}
 	ret = -EPROTO;
 err:
 	free(key);
-	free(*out);
+	free_wgdevice(dev);
 	*out = NULL;
 	fclose(f);
 	errno = -ret;
 	return ret;
 
 }
-#undef ADD
 #undef NUM
-#undef KEY
 
 #ifdef __linux__
-static int check_version_magic(struct wgdevice *device, int ret)
-{
-	if (ret == -EPROTO || (!ret && device->version_magic != WG_API_VERSION_MAGIC)) {
-		fprintf(stderr, "This program was built for a different version of WireGuard than\nwhat is currently running. Either this version of wg(8) is out\nof date, or the currently loaded WireGuard module is out of date.\nIf you have just updated your WireGuard installation, you may have\nforgotten to unload the previous running WireGuard module. Try\nrunning `rmmod wireguard` as root, and then try re-adding the interface\nand trying again.\n\n");
-		errno = EPROTO;
-		return -EPROTO;
-	}
-	return ret;
-}
 
 static int parse_linkinfo(const struct nlattr *attr, void *data)
 {
@@ -477,7 +493,7 @@ static int kernel_get_wireguard_interfaces(struct inflatable_buffer *buffer)
 	struct ifinfomsg *ifm;
 
 	ret = -ENOMEM;
-	rtnl_buffer = calloc(4096, 1);
+	rtnl_buffer = calloc(MNL_SOCKET_BUFFER_SIZE, 1);
 	if (!rtnl_buffer)
 		goto cleanup;
 
@@ -508,7 +524,7 @@ static int kernel_get_wireguard_interfaces(struct inflatable_buffer *buffer)
 	}
 
 another:
-	if ((len = mnl_socket_recvfrom(nl, rtnl_buffer, 4096)) < 0) {
+	if ((len = mnl_socket_recvfrom(nl, rtnl_buffer, MNL_SOCKET_BUFFER_SIZE)) < 0) {
 		ret = -errno;
 		goto cleanup;
 	}
@@ -527,82 +543,368 @@ cleanup:
 	return ret;
 }
 
-static bool kernel_has_wireguard_interface(const char *interface)
+static int kernel_set_device(struct wgdevice *dev)
 {
-	char *this_interface;
-	struct inflatable_buffer buffer = { .len = 4096 };
+	int ret = 0;
+	size_t i, j;
+	struct wgpeer *peer = NULL;
+	struct wgallowedip *allowedip = NULL;
+	struct nlattr *peers_nest, *peer_nest, *allowedips_nest, *allowedip_nest;
+	struct nlmsghdr *nlh;
+	struct mnlg_socket *nlg;
 
-	buffer.buffer = calloc(1, buffer.len);
-	if (!buffer.buffer)
-		return false;
-	if (kernel_get_wireguard_interfaces(&buffer) < 0) {
-		free(buffer.buffer);
-		return false;
+	nlg= mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
+	if (!nlg)
+		return -errno;
+
+again:
+	nlh = mnlg_msg_prepare(nlg, WG_CMD_SET_DEVICE, NLM_F_REQUEST | NLM_F_ACK);
+	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, dev->name);
+
+	if (!peer) {
+		uint32_t flags = 0;
+		if (dev->flags & WGDEVICE_HAS_PRIVATE_KEY)
+			mnl_attr_put(nlh, WGDEVICE_A_PRIVATE_KEY, sizeof(dev->private_key), dev->private_key);
+		if (dev->flags & WGDEVICE_HAS_LISTEN_PORT)
+			mnl_attr_put_u16(nlh, WGDEVICE_A_LISTEN_PORT, dev->listen_port);
+		if (dev->flags & WGDEVICE_HAS_FWMARK)
+			mnl_attr_put_u32(nlh, WGDEVICE_A_FWMARK, dev->fwmark);
+		if (dev->flags & WGDEVICE_REPLACE_PEERS)
+			flags |= WGDEVICE_F_REPLACE_PEERS;
+		if (flags)
+			mnl_attr_put_u32(nlh, WGDEVICE_A_FLAGS, flags);
 	}
-	this_interface = buffer.buffer;
-	for (size_t len = 0; (len = strlen(this_interface)); this_interface += len + 1) {
-		if (!strcmp(interface, this_interface)) {
-			free(buffer.buffer);
-			return true;
+	if (!dev->first_peer)
+		goto send;
+	peers_nest = peer_nest = allowedips_nest = allowedip_nest = NULL;
+	peers_nest = mnl_attr_nest_start(nlh, WGDEVICE_A_PEERS);
+	for (i = 0, peer = peer ? peer : dev->first_peer; peer; peer = peer->next_peer) {
+		uint32_t flags = 0;
+		peer_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, i++);
+		if (!peer_nest)
+			goto toobig_peers;
+		if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PUBLIC_KEY, sizeof(peer->public_key), peer->public_key))
+			goto toobig_peers;
+		if (peer->flags & WGPEER_REMOVE_ME)
+			flags |= WGPEER_F_REMOVE_ME;
+		if (!allowedip) {
+			if (peer->flags & WGPEER_REPLACE_ALLOWEDIPS)
+				flags |= WGPEER_F_REPLACE_ALLOWEDIPS;
+			if (peer->flags & WGPEER_HAS_PRESHARED_KEY) {
+				if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PRESHARED_KEY, sizeof(peer->preshared_key), peer->preshared_key))
+					goto toobig_peers;
+			}
+			if (peer->endpoint.addr.sa_family == AF_INET) {
+				if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr4), &peer->endpoint.addr4))
+					goto toobig_peers;
+			} else if (peer->endpoint.addr.sa_family == AF_INET6) {
+				if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ENDPOINT, sizeof(peer->endpoint.addr6), &peer->endpoint.addr6))
+					goto toobig_peers;
+			}
+			if (peer->flags & WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL) {
+				if (!mnl_attr_put_u16_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL, peer->persistent_keepalive_interval))
+					goto toobig_peers;
+			}
 		}
+		if (flags) {
+			if (!mnl_attr_put_u32_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_FLAGS, flags))
+				goto toobig_peers;
+		}
+		if (peer->first_allowedip) {
+			if (!allowedip)
+				allowedip = peer->first_allowedip;
+			allowedips_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGPEER_A_ALLOWEDIPS);
+			if (!allowedips_nest)
+				goto toobig_allowedips;
+			for (j = 0; allowedip; allowedip = allowedip->next_allowedip) {
+				allowedip_nest = mnl_attr_nest_start_check(nlh, MNL_SOCKET_BUFFER_SIZE, j++);
+				if (!allowedip_nest)
+					goto toobig_allowedips;
+				if (!mnl_attr_put_u16_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_FAMILY, allowedip->family))
+					goto toobig_allowedips;
+				if (allowedip->family == AF_INET) {
+					if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip4), &allowedip->ip4))
+						goto toobig_allowedips;
+				} else if (allowedip->family == AF_INET6) {
+					if (!mnl_attr_put_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_IPADDR, sizeof(allowedip->ip6), &allowedip->ip6))
+						goto toobig_allowedips;
+				}
+				if (!mnl_attr_put_u8_check(nlh, MNL_SOCKET_BUFFER_SIZE, WGALLOWEDIP_A_CIDR_MASK, allowedip->cidr))
+					goto toobig_allowedips;
+				mnl_attr_nest_end(nlh, allowedip_nest);
+				allowedip_nest = NULL;
+			}
+			mnl_attr_nest_end(nlh, allowedips_nest);
+			allowedips_nest = NULL;
+		}
+
+		mnl_attr_nest_end(nlh, peer_nest);
+		peer_nest = NULL;
 	}
-	free(buffer.buffer);
-	return false;
+	mnl_attr_nest_end(nlh, peers_nest);
+	peers_nest = NULL;
+	goto send;
+toobig_allowedips:
+	if (allowedip_nest)
+		mnl_attr_nest_cancel(nlh, allowedip_nest);
+	if (allowedips_nest)
+		mnl_attr_nest_end(nlh, allowedips_nest);
+	mnl_attr_nest_end(nlh, peer_nest);
+	mnl_attr_nest_end(nlh, peers_nest);
+	goto send;
+toobig_peers:
+	if (peer_nest)
+		mnl_attr_nest_cancel(nlh, peer_nest);
+	mnl_attr_nest_end(nlh, peers_nest);
+	goto send;
+send:
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		ret = -errno;
+		goto out;
+	}
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, NULL, NULL) < 0) {
+		ret = errno ? -errno : -EINVAL;
+		goto out;
+	}
+	if (peer)
+		goto again;
+
+out:
+	mnlg_socket_close(nlg);
+	errno = -ret;
+	return ret;
 }
 
-static int do_ioctl(int req, struct ifreq *ifreq)
+struct get_device_ctx {
+	struct wgdevice *device;
+	struct wgpeer *peer;
+	struct wgallowedip *allowedip;
+};
+
+static int parse_allowedip(const struct nlattr *attr, void *data)
 {
-	static int fd = -1;
+	struct get_device_ctx *ctx = data;
+
+	switch (mnl_attr_get_type(attr)) {
+	case WGALLOWEDIP_A_FAMILY:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
+			ctx->allowedip->family = mnl_attr_get_u16(attr);
+		break;
+	case WGALLOWEDIP_A_IPADDR:
+		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->allowedip->ip4))
+			memcpy(&ctx->allowedip->ip4, mnl_attr_get_payload(attr), sizeof(ctx->allowedip->ip4));
+		else if (mnl_attr_get_payload_len(attr) == sizeof(ctx->allowedip->ip6))
+			memcpy(&ctx->allowedip->ip6, mnl_attr_get_payload(attr), sizeof(ctx->allowedip->ip6));
+		break;
+	case WGALLOWEDIP_A_CIDR_MASK:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U8))
+			ctx->allowedip->cidr = mnl_attr_get_u8(attr);
+		break;
+	default:
+		warn_unrecognized("kernel");
+	}
+
+	return MNL_CB_OK;
+}
+
+static int parse_allowedips(const struct nlattr *attr, void *data)
+{
+	struct get_device_ctx *ctx = data;
+	struct wgallowedip *new_allowedip = calloc(1, sizeof(struct wgallowedip));
 	int ret;
-	if (fd < 0) {
-		fd = socket(AF_INET, SOCK_DGRAM, 0);
-		if (fd < 0)
-			return fd;
+	if (!new_allowedip) {
+		perror("calloc");
+		return MNL_CB_ERROR;
 	}
-	ret = ioctl(fd, req, ifreq);
-	if (ret == -1)
-		ret = -errno;
-	return ret;
+	if (ctx->allowedip)
+		ctx->allowedip->next_allowedip = new_allowedip;
+	else
+		ctx->peer->first_allowedip = new_allowedip;
+	ctx->allowedip = new_allowedip;
+	ret = mnl_attr_parse_nested(attr, parse_allowedip, ctx);
+	if (!ret)
+		return ret;
+	if (!((ctx->allowedip->family == AF_INET && ctx->allowedip->cidr <= 32) || (ctx->allowedip->family == AF_INET6 && ctx->allowedip->cidr <= 128)))
+		return MNL_CB_ERROR;
+	return MNL_CB_OK;
 }
 
-static int kernel_set_device(struct wgdevice *dev)
+static int parse_peer(const struct nlattr *attr, void *data)
 {
-	struct ifreq ifreq = { .ifr_data = (char *)dev };
-	memcpy(&ifreq.ifr_name, dev->interface, IFNAMSIZ);
-	ifreq.ifr_name[IFNAMSIZ - 1] = 0;
-	dev->version_magic = WG_API_VERSION_MAGIC;
-	return check_version_magic(dev, do_ioctl(WG_SET_DEVICE, &ifreq));
+	struct get_device_ctx *ctx = data;
+
+	switch (mnl_attr_get_type(attr)) {
+	case WGPEER_A_PUBLIC_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->public_key))
+			memcpy(ctx->peer->public_key, mnl_attr_get_payload(attr), sizeof(ctx->peer->public_key));
+		break;
+	case WGPEER_A_PRESHARED_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->preshared_key))
+			memcpy(ctx->peer->preshared_key, mnl_attr_get_payload(attr), sizeof(ctx->peer->preshared_key));
+		break;
+	case WGPEER_A_ENDPOINT: {
+		struct sockaddr *addr;
+		if (mnl_attr_get_payload_len(attr) < sizeof(*addr))
+			break;
+		addr = mnl_attr_get_payload(attr);
+		if (addr->sa_family == AF_INET && mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->endpoint.addr4))
+			memcpy(&ctx->peer->endpoint.addr4, addr, sizeof(ctx->peer->endpoint.addr4));
+		else if (addr->sa_family == AF_INET6 && mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->endpoint.addr6))
+			memcpy(&ctx->peer->endpoint.addr6, addr, sizeof(ctx->peer->endpoint.addr6));
+		break;
+	}
+	case WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
+			ctx->peer->persistent_keepalive_interval = mnl_attr_get_u16(attr);
+		break;
+	case WGPEER_A_LAST_HANDSHAKE_TIME:
+		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->peer->last_handshake_time))
+			memcpy(&ctx->peer->last_handshake_time, mnl_attr_get_payload(attr), sizeof(ctx->peer->last_handshake_time));
+		break;
+	case WGPEER_A_RX_BYTES:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
+			ctx->peer->rx_bytes = mnl_attr_get_u64(attr);
+		break;
+	case WGPEER_A_TX_BYTES:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U64))
+			ctx->peer->tx_bytes = mnl_attr_get_u64(attr);
+		break;
+	case WGPEER_A_ALLOWEDIPS:
+		return mnl_attr_parse_nested(attr, parse_allowedips, ctx);
+	default:
+		warn_unrecognized("kernel");
+	}
+
+	return MNL_CB_OK;
 }
 
-static int kernel_get_device(struct wgdevice **dev, const char *interface)
+static int parse_peers(const struct nlattr *attr, void *data)
 {
+	struct get_device_ctx *ctx = data;
+	struct wgpeer *new_peer = calloc(1, sizeof(struct wgpeer));
 	int ret;
-	struct ifreq ifreq = { 0 };
-	memcpy(&ifreq.ifr_name, interface, IFNAMSIZ);
-	ifreq.ifr_name[IFNAMSIZ - 1] = 0;
-	*dev = NULL;
-	do {
-		free(*dev);
-		ret = do_ioctl(WG_GET_DEVICE, &ifreq);
-		if (ret < 0)
-			goto out;
-		*dev = calloc(1, ret + sizeof(struct wgdevice));
-		ret = -ENOMEM;
-		if (!*dev)
-			goto out;
-		(*dev)->peers_size = ret;
-		(*dev)->version_magic = WG_API_VERSION_MAGIC;
-		ifreq.ifr_data = (char *)*dev;
-		memcpy(&ifreq.ifr_name, interface, IFNAMSIZ);
-		ifreq.ifr_name[IFNAMSIZ - 1] = 0;
-		ret = do_ioctl(WG_GET_DEVICE, &ifreq);
-	} while (ret == -EMSGSIZE);
-	ret = check_version_magic(*dev, ret);
-	if (ret < 0) {
-		free(*dev);
+	if (!new_peer) {
+		perror("calloc");
+		return MNL_CB_ERROR;
+	}
+	if (ctx->peer)
+		ctx->peer->next_peer = new_peer;
+	else
+		ctx->device->first_peer = new_peer;
+	ctx->peer = new_peer;
+	ctx->allowedip = NULL;
+	ret = mnl_attr_parse_nested(attr, parse_peer, ctx);
+	if (!ret)
+		return ret;
+	if (key_is_zero(ctx->peer->public_key))
+		return MNL_CB_ERROR;
+	return MNL_CB_OK;
+}
+
+static int parse_device(const struct nlattr *attr, void *data)
+{
+	struct get_device_ctx *ctx = data;
+
+	switch (mnl_attr_get_type(attr)) {
+	case WGDEVICE_A_IFINDEX:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
+			ctx->device->ifindex = mnl_attr_get_u32(attr);
+		break;
+	case WGDEVICE_A_IFNAME:
+		if (!mnl_attr_validate(attr, MNL_TYPE_STRING))
+			strncpy(ctx->device->name, mnl_attr_get_str(attr), sizeof(ctx->device->name) - 1);
+		break;
+	case WGDEVICE_A_PRIVATE_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->device->private_key))
+			memcpy(ctx->device->private_key, mnl_attr_get_payload(attr), sizeof(ctx->device->private_key));
+		break;
+	case WGDEVICE_A_PUBLIC_KEY:
+		if (mnl_attr_get_payload_len(attr) == sizeof(ctx->device->public_key))
+			memcpy(ctx->device->public_key, mnl_attr_get_payload(attr), sizeof(ctx->device->public_key));
+		break;
+	case WGDEVICE_A_LISTEN_PORT:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U16))
+			ctx->device->listen_port = mnl_attr_get_u16(attr);
+		break;
+	case WGDEVICE_A_FWMARK:
+		if (!mnl_attr_validate(attr, MNL_TYPE_U32))
+			ctx->device->fwmark = mnl_attr_get_u32(attr);
+		break;
+	case WGDEVICE_A_PEERS:
+		return mnl_attr_parse_nested(attr, parse_peers, ctx);
+	default:
+		warn_unrecognized("kernel");
+	}
+
+	return MNL_CB_OK;
+}
+
+static int read_device_cb(const struct nlmsghdr *nlh, void *data)
+{
+	return mnl_attr_parse(nlh, sizeof(struct genlmsghdr), parse_device, data);
+}
+
+static void coalesce_peers(struct wgdevice *device)
+{
+	struct wgallowedip *allowedip;
+	struct wgpeer *old_next_peer, *peer = device->first_peer;
+	while (peer && peer->next_peer) {
+		if (memcmp(peer->public_key, peer->next_peer->public_key, WG_KEY_LEN)) {
+			peer = peer->next_peer;
+			continue;
+		}
+		/* TODO: It would be more efficient to store the tail, rather than having to seek to the end each time. */
+		for (allowedip = peer->first_allowedip; allowedip && allowedip->next_allowedip; allowedip = allowedip->next_allowedip);
+
+		if (!allowedip)
+			peer->first_allowedip = peer->next_peer->first_allowedip;
+		else
+			allowedip->next_allowedip = peer->next_peer->first_allowedip;
+		old_next_peer = peer->next_peer;
+		peer->next_peer = old_next_peer->next_peer;
+		free(old_next_peer);
+	}
+}
+
+static int kernel_get_device(struct wgdevice **dev, const char *interface)
+{
+	int ret = 0;
+	struct nlmsghdr *nlh;
+	struct mnlg_socket *nlg;
+	struct get_device_ctx ctx = { 0 };
+
+	*dev = ctx.device = calloc(1, sizeof(struct wgdevice));
+	if (!*dev)
+		return -errno;
+
+	nlg= mnlg_socket_open(WG_GENL_NAME, WG_GENL_VERSION);
+	if (!nlg) {
+		free_wgdevice(*dev);
 		*dev = NULL;
+		return -errno;
 	}
+
+	nlh = mnlg_msg_prepare(nlg, WG_CMD_GET_DEVICE, NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP);
+	mnl_attr_put_strz(nlh, WGDEVICE_A_IFNAME, interface);
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		ret = -errno;
+		goto out;
+	}
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, read_device_cb, &ctx) < 0) {
+		ret = errno ? -errno : -EINVAL;
+		goto out;
+	}
+	coalesce_peers(*dev);
+
 out:
+	if (nlg)
+		mnlg_socket_close(nlg);
+	if (ret) {
+		free_wgdevice(*dev);
+		*dev = NULL;
+	}
 	errno = -ret;
 	return ret;
 }
@@ -611,7 +913,7 @@ out:
 /* first\0second\0third\0forth\0last\0\0 */
 char *ipc_list_devices(void)
 {
-	struct inflatable_buffer buffer = { .len = 4096 };
+	struct inflatable_buffer buffer = { .len = MNL_SOCKET_BUFFER_SIZE };
 	int ret;
 
 	ret = -ENOMEM;
@@ -652,19 +954,10 @@ int ipc_get_device(struct wgdevice **dev, const char *interface)
 int ipc_set_device(struct wgdevice *dev)
 {
 #ifdef __linux__
-	if (userspace_has_wireguard_interface(dev->interface))
+	if (userspace_has_wireguard_interface(dev->name))
 		return userspace_set_device(dev);
 	return kernel_set_device(dev);
 #else
 	return userspace_set_device(dev);
 #endif
 }
-
-bool ipc_has_device(const char *interface)
-{
-#ifdef __linux__
-	return userspace_has_wireguard_interface(interface) || kernel_has_wireguard_interface(interface);
-#else
-	return userspace_has_wireguard_interface(interface);
-#endif
-}
diff --git a/src/ipc.h b/src/ipc.h
index 2412610..cb660bb 100644
--- a/src/ipc.h
+++ b/src/ipc.h
@@ -10,6 +10,5 @@ struct wgdevice;
 int ipc_set_device(struct wgdevice *dev);
 int ipc_get_device(struct wgdevice **dev, const char *interface);
 char *ipc_list_devices(void);
-bool ipc_has_device(const char *interface);
 
 #endif
diff --git a/src/mnlg.c b/src/mnlg.c
new file mode 100644
index 0000000..ff70bdc
--- /dev/null
+++ b/src/mnlg.c
@@ -0,0 +1,327 @@
+/* Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * Original author: Jiri Pirko <jiri@mellanox.com> */
+
+#ifdef __linux__
+
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <time.h>
+#include <libmnl/libmnl.h>
+#include <linux/genetlink.h>
+
+#include "mnlg.h"
+
+struct mnlg_socket {
+	struct mnl_socket *nl;
+	char *buf;
+	uint32_t id;
+	uint8_t version;
+	unsigned int seq;
+	unsigned int portid;
+};
+
+static struct nlmsghdr *__mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
+					   uint16_t flags, uint32_t id,
+					   uint8_t version)
+{
+	struct nlmsghdr *nlh;
+	struct genlmsghdr *genl;
+
+	nlh = mnl_nlmsg_put_header(nlg->buf);
+	nlh->nlmsg_type	= id;
+	nlh->nlmsg_flags = flags;
+	nlg->seq = time(NULL);
+	nlh->nlmsg_seq = nlg->seq;
+
+	genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
+	genl->cmd = cmd;
+	genl->version = version;
+
+	return nlh;
+}
+
+struct nlmsghdr *mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
+				  uint16_t flags)
+{
+	return __mnlg_msg_prepare(nlg, cmd, flags, nlg->id, nlg->version);
+}
+
+int mnlg_socket_send(struct mnlg_socket *nlg, const struct nlmsghdr *nlh)
+{
+	return mnl_socket_sendto(nlg->nl, nlh, nlh->nlmsg_len);
+}
+
+static int mnlg_cb_noop(const struct nlmsghdr *nlh, void *data)
+{
+	(void)nlh;
+	(void)data;
+	return MNL_CB_OK;
+}
+
+static int mnlg_cb_error(const struct nlmsghdr *nlh, void *data)
+{
+	const struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);
+	(void)data;
+
+	if (nlh->nlmsg_len < mnl_nlmsg_size(sizeof(struct nlmsgerr))) {
+		errno = EBADMSG;
+		return MNL_CB_ERROR;
+	}
+	/* Netlink subsystems returns the errno value with different signess */
+	if (err->error < 0)
+		errno = -err->error;
+	else
+		errno = err->error;
+
+	return err->error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+}
+
+static int mnlg_cb_stop(const struct nlmsghdr *nlh, void *data)
+{
+	(void)data;
+	if (nlh->nlmsg_flags & NLM_F_MULTI && nlh->nlmsg_len == mnl_nlmsg_size(sizeof(int))) {
+		int error = *(int *)mnl_nlmsg_get_payload(nlh);
+		/* Netlink subsystems returns the errno value with different signess */
+		if (error < 0)
+			errno = -error;
+		else
+			errno = error;
+
+		return error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+	}
+	return MNL_CB_STOP;
+}
+
+static mnl_cb_t mnlg_cb_array[] = {
+	[NLMSG_NOOP]	= mnlg_cb_noop,
+	[NLMSG_ERROR]	= mnlg_cb_error,
+	[NLMSG_DONE]	= mnlg_cb_stop,
+	[NLMSG_OVERRUN]	= mnlg_cb_noop,
+};
+
+int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data)
+{
+	int err;
+
+	do {
+		err = mnl_socket_recvfrom(nlg->nl, nlg->buf,
+					  MNL_SOCKET_BUFFER_SIZE);
+		if (err <= 0)
+			break;
+		err = mnl_cb_run2(nlg->buf, err, nlg->seq, nlg->portid,
+				  data_cb, data, mnlg_cb_array, sizeof(mnlg_cb_array) / sizeof(mnlg_cb_array[0]));
+	} while (err > 0);
+
+	return err;
+}
+
+struct group_info {
+	bool found;
+	uint32_t id;
+	const char *name;
+};
+
+static int parse_mc_grps_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, CTRL_ATTR_MCAST_GRP_MAX) < 0)
+		return MNL_CB_OK;
+
+	switch (type) {
+	case CTRL_ATTR_MCAST_GRP_ID:
+		if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0)
+			return MNL_CB_ERROR;
+		break;
+	case CTRL_ATTR_MCAST_GRP_NAME:
+		if (mnl_attr_validate(attr, MNL_TYPE_STRING) < 0)
+			return MNL_CB_ERROR;
+		break;
+	}
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static void parse_genl_mc_grps(struct nlattr *nested,
+			       struct group_info *group_info)
+{
+	struct nlattr *pos;
+	const char *name;
+
+	mnl_attr_for_each_nested(pos, nested) {
+		struct nlattr *tb[CTRL_ATTR_MCAST_GRP_MAX + 1] = {};
+
+		mnl_attr_parse_nested(pos, parse_mc_grps_cb, tb);
+		if (!tb[CTRL_ATTR_MCAST_GRP_NAME] ||
+		    !tb[CTRL_ATTR_MCAST_GRP_ID])
+			continue;
+
+		name = mnl_attr_get_str(tb[CTRL_ATTR_MCAST_GRP_NAME]);
+		if (strcmp(name, group_info->name) != 0)
+			continue;
+
+		group_info->id = mnl_attr_get_u32(tb[CTRL_ATTR_MCAST_GRP_ID]);
+		group_info->found = true;
+	}
+}
+
+static int get_group_id_attr_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
+		return MNL_CB_ERROR;
+
+	if (type == CTRL_ATTR_MCAST_GROUPS &&
+	    mnl_attr_validate(attr, MNL_TYPE_NESTED) < 0)
+		return MNL_CB_ERROR;
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static int get_group_id_cb(const struct nlmsghdr *nlh, void *data)
+{
+	struct group_info *group_info = data;
+	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
+
+	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_group_id_attr_cb, tb);
+	if (!tb[CTRL_ATTR_MCAST_GROUPS])
+		return MNL_CB_ERROR;
+	parse_genl_mc_grps(tb[CTRL_ATTR_MCAST_GROUPS], group_info);
+	return MNL_CB_OK;
+}
+
+int mnlg_socket_group_add(struct mnlg_socket *nlg, const char *group_name)
+{
+	struct nlmsghdr *nlh;
+	struct group_info group_info;
+	int err;
+
+	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
+				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
+	mnl_attr_put_u32(nlh, CTRL_ATTR_FAMILY_ID, nlg->id);
+
+	err = mnlg_socket_send(nlg, nlh);
+	if (err < 0)
+		return err;
+
+	group_info.found = false;
+	group_info.name = group_name;
+	err = mnlg_socket_recv_run(nlg, get_group_id_cb, &group_info);
+	if (err < 0)
+		return err;
+
+	if (!group_info.found) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	err = mnl_socket_setsockopt(nlg->nl, NETLINK_ADD_MEMBERSHIP,
+				    &group_info.id, sizeof(group_info.id));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int get_family_id_attr_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
+		return MNL_CB_ERROR;
+
+	if (type == CTRL_ATTR_FAMILY_ID &&
+	    mnl_attr_validate(attr, MNL_TYPE_U16) < 0)
+		return MNL_CB_ERROR;
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static int get_family_id_cb(const struct nlmsghdr *nlh, void *data)
+{
+	uint32_t *p_id = data;
+	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
+
+	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_family_id_attr_cb, tb);
+	if (!tb[CTRL_ATTR_FAMILY_ID])
+		return MNL_CB_ERROR;
+	*p_id = mnl_attr_get_u16(tb[CTRL_ATTR_FAMILY_ID]);
+	return MNL_CB_OK;
+}
+
+struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t version)
+{
+	struct mnlg_socket *nlg;
+	struct nlmsghdr *nlh;
+	int err;
+
+	nlg = malloc(sizeof(*nlg));
+	if (!nlg)
+		return NULL;
+
+	err = -ENOMEM;
+	nlg->buf = malloc(MNL_SOCKET_BUFFER_SIZE);
+	if (!nlg->buf)
+		goto err_buf_alloc;
+
+	nlg->nl = mnl_socket_open(NETLINK_GENERIC);
+	if (!nlg->nl) {
+		err = -errno;
+		goto err_mnl_socket_open;
+	}
+
+	if (mnl_socket_bind(nlg->nl, 0, MNL_SOCKET_AUTOPID) < 0) {
+		err = -errno;
+		goto err_mnl_socket_bind;
+	}
+
+	nlg->portid = mnl_socket_get_portid(nlg->nl);
+
+	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
+				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
+	mnl_attr_put_strz(nlh, CTRL_ATTR_FAMILY_NAME, family_name);
+
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		err = -errno;
+		goto err_mnlg_socket_send;
+	}
+
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, get_family_id_cb, &nlg->id) < 0) {
+		errno = errno == ENOENT ? EPROTONOSUPPORT : errno;
+		err = errno ? -errno : -ENOSYS;
+		goto err_mnlg_socket_recv_run;
+	}
+
+	nlg->version = version;
+	errno = 0;
+	return nlg;
+
+err_mnlg_socket_recv_run:
+err_mnlg_socket_send:
+err_mnl_socket_bind:
+	mnl_socket_close(nlg->nl);
+err_mnl_socket_open:
+	free(nlg->buf);
+err_buf_alloc:
+	free(nlg);
+	errno = -err;
+	return NULL;
+}
+
+void mnlg_socket_close(struct mnlg_socket *nlg)
+{
+	mnl_socket_close(nlg->nl);
+	free(nlg->buf);
+	free(nlg);
+}
+
+#endif
diff --git a/src/mnlg.h b/src/mnlg.h
new file mode 100644
index 0000000..46c53ba
--- /dev/null
+++ b/src/mnlg.h
@@ -0,0 +1,22 @@
+/* Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * Original author: Jiri Pirko <jiri@mellanox.com> */
+
+#ifndef MNLG_H
+#define MNLG_H
+#ifdef __linux__
+
+#include <libmnl/libmnl.h>
+
+struct mnlg_socket;
+
+struct nlmsghdr *mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
+				  uint16_t flags);
+int mnlg_socket_send(struct mnlg_socket *nlg, const struct nlmsghdr *nlh);
+int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data);
+int mnlg_socket_group_add(struct mnlg_socket *nlg, const char *group_name);
+struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t version);
+void mnlg_socket_close(struct mnlg_socket *nlg);
+
+#endif
+#endif
diff --git a/src/set.c b/src/set.c
index 497edcc..57a6428 100644
--- a/src/set.c
+++ b/src/set.c
@@ -3,9 +3,11 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include "subcommands.h"
+
+#include "containers.h"
 #include "config.h"
 #include "ipc.h"
+#include "subcommands.h"
 
 int set_main(int argc, char *argv[])
 {
@@ -17,10 +19,11 @@ int set_main(int argc, char *argv[])
 		return 1;
 	}
 
-	if (!config_read_cmd(&device, argv + 2, argc - 2))
+	device = config_read_cmd(argv + 2, argc - 2);
+	if (!device)
 		goto cleanup;
-	strncpy(device->interface, argv[1], IFNAMSIZ -  1);
-	device->interface[IFNAMSIZ - 1] = 0;
+	strncpy(device->name, argv[1], IFNAMSIZ -  1);
+	device->name[IFNAMSIZ - 1] = 0;
 
 	if (ipc_set_device(device) != 0) {
 		perror("Unable to set device");
@@ -30,6 +33,6 @@ int set_main(int argc, char *argv[])
 	ret = 0;
 
 cleanup:
-	free(device);
+	free_wgdevice(device);
 	return ret;
 }
diff --git a/src/setconf.c b/src/setconf.c
index c70edab..1857ff6 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -5,6 +5,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "containers.h"
 #include "config.h"
 #include "ipc.h"
 #include "subcommands.h"
@@ -28,7 +29,7 @@ int setconf_main(int argc, char *argv[])
 		perror("fopen");
 		return 1;
 	}
-	if (!config_read_init(&ctx, &device, !strcmp(argv[0], "addconf"))) {
+	if (!config_read_init(&ctx, !strcmp(argv[0], "addconf"))) {
 		fclose(config_input);
 		return 1;
 	}
@@ -38,12 +39,13 @@ int setconf_main(int argc, char *argv[])
 			goto cleanup;
 		}
 	}
-	if (!config_read_finish(&ctx) || !device) {
+	device = config_read_finish(&ctx);
+	if (!device) {
 		fprintf(stderr, "Invalid configuration\n");
 		goto cleanup;
 	}
-	strncpy(device->interface, argv[1], IFNAMSIZ - 1);
-	device->interface[IFNAMSIZ - 1] = 0;
+	strncpy(device->name, argv[1], IFNAMSIZ - 1);
+	device->name[IFNAMSIZ - 1] = 0;
 
 	if (ipc_set_device(device) != 0) {
 		perror("Unable to set device");
@@ -56,6 +58,6 @@ cleanup:
 	if (config_input)
 		fclose(config_input);
 	free(config_buffer);
-	free(device);
+	free_wgdevice(device);
 	return ret;
 }
diff --git a/src/show.c b/src/show.c
index 6e5de96..476d002 100644
--- a/src/show.c
+++ b/src/show.c
@@ -13,11 +13,11 @@
 #include <time.h>
 #include <netdb.h>
 
+#include "containers.h"
 #include "ipc.h"
-#include "subcommands.h"
 #include "terminal.h"
 #include "encoding.h"
-#include "../uapi.h"
+#include "subcommands.h"
 
 static int peer_cmp(const void *first, const void *second)
 {
@@ -37,42 +37,29 @@ static int peer_cmp(const void *first, const void *second)
 	return 0;
 }
 
+/* This, hilariously, is not the right way to sort a linked list... */
 static void sort_peers(struct wgdevice *device)
 {
-	uint8_t *new_device, *pos;
-	struct wgpeer **peers;
-	struct wgpeer *peer;
-	size_t i, len;
+	size_t peer_count = 0, i = 0;
+	struct wgpeer *peer, **peers;
 
-	peers = calloc(device->num_peers, sizeof(struct wgpeer *));
-	if (!peers)
+	for_each_wgpeer (device, peer)
+		++peer_count;
+	if (!peer_count)
 		return;
-
-	len = sizeof(struct wgdevice);
-	for_each_wgpeer(device, peer, i)
-		len += sizeof(struct wgpeer) + (peer->num_ipmasks * sizeof(struct wgipmask));
-	pos = new_device = malloc(len);
-	if (!new_device) {
-		free(peers);
+	peers = calloc(peer_count, sizeof(struct wgpeer *));
+	if (!peers)
 		return;
-	}
-
-	memcpy(pos, device, sizeof(struct wgdevice));
-	pos += sizeof(struct wgdevice);
-
-	for_each_wgpeer(device, peer, i)
-		peers[i] = peer;
-
-	qsort(peers, device->num_peers, sizeof(struct wgpeer *), peer_cmp);
-	for (i = 0; i < device->num_peers; ++i) {
-		len = sizeof(struct wgpeer) + (peers[i]->num_ipmasks * sizeof(struct wgipmask));
-		memcpy(pos, peers[i], len);
-		pos += len;
+	for_each_wgpeer (device, peer)
+		peers[i++] = peer;
+	qsort(peers, peer_count, sizeof(struct wgpeer *), peer_cmp);
+	device->first_peer = peers[0];
+	peers[0]->next_peer = NULL;
+	for (i = 1; i < peer_count; ++i) {
+		peers[i - 1]->next_peer = peers[i];
+		peers[i]->next_peer = NULL;
 	}
 	free(peers);
-
-	memcpy(device, new_device, pos - new_device);
-	free(new_device);
 }
 
 static char *key(const uint8_t key[static WG_KEY_LEN])
@@ -92,7 +79,7 @@ static char *masked_key(const uint8_t masked_key[static WG_KEY_LEN])
 	return "(hidden)";
 }
 
-static char *ip(const struct wgipmask *ip)
+static char *ip(const struct wgallowedip *ip)
 {
 	static char buf[INET6_ADDRSTRLEN + 1];
 	memset(buf, 0, INET6_ADDRSTRLEN + 1);
@@ -204,34 +191,33 @@ static void show_usage(void)
 
 static void pretty_print(struct wgdevice *device)
 {
-	size_t i, j;
 	struct wgpeer *peer;
-	struct wgipmask *ipmask;
+	struct wgallowedip *allowedip;
 
 	terminal_printf(TERMINAL_RESET);
-	terminal_printf(TERMINAL_FG_GREEN TERMINAL_BOLD "interface" TERMINAL_RESET ": " TERMINAL_FG_GREEN "%s" TERMINAL_RESET "\n", device->interface);
+	terminal_printf(TERMINAL_FG_GREEN TERMINAL_BOLD "interface" TERMINAL_RESET ": " TERMINAL_FG_GREEN "%s" TERMINAL_RESET "\n", device->name);
 	if (!key_is_zero(device->public_key))
 		terminal_printf("  " TERMINAL_BOLD "public key" TERMINAL_RESET ": %s\n", key(device->public_key));
 	if (!key_is_zero(device->private_key))
 		terminal_printf("  " TERMINAL_BOLD "private key" TERMINAL_RESET ": %s\n", masked_key(device->private_key));
-	if (device->port)
-		terminal_printf("  " TERMINAL_BOLD "listening port" TERMINAL_RESET ": %u\n", device->port);
+	if (device->listen_port)
+		terminal_printf("  " TERMINAL_BOLD "listening port" TERMINAL_RESET ": %u\n", device->listen_port);
 	if (device->fwmark)
 		terminal_printf("  " TERMINAL_BOLD "fwmark" TERMINAL_RESET ": 0x%x\n", device->fwmark);
-	if (device->num_peers) {
+	if (device->first_peer) {
 		sort_peers(device);
 		terminal_printf("\n");
 	}
-	for_each_wgpeer(device, peer, i) {
+	for_each_wgpeer (device, peer) {
 		terminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD "peer" TERMINAL_RESET ": " TERMINAL_FG_YELLOW "%s" TERMINAL_RESET "\n", key(peer->public_key));
 		if (!key_is_zero(peer->preshared_key))
 			terminal_printf("  " TERMINAL_BOLD "preshared key" TERMINAL_RESET ": %s\n", masked_key(peer->preshared_key));
 		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
 			terminal_printf("  " TERMINAL_BOLD "endpoint" TERMINAL_RESET ": %s\n", endpoint(&peer->endpoint.addr));
 		terminal_printf("  " TERMINAL_BOLD "allowed ips" TERMINAL_RESET ": ");
-		if (peer->num_ipmasks) {
-			for_each_wgipmask(peer, ipmask, j)
-				terminal_printf("%s" TERMINAL_FG_CYAN "/" TERMINAL_RESET "%u%s", ip(ipmask), ipmask->cidr, j == (size_t)peer->num_ipmasks - 1 ? "\n" : ", ");
+		if (peer->first_allowedip) {
+			for_each_wgallowedip (peer, allowedip)
+				terminal_printf("%s" TERMINAL_FG_CYAN "/" TERMINAL_RESET "%u%s", ip(allowedip), allowedip->cidr, allowedip->next_allowedip ? ", " : "\n");
 		} else
 			terminal_printf("(none)\n");
 		if (peer->last_handshake_time.tv_sec)
@@ -243,38 +229,37 @@ static void pretty_print(struct wgdevice *device)
 		}
 		if (peer->persistent_keepalive_interval)
 			terminal_printf("  " TERMINAL_BOLD "persistent keepalive" TERMINAL_RESET ": %s\n", every(peer->persistent_keepalive_interval));
-		if (i + 1 < device->num_peers)
+		if (peer->next_peer)
 			terminal_printf("\n");
 	}
 }
 
 static void dump_print(struct wgdevice *device, bool with_interface)
 {
-	size_t i, j;
 	struct wgpeer *peer;
-	struct wgipmask *ipmask;
+	struct wgallowedip *allowedip;
 
 	if (with_interface)
-		printf("%s\t", device->interface);
+		printf("%s\t", device->name);
 	printf("%s\t", key(device->private_key));
 	printf("%s\t", key(device->public_key));
-	printf("%u\t", device->port);
+	printf("%u\t", device->listen_port);
 	if (device->fwmark)
 		printf("0x%x\n", device->fwmark);
 	else
 		printf("off\n");
-	for_each_wgpeer(device, peer, i) {
+	for_each_wgpeer (device, peer) {
 		if (with_interface)
-			printf("%s\t", device->interface);
+			printf("%s\t", device->name);
 		printf("%s\t", key(peer->public_key));
 		printf("%s\t", key(peer->preshared_key));
 		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
 			printf("%s\t", endpoint(&peer->endpoint.addr));
 		else
 			printf("(none)\t");
-		if (peer->num_ipmasks) {
-			for_each_wgipmask(peer, ipmask, j)
-				printf("%s/%u%c", ip(ipmask), ipmask->cidr, j == (size_t)peer->num_ipmasks - 1 ? '\t' : ',');
+		if (peer->first_allowedip) {
+			for_each_wgallowedip (peer, allowedip)
+				printf("%s/%u%c", ip(allowedip), allowedip->cidr, allowedip->next_allowedip ? ',' : '\t');
 		} else
 			printf("(none)\t");
 		printf("%llu\t", (unsigned long long)peer->last_handshake_time.tv_sec);
@@ -288,32 +273,31 @@ static void dump_print(struct wgdevice *device, bool with_interface)
 
 static bool ugly_print(struct wgdevice *device, const char *param, bool with_interface)
 {
-	size_t i, j;
 	struct wgpeer *peer;
-	struct wgipmask *ipmask;
+	struct wgallowedip *allowedip;
 	if (!strcmp(param, "public-key")) {
 		if (with_interface)
-			printf("%s\t", device->interface);
+			printf("%s\t", device->name);
 		printf("%s\n", key(device->public_key));
 	} else if (!strcmp(param, "private-key")) {
 		if (with_interface)
-			printf("%s\t", device->interface);
+			printf("%s\t", device->name);
 		printf("%s\n", key(device->private_key));
 	} else if (!strcmp(param, "listen-port")) {
 		if (with_interface)
-			printf("%s\t", device->interface);
-		printf("%u\n", device->port);
+			printf("%s\t", device->name);
+		printf("%u\n", device->listen_port);
 	} else if (!strcmp(param, "fwmark")) {
 		if (with_interface)
-			printf("%s\t", device->interface);
+			printf("%s\t", device->name);
 		if (device->fwmark)
 			printf("0x%x\n", device->fwmark);
 		else
 			printf("off\n");
 	} else if (!strcmp(param, "endpoints")) {
 		if (with_interface)
-			printf("%s\t", device->interface);
-		for_each_wgpeer(device, peer, i) {
+			printf("%s\t", device->name);
+		for_each_wgpeer (device, peer) {
 			printf("%s\t", key(peer->public_key));
 			if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
 				printf("%s\n", endpoint(&peer->endpoint.addr));
@@ -321,48 +305,48 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 				printf("(none)\n");
 		}
 	} else if (!strcmp(param, "allowed-ips")) {
-		for_each_wgpeer(device, peer, i) {
+		for_each_wgpeer (device, peer) {
 			if (with_interface)
-				printf("%s\t", device->interface);
+				printf("%s\t", device->name);
 			printf("%s\t", key(peer->public_key));
-			if (peer->num_ipmasks) {
-				for_each_wgipmask(peer, ipmask, j)
-					printf("%s/%u%c", ip(ipmask), ipmask->cidr, j == (size_t)peer->num_ipmasks - 1 ? '\n' : ' ');
+			if (peer->first_allowedip) {
+				for_each_wgallowedip (peer, allowedip)
+					printf("%s/%u%c", ip(allowedip), allowedip->cidr, allowedip->next_allowedip ? ' ' : '\n');
 			} else
 				printf("(none)\n");
 		}
 	} else if (!strcmp(param, "latest-handshakes")) {
-		for_each_wgpeer(device, peer, i) {
+		for_each_wgpeer (device, peer) {
 			if (with_interface)
-				printf("%s\t", device->interface);
+				printf("%s\t", device->name);
 			printf("%s\t%llu\n", key(peer->public_key), (unsigned long long)peer->last_handshake_time.tv_sec);
 		}
 	} else if (!strcmp(param, "transfer")) {
-		for_each_wgpeer(device, peer, i) {
+		for_each_wgpeer (device, peer) {
 			if (with_interface)
-				printf("%s\t", device->interface);
+				printf("%s\t", device->name);
 			printf("%s\t%" PRIu64 "\t%" PRIu64 "\n", key(peer->public_key), (uint64_t)peer->rx_bytes, (uint64_t)peer->tx_bytes);
 		}
 	} else if (!strcmp(param, "persistent-keepalive")) {
-		for_each_wgpeer(device, peer, i) {
+		for_each_wgpeer (device, peer) {
 			if (with_interface)
-				printf("%s\t", device->interface);
+				printf("%s\t", device->name);
 			if (peer->persistent_keepalive_interval)
 				printf("%s\t%u\n", key(peer->public_key), peer->persistent_keepalive_interval);
 			else
 				printf("%s\toff\n", key(peer->public_key));
 		}
 	} else if (!strcmp(param, "preshared-keys")) {
-		for_each_wgpeer(device, peer, i) {
+		for_each_wgpeer (device, peer) {
 			if (with_interface)
-				printf("%s\t", device->interface);
+				printf("%s\t", device->name);
 			printf("%s\t", key(peer->public_key));
 			printf("%s\n", key(peer->preshared_key));
 		}
 	} else if (!strcmp(param, "peers")) {
-		for_each_wgpeer(device, peer, i) {
+		for_each_wgpeer (device, peer) {
 			if (with_interface)
-				printf("%s\t", device->interface);
+				printf("%s\t", device->name);
 			printf("%s\n", key(peer->public_key));
 		}
 	} else if (!strcmp(param, "dump"))
@@ -401,7 +385,7 @@ int show_main(int argc, char *argv[])
 			if (argc == 3) {
 				if (!ugly_print(device, argv[2], true)) {
 					ret = 1;
-					free(device);
+					free_wgdevice(device);
 					break;
 				}
 			} else {
@@ -409,7 +393,7 @@ int show_main(int argc, char *argv[])
 				if (strlen(interface + len + 1))
 					printf("\n");
 			}
-			free(device);
+			free_wgdevice(device);
 		}
 		free(interfaces);
 	} else if (!strcmp(argv[1], "interfaces")) {
@@ -431,14 +415,8 @@ int show_main(int argc, char *argv[])
 		show_usage();
 	else {
 		struct wgdevice *device = NULL;
-		if (!ipc_has_device(argv[1])) {
-			fprintf(stderr, "`%s` is not a valid WireGuard interface\n", argv[1]);
-			show_usage();
-			return 1;
-		}
 		if (ipc_get_device(&device, argv[1]) < 0) {
 			perror("Unable to get device");
-			show_usage();
 			return 1;
 		}
 		if (argc == 3) {
@@ -446,7 +424,7 @@ int show_main(int argc, char *argv[])
 				ret = 1;
 		} else
 			pretty_print(device);
-		free(device);
+		free_wgdevice(device);
 	}
 	return ret;
 }
diff --git a/src/showconf.c b/src/showconf.c
index 09dc2ec..51f9a6f 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -9,10 +9,10 @@
 #include <stdlib.h>
 #include <netdb.h>
 
-#include "subcommands.h"
+#include "containers.h"
 #include "encoding.h"
 #include "ipc.h"
-#include "../uapi.h"
+#include "subcommands.h"
 
 int showconf_main(int argc, char *argv[])
 {
@@ -20,8 +20,7 @@ int showconf_main(int argc, char *argv[])
 	char ip[INET6_ADDRSTRLEN];
 	struct wgdevice *device = NULL;
 	struct wgpeer *peer;
-	struct wgipmask *ipmask;
-	size_t i, j;
+	struct wgallowedip *allowedip;
 	int ret = 1;
 
 	if (argc != 2) {
@@ -29,20 +28,14 @@ int showconf_main(int argc, char *argv[])
 		return 1;
 	}
 
-	if (!ipc_has_device(argv[1])) {
-		fprintf(stderr, "`%s` is not a valid WireGuard interface\n", argv[1]);
-		fprintf(stderr, "Usage: %s %s <interface>\n", PROG_NAME, argv[0]);
-		return 1;
-	}
-
 	if (ipc_get_device(&device, argv[1])) {
 		perror("Unable to get device");
 		goto cleanup;
 	}
 
 	printf("[Interface]\n");
-	if (device->port)
-		printf("ListenPort = %u\n", device->port);
+	if (device->listen_port)
+		printf("ListenPort = %u\n", device->listen_port);
 	if (device->fwmark)
 		printf("FwMark = 0x%x\n", device->fwmark);
 	if (!key_is_zero(device->private_key)) {
@@ -50,29 +43,29 @@ int showconf_main(int argc, char *argv[])
 		printf("PrivateKey = %s\n", base64);
 	}
 	printf("\n");
-	for_each_wgpeer(device, peer, i) {
+	for_each_wgpeer (device, peer) {
 		key_to_base64(base64, peer->public_key);
 		printf("[Peer]\nPublicKey = %s\n", base64);
 		if (!key_is_zero(peer->preshared_key)) {
 			key_to_base64(base64, peer->preshared_key);
 			printf("PresharedKey = %s\n", base64);
 		}
-		if (peer->num_ipmasks)
+		if (peer->first_allowedip)
 			printf("AllowedIPs = ");
-		for_each_wgipmask(peer, ipmask, j) {
-			if (ipmask->family == AF_INET) {
-				if (!inet_ntop(AF_INET, &ipmask->ip4, ip, INET6_ADDRSTRLEN))
+		for_each_wgallowedip (peer, allowedip) {
+			if (allowedip->family == AF_INET) {
+				if (!inet_ntop(AF_INET, &allowedip->ip4, ip, INET6_ADDRSTRLEN))
 					continue;
-			} else if (ipmask->family == AF_INET6) {
-				if (!inet_ntop(AF_INET6, &ipmask->ip6, ip, INET6_ADDRSTRLEN))
+			} else if (allowedip->family == AF_INET6) {
+				if (!inet_ntop(AF_INET6, &allowedip->ip6, ip, INET6_ADDRSTRLEN))
 					continue;
 			} else
 				continue;
-			printf("%s/%d", ip, ipmask->cidr);
-			if (j + 1 < (size_t)peer->num_ipmasks)
+			printf("%s/%d", ip, allowedip->cidr);
+			if (allowedip->next_allowedip)
 				printf(", ");
 		}
-		if (peer->num_ipmasks)
+		if (peer->first_allowedip)
 			printf("\n");
 
 		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6) {
@@ -94,12 +87,12 @@ int showconf_main(int argc, char *argv[])
 		if (peer->persistent_keepalive_interval)
 			printf("PersistentKeepalive = %u\n", peer->persistent_keepalive_interval);
 
-		if (i + 1 < device->num_peers)
+		if (peer->next_peer)
 			printf("\n");
 	}
 	ret = 0;
 
 cleanup:
-	free(device);
+	free_wgdevice(device);
 	return ret;
 }

commit 9a0790b50a54ae85f741ec129591bbfd8934525b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Sep 26 15:02:41 2017 +0200

    wg: uapi: only make sure socket file is socket
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index d0b5a46..45278ec 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -129,11 +129,16 @@ out:
 
 static bool userspace_has_wireguard_interface(const char *interface)
 {
-	FILE *f = userspace_interface_file(interface);
-	if (!f)
+	struct stat sbuf;
+	char path[PATH_MAX] = { 0 };
+
+	if (strchr(interface, '/'))
 		return false;
-	fclose(f);
-	return true;
+	if (snprintf(path, sizeof(path) - 1, SOCK_PATH "%s" SOCK_SUFFIX, interface) < 0)
+		return false;
+	if (stat(path, &sbuf) < 0)
+		return false;
+	return S_ISSOCK(sbuf.st_mode);
 }
 
 static int userspace_get_wireguard_interfaces(struct inflatable_buffer *buffer)

commit 9ef84af8c0bc31d1e56d0a66a9ed909c1edfdd5d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Sep 22 04:04:00 2017 +0200

    wg: use key_is_zero for comparing to zeros
    
    Maybe an attacker on the system could use the infoleak in /proc to gauge
    how long a wg(8) process takes to complete and determine the number of
    leading zeros. This is somewhat ridiculous, but it's possible somebody
    somewhere might at somepoint care in the future, so alright.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 2f61d5b..af74bda 100644
--- a/src/config.c
+++ b/src/config.c
@@ -387,17 +387,11 @@ bool config_read_init(struct config_ctx *ctx, struct wgdevice **device, bool app
 	return true;
 }
 
-static inline bool key_is_valid(uint8_t key[WG_KEY_LEN])
-{
-	static const uint8_t zero[WG_KEY_LEN] = { 0 };
-	return !!memcmp(key, zero, WG_KEY_LEN);
-}
-
 bool config_read_finish(struct config_ctx *ctx)
 {
 	size_t i;
 	struct wgpeer *peer;
-	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !key_is_valid(ctx->buf.dev->private_key)) {
+	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && key_is_zero(ctx->buf.dev->private_key)) {
 		fprintf(stderr, "No private key configured\n");
 		goto err;
 	}
@@ -405,7 +399,7 @@ bool config_read_finish(struct config_ctx *ctx)
 		ctx->buf.dev->flags |= WGDEVICE_REMOVE_FWMARK;
 
 	for_each_wgpeer(ctx->buf.dev, peer, i) {
-		if (!key_is_valid(peer->public_key)) {
+		if (key_is_zero(peer->public_key)) {
 			fprintf(stderr, "A peer is missing a public key\n");
 			goto err;
 		}
diff --git a/src/encoding.c b/src/encoding.c
index 389bbf7..3d5e94b 100644
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -77,12 +77,12 @@ void key_to_hex(char hex[static WG_KEY_LEN_HEX], const uint8_t key[static WG_KEY
 
 bool key_from_hex(uint8_t key[static WG_KEY_LEN], const char *hex)
 {
-	uint8_t i, c, c_acc = 0, c_alpha0, c_alpha, c_num0, c_num, c_val, state = 0;
+	uint8_t c, c_acc = 0, c_alpha0, c_alpha, c_num0, c_num, c_val, state = 0;
 
 	if (strlen(hex) != WG_KEY_LEN_HEX - 1)
 		return false;
 
-	for (i = 0; i < WG_KEY_LEN_HEX - 1; ++i) {
+	for (unsigned int i = 0; i < WG_KEY_LEN_HEX - 1; ++i) {
 		c = (uint8_t)hex[i];
 		c_num = c ^ 48U;
 		c_num0 = (c_num - 10U) >> 8;
@@ -99,3 +99,13 @@ bool key_from_hex(uint8_t key[static WG_KEY_LEN], const char *hex)
 	}
 	return true;
 }
+
+bool key_is_zero(const uint8_t key[static WG_KEY_LEN])
+{
+	uint8_t acc = 0;
+	for (unsigned int i = 0; i < WG_KEY_LEN; ++i) {
+		acc |= key[i];
+		__asm__ ("" : "=r" (acc) : "0" (acc));
+	}
+	return acc == 0;
+}
diff --git a/src/encoding.h b/src/encoding.h
index f4fe51e..9db4c6e 100644
--- a/src/encoding.h
+++ b/src/encoding.h
@@ -16,4 +16,6 @@ bool key_from_base64(uint8_t key[static WG_KEY_LEN], const char *base64);
 void key_to_hex(char hex[static WG_KEY_LEN_HEX], const uint8_t key[static WG_KEY_LEN]);
 bool key_from_hex(uint8_t key[static WG_KEY_LEN], const char *hex);
 
+bool key_is_zero(const uint8_t key[static WG_KEY_LEN]);
+
 #endif
diff --git a/src/ipc.c b/src/ipc.c
index 48d06aa..d0b5a46 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -170,7 +170,6 @@ out:
 
 static int userspace_set_device(struct wgdevice *dev)
 {
-	static const uint8_t zero[WG_KEY_LEN] = { 0 };
 	char hex[WG_KEY_LEN_HEX], ip[INET6_ADDRSTRLEN], host[4096 + 1], service[512 + 1];
 	struct wgpeer *peer;
 	struct wgipmask *ipmask;
@@ -186,7 +185,7 @@ static int userspace_set_device(struct wgdevice *dev)
 
 	if (dev->flags & WGDEVICE_REMOVE_PRIVATE_KEY)
 		fprintf(f, "private_key=\n");
-	else if (memcmp(dev->private_key, zero, WG_KEY_LEN)) {
+	else if (!key_is_zero(dev->private_key)) {
 		key_to_hex(hex, dev->private_key);
 		fprintf(f, "private_key=%s\n", hex);
 	}
@@ -208,7 +207,7 @@ static int userspace_set_device(struct wgdevice *dev)
 		}
 		if (peer->flags & WGPEER_REMOVE_PRESHARED_KEY)
 			fprintf(f, "preshared_key=\n");
-		else if (memcmp(peer->preshared_key, zero, WG_KEY_LEN)) {
+		else if (!key_is_zero(peer->preshared_key)) {
 			key_to_hex(hex, peer->preshared_key);
 			fprintf(f, "preshared_key=%s\n", hex);
 		}
diff --git a/src/show.c b/src/show.c
index 4eb096f..6e5de96 100644
--- a/src/show.c
+++ b/src/show.c
@@ -75,12 +75,10 @@ static void sort_peers(struct wgdevice *device)
 	free(new_device);
 }
 
-static const uint8_t zero[WG_KEY_LEN] = { 0 };
-
 static char *key(const uint8_t key[static WG_KEY_LEN])
 {
 	static char base64[WG_KEY_LEN_BASE64];
-	if (!memcmp(key, zero, WG_KEY_LEN))
+	if (key_is_zero(key))
 		return "(none)";
 	key_to_base64(base64, key);
 	return base64;
@@ -212,9 +210,9 @@ static void pretty_print(struct wgdevice *device)
 
 	terminal_printf(TERMINAL_RESET);
 	terminal_printf(TERMINAL_FG_GREEN TERMINAL_BOLD "interface" TERMINAL_RESET ": " TERMINAL_FG_GREEN "%s" TERMINAL_RESET "\n", device->interface);
-	if (memcmp(device->public_key, zero, WG_KEY_LEN))
+	if (!key_is_zero(device->public_key))
 		terminal_printf("  " TERMINAL_BOLD "public key" TERMINAL_RESET ": %s\n", key(device->public_key));
-	if (memcmp(device->private_key, zero, WG_KEY_LEN))
+	if (!key_is_zero(device->private_key))
 		terminal_printf("  " TERMINAL_BOLD "private key" TERMINAL_RESET ": %s\n", masked_key(device->private_key));
 	if (device->port)
 		terminal_printf("  " TERMINAL_BOLD "listening port" TERMINAL_RESET ": %u\n", device->port);
@@ -226,7 +224,7 @@ static void pretty_print(struct wgdevice *device)
 	}
 	for_each_wgpeer(device, peer, i) {
 		terminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD "peer" TERMINAL_RESET ": " TERMINAL_FG_YELLOW "%s" TERMINAL_RESET "\n", key(peer->public_key));
-		if (memcmp(peer->preshared_key, zero, WG_KEY_LEN))
+		if (!key_is_zero(peer->preshared_key))
 			terminal_printf("  " TERMINAL_BOLD "preshared key" TERMINAL_RESET ": %s\n", masked_key(peer->preshared_key));
 		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
 			terminal_printf("  " TERMINAL_BOLD "endpoint" TERMINAL_RESET ": %s\n", endpoint(&peer->endpoint.addr));
diff --git a/src/showconf.c b/src/showconf.c
index 2453c86..09dc2ec 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -16,7 +16,6 @@
 
 int showconf_main(int argc, char *argv[])
 {
-	static const uint8_t zero[WG_KEY_LEN] = { 0 };
 	char base64[WG_KEY_LEN_BASE64];
 	char ip[INET6_ADDRSTRLEN];
 	struct wgdevice *device = NULL;
@@ -46,7 +45,7 @@ int showconf_main(int argc, char *argv[])
 		printf("ListenPort = %u\n", device->port);
 	if (device->fwmark)
 		printf("FwMark = 0x%x\n", device->fwmark);
-	if (memcmp(device->private_key, zero, WG_KEY_LEN)) {
+	if (!key_is_zero(device->private_key)) {
 		key_to_base64(base64, device->private_key);
 		printf("PrivateKey = %s\n", base64);
 	}
@@ -54,7 +53,7 @@ int showconf_main(int argc, char *argv[])
 	for_each_wgpeer(device, peer, i) {
 		key_to_base64(base64, peer->public_key);
 		printf("[Peer]\nPublicKey = %s\n", base64);
-		if (memcmp(peer->preshared_key, zero, WG_KEY_LEN)) {
+		if (!key_is_zero(peer->preshared_key)) {
 			key_to_base64(base64, peer->preshared_key);
 			printf("PresharedKey = %s\n", base64);
 		}

commit 6c7d67acfe953849622a64771fa5008730517a75
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Sep 19 23:17:56 2017 +0200

    contrib: add sticky sockets example code
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/sticky-sockets/README b/contrib/sticky-sockets/README
new file mode 100644
index 0000000..cc14570
--- /dev/null
+++ b/contrib/sticky-sockets/README
@@ -0,0 +1,5 @@
+Sticky Sockets
+==============
+
+This is a small userspace mini-library that implements as close to
+possible how the kernel does its sticky src address sending.
diff --git a/contrib/sticky-sockets/a.out b/contrib/sticky-sockets/a.out
new file mode 100755
index 0000000..844d08e
Binary files /dev/null and b/contrib/sticky-sockets/a.out differ
diff --git a/contrib/sticky-sockets/sticky-sockets.c b/contrib/sticky-sockets/sticky-sockets.c
new file mode 100644
index 0000000..1a910b2
--- /dev/null
+++ b/contrib/sticky-sockets/sticky-sockets.c
@@ -0,0 +1,337 @@
+/* Copyright 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * This implements userspace semantics of "sticky sockets", modeled after
+ * WireGuard's kernelspace implementation.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <linux/ipv6.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/udp.h>
+#include <arpa/inet.h>
+
+struct magic_endpoint {
+	union {
+		struct sockaddr addr;
+		struct sockaddr_in addr4;
+		struct sockaddr_in6 addr6;
+	};
+	union {
+		struct {
+			struct in_addr src4;
+			int src_if4; /* Essentially the same as addr6->scope_id */
+		};
+		struct in6_addr src6;
+	};
+};
+
+ssize_t magic_send4(int sock, struct magic_endpoint *endpoint, void *buffer, size_t len)
+{
+	ssize_t ret;
+	struct iovec iovec = {
+		.iov_base = buffer,
+		.iov_len = len
+	};
+	struct {
+		struct cmsghdr cmsghdr;
+		struct in_pktinfo pktinfo;
+	} cmsg = {
+		.cmsghdr.cmsg_level = IPPROTO_IP,
+		.cmsghdr.cmsg_type = IP_PKTINFO,
+		.cmsghdr.cmsg_len = CMSG_LEN(sizeof(cmsg.pktinfo)),
+		.pktinfo.ipi_spec_dst = endpoint->src4,
+		.pktinfo.ipi_ifindex = endpoint->src_if4
+	};
+	struct msghdr msghdr = {
+		.msg_iov = &iovec,
+		.msg_iovlen = 1,
+		.msg_name = &endpoint->addr4,
+		.msg_namelen = sizeof(endpoint->addr4),
+		.msg_control = &cmsg,
+		.msg_controllen = sizeof(cmsg)
+	};
+	ret = sendmsg(sock, &msghdr, 0);
+	if (ret < 0 && errno == EINVAL) {
+		memset(&cmsg.pktinfo, 0, sizeof(cmsg.pktinfo));
+		endpoint->src4.s_addr = endpoint->src_if4 = 0;
+		return sendmsg(sock, &msghdr, 0);
+	}
+	return ret;
+}
+
+ssize_t magic_send6(int sock, struct magic_endpoint *endpoint, void *buffer, size_t len)
+{
+	ssize_t ret;
+	struct iovec iovec = {
+		.iov_base = buffer,
+		.iov_len = len
+	};
+	struct {
+		struct cmsghdr cmsghdr;
+		struct in6_pktinfo pktinfo;
+	} cmsg = {
+		.cmsghdr.cmsg_level = IPPROTO_IPV6,
+		.cmsghdr.cmsg_type = IPV6_PKTINFO,
+		.cmsghdr.cmsg_len = CMSG_LEN(sizeof(cmsg.pktinfo)),
+		.pktinfo.ipi6_addr = endpoint->src6,
+		.pktinfo.ipi6_ifindex = memcmp(&in6addr_any, &endpoint->src6, sizeof(endpoint->src6)) ? endpoint->addr6.sin6_scope_id : 0
+	};
+	struct msghdr msghdr = {
+		.msg_iov = &iovec,
+		.msg_iovlen = 1,
+		.msg_name = &endpoint->addr6,
+		.msg_namelen = sizeof(endpoint->addr6),
+		.msg_control = &cmsg,
+		.msg_controllen = sizeof(cmsg)
+	};
+
+	ret = sendmsg(sock, &msghdr, 0);
+	if (ret < 0 && errno == EINVAL) {
+		memset(&cmsg.pktinfo, 0, sizeof(cmsg.pktinfo));
+		memset(&endpoint->src6, 0, sizeof(endpoint->src6));
+		return sendmsg(sock, &msghdr, 0);
+	}
+	return ret;
+}
+
+ssize_t magic_receive4(int sock, struct magic_endpoint *endpoint, void *buffer, size_t len)
+{
+	ssize_t ret;
+	struct iovec iovec = {
+		.iov_base = buffer,
+		.iov_len = len
+	};
+	struct {
+		struct cmsghdr cmsghdr;
+		struct in_pktinfo pktinfo;
+	} cmsg;
+	struct msghdr msghdr = {
+		.msg_iov = &iovec,
+		.msg_iovlen = 1,
+		.msg_name = &endpoint->addr4,
+		.msg_namelen = sizeof(endpoint->addr4),
+		.msg_control = &cmsg,
+		.msg_controllen = sizeof(cmsg)
+	};
+
+	ret = recvmsg(sock, &msghdr, 0);
+	if (ret < 0)
+		return ret;
+	if (cmsg.cmsghdr.cmsg_level == IPPROTO_IP && cmsg.cmsghdr.cmsg_type == IP_PKTINFO && cmsg.cmsghdr.cmsg_len >= CMSG_LEN(sizeof(cmsg.pktinfo))) {
+		endpoint->src4 = cmsg.pktinfo.ipi_spec_dst;
+		endpoint->src_if4 = cmsg.pktinfo.ipi_ifindex;
+	}
+	return ret;
+}
+
+ssize_t magic_receive6(int sock, struct magic_endpoint *endpoint, void *buffer, size_t len)
+{
+	ssize_t ret;
+	struct iovec iovec = {
+		.iov_base = buffer,
+		.iov_len = len
+	};
+	struct {
+		struct cmsghdr cmsghdr;
+		struct in6_pktinfo pktinfo;
+	} cmsg;
+	struct msghdr msghdr = {
+		.msg_iov = &iovec,
+		.msg_iovlen = 1,
+		.msg_name = &endpoint->addr6,
+		.msg_namelen = sizeof(endpoint->addr6),
+		.msg_control = &cmsg,
+		.msg_controllen = sizeof(cmsg)
+	};
+
+	ret = recvmsg(sock, &msghdr, 0);
+	if (ret < 0)
+		return ret;
+	if (cmsg.cmsghdr.cmsg_level == IPPROTO_IPV6 && cmsg.cmsghdr.cmsg_type == IPV6_PKTINFO && cmsg.cmsghdr.cmsg_len >= CMSG_LEN(sizeof(cmsg.pktinfo))) {
+		endpoint->src6 = cmsg.pktinfo.ipi6_addr;
+		endpoint->addr6.sin6_scope_id = cmsg.pktinfo.ipi6_ifindex;
+	}
+	return ret;
+}
+
+void magic_endpoint_clearsrc(struct magic_endpoint *endpoint)
+{
+	if (endpoint->addr.sa_family == AF_INET)
+		endpoint->src4.s_addr = endpoint->src_if4 = 0;
+	else if (endpoint->addr.sa_family == AF_INET6)
+		memset(&endpoint->src6, 0, sizeof(endpoint->src6));
+	else
+		memset(endpoint, 0, sizeof(*endpoint));
+}
+
+void magic_endpoint_set(struct magic_endpoint *endpoint, const struct sockaddr *addr)
+{
+	if (addr->sa_family == AF_INET)
+		endpoint->addr4 = *(struct sockaddr_in *)addr;
+	else if (addr->sa_family == AF_INET6)
+		endpoint->addr6 = *(struct sockaddr_in6 *)addr;
+	magic_endpoint_clearsrc(endpoint);
+}
+
+int magic_create_sock4(uint16_t listen_port)
+{
+	static const int on = 1;
+	struct sockaddr_in listen_addr = {
+		.sin_family = AF_INET,
+		.sin_port = htons(listen_port),
+		.sin_addr = INADDR_ANY
+	};
+	int fd, ret;
+	
+	fd = socket(AF_INET, SOCK_DGRAM, 0);
+	if (fd < 0)
+		return fd;
+	
+	ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
+	if (ret < 0)
+		goto err;
+	
+	ret = setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &on, sizeof(on));
+	if (ret < 0)
+		goto err;
+	
+	ret = bind(fd, (struct sockaddr *)&listen_addr, sizeof(listen_addr));
+	if (ret < 0)
+		goto err;
+	
+	return fd;
+
+err:
+	close(fd);
+	return ret;
+}
+
+int magic_create_sock6(uint16_t listen_port)
+{
+	static const int on = 1;
+	struct sockaddr_in6 listen_addr = {
+		.sin6_family = AF_INET6,
+		.sin6_port = htons(listen_port),
+		.sin6_addr = IN6ADDR_ANY_INIT
+	};
+	int fd, ret;
+	
+	fd = socket(AF_INET6, SOCK_DGRAM, 0);
+	if (fd < 0)
+		return fd;
+	
+	ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
+	if (ret < 0)
+		goto err;
+	
+	ret = setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on, sizeof(on));
+	if (ret < 0)
+		goto err;
+
+	ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on));
+	if (ret < 0)
+		goto err;
+	
+	ret = bind(fd, (struct sockaddr *)&listen_addr, sizeof(listen_addr));
+	if (ret < 0)
+		goto err;
+	
+	return fd;
+
+err:
+	close(fd);
+	return ret;
+}
+
+int main(int argc, char *argv[])
+{
+	struct magic_endpoint endpoint = { 0 };
+	int sock;
+	ssize_t ret;
+	uint8_t buffer[1024] = { 0 };
+	char srcaddr[40], dstaddr[40];
+
+	if (argc == 2 && !strcmp(argv[1], "-4"))
+		goto v4;
+	if (argc == 2 && !strcmp(argv[1], "-6"))
+		goto v6;
+	return 1;
+
+v6:
+	sock = magic_create_sock6(51820);
+	if (sock < 0) {
+		perror("magic_create_sock6");
+		return 1;
+	}
+
+	ret = magic_receive6(sock, &endpoint, buffer, sizeof(buffer));
+	if (ret < 0) {
+		perror("magic_receive6");
+		return 1;
+	}
+
+	if (!inet_ntop(AF_INET6, &endpoint.src6, srcaddr, sizeof(srcaddr))) {
+		perror("inet_ntop");
+		return 1;
+	}
+
+	if (!inet_ntop(AF_INET6, &endpoint.addr6.sin6_addr, dstaddr, sizeof(dstaddr))) {
+		perror("inet_ntop");
+		return 1;
+	}
+
+	printf("if:%d src:%s dst:%s\n", endpoint.addr6.sin6_scope_id, srcaddr, dstaddr);
+	printf("Received a packet. Sleeping for 10 seconds before replying, so you have time to mess with your networking setup.\n");
+	sleep(10);
+
+	ret = magic_send6(sock, &endpoint, buffer, sizeof(buffer));
+	if (ret < 0) {
+		perror("magic_send6");
+		return 1;
+	}
+
+	close(sock);
+	return 0;
+
+v4:
+	sock = magic_create_sock4(51820);
+	if (sock < 0) {
+		perror("magic_create_sock4");
+		return 1;
+	}
+
+	ret = magic_receive4(sock, &endpoint, buffer, sizeof(buffer));
+	if (ret < 0) {
+		perror("magic_receive4");
+		return 1;
+	}
+
+	if (!inet_ntop(AF_INET, &endpoint.src4, srcaddr, sizeof(srcaddr))) {
+		perror("inet_ntop");
+		return 1;
+	}
+
+	if (!inet_ntop(AF_INET, &endpoint.addr4.sin_addr, dstaddr, sizeof(dstaddr))) {
+		perror("inet_ntop");
+		return 1;
+	}
+
+	printf("if:%d src:%s dst:%s\n", endpoint.src_if4, srcaddr, dstaddr);
+	printf("Received a packet. Sleeping for 10 seconds before replying, so you have time to mess with your networking setup.\n");
+	sleep(10);
+
+	ret = magic_send4(sock, &endpoint, buffer, sizeof(buffer));
+	if (ret < 0) {
+		perror("magic_send4");
+		return 1;
+	}
+	
+	close(sock);
+	return 0;
+}

commit 92feabdd176f1089baff811a9c0d148259022501
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Sep 6 20:51:41 2017 +0200

    wg-quick: only bash complete existing interfaces for down
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/completion/wg-quick.bash-completion b/src/completion/wg-quick.bash-completion
index e0bdf9f..b931323 100644
--- a/src/completion/wg-quick.bash-completion
+++ b/src/completion/wg-quick.bash-completion
@@ -4,20 +4,23 @@ _wg_quick_completion() {
 	local i a
 	if [[ $COMP_CWORD -eq 1 ]]; then
 		COMPREPLY+=( $(compgen -W "up down" -- "${COMP_WORDS[1]}") )
-		return
 	elif [[ $COMP_CWORD -eq 2 ]]; then
-		local old_glob="$(shopt -p nullglob)"
-		shopt -s nullglob
-		for i in /etc/wireguard/*.conf; do
-			i="${i##*/}"; i="${i%.conf}"
-			mapfile -t a < <(compgen -W "$i" -- "${COMP_WORDS[2]}")
+		if [[ ${COMP_WORDS[1]} == up ]]; then
+			local old_glob="$(shopt -p nullglob)"
+			shopt -s nullglob
+			for i in /etc/wireguard/*.conf; do
+				i="${i##*/}"; i="${i%.conf}"
+				mapfile -t a < <(compgen -W "$i" -- "${COMP_WORDS[2]}")
+				COMPREPLY+=( "${a[@]}" )
+			done
+			eval "$old_glob"
+			mapfile -t a < <(compgen -f -X '!*.conf' -- "${COMP_WORDS[2]}")
 			COMPREPLY+=( "${a[@]}" )
-		done
-		eval "$old_glob"
-		mapfile -t a < <(compgen -f -X '!*.conf' -- "${COMP_WORDS[2]}")
-		COMPREPLY+=( "${a[@]}" )
-		mapfile -t a < <(compgen -d -- "${COMP_WORDS[2]}")
-		COMPREPLY+=( "${a[@]}" )
+			mapfile -t a < <(compgen -d -- "${COMP_WORDS[2]}")
+			COMPREPLY+=( "${a[@]}" )
+		elif [[ ${COMP_WORDS[1]} == down ]]; then
+			COMPREPLY+=( $(compgen -W "$(wg show interfaces)" -- "${COMP_WORDS[2]}") )
+		fi
 	fi
 }
 

commit 34337b0906ad8049d8a0ab6ef8fa2dedddf5b90c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Aug 23 12:51:52 2017 -0600

    wg: fix removal of psk
    
    This is an attribute of the peer, not the device.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 5bb985f..2f61d5b 100644
--- a/src/config.c
+++ b/src/config.c
@@ -556,7 +556,7 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 				if (!parse_key(peer_from_offset(buf.dev, peer_offset)->preshared_key, key_line))
 					goto error;
 			} else if (ret == 1)
-				buf.dev->flags |= WGPEER_REMOVE_PRESHARED_KEY;
+				peer_from_offset(buf.dev, peer_offset)->flags |= WGPEER_REMOVE_PRESHARED_KEY;
 			else
 				goto error;
 			argv += 2;

commit bc9494f8b68fc138ba6bc303ca90cee1b33e3ea9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Aug 2 21:07:25 2017 +0200

    wg: stricter userspace ipc parsing
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index ed5fbc2..48d06aa 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -314,13 +314,13 @@ static int userspace_get_device(struct wgdevice **out, const char *interface)
 			break;
 		*value++ = key[--line_len] = '\0';
 
-		if (!strcmp(key, "private_key")) {
+		if (!peer && !strcmp(key, "private_key")) {
 			if (!key_from_hex(dev->private_key, value))
 				break;
 			curve25519_generate_public(dev->public_key, dev->private_key);
-		} else if (!strcmp(key, "listen_port"))
+		} else if (!peer && !strcmp(key, "listen_port"))
 			dev->port = NUM(0xffffU);
-		else if (!strcmp(key, "fwmark"))
+		else if (!peer && !strcmp(key, "fwmark"))
 			dev->fwmark = NUM(0xffffffffU);
 		else if (!strcmp(key, "public_key")) {
 			peer = ADD(sizeof(struct wgpeer));

commit 10191751798c08c259ba4c0ac3173b3453a5357a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jul 31 03:03:06 2017 +0200

    contrib: move Android tools to wireguard-android repo
    
    https: //git.zx2c4.com/wireguard-android/
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/android/README.md b/contrib/android/README.md
deleted file mode 100644
index 2d16fc4..0000000
--- a/contrib/android/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# Tools for Android
-
-This currently contains a version of wg-quick.bash that works with
-Android 7's `ndc` command. It requires the WireGuard module to be
-part of your kernel, but after that, the usual `wg-quick up` and
-`wg-quick down` commands work normally.
-
-## Installation
-
-Build a `wg` binary for Android and place it in this folder. Then
-copy this folder some place on your phone, and run `sh ./install.sh`
-as root. It should survive ROM flashes.
-
-## Usage
-
-Compared to the ordinary wg-quick, this one does not support SaveConfig
-and {Pre,Post}{Up,Down}.
-
-Put your configuration files into `/data/misc/wireguard/`. After that,
-the normal `wg-quick up|down` commands will work.
-
diff --git a/contrib/android/addonsd.sh b/contrib/android/addonsd.sh
deleted file mode 100644
index 90865d0..0000000
--- a/contrib/android/addonsd.sh
+++ /dev/null
@@ -1,37 +0,0 @@
-#!/sbin/sh
-
-. /tmp/backuptool.functions
-
-list_files() {
-cat <<_EOF
-xbin/wg
-xbin/wg-quick
-_EOF
-}
-
-case "$1" in
-	backup)
-		list_files | while read FILE DUMMY; do
-			backup_file $S/"$FILE"
-		done
-	;;
-	restore)
-		list_files | while read FILE REPLACEMENT; do
-			R=""
-			[ -n "$REPLACEMENT" ] && R="$S/$REPLACEMENT"
-			[ -f "$C/$S/$FILE" ] && restore_file $S/"$FILE" "$R"
-		done
-	;;
-	pre-backup)
-		# Stub
-	;;
-	post-backup)
-		# Stub
-	;;
-	pre-restore)
-		# Stub
-	;;
-	post-restore)
-		# Stub
-	;;
-esac
diff --git a/contrib/android/install.sh b/contrib/android/install.sh
deleted file mode 100755
index f619eb6..0000000
--- a/contrib/android/install.sh
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-mount -o rw,remount /system
-
-cp -v ./addonsd.sh /system/addon.d/40-wireguard.sh
-if [ -f ./wg ]; then
-	cp -v ./wg /system/xbin/wg
-else
-	echo "Warning: this directory does not contain wg. You may have forgotten to compile it yourself?" >&2
-fi
-cp -v ./wg-quick.bash /system/xbin/wg-quick
-chmod 755 /system/xbin/wg /system/xbin/wg-quick /system/addon.d/40-wireguard.sh
-mkdir -pvm 700 /data/misc/wireguard
-
-mount -o ro,remount /system
diff --git a/contrib/android/wg-quick.bash b/contrib/android/wg-quick.bash
deleted file mode 100644
index 4041735..0000000
--- a/contrib/android/wg-quick.bash
+++ /dev/null
@@ -1,187 +0,0 @@
-#!/system/xbin/bash
-#
-# Copyright (C) 2016-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
-#
-
-set -e -o pipefail
-shopt -s extglob
-export LC_ALL=C
-
-SELF="$(readlink -f "${BASH_SOURCE[0]}")"
-export PATH="${SELF%/*}:$PATH"
-
-WG_CONFIG=""
-INTERFACE=""
-NETID=0
-ADDRESSES=( )
-MTU=""
-DNS=""
-CONFIG_FILE=""
-PROGRAM="${0##*/}"
-ARGS=( "$@" )
-
-parse_options() {
-	local interface_section=0 line key value
-	CONFIG_FILE="$1"
-	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,16}$ ]] && CONFIG_FILE="/data/misc/wireguard/$CONFIG_FILE.conf"
-	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
-	[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,16})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
-	((($(stat -c '%#a' "$CONFIG_FILE") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
-	INTERFACE="${BASH_REMATCH[1]}"
-	shopt -s nocasematch
-	while read -r line || [[ -n $line ]]; do
-		key="${line%%=*}"; key="${key##*( )}"; key="${key%%*( )}"
-		value="${line#*=}"; value="${value##*( )}"; value="${value%%*( )}"
-		[[ $key == "["* ]] && interface_section=0
-		[[ $key == "[Interface]" ]] && interface_section=1
-		if [[ $interface_section -eq 1 ]]; then
-			case "$key" in
-			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
-			MTU) MTU="$value"; continue ;;
-			DNS) DNS="$value"; continue ;;
-			esac
-		fi
-		WG_CONFIG+="$line"$'\n'
-	done < "$CONFIG_FILE"
-	shopt -u nocasematch
-}
-
-cmd() {
-	echo "[#] $*" >&2
-	"$@"
-}
-
-cndc() {
-	local out="$(cmd ndc "$@")"
-	[[ $out == *200\ 0* ]] || { echo "$out"; return 1; }
-}
-
-die() {
-	echo "$PROGRAM: $*" >&2
-	exit 1
-}
-
-auto_su() {
-	[[ $UID == 0 ]] || exec su -p -c "'$SELF' ${ARGS[*]}"
-}
-
-add_if() {
-	cmd ip link add "$INTERFACE" type wireguard
-}
-
-del_if() {
-	cmd ip link del "$INTERFACE"
-	[[ $(ip rule show) =~ 0xc([0-9a-f]+)/0xcffff\ lookup\ $INTERFACE ]] && cndc network destroy $(( 0x${BASH_REMATCH[1]} ));
-}
-
-up_if() {
-	while [[ $NETID -lt 4096 ]]; do
-		NETID="$RANDOM"
-	done
-	cmd wg set "$INTERFACE" fwmark 0x20000
-	cndc interface setcfg "$INTERFACE" up
-	cndc network create "$NETID" vpn 1 1
-	cndc network interface add "$NETID" "$INTERFACE"
-	cndc network users add "$NETID" 0-99999
-}
-
-set_dns() {
-	cndc resolver setnetdns "$NETID" "" "$1"
-}
-
-add_addr() {
-	if [[ $1 == *:* ]]; then
-		cndc interface ipv6 "$INTERFACE" enable
-		cmd ip -6 addr add "$1" dev "$INTERFACE"
-	else
-		local ip="${1%%/*}" mask=32
-		[[ $1 == */* ]] && mask="${1##*/}"
-		cndc interface setcfg "$INTERFACE" "$ip" "$mask"
-	fi
-}
-
-set_mtu() {
-	local mtu=0 endpoint output
-	if [[ -n $MTU ]]; then
-		cndc interface setmtu "$INTERFACE" "$MTU"
-		return
-	fi
-	while read -r _ endpoint; do
-		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
-		output="$(ip route get "${BASH_REMATCH[1]}" || true)"
-		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
-	done < <(wg show "$INTERFACE" endpoints)
-	if [[ $mtu -eq 0 ]]; then
-		read -r output < <(ip route show default || true) || true
-		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
-	fi
-	[[ $mtu -gt 0 ]] || mtu=1500
-	cndc interface setmtu "$INTERFACE" $(( mtu - 80 ))
-}
-
-add_route() {
-	cndc network route add "$NETID" "$INTERFACE" "$1"
-}
-
-set_config() {
-	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG")
-}
-
-cmd_usage() {
-	cat >&2 <<-_EOF
-	Usage: $PROGRAM [ up | down ] [ CONFIG_FILE | INTERFACE ]
-
-	  CONFIG_FILE is a configuration file, whose filename is the interface name
-	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
-	  configuration found at /data/misc/wireguard/INTERFACE.conf. It is to be readable
-	  by wg(8)'s \`setconf' sub-command, with the exception of the following additions
-	  to the [Interface] section, which are handled by $PROGRAM:
-
-	  - Address: may be specified one or more times and contains one or more
-	    IP addresses (with an optional CIDR mask) to be set for the interface.
-	  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.
-	  - DNS: an optional DNS server to use while the device is up.
-
-	See wg-quick(8) for more info and examples.
-	_EOF
-}
-
-cmd_up() {
-	local i
-	[[ -z $(ip link show dev "$INTERFACE" 2>/dev/null) ]] || die "\`$INTERFACE' already exists"
-	trap 'del_if; exit' INT TERM EXIT
-	add_if
-	set_config
-	set_mtu
-	for i in "${ADDRESSES[@]}"; do
-		add_addr "$i"
-	done
-	up_if
-	[[ -z $DNS ]] || set_dns "$DNS"
-	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
-		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"
-	done
-	trap - INT TERM EXIT
-}
-
-cmd_down() {
-	[[ -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] || die "\`$INTERFACE' is not a WireGuard interface"
-	del_if
-}
-
-if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
-	cmd_usage
-elif [[ $# -eq 2 && $1 == up ]]; then
-	auto_su
-	parse_options "$2"
-	cmd_up
-elif [[ $# -eq 2 && $1 == down ]]; then
-	auto_su
-	parse_options "$2"
-	cmd_down
-else
-	cmd_usage
-	exit 1
-fi
-
-exit 0

commit a9d19159a93cec2429817ba2262a14ec66d7ac1c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jul 26 04:10:33 2017 +0200

    android: fix readme
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/android/README.md b/contrib/android/README.md
index 943d5f2..2d16fc4 100644
--- a/contrib/android/README.md
+++ b/contrib/android/README.md
@@ -13,8 +13,8 @@ as root. It should survive ROM flashes.
 
 ## Usage
 
-Compared to the ordinary wg-quick, this one gains a "DNS =" field,
-but loses SaveConfig and {Pre,Post}{Up,Down}.
+Compared to the ordinary wg-quick, this one does not support SaveConfig
+and {Pre,Post}{Up,Down}.
 
 Put your configuration files into `/data/misc/wireguard/`. After that,
 the normal `wg-quick up|down` commands will work.

commit 6b27d0d0f03a5ad4b2b3fe620aa345325b94d353
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jul 26 03:09:48 2017 +0200

    wg-quick: add explicit support for common DNS usage
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index 04653a8..f27a270 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -62,9 +62,16 @@ sub-command, with the exception of the following additions to the \fIInterface\f
 which are handled by this tool:
 
 .IP \(bu
-Address \(em a comma-separated list of ip (v4 or v6) addresses (optionally with CIDR masks)
+Address \(em a comma-separated list of IP (v4 or v6) addresses (optionally with CIDR masks)
 to be assigned to the interface. May be specified multiple times.
 .IP \(bu
+DNS \(em a comma-separated list of IP (v4 or v6) addresses to be set as the interface's
+DNS servers. May be specified multiple times. Upon bringing the interface up, this runs
+`resolvconf -a tun.\fIINTERFACE\fP -m 0 -x` and upon bringing it down, this runs
+`resolvconf -d tun.\fIINTERFACE\fP`. If these particular invocations of
+.BR resolvconf (8)
+are undesirable, the PostUp and PostDown keys below may be used instead.
+.IP \(bu
 MTU \(em if not specified, the MTU is automatically determined from the endpoint addresses
 or the system default route, which is usually a sane choice. However, to manually specify
 an MTU to override this automatic discovery, this value may be specified explicitly.
@@ -72,7 +79,8 @@ an MTU to override this automatic discovery, this value may be specified explici
 PreUp, PostUp, PreDown, PostDown \(em script snippets which will be executed by
 .BR bash (1)
 before/after setting up/tearing down the interface, most commonly used
-to configure DNS. The special string `%i' is expanded to \fIINTERFACE\fP.
+to configure custom DNS options or firewall rules. The special string `%i'
+is expanded to \fIINTERFACE\fP.
 .IP \(bu
 SaveConfig \(em if set to `true', the configuration is saved from the current state of the
 interface upon shutdown.
@@ -98,9 +106,7 @@ traffic:
 .br
     \fBAddress = 10.200.100.8/24\fP
 .br
-    \fBPostUp = echo nameserver 10.200.100.1 | resolvconf -a tun.%i -m 0 -x\fP
-.br
-    \fBPostDown = resolvconf -d tun.%i\fP
+    \fBDNS = 10.200.100.1\fP
 .br
     PrivateKey = oK56DE9Ue9zK76rAc8pBl6opph+1v36lm7cXXsQKrQM= 
 .br
@@ -117,12 +123,11 @@ traffic:
     Endpoint = demo.wireguard.com:51820 
 .br
 
-Notice that the `PostUp` and `PostDown` commands are used here to configure DNS using
-.BR resolvconf (8),
-which is one of the many options for DNS configuration. The `Address` field is added
-here in order to set up the address for the interface. The peer's allowed IPs entry
-implies that this interface should be configured as the default gateway, which this
-script does.
+The `Address` field is added here in order to set up the address for the interface. The `DNS` field
+indicates that a DNS server for the interface should be configured via
+.BR resolvconf (8).
+The peer's allowed IPs entry implies that this interface should be configured as the default gateway,
+which this script does.
 
 Here is a more complicated example, fit for usage on a server:
     
@@ -184,7 +189,8 @@ This will load the configuration file `/etc/wireguard/wgnet0.conf'.
 .BR ip-link (8),
 .BR ip-address (8),
 .BR ip-route (8),
-.BR ip-rule (8).
+.BR ip-rule (8),
+.BR resolvconf (8).
 
 .SH AUTHOR
 .B wg-quick
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index d7e7d68..e5ae48f 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -14,6 +14,7 @@ WG_CONFIG=""
 INTERFACE=""
 ADDRESSES=( )
 MTU=""
+DNS=( )
 PRE_UP=""
 POST_UP=""
 PRE_DOWN=""
@@ -41,6 +42,7 @@ parse_options() {
 			case "$key" in
 			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
 			MTU) MTU="$value"; continue ;;
+			DNS) DNS+=( ${value//,/ } ); continue ;;
 			PreUp) PRE_UP="$value"; continue ;;
 			PreDown) PRE_DOWN="$value"; continue ;;
 			PostUp) POST_UP="$value"; continue ;;
@@ -128,6 +130,14 @@ set_mtu() {
 	cmd ip link set mtu $(( mtu - 80 )) dev "$INTERFACE"
 }
 
+set_dns() {
+	[[ ${#DNS[@]} -eq 0 ]] || printf 'nameserver %s\n' "${DNS[@]}" | cmd resolvconf -a "tun.$INTERFACE" -m 0 -x
+}
+
+unset_dns() {
+	[[ ${#DNS[@]} -eq 0 ]] || cmd resolvconf -d "tun.$INTERFACE"
+}
+
 add_route() {
 	if [[ $1 == 0.0.0.0/0 || $1 =~ ^[0:]+/0$ ]]; then
 		add_default "$1"
@@ -168,6 +178,9 @@ save_config() {
 	for address in ${BASH_REMATCH[1]}; do
 		new_config+="Address = $address"$'\n'
 	done
+	while read -r address; do
+		[[ $address =~ ^nameserver\ ([a-zA-Z0-9_=+:%.-]+)$ ]] && new_config+="DNS = ${BASH_REMATCH[1]}"$'\n'
+	done < <(resolvconf -l "tun.$INTERFACE" 2>/dev/null)
 	[[ -n $MTU && $(ip link show dev "$INTERFACE") =~ mtu\ ([0-9]+) ]] && new_config+="MTU = ${BASH_REMATCH[1]}"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
 	[[ -z $PRE_UP ]] || new_config+="PreUp = $PRE_UP"$'\n'
@@ -203,6 +216,7 @@ cmd_usage() {
 
 	  - Address: may be specified one or more times and contains one or more
 	    IP addresses (with an optional CIDR mask) to be set for the interface.
+	  - DNS: an optional DNS server to use while the device is up.
 	  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.
 	  - PreUp, PostUp, PreDown, PostDown: script snippets which will be executed
 	    by bash(1) at the corresponding phases of the link, most commonly used
@@ -226,6 +240,7 @@ cmd_up() {
 	done
 	set_mtu
 	up_if
+	set_dns
 	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
 		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"
 	done
@@ -237,6 +252,7 @@ cmd_down() {
 	[[ -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] || die "\`$INTERFACE' is not a WireGuard interface"
 	execute_hook "$PRE_DOWN"
 	[[ $SAVE_CONFIG -eq 0 ]] || save_config
+	unset_dns
 	del_if
 	execute_hook "$POST_DOWN"
 }

commit 41e50edbe5fd5c4a34b27830907f3e49114e8695
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jul 24 23:22:10 2017 +0200

    wg-quick: do not use grep
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index b1fb435..d7e7d68 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -226,7 +226,7 @@ cmd_up() {
 	done
 	set_mtu
 	up_if
-	for i in $(wg show "$INTERFACE" allowed-ips | grep -Po '(?<=[\t ])[0-9.:/a-f]+' | sort -nr -k 2 -t /); do
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
 		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"
 	done
 	execute_hook "$POST_UP"

commit 11204afd6fe739598475b67f450629fecb5bd6f2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jul 24 16:08:42 2017 +0200

    wg-quick: do not set explicit src route for v6 default route
    
    This was only required because clueless network operators were trying to
    route fec0::/10 globally, when that range doesn't actually have global
    scope. Now that we understand the cause was operator error, we revert
    the change here, so that the routing table is kept consistent.
    
    This reverts commit 64e47de870a2f0575b5564a70e5680b48ab83ff9.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index ff92221..b1fb435 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -144,18 +144,10 @@ add_default() {
 			((DEFAULT_TABLE++))
 		done
 	fi
-	local proto=-4 src ip
-	if [[ $1 == *:* ]]; then
-		proto=-6
-		for ip in "${ADDRESSES[@]}"; do
-			if [[ $ip == *:* ]]; then
-				src="src ${ip%/*}"
-				break
-			fi
-		done
-	fi
+	local proto=-4
+	[[ $1 == *:* ]] && proto=-6
 	cmd wg set "$INTERFACE" fwmark $DEFAULT_TABLE
-	cmd ip $proto route add "$1" $src dev "$INTERFACE" table $DEFAULT_TABLE
+	cmd ip $proto route add "$1" dev "$INTERFACE" table $DEFAULT_TABLE
 	cmd ip $proto rule add not fwmark $DEFAULT_TABLE table $DEFAULT_TABLE
 	cmd ip $proto rule add table main suppress_prefixlength 0
 	local key value

commit 91fb17a01435bbcc101b4edf6918127af6b275f0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 20 06:07:48 2017 +0200

    android: add port of wg-quick
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/android/README.md b/contrib/android/README.md
new file mode 100644
index 0000000..943d5f2
--- /dev/null
+++ b/contrib/android/README.md
@@ -0,0 +1,21 @@
+# Tools for Android
+
+This currently contains a version of wg-quick.bash that works with
+Android 7's `ndc` command. It requires the WireGuard module to be
+part of your kernel, but after that, the usual `wg-quick up` and
+`wg-quick down` commands work normally.
+
+## Installation
+
+Build a `wg` binary for Android and place it in this folder. Then
+copy this folder some place on your phone, and run `sh ./install.sh`
+as root. It should survive ROM flashes.
+
+## Usage
+
+Compared to the ordinary wg-quick, this one gains a "DNS =" field,
+but loses SaveConfig and {Pre,Post}{Up,Down}.
+
+Put your configuration files into `/data/misc/wireguard/`. After that,
+the normal `wg-quick up|down` commands will work.
+
diff --git a/contrib/android/addonsd.sh b/contrib/android/addonsd.sh
new file mode 100644
index 0000000..90865d0
--- /dev/null
+++ b/contrib/android/addonsd.sh
@@ -0,0 +1,37 @@
+#!/sbin/sh
+
+. /tmp/backuptool.functions
+
+list_files() {
+cat <<_EOF
+xbin/wg
+xbin/wg-quick
+_EOF
+}
+
+case "$1" in
+	backup)
+		list_files | while read FILE DUMMY; do
+			backup_file $S/"$FILE"
+		done
+	;;
+	restore)
+		list_files | while read FILE REPLACEMENT; do
+			R=""
+			[ -n "$REPLACEMENT" ] && R="$S/$REPLACEMENT"
+			[ -f "$C/$S/$FILE" ] && restore_file $S/"$FILE" "$R"
+		done
+	;;
+	pre-backup)
+		# Stub
+	;;
+	post-backup)
+		# Stub
+	;;
+	pre-restore)
+		# Stub
+	;;
+	post-restore)
+		# Stub
+	;;
+esac
diff --git a/contrib/android/install.sh b/contrib/android/install.sh
new file mode 100755
index 0000000..f619eb6
--- /dev/null
+++ b/contrib/android/install.sh
@@ -0,0 +1,14 @@
+#!/bin/sh
+mount -o rw,remount /system
+
+cp -v ./addonsd.sh /system/addon.d/40-wireguard.sh
+if [ -f ./wg ]; then
+	cp -v ./wg /system/xbin/wg
+else
+	echo "Warning: this directory does not contain wg. You may have forgotten to compile it yourself?" >&2
+fi
+cp -v ./wg-quick.bash /system/xbin/wg-quick
+chmod 755 /system/xbin/wg /system/xbin/wg-quick /system/addon.d/40-wireguard.sh
+mkdir -pvm 700 /data/misc/wireguard
+
+mount -o ro,remount /system
diff --git a/contrib/android/wg-quick.bash b/contrib/android/wg-quick.bash
new file mode 100644
index 0000000..4041735
--- /dev/null
+++ b/contrib/android/wg-quick.bash
@@ -0,0 +1,187 @@
+#!/system/xbin/bash
+#
+# Copyright (C) 2016-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+#
+
+set -e -o pipefail
+shopt -s extglob
+export LC_ALL=C
+
+SELF="$(readlink -f "${BASH_SOURCE[0]}")"
+export PATH="${SELF%/*}:$PATH"
+
+WG_CONFIG=""
+INTERFACE=""
+NETID=0
+ADDRESSES=( )
+MTU=""
+DNS=""
+CONFIG_FILE=""
+PROGRAM="${0##*/}"
+ARGS=( "$@" )
+
+parse_options() {
+	local interface_section=0 line key value
+	CONFIG_FILE="$1"
+	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,16}$ ]] && CONFIG_FILE="/data/misc/wireguard/$CONFIG_FILE.conf"
+	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
+	[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,16})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
+	((($(stat -c '%#a' "$CONFIG_FILE") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
+	INTERFACE="${BASH_REMATCH[1]}"
+	shopt -s nocasematch
+	while read -r line || [[ -n $line ]]; do
+		key="${line%%=*}"; key="${key##*( )}"; key="${key%%*( )}"
+		value="${line#*=}"; value="${value##*( )}"; value="${value%%*( )}"
+		[[ $key == "["* ]] && interface_section=0
+		[[ $key == "[Interface]" ]] && interface_section=1
+		if [[ $interface_section -eq 1 ]]; then
+			case "$key" in
+			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
+			MTU) MTU="$value"; continue ;;
+			DNS) DNS="$value"; continue ;;
+			esac
+		fi
+		WG_CONFIG+="$line"$'\n'
+	done < "$CONFIG_FILE"
+	shopt -u nocasematch
+}
+
+cmd() {
+	echo "[#] $*" >&2
+	"$@"
+}
+
+cndc() {
+	local out="$(cmd ndc "$@")"
+	[[ $out == *200\ 0* ]] || { echo "$out"; return 1; }
+}
+
+die() {
+	echo "$PROGRAM: $*" >&2
+	exit 1
+}
+
+auto_su() {
+	[[ $UID == 0 ]] || exec su -p -c "'$SELF' ${ARGS[*]}"
+}
+
+add_if() {
+	cmd ip link add "$INTERFACE" type wireguard
+}
+
+del_if() {
+	cmd ip link del "$INTERFACE"
+	[[ $(ip rule show) =~ 0xc([0-9a-f]+)/0xcffff\ lookup\ $INTERFACE ]] && cndc network destroy $(( 0x${BASH_REMATCH[1]} ));
+}
+
+up_if() {
+	while [[ $NETID -lt 4096 ]]; do
+		NETID="$RANDOM"
+	done
+	cmd wg set "$INTERFACE" fwmark 0x20000
+	cndc interface setcfg "$INTERFACE" up
+	cndc network create "$NETID" vpn 1 1
+	cndc network interface add "$NETID" "$INTERFACE"
+	cndc network users add "$NETID" 0-99999
+}
+
+set_dns() {
+	cndc resolver setnetdns "$NETID" "" "$1"
+}
+
+add_addr() {
+	if [[ $1 == *:* ]]; then
+		cndc interface ipv6 "$INTERFACE" enable
+		cmd ip -6 addr add "$1" dev "$INTERFACE"
+	else
+		local ip="${1%%/*}" mask=32
+		[[ $1 == */* ]] && mask="${1##*/}"
+		cndc interface setcfg "$INTERFACE" "$ip" "$mask"
+	fi
+}
+
+set_mtu() {
+	local mtu=0 endpoint output
+	if [[ -n $MTU ]]; then
+		cndc interface setmtu "$INTERFACE" "$MTU"
+		return
+	fi
+	while read -r _ endpoint; do
+		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
+		output="$(ip route get "${BASH_REMATCH[1]}" || true)"
+		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
+	done < <(wg show "$INTERFACE" endpoints)
+	if [[ $mtu -eq 0 ]]; then
+		read -r output < <(ip route show default || true) || true
+		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
+	fi
+	[[ $mtu -gt 0 ]] || mtu=1500
+	cndc interface setmtu "$INTERFACE" $(( mtu - 80 ))
+}
+
+add_route() {
+	cndc network route add "$NETID" "$INTERFACE" "$1"
+}
+
+set_config() {
+	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG")
+}
+
+cmd_usage() {
+	cat >&2 <<-_EOF
+	Usage: $PROGRAM [ up | down ] [ CONFIG_FILE | INTERFACE ]
+
+	  CONFIG_FILE is a configuration file, whose filename is the interface name
+	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
+	  configuration found at /data/misc/wireguard/INTERFACE.conf. It is to be readable
+	  by wg(8)'s \`setconf' sub-command, with the exception of the following additions
+	  to the [Interface] section, which are handled by $PROGRAM:
+
+	  - Address: may be specified one or more times and contains one or more
+	    IP addresses (with an optional CIDR mask) to be set for the interface.
+	  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.
+	  - DNS: an optional DNS server to use while the device is up.
+
+	See wg-quick(8) for more info and examples.
+	_EOF
+}
+
+cmd_up() {
+	local i
+	[[ -z $(ip link show dev "$INTERFACE" 2>/dev/null) ]] || die "\`$INTERFACE' already exists"
+	trap 'del_if; exit' INT TERM EXIT
+	add_if
+	set_config
+	set_mtu
+	for i in "${ADDRESSES[@]}"; do
+		add_addr "$i"
+	done
+	up_if
+	[[ -z $DNS ]] || set_dns "$DNS"
+	for i in $(while read -r _ i; do for i in $i; do [[ $i =~ ^[0-9a-z:.]+/[0-9]+$ ]] && echo "$i"; done; done < <(wg show "$INTERFACE" allowed-ips) | sort -nr -k 2 -t /); do
+		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"
+	done
+	trap - INT TERM EXIT
+}
+
+cmd_down() {
+	[[ -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] || die "\`$INTERFACE' is not a WireGuard interface"
+	del_if
+}
+
+if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
+	cmd_usage
+elif [[ $# -eq 2 && $1 == up ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_up
+elif [[ $# -eq 2 && $1 == down ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_down
+else
+	cmd_usage
+	exit 1
+fi
+
+exit 0

commit 077dac0514a650cc92501ecb8a07a0b297e6f331
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 20 06:29:14 2017 +0200

    wg-quick: usage typos
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 243f35d..ff92221 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -211,13 +211,14 @@ cmd_usage() {
 
 	  - Address: may be specified one or more times and contains one or more
 	    IP addresses (with an optional CIDR mask) to be set for the interface.
+	  - MTU: an optional MTU for the interface; if unspecified, auto-calculated.
 	  - PreUp, PostUp, PreDown, PostDown: script snippets which will be executed
 	    by bash(1) at the corresponding phases of the link, most commonly used
 	    to configure DNS. The string \`%i' is expanded to INTERFACE.
 	  - SaveConfig: if set to \`true', the configuration is saved from the current
 	    state of the interface upon shutdown.
 
-	 See wg-quick(8) for more info and examples.
+	See wg-quick(8) for more info and examples.
 	_EOF
 }
 

commit aad91ae6791910315a929cc3f1973e96d33bcd1c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 16 16:12:20 2017 +0200

    global: wireguard.io --> wireguard.com
    
    Due to concerns with the .io TLD, we are switching to using
    wireguard.com instead.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/README.md b/README.md
index 0f6e1c5..08f8827 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,7 @@
 
 WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes **state-of-the-art cryptography**. It aims to be faster, simpler, leaner, and more useful than IPSec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. It runs over UDP.
 
-**More information may be found at [WireGuard.io](https://www.wireguard.io/).**
+**More information may be found at [WireGuard.com](https://www.wireguard.com/).**
 
 ## License
 
diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index e3627f3..9b60636 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -51,7 +51,7 @@ func main() {
 		StaticKeypair:         noise.DHKey{Private: ourPrivate, Public: ourPublic},
 		PeerStatic:            theirPublic,
 	})
-	conn, err := net.Dial("udp", "demo.wireguard.io:12913")
+	conn, err := net.Dial("udp", "demo.wireguard.com:12913")
 	if err != nil {
 		log.Fatalf("error dialing udp socket: %s", err)
 	}
diff --git a/contrib/external-tests/haskell/src/Main.hs b/contrib/external-tests/haskell/src/Main.hs
index b0b7503..7863829 100644
--- a/contrib/external-tests/haskell/src/Main.hs
+++ b/contrib/external-tests/haskell/src/Main.hs
@@ -57,7 +57,7 @@ unsafeMessage write mpsk msg ns = case operation msg ns of
 
 main :: IO ()
 main = do
-  let ip           = "demo.wireguard.io"
+  let ip           = "demo.wireguard.com"
       port         = "12913"
       myKeyB64     = "WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=" -- private key
       serverKeyB64 = "qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=" -- public key
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index 9fb0f5a..fdd220e 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -17,7 +17,7 @@ use pnet::packet::icmp::{MutableIcmpPacket, IcmpTypes, echo_reply, echo_request,
 use std::net::*;
 use std::str::FromStr;
 
-static TEST_SERVER: &'static str = "demo.wireguard.io:12913";
+static TEST_SERVER: &'static str = "demo.wireguard.com:12913";
 
 fn memcpy(out: &mut [u8], data: &[u8]) {
 	out[..data.len()].copy_from_slice(data);
diff --git a/contrib/nat-hole-punching/nat-punch-client.c b/contrib/nat-hole-punching/nat-punch-client.c
index 65f3249..aa00d35 100644
--- a/contrib/nat-hole-punching/nat-punch-client.c
+++ b/contrib/nat-hole-punching/nat-punch-client.c
@@ -140,7 +140,7 @@ int main(int argc, char *argv[])
 	const char *server = argv[1], *interface = argv[2];
 
 	if (argc < 3) {
-		fprintf(stderr, "Usage: %s SERVER WIREGUARD_INTERFACE\nExample:\n    %s demo.wireguard.io wg0\n", argv[0], argv[0]);
+		fprintf(stderr, "Usage: %s SERVER WIREGUARD_INTERFACE\nExample:\n    %s demo.wireguard.com wg0\n", argv[0], argv[0]);
 		return EINVAL;
 	}
 
diff --git a/contrib/ncat-client-server/README b/contrib/ncat-client-server/README
index f584829..0c0667a 100644
--- a/contrib/ncat-client-server/README
+++ b/contrib/ncat-client-server/README
@@ -11,6 +11,6 @@ That all said, this is a pretty cool example of just how
 darn easy WireGuard can be.
 
 Disclaimer:
-  The `demo.wireguard.io` server in client.sh is for testing
+  The `demo.wireguard.com` server in client.sh is for testing
   purposes only. You may not use this server for abusive or
   illegal purposes.
diff --git a/contrib/ncat-client-server/client.sh b/contrib/ncat-client-server/client.sh
index b49a05e..1d30f49 100755
--- a/contrib/ncat-client-server/client.sh
+++ b/contrib/ncat-client-server/client.sh
@@ -6,13 +6,13 @@ set -e
 [[ $UID == 0 ]] || { echo "You must be root to run this."; exit 1; }
 umask 077
 trap 'rm -f /tmp/wg_private_key' EXIT INT TERM
-exec 3<>/dev/tcp/demo.wireguard.io/42912
+exec 3<>/dev/tcp/demo.wireguard.com/42912
 wg genkey | tee /tmp/wg_private_key | wg pubkey >&3
 IFS=: read -r status server_pubkey server_port internal_ip <&3
 [[ $status == OK ]]
 ip link del dev wg0 2>/dev/null || true
 ip link add dev wg0 type wireguard
-wg set wg0 private-key /tmp/wg_private_key peer "$server_pubkey" allowed-ips 0.0.0.0/0 endpoint "demo.wireguard.io:$server_port" persistent-keepalive 25
+wg set wg0 private-key /tmp/wg_private_key peer "$server_pubkey" allowed-ips 0.0.0.0/0 endpoint "demo.wireguard.com:$server_port" persistent-keepalive 25
 ip address add "$internal_ip"/24 dev wg0
 ip link set up dev wg0
 if [ "$1" == "default-route" ]; then
diff --git a/src/wg-quick.8 b/src/wg-quick.8
index ceee026..04653a8 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -114,7 +114,7 @@ traffic:
 .br
     AllowedIPs = 0.0.0.0/0 
 .br
-    Endpoint = demo.wireguard.io:51820 
+    Endpoint = demo.wireguard.com:51820 
 .br
 
 Notice that the `PostUp` and `PostDown` commands are used here to configure DNS using
@@ -193,6 +193,6 @@ was written by
 Jason A. Donenfeld
 .ME .
 For updates and more information, a project page is available on the
-.UR https://\:www.wireguard.io/
+.UR https://\:www.wireguard.com/
 World Wide Web
 .UE .
diff --git a/src/wg-quick@.service b/src/wg-quick@.service
index f5f4e8f..ce6d70a 100644
--- a/src/wg-quick@.service
+++ b/src/wg-quick@.service
@@ -4,8 +4,8 @@ After=network-online.target
 Wants=network-online.target
 Documentation=man:wg-quick(8)
 Documentation=man:wg(8)
-Documentation=https://www.wireguard.io/
-Documentation=https://www.wireguard.io/quickstart/
+Documentation=https://www.wireguard.com/
+Documentation=https://www.wireguard.com/quickstart/
 Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/wg-quick.8
 Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/wg.8
 
diff --git a/src/wg.8 b/src/wg.8
index 1517432..612fb4e 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -200,7 +200,7 @@ ignored.
 .br
     PublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA=
 .br
-    Endpoint = test.wireguard.io:18981
+    Endpoint = test.wireguard.com:18981
 .br
     AllowedIPs = 10.10.10.230/32
 
@@ -225,6 +225,6 @@ was written by
 Jason A. Donenfeld
 .ME .
 For updates and more information, a project page is available on the
-.UR https://\:www.wireguard.io/
+.UR https://\:www.wireguard.com/
 World Wide Web
 .UE .

commit 28f373e9cd04282343f9e280939b2a17b707f1c1
Author: Samuel Holland <samuel@sholland.org>
Date:   Wed May 31 11:30:59 2017 -0500

    gitignore: ignore split DWARF debug info
    
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/.gitignore b/.gitignore
index cba889d..83768f6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,7 @@
 cscope.out
 *.o
 *.d
+*.dwo
 *.ko
 *.mod.c
 src/tools/wg

commit e22155a3b7cf238f18aae087b4f7f8000757815d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jun 29 14:34:27 2017 +0200

    wg: remove double include in ipc
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 5290996..ed5fbc2 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -14,7 +14,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <errno.h>
 #include <unistd.h>
 #include <time.h>
 #include <dirent.h>

commit d3ebbaccab322021614949de3081671c44b5aefe
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jun 27 22:18:13 2017 +0200

    wg-quick: use printf -v instead of namerefs for bash 4.2
    
    I'm not happy about this.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 6edcd3a..243f35d 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -54,10 +54,9 @@ parse_options() {
 }
 
 read_bool() {
-	local -n out="$1"
 	case "$2" in
-	true) out=1 ;;
-	false) out=0 ;;
+	true) printf -v "$1" 1 ;;
+	false) printf -v "$1" 0 ;;
 	*) die "\`$2' is neither true nor false"
 	esac
 }

commit cf4b3ebd080dcce574e2890927e52e6426aa776f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 23 14:48:03 2017 +0200

    wg-quick: properly match IPv6 endpoint
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 012e41f..6edcd3a 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -117,7 +117,7 @@ set_mtu() {
 		return
 	fi
 	while read -r _ endpoint; do
-		[[ $endpoint =~ ^([a-z0-9:.]+):[0-9]+$ ]] || continue
+		[[ $endpoint =~ ^\[?([a-z0-9:.]+)\]?:[0-9]+$ ]] || continue
 		output="$(ip route get "${BASH_REMATCH[1]}" || true)"
 		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
 	done < <(wg show "$INTERFACE" endpoints)

commit e7fd4cfd3f98e9709842f6a33695e0ee7b79fbd0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jun 13 23:35:27 2017 +0200

    haskell: re-add updated haskell example
    
    Code-from: John Galt <jgalt@centromere.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/haskell/Setup.hs b/contrib/external-tests/haskell/Setup.hs
new file mode 100644
index 0000000..9a994af
--- /dev/null
+++ b/contrib/external-tests/haskell/Setup.hs
@@ -0,0 +1,2 @@
+import Distribution.Simple
+main = defaultMain
diff --git a/contrib/external-tests/haskell/package.yaml b/contrib/external-tests/haskell/package.yaml
new file mode 100644
index 0000000..3c8cc55
--- /dev/null
+++ b/contrib/external-tests/haskell/package.yaml
@@ -0,0 +1,36 @@
+name: cacophony-wg
+version: 0.1.0
+license: PublicDomain
+maintainer: John Galt <jgalt@centromere.net>
+category: Cryptography
+ghc-options: -Wall
+
+executables:
+  cacophony-wg:
+    main: Main.hs
+    source-dirs: src
+
+    dependencies:
+      - base
+      - base16-bytestring
+      - base64-bytestring
+      - blake2
+      - bytestring
+      - cacophony >= 0.10
+      - cereal
+      - cryptonite
+      - memory
+      - network
+      - time
+
+    ghc-options:
+      - -O2
+      - -rtsopts
+      - -threaded
+      - -with-rtsopts=-N
+
+    other-modules:
+      - Data.Time.TAI64
+
+    default-extensions:
+      - OverloadedStrings
diff --git a/contrib/external-tests/haskell/src/Data/Time/TAI64.hs b/contrib/external-tests/haskell/src/Data/Time/TAI64.hs
new file mode 100644
index 0000000..37a90e6
--- /dev/null
+++ b/contrib/external-tests/haskell/src/Data/Time/TAI64.hs
@@ -0,0 +1,86 @@
+module Data.Time.TAI64 (
+    TAI64(..)
+  , TAI64N(..)
+  , TAI64NA(..)
+  , posixToTAI64
+  , posixToTAI64N
+  , posixToTAI64NA
+  , getCurrentTAI64
+  , getCurrentTAI64N
+  , getCurrentTAI64NA
+  , tAI64ToPosix
+  , tAI64NToPosix
+  , tAI64NAToPosix
+) where
+
+import Data.Serialize
+import Control.Monad
+import Data.Word
+
+import Data.Time.Clock
+import Data.Time.Clock.POSIX
+
+import Numeric
+
+data TAI64 = TAI64
+  {-# UNPACK #-} !Word64
+  deriving (Eq, Ord)
+
+data TAI64N = TAI64N
+  {-# UNPACK #-} !TAI64
+  {-# UNPACK #-} !Word32
+  deriving (Eq, Ord, Show)
+
+data TAI64NA = TAI64NA
+  {-# UNPACK #-} !TAI64N
+  {-# UNPACK #-} !Word32
+  deriving (Eq, Ord, Show)
+
+instance Show TAI64   where
+  show (TAI64 t) = "TAI64 0x" ++ showHex t ""
+
+instance Serialize TAI64 where
+  put (TAI64 t) = putWord64be t
+  get = liftM TAI64 get
+
+instance Serialize TAI64N where
+  put (TAI64N  t' nt) = put t' >> putWord32be nt
+  get = liftM2 TAI64N  get get
+
+instance Serialize TAI64NA where
+  put (TAI64NA t' at) = put t' >> putWord32be at
+  get = liftM2 TAI64NA get get
+
+
+posixToTAI64 :: POSIXTime -> TAI64
+posixToTAI64 = TAI64 . (2^62 +) . truncate . realToFrac
+
+posixToTAI64N :: POSIXTime -> TAI64N
+posixToTAI64N pt = TAI64N t' ns where
+  t' = posixToTAI64 pt
+  ns = (`mod` 10^9) $ truncate (pts * 10**9)
+  pts = realToFrac pt
+
+posixToTAI64NA :: POSIXTime -> TAI64NA -- | PICOsecond precision
+posixToTAI64NA pt = TAI64NA t' as where
+  t' = posixToTAI64N pt
+  as = (`mod` 10^9) $ truncate (pts * 10**18)
+  pts = realToFrac pt
+
+getCurrentTAI64   :: IO TAI64
+getCurrentTAI64N  :: IO TAI64N
+getCurrentTAI64NA :: IO TAI64NA
+getCurrentTAI64   = liftM posixToTAI64   getPOSIXTime
+getCurrentTAI64N  = liftM posixToTAI64N  getPOSIXTime
+getCurrentTAI64NA = liftM posixToTAI64NA getPOSIXTime
+
+tAI64ToPosix :: TAI64 -> POSIXTime
+tAI64ToPosix (TAI64 s) = fromRational . fromIntegral $ s - 2^62
+
+tAI64NToPosix :: TAI64N -> POSIXTime
+tAI64NToPosix (TAI64N t' n) = tAI64ToPosix t' + nanopart where
+  nanopart = fromRational $ (toRational $ 10**(-9)) * toRational n -- TODO: optimize?
+
+tAI64NAToPosix :: TAI64NA -> POSIXTime
+tAI64NAToPosix (TAI64NA t' a) = tAI64NToPosix t' + attopart where
+  attopart = fromRational $ (toRational $ 10**(-18)) * toRational a
diff --git a/contrib/external-tests/haskell/src/Main.hs b/contrib/external-tests/haskell/src/Main.hs
new file mode 100644
index 0000000..b0b7503
--- /dev/null
+++ b/contrib/external-tests/haskell/src/Main.hs
@@ -0,0 +1,138 @@
+module Main where
+
+import           Control.Monad              (void)
+import           Crypto.Hash.BLAKE2.BLAKE2s (hash)
+import           Data.ByteArray             (ScrubbedBytes, convert)
+import           Data.ByteString            (ByteString, replicate, take, drop)
+import qualified Data.ByteString.Base16     as B16
+import qualified Data.ByteString.Base64     as B64
+import           Data.Maybe                 (fromMaybe)
+import           Data.Monoid                ((<>))
+import qualified Data.Serialize             as S
+import           Network.Socket
+import qualified Network.Socket.ByteString  as NBS
+import           Prelude hiding             (replicate, take, drop)
+
+import Crypto.Noise
+import Crypto.Noise.Cipher
+import Crypto.Noise.Cipher.ChaChaPoly1305
+import Crypto.Noise.DH
+import Crypto.Noise.DH.Curve25519
+import Crypto.Noise.HandshakePatterns (noiseIKpsk2)
+import Crypto.Noise.Hash hiding (hash)
+import Crypto.Noise.Hash.BLAKE2s
+
+import Data.Time.TAI64
+
+sampleICMPRequest :: ByteString
+sampleICMPRequest = fst . B16.decode $
+  "450000250000000014018f5b0abd81020abd810108001bfa039901b6576972654775617264"
+
+validateICMPResponse :: ByteString
+                     -> Bool
+validateICMPResponse r =
+  -- Strip off part of IPv4 header because this is only a demo.
+  drop 12 sample == drop 12 r
+  where
+    sample = fst . B16.decode $ "45000025e3030000400180570abd81010abd8102000023fa039901b65769726547756172640000000000000000000000"
+
+unsafeMessage :: (Cipher c, DH d, Hash h)
+              => Bool
+              -> Maybe ScrubbedBytes
+              -> ScrubbedBytes
+              -> NoiseState c d h
+              -> (ScrubbedBytes, NoiseState c d h)
+unsafeMessage write mpsk msg ns = case operation msg ns of
+  NoiseResultMessage ct ns' -> (ct, ns')
+
+  NoiseResultNeedPSK ns' -> case mpsk of
+    Nothing -> error "psk required but not provided"
+    Just k  -> case operation k ns' of
+      NoiseResultMessage ct ns'' -> (ct, ns'')
+      _ -> error "something terrible happened"
+
+  _ -> error "something terrible happened"
+  where
+    operation = if write then writeMessage else readMessage
+
+main :: IO ()
+main = do
+  let ip           = "demo.wireguard.io"
+      port         = "12913"
+      myKeyB64     = "WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=" -- private key
+      serverKeyB64 = "qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=" -- public key
+      pskB64       = "FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE="
+
+  addrInfo <- head <$> getAddrInfo Nothing (Just ip) (Just port)
+  sock     <- socket (addrFamily addrInfo) Datagram defaultProtocol
+
+  let addr        = addrAddress addrInfo
+      myStaticKey = fromMaybe (error "invalid private key")
+                    . dhBytesToPair
+                    . convert
+                    . either (error "error Base64 decoding my private key") id
+                    . B64.decode
+                    $ myKeyB64 :: KeyPair Curve25519
+
+      serverKey   = fromMaybe (error "invalid public key")
+                    . dhBytesToPub
+                    . convert
+                    . either (error "error Base64 decoding server public key") id
+                    . B64.decode
+                    $ serverKeyB64 :: PublicKey Curve25519
+
+      psk         = convert
+                    . either (error "error decoding PSK") id
+                    . B64.decode
+                    $ pskB64 :: ScrubbedBytes
+
+  myEphemeralKey <- dhGenKey
+
+  let dho  = defaultHandshakeOpts InitiatorRole "WireGuard v1 zx2c4 Jason@zx2c4.com"
+      opts = setLocalEphemeral (Just myEphemeralKey)
+             . setLocalStatic  (Just myStaticKey)
+             . setRemoteStatic (Just serverKey)
+             $ dho
+      ns0  = noiseState opts noiseIKpsk2 :: NoiseState ChaChaPoly1305 Curve25519 BLAKE2s
+
+  tai64n <- convert . S.encode <$> getCurrentTAI64N
+
+  -- Handshake: Initiator to responder -----------------------------------------
+
+  let (msg0, ns1) = unsafeMessage True Nothing tai64n ns0
+      macKey      = hash 32 mempty $ "mac1----" `mappend` (convert . dhPubToBytes) serverKey
+      initiation  = "\x01\x00\x00\x00\x1c\x00\x00\x00" <> convert msg0 -- sender index = 28 to match other examples
+      mac1        = hash 16 macKey initiation
+
+  void $ NBS.sendTo sock (initiation <> mac1 <> replicate 16 0) addr
+
+  -- Handshake: Responder to initiator -----------------------------------------
+
+  (response0, _) <- NBS.recvFrom sock 1024
+
+  let theirIndex  = take 4  . drop 4  $ response0
+      (_, ns2)    = unsafeMessage False (Just psk) (convert . take 48 . drop 12 $ response0) ns1
+
+  -- ICMP: Initiator to responder ----------------------------------------------
+
+  let (msg1, ns3) = unsafeMessage True Nothing (convert sampleICMPRequest) ns2
+      icmp        = "\x04\x00\x00\x00" <> theirIndex <> replicate 8 0 <> convert msg1
+
+  void $ NBS.sendTo sock icmp addr
+
+  -- ICMP: Responder to initiator ----------------------------------------------
+
+  (response1, _) <- NBS.recvFrom sock 1024
+
+  let (icmpPayload, ns4) = unsafeMessage False Nothing (convert . drop 16 $ response1) ns3
+
+  -- KeepAlive: Initiator to responder -----------------------------------------
+
+  if validateICMPResponse . convert $ icmpPayload
+    then do
+      let (msg2, _) = unsafeMessage True Nothing mempty ns4
+          keepAlive = "\x04\x00\x00\x00" <> theirIndex <> "\x01" <> replicate 7 0 <> convert msg2
+
+      void $ NBS.sendTo sock keepAlive addr
+
+    else error "unexpected ICMP response from server!"
diff --git a/contrib/external-tests/haskell/stack.yaml b/contrib/external-tests/haskell/stack.yaml
new file mode 100644
index 0000000..f5612fc
--- /dev/null
+++ b/contrib/external-tests/haskell/stack.yaml
@@ -0,0 +1,6 @@
+resolver: lts-8.18
+packages:
+  - '.'
+extra-deps: []
+flags: {}
+extra-package-dbs: []

commit f90f8f33a718bade18599c711d1765519b05d2e1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jun 12 17:01:23 2017 +0200

    wg: use proper __linux__ ifdef
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/genkey.c b/src/genkey.c
index 52aeef5..9a62060 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -7,7 +7,7 @@
 #include <sys/stat.h>
 #include <string.h>
 #include <fcntl.h>
-#ifdef __linux
+#ifdef __linux__
 #include <sys/syscall.h>
 #endif
 

commit eaa64b198bf82ffe73e8a9a17ab047f21dd44866
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jun 12 00:20:31 2017 +0200

    wg-quick: match ipv6 default route more broadly
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 75050fd..012e41f 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -130,7 +130,7 @@ set_mtu() {
 }
 
 add_route() {
-	if [[ $1 == 0.0.0.0/0 || $1 == ::/0 ]]; then
+	if [[ $1 == 0.0.0.0/0 || $1 =~ ^[0:]+/0$ ]]; then
 		add_default "$1"
 	else
 		cmd ip route add "$1" dev "$INTERFACE"

commit 1b5234f3d59f2bca0c2d49600979d856229ba781
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jun 11 23:39:17 2017 +0200

    wg-quick: make sure we have empty table for both v6 and v4
    
    Otherwise, we wind up not doing the right thing in the v6-only case, or
    doing something totally borked when v4 and v6 are filled unevenly.
    
    Reported-by: Roelf Wichertjes <contact@roelf.org>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index a4f349a..75050fd 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -141,7 +141,9 @@ DEFAULT_TABLE=
 add_default() {
 	if [[ -z $DEFAULT_TABLE ]]; then
 		DEFAULT_TABLE=51820
-		while [[ -n $(ip route show table $DEFAULT_TABLE) ]]; do ((DEFAULT_TABLE++)); done
+		while [[ -n $(ip -4 route show table $DEFAULT_TABLE) || -n $(ip -6 route show table $DEFAULT_TABLE) ]]; do
+			((DEFAULT_TABLE++))
+		done
 	fi
 	local proto=-4 src ip
 	if [[ $1 == *:* ]]; then

commit fbf715ea45fae7028e726f80e4d5bef7174677d0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 9 02:56:08 2017 +0200

    external-tests: trim the fat
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/haskell/.gitignore b/contrib/external-tests/haskell/.gitignore
deleted file mode 100644
index 1159ea5..0000000
--- a/contrib/external-tests/haskell/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-.cabal-sandbox/
-dist
diff --git a/contrib/external-tests/haskell/Setup.hs b/contrib/external-tests/haskell/Setup.hs
deleted file mode 100644
index 9a994af..0000000
--- a/contrib/external-tests/haskell/Setup.hs
+++ /dev/null
@@ -1,2 +0,0 @@
-import Distribution.Simple
-main = defaultMain
diff --git a/contrib/external-tests/haskell/cacophony-wg.cabal b/contrib/external-tests/haskell/cacophony-wg.cabal
deleted file mode 100644
index 90f519d..0000000
--- a/contrib/external-tests/haskell/cacophony-wg.cabal
+++ /dev/null
@@ -1,34 +0,0 @@
--- Initial cacophony-wg.cabal generated by cabal init.  For further 
--- documentation, see https://www.haskell.org/cabal/users-guide/
-
-name:                cacophony-wg
-version:             0.1.0
--- synopsis:            
--- description:         
-license:             PublicDomain
-license-file:        LICENSE
-author:              John Galt
-maintainer:          centromere@users.noreply.github.com
--- copyright:           
--- category:            
-build-type:          Simple
--- extra-source-files:  
-cabal-version:       >=1.10
-
-executable cacophony-wg
-  main-is:             Main.hs
-  other-modules:
-    Data.Time.TAI64
-  build-depends:
-    base >=4.8 && <4.9,
-    base16-bytestring,
-    base64-bytestring,
-    blake2,
-    bytestring,
-    cacophony,
-    cereal,
-    cryptonite,
-    network,
-    time
-  hs-source-dirs:      src
-  default-language:    Haskell2010
diff --git a/contrib/external-tests/haskell/src/Data/Time/TAI64.hs b/contrib/external-tests/haskell/src/Data/Time/TAI64.hs
deleted file mode 100644
index 37a90e6..0000000
--- a/contrib/external-tests/haskell/src/Data/Time/TAI64.hs
+++ /dev/null
@@ -1,86 +0,0 @@
-module Data.Time.TAI64 (
-    TAI64(..)
-  , TAI64N(..)
-  , TAI64NA(..)
-  , posixToTAI64
-  , posixToTAI64N
-  , posixToTAI64NA
-  , getCurrentTAI64
-  , getCurrentTAI64N
-  , getCurrentTAI64NA
-  , tAI64ToPosix
-  , tAI64NToPosix
-  , tAI64NAToPosix
-) where
-
-import Data.Serialize
-import Control.Monad
-import Data.Word
-
-import Data.Time.Clock
-import Data.Time.Clock.POSIX
-
-import Numeric
-
-data TAI64 = TAI64
-  {-# UNPACK #-} !Word64
-  deriving (Eq, Ord)
-
-data TAI64N = TAI64N
-  {-# UNPACK #-} !TAI64
-  {-# UNPACK #-} !Word32
-  deriving (Eq, Ord, Show)
-
-data TAI64NA = TAI64NA
-  {-# UNPACK #-} !TAI64N
-  {-# UNPACK #-} !Word32
-  deriving (Eq, Ord, Show)
-
-instance Show TAI64   where
-  show (TAI64 t) = "TAI64 0x" ++ showHex t ""
-
-instance Serialize TAI64 where
-  put (TAI64 t) = putWord64be t
-  get = liftM TAI64 get
-
-instance Serialize TAI64N where
-  put (TAI64N  t' nt) = put t' >> putWord32be nt
-  get = liftM2 TAI64N  get get
-
-instance Serialize TAI64NA where
-  put (TAI64NA t' at) = put t' >> putWord32be at
-  get = liftM2 TAI64NA get get
-
-
-posixToTAI64 :: POSIXTime -> TAI64
-posixToTAI64 = TAI64 . (2^62 +) . truncate . realToFrac
-
-posixToTAI64N :: POSIXTime -> TAI64N
-posixToTAI64N pt = TAI64N t' ns where
-  t' = posixToTAI64 pt
-  ns = (`mod` 10^9) $ truncate (pts * 10**9)
-  pts = realToFrac pt
-
-posixToTAI64NA :: POSIXTime -> TAI64NA -- | PICOsecond precision
-posixToTAI64NA pt = TAI64NA t' as where
-  t' = posixToTAI64N pt
-  as = (`mod` 10^9) $ truncate (pts * 10**18)
-  pts = realToFrac pt
-
-getCurrentTAI64   :: IO TAI64
-getCurrentTAI64N  :: IO TAI64N
-getCurrentTAI64NA :: IO TAI64NA
-getCurrentTAI64   = liftM posixToTAI64   getPOSIXTime
-getCurrentTAI64N  = liftM posixToTAI64N  getPOSIXTime
-getCurrentTAI64NA = liftM posixToTAI64NA getPOSIXTime
-
-tAI64ToPosix :: TAI64 -> POSIXTime
-tAI64ToPosix (TAI64 s) = fromRational . fromIntegral $ s - 2^62
-
-tAI64NToPosix :: TAI64N -> POSIXTime
-tAI64NToPosix (TAI64N t' n) = tAI64ToPosix t' + nanopart where
-  nanopart = fromRational $ (toRational $ 10**(-9)) * toRational n -- TODO: optimize?
-
-tAI64NAToPosix :: TAI64NA -> POSIXTime
-tAI64NAToPosix (TAI64NA t' a) = tAI64NToPosix t' + attopart where
-  attopart = fromRational $ (toRational $ 10**(-18)) * toRational a
diff --git a/contrib/external-tests/haskell/src/Main.hs b/contrib/external-tests/haskell/src/Main.hs
deleted file mode 100644
index 8983e6c..0000000
--- a/contrib/external-tests/haskell/src/Main.hs
+++ /dev/null
@@ -1,81 +0,0 @@
-{-# LANGUAGE OverloadedStrings #-}
-module Main where
-
-import Control.Applicative ((<$>))
-import Control.Concurrent.MVar
-import Control.Monad       (void)
-import Data.ByteString.Char8 (pack, unpack, take, drop, replicate)
-import Data.ByteString (ByteString)
-import qualified Data.ByteString.Base16 as Hex
-import qualified Data.ByteString.Base64 as B64
-import qualified Data.Serialize         as S
-import Prelude hiding (take, drop, replicate)
-import System.Environment
-import Network.Socket
-import qualified Network.Socket.ByteString as NBS
-
-import Crypto.Hash.BLAKE2.BLAKE2s
-import Crypto.Noise.Cipher
-import Crypto.Noise.Cipher.ChaChaPoly1305
-import Crypto.Noise.Curve
-import Crypto.Noise.Curve.Curve25519
-import Crypto.Noise.Handshake
-import Crypto.Noise.HandshakePatterns
-import Crypto.Noise.Hash.BLAKE2s
-import Crypto.Noise.Types
-
-import Data.Time.TAI64
-
-w :: PublicKey Curve25519
-  -> Plaintext
-  -> Socket
-  -> SockAddr
-  -> ByteString
-  -> IO ()
-w theirPub (Plaintext myPSK) sock addr msg = do
-  let x      = "\x01\x00\x00\x00\x00\x00" `mappend` msg
-      mac    = hash 16 myPSK (sbToBS' (curvePubToBytes theirPub) `mappend` sbToBS' x) -- TODO: this should actually be blake2s(key=blake2s("mac1----" || theirPub), payload=blah)
-  void $ NBS.sendTo sock (x `mappend` mac `mappend` replicate 16 '\0') addr
-
-r :: MVar ByteString -> Socket -> IO ByteString
-r smv sock = do
-  (r, _) <- NBS.recvFrom sock 1024
-  putMVar smv $ (take 2 . drop 1) r
-  return . take 48 . drop 8 $ r
-
-payload :: IO Plaintext
-payload = do
-  tai64n <- getCurrentTAI64N
-  return . Plaintext . bsToSB' $ S.encode tai64n
-
-main :: IO ()
-main = do
-  let ip = "demo.wireguard.io"
-  let port = "12913"
-  let mykey = "WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo="
-  let serverkey = "qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM="
-  let psk = "FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE="
-  addrInfo <- head <$> getAddrInfo Nothing (Just ip) (Just port)
-  sock     <- socket (addrFamily addrInfo) Datagram defaultProtocol
-
-  let addr       = addrAddress addrInfo
-      mykey'     = curveBytesToPair  . bsToSB' . either undefined id . B64.decode . pack $ mykey     :: KeyPair Curve25519
-      serverkey' = curveBytesToPub   . bsToSB' . either undefined id . B64.decode . pack $ serverkey :: PublicKey Curve25519
-      psk'       = Plaintext . bsToSB' . either undefined id . B64.decode . pack $ psk
-      hs         = handshakeState $ HandshakeStateParams
-                   noiseIK -- TODO: specify psk2 mode
-                   "WireGuard v1 zx2c4 Jason@zx2c4.com"
-                   (Just psk')
-                   (Just mykey')
-                   Nothing
-                   (Just serverkey')
-                   Nothing
-                   True :: HandshakeState ChaChaPoly1305 Curve25519 BLAKE2s
-
-  senderindexmv <- newEmptyMVar
-  let hc = HandshakeCallbacks (w serverkey' psk' sock addr) (r senderindexmv sock) (\_ -> return ()) payload
-  (encryption, decryption) <- runHandshake hs hc
-
-  let (keepAlive, encryption') = encryptPayload "" encryption
-  senderindex <- takeMVar senderindexmv
-  void $ NBS.sendTo sock ("\x04\x00\x00\x00" `mappend` senderindex `mappend` replicate 8 '\0' `mappend` keepAlive) addr

commit bdbb6298a0868d528319b8a33346f1a0197d882a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jun 6 16:50:20 2017 +0200

    go test: use x/crypto for blake2s now that we have 128-bit mac
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 4081bb5..e3627f3 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -10,10 +10,10 @@ import (
 	"net"
 	"time"
 
-	"github.com/dchest/blake2s"
 	"github.com/titanous/noise"
 	"golang.org/x/net/icmp"
 	"golang.org/x/net/ipv4"
+	"golang.org/x/crypto/blake2s"
 )
 
 func ipChecksum(buf []byte) uint16 {
@@ -69,10 +69,10 @@ func main() {
 	initiationPacket[3] = 0                                 // Reserved
 	binary.LittleEndian.PutUint32(initiationPacket[4:], 28) // Sender index: 28 (arbitrary)
 	initiationPacket, _, _ = hs.WriteMessage(initiationPacket, tai64n)
-	hasher, _ := blake2s.New(&blake2s.Config{Size: 32})
+	hasher, _ := blake2s.New256(nil)
 	hasher.Write([]byte("mac1----"))
 	hasher.Write(theirPublic)
-	hasher, _ = blake2s.New(&blake2s.Config{Size: 16, Key: hasher.Sum(nil)})
+	hasher, _ = blake2s.New128(hasher.Sum(nil))
 	hasher.Write(initiationPacket)
 	initiationPacket = append(initiationPacket, hasher.Sum(nil)[:16]...)
 	initiationPacket = append(initiationPacket, make([]byte, 16)...)

commit 9fbd187288f20b914ce6a85e439153d6bcf29a2c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jun 1 19:08:24 2017 +0200

    go test: correct tai64n and formatting
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 435063d..4081bb5 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -41,15 +41,15 @@ func main() {
 	preshared, _ := base64.StdEncoding.DecodeString("FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=")
 	cs := noise.NewCipherSuite(noise.DH25519, noise.CipherChaChaPoly, noise.HashBLAKE2s)
 	hs := noise.NewHandshakeState(noise.Config{
-		CipherSuite:   cs,
-		Random:        rand.Reader,
-		Pattern:       noise.HandshakeIK,
-		Initiator:     true,
-		Prologue:      []byte("WireGuard v1 zx2c4 Jason@zx2c4.com"),
-		PresharedKey:  preshared,
+		CipherSuite:           cs,
+		Random:                rand.Reader,
+		Pattern:               noise.HandshakeIK,
+		Initiator:             true,
+		Prologue:              []byte("WireGuard v1 zx2c4 Jason@zx2c4.com"),
+		PresharedKey:          preshared,
 		PresharedKeyPlacement: 2,
-		StaticKeypair: noise.DHKey{Private: ourPrivate, Public: ourPublic},
-		PeerStatic:    theirPublic,
+		StaticKeypair:         noise.DHKey{Private: ourPrivate, Public: ourPublic},
+		PeerStatic:            theirPublic,
 	})
 	conn, err := net.Dial("udp", "demo.wireguard.io:12913")
 	if err != nil {
@@ -61,12 +61,12 @@ func main() {
 	now := time.Now()
 	tai64n := make([]byte, 12)
 	binary.BigEndian.PutUint64(tai64n[:], 4611686018427387914+uint64(now.Unix()))
-	binary.BigEndian.PutUint32(tai64n[8:], uint32(now.UnixNano()))
+	binary.BigEndian.PutUint32(tai64n[8:], uint32(now.Nanosecond()))
 	initiationPacket := make([]byte, 8)
-	initiationPacket[0] = 1 // Type: Initiation
-	initiationPacket[1] = 0 // Reserved
-	initiationPacket[2] = 0	// Reserved
-	initiationPacket[3] = 0	// Reserved
+	initiationPacket[0] = 1                                 // Type: Initiation
+	initiationPacket[1] = 0                                 // Reserved
+	initiationPacket[2] = 0                                 // Reserved
+	initiationPacket[3] = 0                                 // Reserved
 	binary.LittleEndian.PutUint32(initiationPacket[4:], 28) // Sender index: 28 (arbitrary)
 	initiationPacket, _, _ = hs.WriteMessage(initiationPacket, tai64n)
 	hasher, _ := blake2s.New(&blake2s.Config{Size: 32})
@@ -130,13 +130,13 @@ func main() {
 	pingData := append(append(pingHeader, pingMessage...), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
 	binary.BigEndian.PutUint16(pingData[10:], ipChecksum(pingData))
 	pingPacket := make([]byte, 16)
-	pingPacket[0] = 4 // Type: Data
-	pingPacket[1] = 0 // Reserved
-	pingPacket[2] = 0 // Reserved
-	pingPacket[3] = 0 // Reserved
-	binary.LittleEndian.PutUint32(pingPacket[4:], theirIndex)
-	binary.LittleEndian.PutUint64(pingPacket[8:], 0) // Nonce
-	pingPacket = sendCipher.Encrypt(pingPacket, nil, pingData)
+	pingPacket[0] = 4                                          // Type: Data
+	pingPacket[1] = 0                                          // Reserved
+	pingPacket[2] = 0                                          // Reserved
+	pingPacket[3] = 0                                          // Reserved
+	binary.LittleEndian.PutUint32(pingPacket[4:], theirIndex)  // Their index
+	binary.LittleEndian.PutUint64(pingPacket[8:], 0)           // Nonce
+	pingPacket = sendCipher.Encrypt(pingPacket, nil, pingData) // Payload data
 	if _, err := conn.Write(pingPacket); err != nil {
 		log.Fatalf("error writing ping message: %s", err)
 	}
@@ -174,12 +174,12 @@ func main() {
 	}
 
 	keepalivePacket := make([]byte, 16)
-	keepalivePacket[0] = 4 // Type: Data
-	keepalivePacket[1] = 0 // Reserved
-	keepalivePacket[2] = 0 // Reserved
-	keepalivePacket[3] = 0 // Reserved
-	binary.LittleEndian.PutUint32(keepalivePacket[4:], theirIndex)
-	binary.LittleEndian.PutUint64(keepalivePacket[8:], 1) // Nonce
+	keepalivePacket[0] = 4                                          // Type: Data
+	keepalivePacket[1] = 0                                          // Reserved
+	keepalivePacket[2] = 0                                          // Reserved
+	keepalivePacket[3] = 0                                          // Reserved
+	binary.LittleEndian.PutUint32(keepalivePacket[4:], theirIndex)  // Their index
+	binary.LittleEndian.PutUint64(keepalivePacket[8:], 1)           // Nonce
 	keepalivePacket = sendCipher.Encrypt(keepalivePacket, nil, nil) // Empty data means keepalive
 	if _, err := conn.Write(keepalivePacket); err != nil {
 		log.Fatalf("error writing keepalive message: %s", err)

commit 19c89f3c3afad8226d9162197942942cf1bebd1c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jun 1 18:45:20 2017 +0200

    external-tests: add keepalive packet
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 013a1a9..435063d 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -172,4 +172,16 @@ func main() {
 	if echo.ID != 921 || echo.Seq != 438 || string(echo.Data) != "WireGuard" {
 		log.Fatalf("incorrect echo response: %#v", echo)
 	}
+
+	keepalivePacket := make([]byte, 16)
+	keepalivePacket[0] = 4 // Type: Data
+	keepalivePacket[1] = 0 // Reserved
+	keepalivePacket[2] = 0 // Reserved
+	keepalivePacket[3] = 0 // Reserved
+	binary.LittleEndian.PutUint32(keepalivePacket[4:], theirIndex)
+	binary.LittleEndian.PutUint64(keepalivePacket[8:], 1) // Nonce
+	keepalivePacket = sendCipher.Encrypt(keepalivePacket, nil, nil) // Empty data means keepalive
+	if _, err := conn.Write(keepalivePacket); err != nil {
+		log.Fatalf("error writing keepalive message: %s", err)
+	}
 }
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index 47c432f..9fb0f5a 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -123,4 +123,15 @@ fn main() {
 	assert!(icmp_reply.get_icmp_type() == IcmpTypes::EchoReply && icmp_reply.get_icmp_code() == echo_reply::IcmpCodes::NoCode);
 	assert!(icmp_reply.get_identifier() == 921 && icmp_reply.get_sequence_number() == 438);
 	assert!(icmp_reply.payload() == b"WireGuard");
+
+	let mut keepalive_packet = [0; 32];
+	keepalive_packet[0] = 4; /* Type: Data */
+	keepalive_packet[1] = 0; /* Reserved */
+	keepalive_packet[2] = 0; /* Reserved */
+	keepalive_packet[3] = 0; /* Reserved */
+	LittleEndian::write_u32(&mut keepalive_packet[4..], their_index);
+	LittleEndian::write_u64(&mut keepalive_packet[8..], 1);
+	let empty_payload = [0; 0]; /* Empty payload means keepalive */
+	noise.write_message(&empty_payload, &mut keepalive_packet[16..]).unwrap();
+	socket.send_to(&keepalive_packet, TEST_SERVER).unwrap();
 }

commit a1e931f9dc0e839530a434fee4aac7ac501c7fd0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jun 1 06:31:26 2017 +0200

    go test: properly pad message
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 4b58891..013a1a9 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -127,7 +127,7 @@ func main() {
 		Dst:      net.IPv4(10, 189, 129, 1),
 	}).Marshal()
 	binary.BigEndian.PutUint16(pingHeader[2:], uint16(ipv4.HeaderLen+len(pingMessage))) // fix the length endianness on BSDs
-	pingData := append(pingHeader, pingMessage...)
+	pingData := append(append(pingHeader, pingMessage...), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
 	binary.BigEndian.PutUint16(pingData[10:], ipChecksum(pingData))
 	pingPacket := make([]byte, 16)
 	pingPacket[0] = 4 // Type: Data
@@ -142,7 +142,7 @@ func main() {
 	}
 
 	// read ICMP Echo Reply packet
-	replyPacket := make([]byte, 128)
+	replyPacket := make([]byte, 80)
 	n, err = conn.Read(replyPacket)
 	if err != nil {
 		log.Fatalf("error reading ping reply message: %s", err)

commit 32afe0e22080c7ce0b346a94327179972281d5c6
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue May 30 05:14:53 2017 +0200

    wg: allow creating device with no peers
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index f57fa82..5bb985f 100644
--- a/src/config.c
+++ b/src/config.c
@@ -397,10 +397,6 @@ bool config_read_finish(struct config_ctx *ctx)
 {
 	size_t i;
 	struct wgpeer *peer;
-	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !ctx->buf.dev->num_peers) {
-		fprintf(stderr, "No peers configured\n");
-		goto err;
-	}
 	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !key_is_valid(ctx->buf.dev->private_key)) {
 		fprintf(stderr, "No private key configured\n");
 		goto err;

commit 8d8ea7a4fb630c8fcd1d559a00acd8c6e289a65e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 29 16:58:10 2017 +0200

    rust test: add icmp ping
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/rust/Cargo.toml b/contrib/external-tests/rust/Cargo.toml
index edbb5e3..88d94a7 100644
--- a/contrib/external-tests/rust/Cargo.toml
+++ b/contrib/external-tests/rust/Cargo.toml
@@ -1,5 +1,5 @@
 [package]
-name = "wireguard-keepalive"
+name = "wireguard-ping"
 version = "0.1.0"
 authors = ["jason@zx2c4.com", "me@jake.su"]
 publish = false
@@ -10,3 +10,7 @@ base64 = "^0.5"
 rust-crypto = "*"
 byteorder = "*"
 time = "*"
+
+[dependencies.pnet]
+version = "*"
+features = [ ]
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index e105038..47c432f 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -5,11 +5,17 @@ extern crate base64;
 extern crate time;
 extern crate byteorder;
 extern crate crypto;
+extern crate pnet;
 
 use byteorder::{ByteOrder, BigEndian, LittleEndian};
 use crypto::blake2s::Blake2s;
 use snow::NoiseBuilder;
+use pnet::packet::Packet;
+use pnet::packet::ip::IpNextHeaderProtocols;
+use pnet::packet::ipv4::{MutableIpv4Packet, self};
+use pnet::packet::icmp::{MutableIcmpPacket, IcmpTypes, echo_reply, echo_request, self};
 use std::net::*;
+use std::str::FromStr;
 
 static TEST_SERVER: &'static str = "demo.wireguard.io:12913";
 
@@ -65,13 +71,56 @@ fn main() {
 	assert!(payload_len == 0);
 	noise = noise.into_transport_mode().unwrap();
 
-	let mut keepalive_packet = [0; 32];
-	keepalive_packet[0] = 4; /* Type: Data */
-	keepalive_packet[1] = 0; /* Reserved */
-	keepalive_packet[2] = 0; /* Reserved */
-	keepalive_packet[3] = 0; /* Reserved */
-	LittleEndian::write_u32(&mut keepalive_packet[4..], their_index);
-	LittleEndian::write_u64(&mut keepalive_packet[8..], 0);
-	noise.write_message(&[], &mut keepalive_packet[16..]).unwrap(); /* Empty payload means keepalive */
-	socket.send_to(&keepalive_packet, TEST_SERVER).unwrap();
+	let mut icmp_packet = [0; 48];
+	{
+		let mut ipv4 = MutableIpv4Packet::new(&mut icmp_packet).unwrap();
+		ipv4.set_version(4);
+		ipv4.set_header_length(5);
+		ipv4.set_total_length(37);
+		ipv4.set_ttl(20);
+		ipv4.set_next_level_protocol(IpNextHeaderProtocols::Icmp);
+		ipv4.set_source(Ipv4Addr::from_str("10.189.129.2").unwrap());
+		ipv4.set_destination(Ipv4Addr::from_str("10.189.129.1").unwrap());
+		let checksum = ipv4::checksum(&ipv4.to_immutable());
+		ipv4.set_checksum(checksum);
+	}
+	{
+		let mut icmp = echo_request::MutableEchoRequestPacket::new(&mut icmp_packet[20..]).unwrap();
+		icmp.set_icmp_type(IcmpTypes::EchoRequest);
+		icmp.set_icmp_code(echo_request::IcmpCodes::NoCode);
+		icmp.set_identifier(921);
+		icmp.set_sequence_number(438);
+		icmp.set_payload(b"WireGuard");
+	}
+	{
+		let mut icmp = MutableIcmpPacket::new(&mut icmp_packet[20..]).unwrap();
+		let checksum = icmp::checksum(&icmp.to_immutable());
+		icmp.set_checksum(checksum);
+	}
+
+	let mut ping_packet = [0; 80];
+	ping_packet[0] = 4; /* Type: Data */
+	ping_packet[1] = 0; /* Reserved */
+	ping_packet[2] = 0; /* Reserved */
+	ping_packet[3] = 0; /* Reserved */
+	LittleEndian::write_u32(&mut ping_packet[4..], their_index);
+	LittleEndian::write_u64(&mut ping_packet[8..], 0);
+	noise.write_message(&icmp_packet, &mut ping_packet[16..]).unwrap();
+	socket.send_to(&ping_packet, TEST_SERVER).unwrap();
+
+	socket.recv_from(&mut ping_packet).unwrap();
+	assert!(ping_packet[0] == 4 /* Type: Data */);
+	assert!(ping_packet[1] == 0 /* Reserved */);
+	assert!(ping_packet[2] == 0 /* Reserved */);
+	assert!(ping_packet[3] == 0 /* Reserved */);
+	let our_index_received = LittleEndian::read_u32(&ping_packet[4..]);
+	assert!(our_index_received == 28);
+	let nonce = LittleEndian::read_u64(&ping_packet[8..]);
+	assert!(nonce == 0);
+	let payload_len = noise.read_message(&ping_packet[16..], &mut icmp_packet).unwrap();
+	assert!(payload_len == 48);
+	let icmp_reply = echo_reply::EchoReplyPacket::new(&icmp_packet[20..37]).unwrap();
+	assert!(icmp_reply.get_icmp_type() == IcmpTypes::EchoReply && icmp_reply.get_icmp_code() == echo_reply::IcmpCodes::NoCode);
+	assert!(icmp_reply.get_identifier() == 921 && icmp_reply.get_sequence_number() == 438);
+	assert!(icmp_reply.payload() == b"WireGuard");
 }

commit 2d8abfd5a0fe8195832ebcce3817419288f2ef9d
Author: Jake McGinty <me@jake.su>
Date:   Mon May 29 13:47:26 2017 +0800

    rust test: convert screech test to snow
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/rust/Cargo.toml b/contrib/external-tests/rust/Cargo.toml
index c064905..edbb5e3 100644
--- a/contrib/external-tests/rust/Cargo.toml
+++ b/contrib/external-tests/rust/Cargo.toml
@@ -1,10 +1,12 @@
 [package]
 name = "wireguard-keepalive"
 version = "0.1.0"
-authors = ["jason@zx2c4.com"]
+authors = ["jason@zx2c4.com", "me@jake.su"]
+publish = false
+
 [dependencies]
-screech = { git = "https://github.com/trevp/screech" }
+snow = "^0.1.0-preview"
+base64 = "^0.5"
 rust-crypto = "*"
 byteorder = "*"
-rustc-serialize = "*"
 time = "*"
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index ceb68b8..e105038 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -1,46 +1,35 @@
 /* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
-extern crate screech;
-extern crate crypto;
+extern crate snow;
+extern crate base64;
 extern crate time;
-extern crate rustc_serialize;
 extern crate byteorder;
+extern crate crypto;
 
-use screech::*;
 use byteorder::{ByteOrder, BigEndian, LittleEndian};
-use crypto::curve25519::curve25519_base;
 use crypto::blake2s::Blake2s;
-use rustc_serialize::base64::FromBase64;
+use snow::NoiseBuilder;
 use std::net::*;
 
+static TEST_SERVER: &'static str = "demo.wireguard.io:12913";
+
 fn memcpy(out: &mut [u8], data: &[u8]) {
-	for count in 0..data.len() {
-		out[count] = data[count];
-	}
+	out[..data.len()].copy_from_slice(data);
 }
 
 fn main() {
-	let send_addr = "demo.wireguard.io:12913".to_socket_addrs().unwrap().next().unwrap();
-	let listen_addr = "0.0.0.0:0".to_socket_addrs().unwrap().next().unwrap();
-	let socket = UdpSocket::bind(listen_addr).unwrap();
-	let mut empty_payload = [0; 0];
+	let socket = UdpSocket::bind("0.0.0.0:0").unwrap();
+
+	let their_public = base64::decode(&"qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=").unwrap();
+	let my_private = base64::decode(&"WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=").unwrap();
+	let my_preshared = base64::decode(&"FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=").unwrap();
 
-	let mut their_public = [0; 32];
-	memcpy(&mut their_public, &"qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=".from_base64().unwrap());
-	let mut my_private = [0; 32];
-	memcpy(&mut my_private, &"WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=".from_base64().unwrap());
-	let mut my_preshared = [0; 32];
-	memcpy(&mut my_preshared, &"FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=".from_base64().unwrap());
-	let my_public = curve25519_base(&my_private);
-	let mut my_keypair : Dh25519 = Default::default();
-	my_keypair.set(&my_private, &my_public);
-	let mut owner : HandshakeCryptoOwner<RandomOs, Dh25519, CipherChaChaPoly, HashBLAKE2s> = Default::default();
-	owner.set_s(my_keypair);
-	owner.set_rs(&their_public);
-	let mut cipherstate1 : CipherState<CipherChaChaPoly> = Default::default();
-        let mut cipherstate2 : CipherState<CipherChaChaPoly> = Default::default();
-	//TODO: specify psk2 mode
-	let mut handshake = HandshakeState::new_from_owner(&mut owner, true, HandshakePattern::IK, "WireGuard v1 zx2c4 Jason@zx2c4.com".as_bytes(), Some(&my_preshared[..]), &mut cipherstate1, &mut cipherstate2);
+	let mut noise = NoiseBuilder::new("Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s".parse().unwrap())
+		.local_private_key(&my_private[..])
+		.remote_public_key(&their_public[..])
+		.prologue("WireGuard v1 zx2c4 Jason@zx2c4.com".as_bytes())
+		.psk(2, &my_preshared[..])
+		.build_initiator().unwrap();
 
 	let now = time::get_time();
 	let mut tai64n = [0; 12];
@@ -52,7 +41,7 @@ fn main() {
 	initiation_packet[2] = 0; /* Reserved */
 	initiation_packet[3] = 0; /* Reserved */
 	LittleEndian::write_u32(&mut initiation_packet[4..], 28); /* Sender index: 28 (arbitrary) */
-	handshake.write_message(&tai64n, &mut initiation_packet[8..]);
+	noise.write_message(&tai64n, &mut initiation_packet[8..]).unwrap();
 	let mut mac_key_input = [0; 40];
 	let mut mac_key = [0; 32];
 	memcpy(&mut mac_key_input, b"mac1----");
@@ -61,7 +50,7 @@ fn main() {
 	let mut mac = [0; 16];
 	Blake2s::blake2s(&mut mac, &initiation_packet[0..116], &mac_key);
 	memcpy(&mut initiation_packet[116..], &mac);
-	socket.send_to(&initiation_packet, &send_addr).unwrap();
+	socket.send_to(&initiation_packet, TEST_SERVER).unwrap();
 
 	let mut response_packet = [0; 92];
 	socket.recv_from(&mut response_packet).unwrap();
@@ -72,8 +61,9 @@ fn main() {
 	let their_index = LittleEndian::read_u32(&response_packet[4..]);
 	let our_index = LittleEndian::read_u32(&response_packet[8..]);
 	assert!(our_index == 28);
-	let (payload_len, last) = handshake.read_message(&response_packet[12..60], &mut empty_payload).unwrap();
-	assert!(payload_len == 0 && last);
+	let payload_len = noise.read_message(&response_packet[12..60], &mut []).unwrap();
+	assert!(payload_len == 0);
+	noise = noise.into_transport_mode().unwrap();
 
 	let mut keepalive_packet = [0; 32];
 	keepalive_packet[0] = 4; /* Type: Data */
@@ -81,7 +71,7 @@ fn main() {
 	keepalive_packet[2] = 0; /* Reserved */
 	keepalive_packet[3] = 0; /* Reserved */
 	LittleEndian::write_u32(&mut keepalive_packet[4..], their_index);
-	LittleEndian::write_u64(&mut keepalive_packet[8..], cipherstate1.n);
-	cipherstate1.encrypt(&empty_payload, &mut keepalive_packet[16..]); /* Empty payload means keepalive */
-	socket.send_to(&keepalive_packet, &send_addr).unwrap();
+	LittleEndian::write_u64(&mut keepalive_packet[8..], 0);
+	noise.write_message(&[], &mut keepalive_packet[16..]).unwrap(); /* Empty payload means keepalive */
+	socket.send_to(&keepalive_packet, TEST_SERVER).unwrap();
 }

commit f65fba7dd8fe401d9e40d89ccdc85bb3bf162c83
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 22 13:28:02 2017 +0200

    man: update wg-quick(8) to show Debian resolvconf braindamage
    
    While OpenResolv supports explicit ordering directives such as `-m` and
    exclusivity directives such as `-x`, Debian's own resolvconf supports
    none of this, instead using a hard coded list of interface name
    templates for determining ordering. While trying to emulate `-x` is
    difficult [*], we can at least try to mostly emulate `-m 0` by
    masquerading as a `tun*` interface to resolvconf. Ugly, but it works.
    
    [*] One heavy handed way of emulating `-x` would be something like:
    
       # echo nameserver 8.8.8.8 > /etc/resolv.conf.wg0-exclusive
       # mount --bind -o ro /etc/resolv.conf.wg0-exclusive /etc/resolv.conf
       # rm -f /etc/resolv.conf.wg0-exclusive
    
    This in practice works quite well, but is a bit heavy to put in a man
    page. It also doesn't "stack" well. For example, if we simply run
    `umount /etc/resolv.conf`, how do we know which resolv.conf entry we're
    unmounting?
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index fcc855c..ceee026 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -98,9 +98,9 @@ traffic:
 .br
     \fBAddress = 10.200.100.8/24\fP
 .br
-    \fBPostUp = echo nameserver 10.200.100.1 | resolvconf -a %i -m 0 -x\fP
+    \fBPostUp = echo nameserver 10.200.100.1 | resolvconf -a tun.%i -m 0 -x\fP
 .br
-    \fBPostDown = resolvconf -d %i\fP
+    \fBPostDown = resolvconf -d tun.%i\fP
 .br
     PrivateKey = oK56DE9Ue9zK76rAc8pBl6opph+1v36lm7cXXsQKrQM= 
 .br

commit 682b15cb5e329aaf8d9d55e81605d82661dd5c2b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu May 18 14:40:26 2017 +0200

    wg-quick: use src routing for default routes in v6
    
    Otherwise, traffic is sent with the IP address of a different interface,
    and then packets don't actually get delivered.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 8cb439a..a4f349a 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -143,10 +143,18 @@ add_default() {
 		DEFAULT_TABLE=51820
 		while [[ -n $(ip route show table $DEFAULT_TABLE) ]]; do ((DEFAULT_TABLE++)); done
 	fi
-	local proto=-4
-	[[ $1 == *:* ]] && proto=-6
+	local proto=-4 src ip
+	if [[ $1 == *:* ]]; then
+		proto=-6
+		for ip in "${ADDRESSES[@]}"; do
+			if [[ $ip == *:* ]]; then
+				src="src ${ip%/*}"
+				break
+			fi
+		done
+	fi
 	cmd wg set "$INTERFACE" fwmark $DEFAULT_TABLE
-	cmd ip $proto route add "$1" dev "$INTERFACE" table $DEFAULT_TABLE
+	cmd ip $proto route add "$1" $src dev "$INTERFACE" table $DEFAULT_TABLE
 	cmd ip $proto rule add not fwmark $DEFAULT_TABLE table $DEFAULT_TABLE
 	cmd ip $proto rule add table main suppress_prefixlength 0
 	local key value

commit 641b479b4403f2e236bd57e75ded701dc48ed451
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu May 18 13:37:31 2017 +0200

    man: fix psk mention in wg-quick man page
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index e32971e..fcc855c 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -104,13 +104,13 @@ traffic:
 .br
     PrivateKey = oK56DE9Ue9zK76rAc8pBl6opph+1v36lm7cXXsQKrQM= 
 .br
-    PresharedKey = /UwcSPg38hW/D9Y3tcS1FOV0K1wuURMbS0sesJEP5ak= 
-.br
      
 .br
     [Peer] 
 .br
     PublicKey = GtL7fZc/bLnqZldpVofMCD6hDjrK28SsdLxevJ+qtKU= 
+.br
+    PresharedKey = /UwcSPg38hW/D9Y3tcS1FOV0K1wuURMbS0sesJEP5ak= 
 .br
     AllowedIPs = 0.0.0.0/0 
 .br

commit 3a7be3fac59242008bad81cdc1a6a0e40393b65d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed May 17 18:34:23 2017 +0200

    wg: opt-in globally to GNU-isms to keep the BSDs happy
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index ec75052..2dd7f6a 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -32,7 +32,7 @@ endif
 endif
 
 CFLAGS ?= -O3
-CFLAGS += -std=gnu11
+CFLAGS += -std=gnu11 -D_GNU_SOURCE
 CFLAGS += -Wall -Wextra
 CFLAGS += -MMD -MP
 CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
diff --git a/src/terminal.c b/src/terminal.c
index 862bb4a..e5b5edb 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -1,6 +1,5 @@
 /* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
-#define _GNU_SOURCE
 #include <ctype.h>
 #include <stdarg.h>
 #include <stddef.h>

commit 945fae0c7cfa787785833f0335e97c3fd30a79a8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon May 15 23:24:48 2017 +0200

    wg: support text-based ipc
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 7007b88..f57fa82 100644
--- a/src/config.c
+++ b/src/config.c
@@ -15,7 +15,7 @@
 
 #include "config.h"
 #include "ipc.h"
-#include "base64.h"
+#include "encoding.h"
 
 #define COMMENT_CHAR '#'
 
@@ -171,14 +171,12 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 			fprintf(stderr, "Unable to find matching brace of endpoint: `%s`\n", value);
 			return false;
 		}
-		*end = '\0';
-		++end;
-		if (*end != ':' || !*(end + 1)) {
+		*end++ = '\0';
+		if (*end++ != ':' || !*end) {
 			free(mutable);
 			fprintf(stderr, "Unable to find port of endpoint: `%s`\n", value);
 			return false;
 		}
-		++end;
 	} else {
 		begin = mutable;
 		end = strrchr(mutable, ':');
@@ -187,8 +185,7 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 			fprintf(stderr, "Unable to find port of endpoint: `%s`\n", value);
 			return false;
 		}
-		*end = '\0';
-		++end;
+		*end++ = '\0';
 	}
 
 	for (unsigned int timeout = 1000000; timeout < 90000000; timeout = timeout * 3 / 2) {
diff --git a/src/base64.c b/src/encoding.c
similarity index 53%
rename from src/base64.c
rename to src/encoding.c
index 48ac1be..389bbf7 100644
--- a/src/base64.c
+++ b/src/encoding.c
@@ -1,12 +1,12 @@
 /* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
- * This is a specialized constant-time base64 implementation that resists side-channel attacks.
+ * This is a specialized constant-time base64/hex implementation that resists side-channel attacks.
  */
 
 #include <string.h>
-#include "base64.h"
+#include "encoding.h"
 
-static inline void encode(char dest[4], const uint8_t src[3])
+static inline void encode_base64(char dest[4], const uint8_t src[3])
 {
 	const uint8_t input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
 	for (unsigned int i = 0; i < 4; ++i)
@@ -22,13 +22,13 @@ void key_to_base64(char base64[static WG_KEY_LEN_BASE64], const uint8_t key[stat
 {
 	unsigned int i;
 	for (i = 0; i < WG_KEY_LEN / 3; ++i)
-		encode(&base64[i * 4], &key[i * 3]);
-	encode(&base64[i * 4], (const uint8_t[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
+		encode_base64(&base64[i * 4], &key[i * 3]);
+	encode_base64(&base64[i * 4], (const uint8_t[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
 	base64[WG_KEY_LEN_BASE64 - 2] = '=';
 	base64[WG_KEY_LEN_BASE64 - 1] = '\0';
 }
 
-static inline int decode(const char src[4])
+static inline int decode_base64(const char src[4])
 {
 	int val = 0;
 	for (unsigned int i = 0; i < 4; ++i)
@@ -50,17 +50,52 @@ bool key_from_base64(uint8_t key[static WG_KEY_LEN], const char *base64)
 		return false;
 
 	for (i = 0; i < WG_KEY_LEN / 3; ++i) {
-		val = decode(&base64[i * 4]);
+		val = decode_base64(&base64[i * 4]);
 		if (val < 0)
 			return false;
 		key[i * 3 + 0] = (val >> 16) & 0xff;
 		key[i * 3 + 1] = (val >> 8) & 0xff;
 		key[i * 3 + 2] = val & 0xff;
 	}
-	val = decode((const char[]){ base64[i * 4 + 0], base64[i * 4 + 1], base64[i * 4 + 2], 'A' });
+	val = decode_base64((const char[]){ base64[i * 4 + 0], base64[i * 4 + 1], base64[i * 4 + 2], 'A' });
 	if (val < 0 || val & 0xff)
 		return false;
 	key[i * 3 + 0] = (val >> 16) & 0xff;
 	key[i * 3 + 1] = (val >> 8) & 0xff;
 	return true;
 }
+
+void key_to_hex(char hex[static WG_KEY_LEN_HEX], const uint8_t key[static WG_KEY_LEN])
+{
+	unsigned int i;
+	for (i = 0; i < WG_KEY_LEN; ++i) {
+		hex[i * 2] = 87U + (key[i] >> 4) + ((((key[i] >> 4) - 10U) >> 8) & ~38U);
+		hex[i * 2 + 1] = 87U + (key[i] & 0xf) + ((((key[i] & 0xf) - 10U) >> 8) & ~38U);
+	}
+	hex[i * 2] = '\0';
+}
+
+bool key_from_hex(uint8_t key[static WG_KEY_LEN], const char *hex)
+{
+	uint8_t i, c, c_acc = 0, c_alpha0, c_alpha, c_num0, c_num, c_val, state = 0;
+
+	if (strlen(hex) != WG_KEY_LEN_HEX - 1)
+		return false;
+
+	for (i = 0; i < WG_KEY_LEN_HEX - 1; ++i) {
+		c = (uint8_t)hex[i];
+		c_num = c ^ 48U;
+		c_num0 = (c_num - 10U) >> 8;
+		c_alpha = (c & ~32U) - 55U;
+		c_alpha0 = ((c_alpha - 10U) ^ (c_alpha - 16U)) >> 8;
+		if (!(c_num0 | c_alpha0))
+			return false;
+		c_val = (c_num0 & c_num) | (c_alpha0 & c_alpha);
+		if (!state)
+			c_acc = c_val * 16U;
+		else
+			key[i / 2] = c_acc | c_val;
+		state = ~state;
+	}
+	return true;
+}
diff --git a/src/base64.h b/src/encoding.h
similarity index 62%
rename from src/base64.h
rename to src/encoding.h
index 37cf1b9..f4fe51e 100644
--- a/src/base64.h
+++ b/src/encoding.h
@@ -1,15 +1,19 @@
 /* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
-#ifndef BASE64_H
-#define BASE64_H
+#ifndef ENCODING_H
+#define ENCODING_H
 
 #include <stdbool.h>
 #include <stdint.h>
 #include "../uapi.h"
 
 #define WG_KEY_LEN_BASE64 ((((WG_KEY_LEN) + 2) / 3) * 4 + 1)
+#define WG_KEY_LEN_HEX (WG_KEY_LEN * 2 + 1)
 
 void key_to_base64(char base64[static WG_KEY_LEN_BASE64], const uint8_t key[static WG_KEY_LEN]);
 bool key_from_base64(uint8_t key[static WG_KEY_LEN], const char *base64);
 
+void key_to_hex(char hex[static WG_KEY_LEN_HEX], const uint8_t key[static WG_KEY_LEN]);
+bool key_from_hex(uint8_t key[static WG_KEY_LEN], const char *hex);
+
 #endif
diff --git a/src/genkey.c b/src/genkey.c
index 9c8da42..52aeef5 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -12,7 +12,7 @@
 #endif
 
 #include "curve25519.h"
-#include "base64.h"
+#include "encoding.h"
 #include "subcommands.h"
 
 static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
diff --git a/src/ipc.c b/src/ipc.c
index 1c13e17..5290996 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -19,14 +19,19 @@
 #include <time.h>
 #include <dirent.h>
 #include <signal.h>
+#include <netdb.h>
+#include <limits.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/un.h>
+#include <arpa/inet.h>
 
 #include "ipc.h"
+#include "encoding.h"
+#include "curve25519.h"
 #include "../uapi.h"
 
 #define SOCK_PATH RUNSTATEDIR "/wireguard/"
@@ -42,16 +47,6 @@ struct inflatable_buffer {
 
 #define max(a, b) ((a) > (b) ? (a) : (b))
 
-static int check_version_magic(struct wgdevice *device, int ret)
-{
-	if (ret == -EPROTO || (!ret && device->version_magic != WG_API_VERSION_MAGIC)) {
-		fprintf(stderr, "This program was built for a different version of WireGuard than\nwhat is currently running. Either this version of wg(8) is out\nof date, or the currently loaded WireGuard module is out of date.\nIf you have just updated your WireGuard installation, you may have\nforgotten to unload the previous running WireGuard module. Try\nrunning `rmmod wireguard` as root, and then try re-adding the interface\nand trying again.\n\n");
-		errno = EPROTO;
-		return -EPROTO;
-	}
-	return ret;
-}
-
 static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 {
 	size_t len, expand_to;
@@ -90,11 +85,12 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
-static int userspace_interface_fd(const char *interface)
+static FILE *userspace_interface_file(const char *interface)
 {
 	struct stat sbuf;
 	struct sockaddr_un addr = { .sun_family = AF_UNIX };
 	int fd = -1, ret;
+	FILE *f;
 
 	ret = -EINVAL;
 	if (strchr(interface, '/'))
@@ -119,20 +115,25 @@ static int userspace_interface_fd(const char *interface)
 			unlink(addr.sun_path);
 		goto out;
 	}
+	f = fdopen(fd, "r+");
+	if (!f)
+		ret = -errno;
 out:
 	if (ret && fd >= 0)
 		close(fd);
-	if (!ret)
-		ret = fd;
-	return ret;
+	if (ret) {
+		errno = -ret;
+		return NULL;
+	}
+	return f;
 }
 
 static bool userspace_has_wireguard_interface(const char *interface)
 {
-	int fd = userspace_interface_fd(interface);
-	if (fd < 0)
+	FILE *f = userspace_interface_file(interface);
+	if (!f)
 		return false;
-	close(fd);
+	fclose(f);
 	return true;
 }
 
@@ -170,110 +171,261 @@ out:
 
 static int userspace_set_device(struct wgdevice *dev)
 {
+	static const uint8_t zero[WG_KEY_LEN] = { 0 };
+	char hex[WG_KEY_LEN_HEX], ip[INET6_ADDRSTRLEN], host[4096 + 1], service[512 + 1];
 	struct wgpeer *peer;
-	size_t len;
-	ssize_t ret;
-	int ret_code;
-	int fd = userspace_interface_fd(dev->interface);
-	if (fd < 0)
-		return fd;
-	for_each_wgpeer(dev, peer, len);
-	len = (uint8_t *)peer - (uint8_t *)dev;
-	ret = -EBADMSG;
-	if (!len)
-		goto out;
-	dev->version_magic = WG_API_VERSION_MAGIC;
-	ret = write(fd, dev, len);
-	if (ret < 0)
-		goto out;
-	ret = read(fd, &ret_code, sizeof(ret_code));
-	if (ret < 0)
-		goto out;
-	if (ret != sizeof(ret_code)) {
-		ret = -EBADMSG;
-		goto out;
+	struct wgipmask *ipmask;
+	FILE *f;
+	int ret;
+	size_t i, j;
+	socklen_t addr_len;
+
+	f = userspace_interface_file(dev->interface);
+	if (!f)
+		return -errno;
+	fprintf(f, "set=1\n");
+
+	if (dev->flags & WGDEVICE_REMOVE_PRIVATE_KEY)
+		fprintf(f, "private_key=\n");
+	else if (memcmp(dev->private_key, zero, WG_KEY_LEN)) {
+		key_to_hex(hex, dev->private_key);
+		fprintf(f, "private_key=%s\n", hex);
 	}
-	ret = ret_code;
-out:
-	close(fd);
+	if (dev->port)
+		fprintf(f, "listen_port=%u\n", dev->port);
+	if (dev->flags & WGDEVICE_REMOVE_FWMARK)
+		fprintf(f, "fwmark=\n");
+	else if (dev->fwmark)
+		fprintf(f, "fwmark=%u\n", dev->fwmark);
+	if (dev->flags & WGDEVICE_REPLACE_PEERS)
+		fprintf(f, "replace_peers=true\n");
+
+	for_each_wgpeer(dev, peer, i) {
+		key_to_hex(hex, peer->public_key);
+		fprintf(f, "public_key=%s\n", hex);
+		if (peer->flags & WGPEER_REMOVE_ME) {
+			fprintf(f, "remove=true\n");
+			continue;
+		}
+		if (peer->flags & WGPEER_REMOVE_PRESHARED_KEY)
+			fprintf(f, "preshared_key=\n");
+		else if (memcmp(peer->preshared_key, zero, WG_KEY_LEN)) {
+			key_to_hex(hex, peer->preshared_key);
+			fprintf(f, "preshared_key=%s\n", hex);
+		}
+		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6) {
+			addr_len = 0;
+			if (peer->endpoint.addr.sa_family == AF_INET)
+				addr_len = sizeof(struct sockaddr_in);
+			else if (peer->endpoint.addr.sa_family == AF_INET6)
+				addr_len = sizeof(struct sockaddr_in6);
+			if (!getnameinfo(&peer->endpoint.addr, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST)) {
+				if (peer->endpoint.addr.sa_family == AF_INET6 && strchr(host, ':'))
+					fprintf(f, "endpoint=[%s]:%s\n", host, service);
+				else
+					fprintf(f, "endpoint=%s:%s\n", host, service);
+			}
+		}
+		if (peer->persistent_keepalive_interval != (uint16_t)-1)
+			fprintf(f, "persistent_keepalive_interval=%u\n", peer->persistent_keepalive_interval);
+		if (peer->flags & WGPEER_REPLACE_IPMASKS)
+			fprintf(f, "replace_allowed_ips=true\n");
+		for_each_wgipmask(peer, ipmask, j) {
+			if (ipmask->family == AF_INET) {
+				if (!inet_ntop(AF_INET, &ipmask->ip4, ip, INET6_ADDRSTRLEN))
+					continue;
+			} else if (ipmask->family == AF_INET6) {
+				if (!inet_ntop(AF_INET6, &ipmask->ip6, ip, INET6_ADDRSTRLEN))
+					continue;
+			} else
+				continue;
+			fprintf(f, "allowed_ip=%s/%d\n", ip, ipmask->cidr);
+		}
+	}
+	fprintf(f, "\n");
+	fflush(f);
+
+	if (fscanf(f, "errno=%d\n\n", &ret) != 1)
+		ret = errno ? -errno : -EPROTO;
+	fclose(f);
 	errno = -ret;
-	return check_version_magic(dev, ret);
+	return ret;
 }
 
-#define READ_BYTES(bytes) ({ \
-	void *__p; \
-	size_t __bytes = (bytes); \
-	if (bytes_left < __bytes) { \
-		offset = p - buffer; \
-		bytes_left += buffer_size; \
-		buffer_size *= 2; \
-		ret = -ENOMEM; \
-		p = realloc(buffer, buffer_size); \
-		if (!p) \
-			goto out; \
-		buffer = p; \
-		p += offset; \
-	} \
-	bytes_left -= __bytes; \
-	ret = read(fd, p, __bytes); \
-	if (ret < 0) \
-		goto out; \
-	if ((size_t)ret != __bytes) { \
-		ret = -EBADMSG; \
-		goto out; \
+#define ADD(bytes) ({ \
+	if (buffer_len - buffer_end < bytes) { \
+		ptrdiff_t peer_offset = (void *)peer - (void *)*out; \
+		buffer_len = buffer_len * 2 + bytes; \
+		*out = realloc(*out, buffer_len); \
+		if (!*out) { \
+			ret = -errno; \
+			goto err; \
+		} \
+		memset((void *)*out + buffer_end, 0, buffer_len - buffer_end); \
+		if (peer) \
+			peer = (void *)*out + peer_offset; \
+		dev = *out; \
 	} \
-	__p = p; \
-	p += __bytes; \
-	__p; \
+	buffer_end += bytes; \
+	(void *)*out + buffer_end - bytes; \
 })
-static int userspace_get_device(struct wgdevice **dev, const char *interface)
-{
-	unsigned int len = 0, i;
-	size_t buffer_size, bytes_left;
-	ssize_t ret;
-	ptrdiff_t offset;
-	uint8_t *buffer = NULL, *p, byte = 0;
-
-	int fd = userspace_interface_fd(interface);
-	if (fd < 0)
-		return fd;
 
-	ret = write(fd, &byte, sizeof(byte));
-	if (ret < 0)
-		goto out;
-	if (ret != sizeof(byte)) {
-		ret = -EBADMSG;
-		goto out;
-	}
-
-	ioctl(fd, FIONREAD, &len);
-	bytes_left = buffer_size = max(len, sizeof(struct wgdevice) + sizeof(struct wgpeer) + sizeof(struct wgipmask));
-	p = buffer = malloc(buffer_size);
-	ret = -ENOMEM;
-	if (!buffer)
-		goto out;
+#define NUM(max) ({ \
+	unsigned long long num; \
+	char *end; \
+	if (!strlen(value)) \
+		break; \
+	num = strtoull(value, &end, 10); \
+	if (*end || num > max) \
+		break; \
+	num; \
+})
 
-	len = ((struct wgdevice *)READ_BYTES(sizeof(struct wgdevice)))->num_peers;
-	ret = check_version_magic((struct wgdevice *)buffer, ret);
-	if (ret)
-		goto out;
-	for (i = 0; i < len; ++i)
-		READ_BYTES(sizeof(struct wgipmask) * ((struct wgpeer *)READ_BYTES(sizeof(struct wgpeer)))->num_ipmasks);
-	ret = 0;
-out:
-	if (buffer && ret) {
-		free(buffer);
-		buffer = NULL;
+static int userspace_get_device(struct wgdevice **out, const char *interface)
+{
+	struct wgdevice *dev;
+	struct wgpeer *peer = NULL;
+	size_t buffer_len = 0, buffer_end = 0, line_buffer_len = 0, line_len;
+	char *key = NULL, *value;
+	FILE *f;
+	int ret = -EPROTO;
+
+	f = userspace_interface_file(interface);
+	if (!f)
+		return -errno;
+
+	fprintf(f, "get=1\n\n");
+	fflush(f);
+
+	*out = NULL;
+	dev = ADD(sizeof(struct wgdevice));
+	dev->version_magic = WG_API_VERSION_MAGIC;
+	strncpy(dev->interface, interface, IFNAMSIZ - 1);
+	dev->interface[IFNAMSIZ - 1] = '\0';
+
+	while (getline(&key, &line_buffer_len, f) > 0) {
+		line_len = strlen(key);
+		if (line_len == 1 && key[0] == '\n') {
+			free(key);
+			fclose(f);
+			return ret;
+		}
+		value = strchr(key, '=');
+		if (!value || line_len == 0 || key[line_len - 1] != '\n')
+			break;
+		*value++ = key[--line_len] = '\0';
+
+		if (!strcmp(key, "private_key")) {
+			if (!key_from_hex(dev->private_key, value))
+				break;
+			curve25519_generate_public(dev->public_key, dev->private_key);
+		} else if (!strcmp(key, "listen_port"))
+			dev->port = NUM(0xffffU);
+		else if (!strcmp(key, "fwmark"))
+			dev->fwmark = NUM(0xffffffffU);
+		else if (!strcmp(key, "public_key")) {
+			peer = ADD(sizeof(struct wgpeer));
+			if (!key_from_hex(peer->public_key, value))
+				break;
+			++dev->num_peers;
+		} else if (peer && !strcmp(key, "preshared_key")) {
+			if (!key_from_hex(peer->preshared_key, value))
+				break;
+		} else if (peer && !strcmp(key, "endpoint")) {
+			char *begin, *end;
+			struct addrinfo *resolved;
+			struct addrinfo hints = {
+				.ai_family = AF_UNSPEC,
+				.ai_socktype = SOCK_DGRAM,
+				.ai_protocol = IPPROTO_UDP
+			};
+			if (!strlen(value))
+				break;
+			if (value[0] == '[') {
+				begin = &value[1];
+				end = strchr(value, ']');
+				if (!end)
+					break;
+				*end++ = '\0';
+				if (*end++ != ':' || !*end)
+					break;
+			} else {
+				begin = value;
+				end = strrchr(value, ':');
+				if (!end || !*(end + 1))
+					break;
+				*end++ = '\0';
+			}
+			if (getaddrinfo(begin, end, &hints, &resolved) != 0) {
+				errno = ENETUNREACH;
+				goto err;
+			}
+			if ((resolved->ai_family == AF_INET && resolved->ai_addrlen == sizeof(struct sockaddr_in)) ||
+			    (resolved->ai_family == AF_INET6 && resolved->ai_addrlen == sizeof(struct sockaddr_in6)))
+				memcpy(&peer->endpoint.addr, resolved->ai_addr, resolved->ai_addrlen);
+			else  {
+				freeaddrinfo(resolved);
+				break;
+			}
+			freeaddrinfo(resolved);
+		} else if (peer && !strcmp(key, "persistent_keepalive_interval"))
+			peer->persistent_keepalive_interval = NUM(65535U);
+		else if (peer && !strcmp(key, "allowed_ip")) {
+			struct wgipmask *ipmask = ADD(sizeof(struct wgipmask));
+			char *end, *cidr = strchr(value, '/');
+			if (!cidr || strlen(cidr) <= 1)
+				break;
+			*cidr++ = '\0';
+			ipmask->family = AF_UNSPEC;
+			if (strchr(value, ':')) {
+				if (inet_pton(AF_INET6, value, &ipmask->ip6) == 1)
+					ipmask->family = AF_INET6;
+			} else {
+				if (inet_pton(AF_INET, value, &ipmask->ip4) == 1)
+					ipmask->family = AF_INET;
+			}
+			ipmask->cidr = strtoul(cidr, &end, 10);
+			if (*end || ipmask->family == AF_UNSPEC || (ipmask->family == AF_INET6 && ipmask->cidr > 128) || (ipmask->family == AF_INET && ipmask->cidr > 32))
+				break;
+			++peer->num_ipmasks;
+		} else if (peer && !strcmp(key, "last_handshake_time_sec"))
+			peer->last_handshake_time.tv_sec = NUM(0xffffffffffffffffULL);
+		else if (peer && !strcmp(key, "last_handshake_time_nsec"))
+			peer->last_handshake_time.tv_usec = NUM(0xffffffffffffffffULL) / 1000;
+		else if (peer && !strcmp(key, "rx_bytes"))
+			peer->rx_bytes = NUM(0xffffffffffffffffULL);
+		else if (peer && !strcmp(key, "tx_bytes"))
+			peer->tx_bytes = NUM(0xffffffffffffffffULL);
+		else if (!strcmp(key, "errno"))
+			ret = -NUM(0x7fffffffU);
+		else
+			break;
 	}
-	*dev = (struct wgdevice *)buffer;
-	close(fd);
+	ret = -EPROTO;
+err:
+	free(key);
+	free(*out);
+	*out = NULL;
+	fclose(f);
 	errno = -ret;
 	return ret;
 
 }
-#undef READ_BYTES
+#undef ADD
+#undef NUM
+#undef KEY
 
 #ifdef __linux__
+static int check_version_magic(struct wgdevice *device, int ret)
+{
+	if (ret == -EPROTO || (!ret && device->version_magic != WG_API_VERSION_MAGIC)) {
+		fprintf(stderr, "This program was built for a different version of WireGuard than\nwhat is currently running. Either this version of wg(8) is out\nof date, or the currently loaded WireGuard module is out of date.\nIf you have just updated your WireGuard installation, you may have\nforgotten to unload the previous running WireGuard module. Try\nrunning `rmmod wireguard` as root, and then try re-adding the interface\nand trying again.\n\n");
+		errno = EPROTO;
+		return -EPROTO;
+	}
+	return ret;
+}
+
 static int parse_linkinfo(const struct nlattr *attr, void *data)
 {
 	struct inflatable_buffer *buffer = data;
@@ -295,9 +447,11 @@ static int parse_infomsg(const struct nlattr *attr, void *data)
 static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
 {
 	struct inflatable_buffer *buffer = data;
+	int ret;
+
 	buffer->good = false;
 	buffer->next = NULL;
-	int ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, data);
+	ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, data);
 	if (ret != MNL_CB_OK)
 		return ret;
 	ret = add_next_to_inflatable_buffer(buffer);
diff --git a/src/pubkey.c b/src/pubkey.c
index 009cd15..6cced49 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -5,7 +5,7 @@
 #include <ctype.h>
 
 #include "curve25519.h"
-#include "base64.h"
+#include "encoding.h"
 #include "subcommands.h"
 
 int pubkey_main(int argc, char *argv[])
diff --git a/src/show.c b/src/show.c
index 7f67dba..4eb096f 100644
--- a/src/show.c
+++ b/src/show.c
@@ -16,7 +16,7 @@
 #include "ipc.h"
 #include "subcommands.h"
 #include "terminal.h"
-#include "base64.h"
+#include "encoding.h"
 #include "../uapi.h"
 
 static int peer_cmp(const void *first, const void *second)
diff --git a/src/showconf.c b/src/showconf.c
index 039abee..2453c86 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -10,7 +10,7 @@
 #include <netdb.h>
 
 #include "subcommands.h"
-#include "base64.h"
+#include "encoding.h"
 #include "ipc.h"
 #include "../uapi.h"
 
@@ -79,16 +79,16 @@ int showconf_main(int argc, char *argv[])
 		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6) {
 			char host[4096 + 1];
 			char service[512 + 1];
-			static char buf[sizeof(host) + sizeof(service) + 4];
 			socklen_t addr_len = 0;
-			memset(buf, 0, sizeof(buf));
 			if (peer->endpoint.addr.sa_family == AF_INET)
 				addr_len = sizeof(struct sockaddr_in);
 			else if (peer->endpoint.addr.sa_family == AF_INET6)
 				addr_len = sizeof(struct sockaddr_in6);
 			if (!getnameinfo(&peer->endpoint.addr, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST)) {
-				snprintf(buf, sizeof(buf) - 1, (peer->endpoint.addr.sa_family == AF_INET6 && strchr(host, ':')) ? "[%s]:%s" : "%s:%s", host, service);
-				printf("Endpoint = %s\n", buf);
+				if (peer->endpoint.addr.sa_family == AF_INET6 && strchr(host, ':'))
+					printf("Endpoint = [%s]:%s\n", host, service);
+				else
+					printf("Endpoint = %s:%s\n", host, service);
 			}
 		}
 

commit c3b2dbcdb0a30a66b126e872ca80773151d652e7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun May 14 19:29:59 2017 +0200

    wg: check for proto error on set too
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index ed18128..1c13e17 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -45,7 +45,8 @@ struct inflatable_buffer {
 static int check_version_magic(struct wgdevice *device, int ret)
 {
 	if (ret == -EPROTO || (!ret && device->version_magic != WG_API_VERSION_MAGIC)) {
-		fprintf(stderr, "This program was built for a different version of WireGuard than\nwhat is currently running. Either this version of wg(8) is out\nof date, or the currently loaded WireGuard module is out of date.\nIf you have just updated your WireGuard installation, you may have\nforgotten to unload the previous running WireGuard module. Try\nrunning `rmmod wireguard` as root, and then try re-adding the device\nand trying again.\n\n");
+		fprintf(stderr, "This program was built for a different version of WireGuard than\nwhat is currently running. Either this version of wg(8) is out\nof date, or the currently loaded WireGuard module is out of date.\nIf you have just updated your WireGuard installation, you may have\nforgotten to unload the previous running WireGuard module. Try\nrunning `rmmod wireguard` as root, and then try re-adding the interface\nand trying again.\n\n");
+		errno = EPROTO;
 		return -EPROTO;
 	}
 	return ret;
@@ -196,7 +197,7 @@ static int userspace_set_device(struct wgdevice *dev)
 out:
 	close(fd);
 	errno = -ret;
-	return (int)ret;
+	return check_version_magic(dev, ret);
 }
 
 #define READ_BYTES(bytes) ({ \
@@ -413,7 +414,7 @@ static int kernel_set_device(struct wgdevice *dev)
 	memcpy(&ifreq.ifr_name, dev->interface, IFNAMSIZ);
 	ifreq.ifr_name[IFNAMSIZ - 1] = 0;
 	dev->version_magic = WG_API_VERSION_MAGIC;
-	return do_ioctl(WG_SET_DEVICE, &ifreq);
+	return check_version_magic(dev, do_ioctl(WG_SET_DEVICE, &ifreq));
 }
 
 static int kernel_get_device(struct wgdevice **dev, const char *interface)

commit 067ebe2cb99d19fbbaa25dd43b976e63497adaa6
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 12 15:03:38 2017 +0200

    wg: stricter key file reading
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index a129088..7007b88 100644
--- a/src/config.c
+++ b/src/config.c
@@ -424,32 +424,48 @@ err:
 	return false;
 }
 
-static int read_line(char **dst, const char *path)
+static int read_keyfile(char dst[WG_KEY_LEN_BASE64], const char *path)
 {
 	FILE *f;
-	size_t n = 0;
-
-	*dst = NULL;
+	int ret = -1, c;
 
 	f = fopen(path, "r");
 	if (!f) {
 		perror("fopen");
 		return -1;
 	}
-	if (getline(dst, &n, f) < 0 && errno) {
-		perror("getline");
-		fclose(f);
-		return -1;
+
+	if (fread(dst, WG_KEY_LEN_BASE64 - 1, 1, f) != 1) {
+		if (errno) {
+			perror("fread");
+			goto out;
+		}
+		/* If we're at the end and we didn't read anything, we're /dev/null. */
+		if (!ferror(f) && feof(f) && !ftell(f)) {
+			ret = 1;
+			goto out;
+		}
+
+		fprintf(stderr, "Invalid length key in key file\n");
+		goto out;
 	}
-	fclose(f);
-	n = strlen(*dst);
-	if (!n)
-		return 1;
-	while (--n) {
-		if (isspace((*dst)[n]))
-			(*dst)[n] = '\0';
+	dst[WG_KEY_LEN_BASE64 - 1] = '\0';
+
+	while ((c = getc(f)) != EOF) {
+		if (!isspace(c)) {
+			fprintf(stderr, "Found trailing character in key file: `%c`\n", c);
+			goto out;
+		}
 	}
-	return 0;
+	if (ferror(f) && errno) {
+		perror("getc");
+		goto out;
+	}
+	ret = 0;
+
+out:
+	fclose(f);
+	return ret;
 }
 
 static char *strip_spaces(const char *in)
@@ -492,14 +508,11 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 			argv += 2;
 			argc -= 2;
 		} else if (!strcmp(argv[0], "private-key") && argc >= 2 && !buf.dev->num_peers) {
-			char *line;
-			int ret = read_line(&line, argv[1]);
+			char key_line[WG_KEY_LEN_BASE64];
+			int ret = read_keyfile(key_line, argv[1]);
 			if (ret == 0) {
-				if (!parse_key(buf.dev->private_key, line)) {
-					free(line);
+				if (!parse_key(buf.dev->private_key, key_line))
 					goto error;
-				}
-				free(line);
 			} else if (ret == 1)
 				buf.dev->flags |= WGDEVICE_REMOVE_PRIVATE_KEY;
 			else
@@ -544,18 +557,14 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 			argv += 2;
 			argc -= 2;
 		} else if (!strcmp(argv[0], "preshared-key") && argc >= 2 && buf.dev->num_peers) {
-			char *line;
-			int ret = read_line(&line, argv[1]);
+			char key_line[WG_KEY_LEN_BASE64];
+			int ret = read_keyfile(key_line, argv[1]);
 			if (ret == 0) {
-				if (!parse_key(peer_from_offset(buf.dev, peer_offset)->preshared_key, line)) {
-					free(line);
+				if (!parse_key(peer_from_offset(buf.dev, peer_offset)->preshared_key, key_line))
 					goto error;
-				}
-				free(line);
-			} else if (ret == 1) {
-				free(line);
+			} else if (ret == 1)
 				buf.dev->flags |= WGPEER_REMOVE_PRESHARED_KEY;
-			} else
+			else
 				goto error;
 			argv += 2;
 			argc -= 2;

commit fabb6eca2b6fd41dd8010d40eaac3f55cec1df2c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Apr 27 11:10:50 2017 +0200

    noise: redesign preshared key mode
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 11c2f86..4b58891 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -37,16 +37,17 @@ func ipChecksum(buf []byte) uint16 {
 func main() {
 	ourPrivate, _ := base64.StdEncoding.DecodeString("WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=")
 	ourPublic, _ := base64.StdEncoding.DecodeString("K5sF9yESrSBsOXPd6TcpKNgqoy1Ik3ZFKl4FolzrRyI=")
-	preshared, _ := base64.StdEncoding.DecodeString("FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=")
 	theirPublic, _ := base64.StdEncoding.DecodeString("qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=")
+	preshared, _ := base64.StdEncoding.DecodeString("FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=")
 	cs := noise.NewCipherSuite(noise.DH25519, noise.CipherChaChaPoly, noise.HashBLAKE2s)
 	hs := noise.NewHandshakeState(noise.Config{
 		CipherSuite:   cs,
 		Random:        rand.Reader,
 		Pattern:       noise.HandshakeIK,
 		Initiator:     true,
-		Prologue:      []byte("WireGuard v0 zx2c4 Jason@zx2c4.com"),
+		Prologue:      []byte("WireGuard v1 zx2c4 Jason@zx2c4.com"),
 		PresharedKey:  preshared,
+		PresharedKeyPlacement: 2,
 		StaticKeypair: noise.DHKey{Private: ourPrivate, Public: ourPublic},
 		PeerStatic:    theirPublic,
 	})
@@ -68,8 +69,10 @@ func main() {
 	initiationPacket[3] = 0	// Reserved
 	binary.LittleEndian.PutUint32(initiationPacket[4:], 28) // Sender index: 28 (arbitrary)
 	initiationPacket, _, _ = hs.WriteMessage(initiationPacket, tai64n)
-	hasher, _ := blake2s.New(&blake2s.Config{Size: 16, Key: preshared})
+	hasher, _ := blake2s.New(&blake2s.Config{Size: 32})
+	hasher.Write([]byte("mac1----"))
 	hasher.Write(theirPublic)
+	hasher, _ = blake2s.New(&blake2s.Config{Size: 16, Key: hasher.Sum(nil)})
 	hasher.Write(initiationPacket)
 	initiationPacket = append(initiationPacket, hasher.Sum(nil)[:16]...)
 	initiationPacket = append(initiationPacket, make([]byte, 16)...)
diff --git a/contrib/external-tests/haskell/src/Main.hs b/contrib/external-tests/haskell/src/Main.hs
index 820e2f1..8983e6c 100644
--- a/contrib/external-tests/haskell/src/Main.hs
+++ b/contrib/external-tests/haskell/src/Main.hs
@@ -34,7 +34,7 @@ w :: PublicKey Curve25519
   -> IO ()
 w theirPub (Plaintext myPSK) sock addr msg = do
   let x      = "\x01\x00\x00\x00\x00\x00" `mappend` msg
-      mac    = hash 16 myPSK (sbToBS' (curvePubToBytes theirPub) `mappend` sbToBS' x)
+      mac    = hash 16 myPSK (sbToBS' (curvePubToBytes theirPub) `mappend` sbToBS' x) -- TODO: this should actually be blake2s(key=blake2s("mac1----" || theirPub), payload=blah)
   void $ NBS.sendTo sock (x `mappend` mac `mappend` replicate 16 '\0') addr
 
 r :: MVar ByteString -> Socket -> IO ByteString
@@ -63,8 +63,8 @@ main = do
       serverkey' = curveBytesToPub   . bsToSB' . either undefined id . B64.decode . pack $ serverkey :: PublicKey Curve25519
       psk'       = Plaintext . bsToSB' . either undefined id . B64.decode . pack $ psk
       hs         = handshakeState $ HandshakeStateParams
-                   noiseIK
-                   "WireGuard v0 zx2c4 Jason@zx2c4.com"
+                   noiseIK -- TODO: specify psk2 mode
+                   "WireGuard v1 zx2c4 Jason@zx2c4.com"
                    (Just psk')
                    (Just mykey')
                    Nothing
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index 232375c..ceb68b8 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -39,11 +39,12 @@ fn main() {
 	owner.set_rs(&their_public);
 	let mut cipherstate1 : CipherState<CipherChaChaPoly> = Default::default();
         let mut cipherstate2 : CipherState<CipherChaChaPoly> = Default::default();
-	let mut handshake = HandshakeState::new_from_owner(&mut owner, true, HandshakePattern::IK, "WireGuard v0 zx2c4 Jason@zx2c4.com".as_bytes(), Some(&my_preshared[..]), &mut cipherstate1, &mut cipherstate2);
+	//TODO: specify psk2 mode
+	let mut handshake = HandshakeState::new_from_owner(&mut owner, true, HandshakePattern::IK, "WireGuard v1 zx2c4 Jason@zx2c4.com".as_bytes(), Some(&my_preshared[..]), &mut cipherstate1, &mut cipherstate2);
 
 	let now = time::get_time();
 	let mut tai64n = [0; 12];
-	BigEndian::write_i64(&mut tai64n[0..], 4611686018427387914ULL + now.sec);
+	BigEndian::write_i64(&mut tai64n[0..], 4611686018427387914 + now.sec);
 	BigEndian::write_i32(&mut tai64n[8..], now.nsec);
 	let mut initiation_packet = [0; 148];
 	initiation_packet[0] = 1; /* Type: Initiation */
@@ -52,11 +53,13 @@ fn main() {
 	initiation_packet[3] = 0; /* Reserved */
 	LittleEndian::write_u32(&mut initiation_packet[4..], 28); /* Sender index: 28 (arbitrary) */
 	handshake.write_message(&tai64n, &mut initiation_packet[8..]);
-	let mut mac_material = [0; 148];
-	memcpy(&mut mac_material, &their_public);
-	memcpy(&mut mac_material[32..], &initiation_packet[0..116]);
+	let mut mac_key_input = [0; 40];
+	let mut mac_key = [0; 32];
+	memcpy(&mut mac_key_input, b"mac1----");
+	memcpy(&mut mac_key_input[8..], &their_public);
+	Blake2s::blake2s(&mut mac_key, &mac_key_input, &[0; 0]);
 	let mut mac = [0; 16];
-	Blake2s::blake2s(&mut mac, &mac_material, &my_preshared);
+	Blake2s::blake2s(&mut mac, &initiation_packet[0..116], &mac_key);
 	memcpy(&mut initiation_packet[116..], &mac);
 	socket.send_to(&initiation_packet, &send_addr).unwrap();
 
diff --git a/contrib/json/wg-json b/contrib/json/wg-json
index 90544e2..1b9a570 100755
--- a/contrib/json/wg-json
+++ b/contrib/json/wg-json
@@ -9,20 +9,20 @@ while read -r -d $'\t' device; do
 	if [[ $device != "$last_device" ]]; then
 		[[ -z $last_device ]] && printf '\n' || printf '%s,\n' "$end"
 		last_device="$device"
-		read -r private_key public_key preshared_key listen_port fwmark
+		read -r private_key public_key listen_port fwmark
 		printf '\t"%s": {' "$device"
 		delim=$'\n'
 		[[ $private_key == "(none)" ]] || { printf '%s\t\t"privateKey": "%s"' "$delim" "$private_key"; delim=$',\n'; }
 		[[ $public_key == "(none)" ]] || { printf '%s\t\t"publicKey": "%s"' "$delim" "$public_key"; delim=$',\n'; }
-		[[ $preshared_key == "(none)" ]] || { printf '%s\t\t"presharedKey": "%s"' "$delim" "$preshared_key"; delim=$',\n'; }
 		[[ $listen_port == "0" ]] || { printf '%s\t\t"listenPort": %u' "$delim" $(( $listen_port )); delim=$',\n'; }
 		[[ $fwmark == "off" ]] || { printf '%s\t\t"fwmark": %u' "$delim" $(( $fwmark )); delim=$',\n'; }
 		printf '%s\t\t"peers": {' "$delim"; end=$'\n\t\t}\n\t}'
 		delim=$'\n'
 	else
-		read -r public_key endpoint allowed_ips latest_handshake transfer_rx transfer_tx persistent_keepalive
+		read -r public_key preshared_key endpoint allowed_ips latest_handshake transfer_rx transfer_tx persistent_keepalive
 		printf '%s\t\t\t"%s": {' "$delim" "$public_key"
 		delim=$'\n'
+		[[ $preshared_key == "(none)" ]] || { printf '%s\t\t\t\t"presharedKey": "%s"' "$delim" "$preshared_key"; delim=$',\n'; }
 		[[ $endpoint == "(none)" ]] || { printf '%s\t\t\t\t"endpoint": "%s"' "$delim" "$endpoint"; delim=$',\n'; }
 		[[ $latest_handshake == "0" ]] || { printf '%s\t\t\t\t"latestHandshake": %u' "$delim" $(( $latest_handshake )); delim=$',\n'; }
 		[[ $transfer_rx == "0" ]] || { printf '%s\t\t\t\t"transferRx": %u' "$delim" $(( $transfer_rx )); delim=$',\n'; }
diff --git a/src/completion/wg.bash-completion b/src/completion/wg.bash-completion
index 355012c..5401bc3 100644
--- a/src/completion/wg.bash-completion
+++ b/src/completion/wg.bash-completion
@@ -21,7 +21,7 @@ _wg_completion() {
 	fi
 
 	if [[ $COMP_CWORD -eq 3 && ${COMP_WORDS[1]} == show && ${COMP_WORDS[2]} != interfaces ]]; then
-		COMPREPLY+=( $(compgen -W "public-key private-key preshared-key listen-port peers endpoints allowed-ips fwmark latest-handshakes persistent-keepalive transfer dump" -- "${COMP_WORDS[3]}") )
+		COMPREPLY+=( $(compgen -W "public-key private-key listen-port peers preshared-keys endpoints allowed-ips fwmark latest-handshakes persistent-keepalive transfer dump" -- "${COMP_WORDS[3]}") )
 		return
 	fi
 
@@ -39,7 +39,6 @@ _wg_completion() {
 		[[ ${COMP_WORDS[i]} == listen-port ]] && has_listen_port=1
 		[[ ${COMP_WORDS[i]} == fwmark ]] && has_fwmark=1
 		[[ ${COMP_WORDS[i]} == private-key ]] && has_private_key=1
-		[[ ${COMP_WORDS[i]} == preshared-key ]] && has_preshared_key=1
 		[[ ${COMP_WORDS[i]} == peer ]] && { has_peer=$i; break; }
 	done
 	if [[ $has_peer -eq 0 ]]; then
@@ -47,7 +46,6 @@ _wg_completion() {
 			[[ $has_listen_port -eq 1 ]] || words+=( listen-port )
 			[[ $has_fwmark -eq 1 ]] || words+=( fwmark )
 			[[ $has_private_key -eq 1 ]] || words+=( private-key )
-			[[ $has_preshared_key -eq 1 ]] || words+=( preshared-key )
 			words+=( peer )
 			COMPREPLY+=( $(compgen -W "${words[*]}" -- "${COMP_WORDS[COMP_CWORD]}") )
 		elif [[ ${COMP_WORDS[COMP_CWORD-1]} == *-key ]]; then
@@ -70,6 +68,7 @@ _wg_completion() {
 			has_endpoint=0
 			has_persistent_keepalive=0
 			has_allowed_ips=0
+			has_preshared_key=0
 			[[ ${COMP_WORDS[i+2]} == = ]] && ((i+=2)) || ((i++))
 			continue
 		fi
@@ -77,6 +76,7 @@ _wg_completion() {
 		[[ ${COMP_WORDS[i]} == endpoint ]] && has_endpoint=1
 		[[ ${COMP_WORDS[i]} == persistent-keepalive ]] && has_persistent_keepalive=1
 		[[ ${COMP_WORDS[i]} == allowed-ips ]] && has_allowed_ips=1
+		[[ ${COMP_WORDS[i]} == preshared-key ]] && has_preshared_key=1
 
 		[[ ${COMP_WORDS[i]} == remove ]] || ((i++))
 	done
@@ -84,6 +84,7 @@ _wg_completion() {
 	((COMP_CWORD == j)) || return
 
 	if [[ $has_remove -ne 1 ]]; then
+		[[ $has_preshared_key -eq 1 ]] || words+=( preshared-key )
 		[[ $has_endpoint -eq 1 ]] || words+=( endpoint )
 		[[ $has_allowed_ips -eq 1 ]] || words+=( allowed-ips )
 		[[ $has_persistent_keepalive -eq 1 ]] || words+=( persistent-keepalive )
diff --git a/src/config.c b/src/config.c
index c00e91c..a129088 100644
--- a/src/config.c
+++ b/src/config.c
@@ -323,10 +323,6 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 			ret = parse_key(ctx->buf.dev->private_key, value);
 			if (!ret)
 				memset(ctx->buf.dev->private_key, 0, WG_KEY_LEN);
-		} else if (key_match("PresharedKey")) {
-			ret = parse_key(ctx->buf.dev->preshared_key, value);
-			if (!ret)
-				memset(ctx->buf.dev->preshared_key, 0, WG_KEY_LEN);
 		} else
 			goto error;
 	} else if (ctx->is_peer_section) {
@@ -338,7 +334,11 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 			ret = parse_ipmasks(&ctx->buf, ctx->peer_offset, value);
 		else if (key_match("PersistentKeepalive"))
 			ret = parse_persistent_keepalive(&peer_from_offset(ctx->buf.dev, ctx->peer_offset)->persistent_keepalive_interval, value);
-		else
+		else if (key_match("PresharedKey")) {
+			ret = parse_key(peer_from_offset(ctx->buf.dev, ctx->peer_offset)->preshared_key, value);
+			if (!ret)
+				memset(peer_from_offset(ctx->buf.dev, ctx->peer_offset)->preshared_key, 0, WG_KEY_LEN);
+		} else
 			goto error;
 	} else
 		goto error;
@@ -408,8 +408,6 @@ bool config_read_finish(struct config_ctx *ctx)
 		fprintf(stderr, "No private key configured\n");
 		goto err;
 	}
-	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !key_is_valid(ctx->buf.dev->preshared_key))
-		ctx->buf.dev->flags |= WGDEVICE_REMOVE_PRESHARED_KEY;
 	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !ctx->buf.dev->fwmark)
 		ctx->buf.dev->flags |= WGDEVICE_REMOVE_FWMARK;
 
@@ -508,21 +506,6 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 				goto error;
 			argv += 2;
 			argc -= 2;
-		} else if (!strcmp(argv[0], "preshared-key") && argc >= 2 && !buf.dev->num_peers) {
-			char *line;
-			int ret = read_line(&line, argv[1]);
-			if (ret == 0) {
-				if (!parse_key(buf.dev->preshared_key, line)) {
-					free(line);
-					goto error;
-				}
-				free(line);
-			} else if (ret == 1)
-				buf.dev->flags |= WGDEVICE_REMOVE_PRESHARED_KEY;
-			else
-				goto error;
-			argv += 2;
-			argc -= 2;
 		} else if (!strcmp(argv[0], "peer") && argc >= 2) {
 			peer_offset = buf.pos;
 			if (use_space(&buf, sizeof(struct wgpeer)) < 0) {
@@ -560,6 +543,22 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 				goto error;
 			argv += 2;
 			argc -= 2;
+		} else if (!strcmp(argv[0], "preshared-key") && argc >= 2 && buf.dev->num_peers) {
+			char *line;
+			int ret = read_line(&line, argv[1]);
+			if (ret == 0) {
+				if (!parse_key(peer_from_offset(buf.dev, peer_offset)->preshared_key, line)) {
+					free(line);
+					goto error;
+				}
+				free(line);
+			} else if (ret == 1) {
+				free(line);
+				buf.dev->flags |= WGPEER_REMOVE_PRESHARED_KEY;
+			} else
+				goto error;
+			argv += 2;
+			argc -= 2;
 		} else {
 			fprintf(stderr, "Invalid argument: %s\n", argv[0]);
 			goto error;
diff --git a/src/set.c b/src/set.c
index 5e4291f..497edcc 100644
--- a/src/set.c
+++ b/src/set.c
@@ -13,7 +13,7 @@ int set_main(int argc, char *argv[])
 	int ret = 1;
 
 	if (argc < 3) {
-		fprintf(stderr, "Usage: %s %s <interface> [listen-port <port>] [fwmark <mark>] [private-key <file path>] [peer <base64 public key> [remove] [endpoint <ip>:<port>] [persistent-keepalive <interval seconds>] [allowed-ips <ip1>/<cidr1>[,<ip2>/<cidr2>]...] ]...\n", PROG_NAME, argv[0]);
+		fprintf(stderr, "Usage: %s %s <interface> [listen-port <port>] [fwmark <mark>] [private-key <file path>] [peer <base64 public key> [remove] [preshared-key <file path>] [endpoint <ip>:<port>] [persistent-keepalive <interval seconds>] [allowed-ips <ip1>/<cidr1>[,<ip2>/<cidr2>]...] ]...\n", PROG_NAME, argv[0]);
 		return 1;
 	}
 
diff --git a/src/show.c b/src/show.c
index 8134883..7f67dba 100644
--- a/src/show.c
+++ b/src/show.c
@@ -201,7 +201,7 @@ static char *bytes(uint64_t b)
 static const char *COMMAND_NAME = NULL;
 static void show_usage(void)
 {
-	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | fwmark | peers | endpoints | allowed-ips | latest-handshakes | transfer | persistent-keepalive | dump]\n", PROG_NAME, COMMAND_NAME);
+	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | listen-port | fwmark | peers | preshared-keys | endpoints | allowed-ips | latest-handshakes | transfer | persistent-keepalive | dump]\n", PROG_NAME, COMMAND_NAME);
 }
 
 static void pretty_print(struct wgdevice *device)
@@ -216,8 +216,6 @@ static void pretty_print(struct wgdevice *device)
 		terminal_printf("  " TERMINAL_BOLD "public key" TERMINAL_RESET ": %s\n", key(device->public_key));
 	if (memcmp(device->private_key, zero, WG_KEY_LEN))
 		terminal_printf("  " TERMINAL_BOLD "private key" TERMINAL_RESET ": %s\n", masked_key(device->private_key));
-	if (memcmp(device->preshared_key, zero, WG_KEY_LEN))
-		terminal_printf("  " TERMINAL_BOLD "preshared key" TERMINAL_RESET ": %s\n", masked_key(device->preshared_key));
 	if (device->port)
 		terminal_printf("  " TERMINAL_BOLD "listening port" TERMINAL_RESET ": %u\n", device->port);
 	if (device->fwmark)
@@ -228,6 +226,8 @@ static void pretty_print(struct wgdevice *device)
 	}
 	for_each_wgpeer(device, peer, i) {
 		terminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD "peer" TERMINAL_RESET ": " TERMINAL_FG_YELLOW "%s" TERMINAL_RESET "\n", key(peer->public_key));
+		if (memcmp(peer->preshared_key, zero, WG_KEY_LEN))
+			terminal_printf("  " TERMINAL_BOLD "preshared key" TERMINAL_RESET ": %s\n", masked_key(peer->preshared_key));
 		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
 			terminal_printf("  " TERMINAL_BOLD "endpoint" TERMINAL_RESET ": %s\n", endpoint(&peer->endpoint.addr));
 		terminal_printf("  " TERMINAL_BOLD "allowed ips" TERMINAL_RESET ": ");
@@ -260,7 +260,6 @@ static void dump_print(struct wgdevice *device, bool with_interface)
 		printf("%s\t", device->interface);
 	printf("%s\t", key(device->private_key));
 	printf("%s\t", key(device->public_key));
-	printf("%s\t", key(device->preshared_key));
 	printf("%u\t", device->port);
 	if (device->fwmark)
 		printf("0x%x\n", device->fwmark);
@@ -270,6 +269,7 @@ static void dump_print(struct wgdevice *device, bool with_interface)
 		if (with_interface)
 			printf("%s\t", device->interface);
 		printf("%s\t", key(peer->public_key));
+		printf("%s\t", key(peer->preshared_key));
 		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
 			printf("%s\t", endpoint(&peer->endpoint.addr));
 		else
@@ -301,10 +301,6 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 		if (with_interface)
 			printf("%s\t", device->interface);
 		printf("%s\n", key(device->private_key));
-	} else if (!strcmp(param, "preshared-key")) {
-		if (with_interface)
-			printf("%s\t", device->interface);
-		printf("%s\n", key(device->preshared_key));
 	} else if (!strcmp(param, "listen-port")) {
 		if (with_interface)
 			printf("%s\t", device->interface);
@@ -358,6 +354,13 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 			else
 				printf("%s\toff\n", key(peer->public_key));
 		}
+	} else if (!strcmp(param, "preshared-keys")) {
+		for_each_wgpeer(device, peer, i) {
+			if (with_interface)
+				printf("%s\t", device->interface);
+			printf("%s\t", key(peer->public_key));
+			printf("%s\n", key(peer->preshared_key));
+		}
 	} else if (!strcmp(param, "peers")) {
 		for_each_wgpeer(device, peer, i) {
 			if (with_interface)
diff --git a/src/showconf.c b/src/showconf.c
index da48486..039abee 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -50,14 +50,14 @@ int showconf_main(int argc, char *argv[])
 		key_to_base64(base64, device->private_key);
 		printf("PrivateKey = %s\n", base64);
 	}
-	if (memcmp(device->preshared_key, zero, WG_KEY_LEN)) {
-		key_to_base64(base64, device->preshared_key);
-		printf("PresharedKey = %s\n", base64);
-	}
 	printf("\n");
 	for_each_wgpeer(device, peer, i) {
 		key_to_base64(base64, peer->public_key);
 		printf("[Peer]\nPublicKey = %s\n", base64);
+		if (memcmp(peer->preshared_key, zero, WG_KEY_LEN)) {
+			key_to_base64(base64, peer->preshared_key);
+			printf("PresharedKey = %s\n", base64);
+		}
 		if (peer->num_ipmasks)
 			printf("AllowedIPs = ");
 		for_each_wgipmask(peer, ipmask, j) {
diff --git a/src/wg.8 b/src/wg.8
index 2aa800e..1517432 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -36,7 +36,7 @@ Sub-commands that take an INTERFACE must be passed a WireGuard interface.
 .SH COMMANDS
 
 .TP
-\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIfwmark\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fItransfer\fP | \fIdump\fP]
+\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIlisten-port\fP | \fIfwmark\fP | \fIpeers\fP | \fIpreshared-keys\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fItransfer\fP | \fIdump\fP]
 Shows current WireGuard configuration of specified \fI<interface>\fP.
 If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
 If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,
@@ -46,16 +46,16 @@ meant for the terminal. Otherwise, prints specified information grouped by
 newlines and tabs, meant to be used in scripts. For this script-friendly display,
 if \fIall\fP is specified, then the first field for all categories of information
 is the interface name. If \fPdump\fP is specified, then several lines are printed;
-the first contains in order separated by tab: private-key, public-key, preshared-key,
-listen-port, fwmark. Subsequent lines are printed for each peer and contain in order
-separated by tab: public-key, endpoint, allowed-ips, latest-handshake, transfer-rx,
-transfer-tx, persistent-keepalive.
+the first contains in order separated by tab: private-key, public-key, listen-port,
+fwmark. Subsequent lines are printed for each peer and contain in order separated
+by tab: public-key, preshared-key, endpoint, allowed-ips, latest-handshake,
+transfer-rx, transfer-tx, persistent-keepalive.
 .TP
 \fBshowconf\fP \fI<interface>\fP
 Shows the current configuration of \fI<interface>\fP in the format described
 by \fICONFIGURATION FILE FORMAT\fP below.
 .TP
-\fBset\fP \fI<interface>\fP [\fIlisten-port\fP \fI<port>\fP] [\fIfwmark\fP \fI<fwmark>\fP] [\fIprivate-key\fP \fI<file-path>\fP] [\fIpreshared-key\fP \fI<file-path>\fP] [\fIpeer\fP \fI<base64-public-key>\fP [\fIremove\fP] [\fIendpoint\fP \fI<ip>:<port>\fP] [\fIpersistent-keepalive\fP \fI<interval seconds>\fP] [\fIallowed-ips\fP \fI<ip1>/<cidr1>\fP[,\fI<ip2>/<cidr2>\fP]...] ]...
+\fBset\fP \fI<interface>\fP [\fIlisten-port\fP \fI<port>\fP] [\fIfwmark\fP \fI<fwmark>\fP] [\fIprivate-key\fP \fI<file-path>\fP] [\fIpeer\fP \fI<base64-public-key>\fP [\fIremove\fP] [\fIpreshared-key\fP \fI<file-path>\fP] [\fIendpoint\fP \fI<ip>:<port>\fP] [\fIpersistent-keepalive\fP \fI<interval seconds>\fP] [\fIallowed-ips\fP \fI<ip1>/<cidr1>\fP[,\fI<ip2>/<cidr2>\fP]...] ]...
 Sets configuration values for the specified \fI<interface>\fP. Multiple
 \fIpeer\fPs may be specified, and if the \fIremove\fP argument is given
 for a peer, that peer is removed, not configured. If \fIlisten-port\fP
@@ -126,11 +126,6 @@ The \fIInterface\fP section may contain the following fields:
 .IP \(bu
 PrivateKey \(em a base64 private key generated by \fIwg genkey\fP. Required.
 .IP \(bu
-PresharedKey \(em a base64 preshared key generated by \fIwg genpsk\fP. Optional,
-and may be omitted. This option adds an additional layer of symmetric-key
-cryptography to be mixed into the already existing public-key cryptography,
-for post-quantum resistance.
-.IP \(bu
 ListenPort \(em a 16-bit port for listening. Optional; if not specified, chosen
 randomly.
 .IP \(bu
@@ -143,6 +138,11 @@ PublicKey \(em a base64 public key calculated by \fIwg pubkey\fP from a
 private key, and usually transmitted out of band to the author of the
 configuration file. Required.
 .IP \(bu
+PresharedKey \(em a base64 preshared key generated by \fIwg genpsk\fP. Optional,
+and may be omitted. This option adds an additional layer of symmetric-key
+cryptography to be mixed into the already existing public-key cryptography,
+for post-quantum resistance.
+.IP \(bu
 AllowedIPs \(em a comma-separated list of ip (v4 or v6) addresses with
 CIDR masks from which this peer is allowed to send incoming traffic and
 to which outgoing traffic for this peer is directed. The catch-all

commit 13db708a0f68a1615ea58e8774bd2b46e3e950ab
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Apr 24 05:01:16 2017 +0200

    wg-quick: auto MTU discovery
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index 40c6650..e32971e 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -22,7 +22,7 @@ suitable for a few common use cases.
 
 Use \fIup\fP to add and set up an interface, and use \fIdown\fP to tear down and remove
 an interface. Running \fIup\fP adds a WireGuard interface, brings up the interface with the
-supplied IP addresses, sets up routes, and optionally runs pre/post up scripts. Running \fIdown\fP
+supplied IP addresses, sets up mtu and routes, and optionally runs pre/post up scripts. Running \fIdown\fP
 optionally saves the current configuration, removes the WireGuard interface, and optionally
 runs pre/post down scripts.
 
@@ -65,6 +65,10 @@ which are handled by this tool:
 Address \(em a comma-separated list of ip (v4 or v6) addresses (optionally with CIDR masks)
 to be assigned to the interface. May be specified multiple times.
 .IP \(bu
+MTU \(em if not specified, the MTU is automatically determined from the endpoint addresses
+or the system default route, which is usually a sane choice. However, to manually specify
+an MTU to override this automatic discovery, this value may be specified explicitly.
+.IP \(bu
 PreUp, PostUp, PreDown, PostDown \(em script snippets which will be executed by
 .BR bash (1)
 before/after setting up/tearing down the interface, most commonly used
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 257ea7d..8cb439a 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -13,6 +13,7 @@ export PATH="${SELF%/*}:$PATH"
 WG_CONFIG=""
 INTERFACE=""
 ADDRESSES=( )
+MTU=""
 PRE_UP=""
 POST_UP=""
 PRE_DOWN=""
@@ -39,6 +40,7 @@ parse_options() {
 		if [[ $interface_section -eq 1 ]]; then
 			case "$key" in
 			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
+			MTU) MTU="$value"; continue ;;
 			PreUp) PRE_UP="$value"; continue ;;
 			PreDown) PRE_DOWN="$value"; continue ;;
 			PostUp) POST_UP="$value"; continue ;;
@@ -108,6 +110,25 @@ add_addr() {
 	cmd ip address add "$1" dev "$INTERFACE"
 }
 
+set_mtu() {
+	local mtu=0 endpoint output
+	if [[ -n $MTU ]]; then
+		cmd ip link set mtu "$MTU" dev "$INTERFACE"
+		return
+	fi
+	while read -r _ endpoint; do
+		[[ $endpoint =~ ^([a-z0-9:.]+):[0-9]+$ ]] || continue
+		output="$(ip route get "${BASH_REMATCH[1]}" || true)"
+		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
+	done < <(wg show "$INTERFACE" endpoints)
+	if [[ $mtu -eq 0 ]]; then
+		read -r output < <(ip route show default || true) || true
+		[[ ( $output =~ mtu\ ([0-9]+) || ( $output =~ dev\ ([^ ]+) && $(ip link show dev "${BASH_REMATCH[1]}") =~ mtu\ ([0-9]+) ) ) && ${BASH_REMATCH[1]} -gt $mtu ]] && mtu="${BASH_REMATCH[1]}"
+	fi
+	[[ $mtu -gt 0 ]] || mtu=1500
+	cmd ip link set mtu $(( mtu - 80 )) dev "$INTERFACE"
+}
+
 add_route() {
 	if [[ $1 == 0.0.0.0/0 || $1 == ::/0 ]]; then
 		add_default "$1"
@@ -146,6 +167,7 @@ save_config() {
 	for address in ${BASH_REMATCH[1]}; do
 		new_config+="Address = $address"$'\n'
 	done
+	[[ -n $MTU && $(ip link show dev "$INTERFACE") =~ mtu\ ([0-9]+) ]] && new_config+="MTU = ${BASH_REMATCH[1]}"$'\n'
 	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
 	[[ -z $PRE_UP ]] || new_config+="PreUp = $PRE_UP"$'\n'
 	[[ -z $POST_UP ]] || new_config+="PostUp = $POST_UP"$'\n'
@@ -200,6 +222,7 @@ cmd_up() {
 	for i in "${ADDRESSES[@]}"; do
 		add_addr "$i"
 	done
+	set_mtu
 	up_if
 	for i in $(wg show "$INTERFACE" allowed-ips | grep -Po '(?<=[\t ])[0-9.:/a-f]+' | sort -nr -k 2 -t /); do
 		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"

commit 83223f8e4c2001b61465509143e12fe9e862b3ea
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Apr 24 03:45:40 2017 +0200

    wg: retry name resolution on temporary failure
    
    This should solve many problems at init time.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index be15870..c00e91c 100644
--- a/src/config.c
+++ b/src/config.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <errno.h>
@@ -189,7 +190,15 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 		*end = '\0';
 		++end;
 	}
-	ret = getaddrinfo(begin, end, &hints, &resolved);
+
+	for (unsigned int timeout = 1000000; timeout < 90000000; timeout = timeout * 3 / 2) {
+		ret = getaddrinfo(begin, end, &hints, &resolved);
+		if (ret != EAI_AGAIN)
+			break;
+		fprintf(stderr, "%s: `%s`. Trying again in %.2f seconds...\n", gai_strerror(ret), value, timeout / 1000000.0);
+		usleep(timeout);
+	}
+
 	if (ret != 0) {
 		free(mutable);
 		fprintf(stderr, "%s: `%s`\n", gai_strerror(ret), value);

commit c98c415bd15aa31e781098689c94fede2c74c43c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Apr 20 20:21:50 2017 +0200

    wg: no hyphen in preshared, to keep uniformity
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/show.c b/src/show.c
index c9ba473..8134883 100644
--- a/src/show.c
+++ b/src/show.c
@@ -217,7 +217,7 @@ static void pretty_print(struct wgdevice *device)
 	if (memcmp(device->private_key, zero, WG_KEY_LEN))
 		terminal_printf("  " TERMINAL_BOLD "private key" TERMINAL_RESET ": %s\n", masked_key(device->private_key));
 	if (memcmp(device->preshared_key, zero, WG_KEY_LEN))
-		terminal_printf("  " TERMINAL_BOLD "pre-shared key" TERMINAL_RESET ": %s\n", masked_key(device->preshared_key));
+		terminal_printf("  " TERMINAL_BOLD "preshared key" TERMINAL_RESET ": %s\n", masked_key(device->preshared_key));
 	if (device->port)
 		terminal_printf("  " TERMINAL_BOLD "listening port" TERMINAL_RESET ": %u\n", device->port);
 	if (device->fwmark)
diff --git a/src/wg.8 b/src/wg.8
index b4f9599..2aa800e 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -210,7 +210,7 @@ ignored.
 If set to \fIalways\fP, always print ANSI colorized output. If set to \fInever\fP, never print ANSI colorized output. If set to \fIauto\fP, something invalid, or unset, then print ANSI colorized output only when writing to a TTY.
 .TP
 .I WG_HIDE_KEYS
-If set to \fInever\fP, then the pretty-printing \fBshow\fP sub-command will show private and pre-shared keys in the output. If set to \fIalways\fP, something invalid, or unset, then private and pre-shared keys will be printed as "(hidden)".
+If set to \fInever\fP, then the pretty-printing \fBshow\fP sub-command will show private and preshared keys in the output. If set to \fIalways\fP, something invalid, or unset, then private and preshared keys will be printed as "(hidden)".
 
 .SH SEE ALSO
 .BR ip (8),
diff --git a/src/wg.c b/src/wg.c
index 0ec64eb..e1d9a60 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -19,7 +19,7 @@ static const struct {
 	{ "setconf", setconf_main, "Applies a configuration file to a WireGuard interface" },
 	{ "addconf", setconf_main, "Appends a configuration file to a WireGuard interface" },
 	{ "genkey", genkey_main, "Generates a new private key and writes it to stdout" },
-	{ "genpsk", genkey_main, "Generates a new pre-shared key and writes it to stdout" },
+	{ "genpsk", genkey_main, "Generates a new preshared key and writes it to stdout" },
 	{ "pubkey", pubkey_main, "Reads a private key from stdin and writes a public key to stdout" }
 };
 

commit 5fab6f18d5c57ebae43ce533b5c4112c1c516b6c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Apr 19 16:53:13 2017 +0200

    wg: argc is always 1
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/genkey.c b/src/genkey.c
index bf35aed..9c8da42 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -50,7 +50,7 @@ int genkey_main(int argc, char *argv[])
 		perror("getrandom");
 		return 1;
 	}
-	if (argc && !strcmp(argv[0], "genkey"))
+	if (!strcmp(argv[0], "genkey"))
 		curve25519_normalize_secret(key);
 
 	key_to_base64(base64, key);

commit 6a967c63a7524b3a86e9d2a6123e4d4e25d2860a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Apr 19 16:51:24 2017 +0200

    wg: check for malloc failure
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 8f75804..be15870 100644
--- a/src/config.c
+++ b/src/config.c
@@ -153,6 +153,10 @@ static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 		.ai_socktype = SOCK_DGRAM,
 		.ai_protocol = IPPROTO_UDP
 	};
+	if (!mutable) {
+		perror("strdup");
+		return false;
+	}
 	if (!strlen(value)) {
 		free(mutable);
 		fprintf(stderr, "Unable to parse empty endpoint\n");

commit 755217bd853f2581a8bb420728942cf785afe204
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 16 01:20:43 2017 +0200

    wg: side channel resistant base64
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 6502c3d..ec75052 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -36,7 +36,6 @@ CFLAGS += -std=gnu11
 CFLAGS += -Wall -Wextra
 CFLAGS += -MMD -MP
 CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
-LDLIBS += -lresolv
 ifeq ($(shell uname -s),Linux)
 LIBMNL_CFLAGS := $(shell $(PKG_CONFIG) --cflags libmnl 2>/dev/null)
 LIBMNL_LDLIBS := $(shell $(PKG_CONFIG) --libs libmnl 2>/dev/null || echo -lmnl)
diff --git a/src/base64.c b/src/base64.c
index cf37464..48ac1be 100644
--- a/src/base64.c
+++ b/src/base64.c
@@ -1,220 +1,66 @@
-/*
- * Copyright (c) 1996, 1998 by Internet Software Consortium.
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
- * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
- * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
- * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
- * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
- * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
- * SOFTWARE.
- *
- * Portions Copyright (c) 1995 by International Business Machines, Inc.
- *
- * International Business Machines, Inc. (hereinafter called IBM) grants
- * permission under its copyrights to use, copy, modify, and distribute this
- * Software with or without fee, provided that the above copyright notice and
- * all paragraphs of this notice appear in all copies, and that the name of IBM
- * not be used in connection with the marketing of any product incorporating
- * the Software or modifications thereof, without specific, written prior
- * permission.
- *
- * To the extent it has a right to do so, IBM grants an immunity from suit
- * under its patents, if any, for the use, sale or manufacture of products to
- * the extent that such products are used for performing Domain Name System
- * dynamic updates in TCP/IP networks by means of the Software.  No immunity is
- * granted for any product per se or for any other function of any product.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,
- * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING
- * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN
- * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.
+ * This is a specialized constant-time base64 implementation that resists side-channel attacks.
  */
 
+#include <string.h>
 #include "base64.h"
-#include <sys/types.h>
-#include <assert.h>
-#include <stdlib.h>
-#include <ctype.h>
-
-#if defined(NEED_B64_NTOP) || defined(NEED_B64_PTON)
-static const char base64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-static const char pad64 = '=';
-#endif
 
-#ifdef NEED_B64_NTOP
-int b64_ntop(unsigned char const *src, size_t srclength, char *target, size_t targsize)
+static inline void encode(char dest[4], const uint8_t src[3])
 {
-	size_t datalength = 0;
-	uint8_t input[3];
-	uint8_t output[4];
-	size_t i;
+	const uint8_t input[] = { (src[0] >> 2) & 63, ((src[0] << 4) | (src[1] >> 4)) & 63, ((src[1] << 2) | (src[2] >> 6)) & 63, src[2] & 63 };
+	for (unsigned int i = 0; i < 4; ++i)
+		dest[i] = input[i] + 'A'
+			  + (((25 - input[i]) >> 8) & 6)
+			  - (((51 - input[i]) >> 8) & 75)
+			  - (((61 - input[i]) >> 8) & 15)
+			  + (((62 - input[i]) >> 8) & 3);
 
-	while (2 < srclength) {
-		input[0] = *src++;
-		input[1] = *src++;
-		input[2] = *src++;
-		srclength -= 3;
-
-		output[0] = input[0] >> 2;
-		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
-		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
-		output[3] = input[2] & 0x3f;
-		assert(output[0] < 64);
-		assert(output[1] < 64);
-		assert(output[2] < 64);
-		assert(output[3] < 64);
-
-		if (datalength + 4 > targsize)
-			return -1;
-		target[datalength++] = base64[output[0]];
-		target[datalength++] = base64[output[1]];
-		target[datalength++] = base64[output[2]];
-		target[datalength++] = base64[output[3]];
-	}
-	if (0 != srclength) {
-		input[0] = input[1] = input[2] = '\0';
-		for (i = 0; i < srclength; i++)
-			input[i] = *src++;
-		output[0] = input[0] >> 2;
-		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
-		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
-		assert(output[0] < 64);
-		assert(output[1] < 64);
-		assert(output[2] < 64);
-
-		if (datalength + 4 > targsize)
-			return -1;
-		target[datalength++] = base64[output[0]];
-		target[datalength++] = base64[output[1]];
-		if (srclength == 1)
-			target[datalength++] = pad64;
-		else
-			target[datalength++] = base64[output[2]];
-		target[datalength++] = pad64;
-	}
-	if (datalength >= targsize)
-		return (-1);
-	target[datalength] = '\0';
-	return datalength;
 }
-#endif
 
-#ifdef NEED_B64_PTON
-int b64_pton(char const *src, uint8_t *target, size_t targsize)
+void key_to_base64(char base64[static WG_KEY_LEN_BASE64], const uint8_t key[static WG_KEY_LEN])
 {
-	static int b64rmap_initialized = 0;
-	static uint8_t b64rmap[256];
-	static const uint8_t b64rmap_special = 0xf0;
-	static const uint8_t b64rmap_end = 0xfd;
-	static const uint8_t b64rmap_space = 0xfe;
-	static const uint8_t b64rmap_invalid = 0xff;
-	int tarindex, state, ch;
-	uint8_t ofs;
-
-	if (!b64rmap_initialized) {
-		int i;
-		char ch;
-		b64rmap[0] = b64rmap_end;
-		for (i = 1; i < 256; ++i) {
-			ch = (char)i;
-			if (isspace(ch))
-				b64rmap[i] = b64rmap_space;
-			else if (ch == pad64)
-				b64rmap[i] = b64rmap_end;
-			else
-				b64rmap[i] = b64rmap_invalid;
-		}
-		for (i = 0; base64[i] != '\0'; ++i)
-			b64rmap[(uint8_t)base64[i]] = i;
-		b64rmap_initialized = 1;
-	}
-
-	state = 0;
-	tarindex = 0;
-
-	for (;;) {
-		ch = *src++;
-		ofs = b64rmap[ch];
-
-		if (ofs >= b64rmap_special) {
-			if (ofs == b64rmap_space)
-				continue;
-			if (ofs == b64rmap_end)
-				break;
-			return -1;
-		}
-
-		switch (state) {
-		case 0:
-			if ((size_t)tarindex >= targsize)
-				return -1;
-			target[tarindex] = ofs << 2;
-			state = 1;
-			break;
-		case 1:
-			if ((size_t)tarindex + 1 >= targsize)
-				return -1;
-			target[tarindex]   |=  ofs >> 4;
-			target[tarindex+1]  = (ofs & 0x0f) << 4 ;
-			tarindex++;
-			state = 2;
-			break;
-		case 2:
-			if ((size_t)tarindex + 1 >= targsize)
-				return -1;
-			target[tarindex]   |=  ofs >> 2;
-			target[tarindex+1]  = (ofs & 0x03) << 6;
-			tarindex++;
-			state = 3;
-			break;
-		case 3:
-			if ((size_t)tarindex >= targsize)
-				return -1;
-			target[tarindex] |= ofs;
-			tarindex++;
-			state = 0;
-			break;
-		default:
-			abort();
-		}
-	}
+	unsigned int i;
+	for (i = 0; i < WG_KEY_LEN / 3; ++i)
+		encode(&base64[i * 4], &key[i * 3]);
+	encode(&base64[i * 4], (const uint8_t[]){ key[i * 3 + 0], key[i * 3 + 1], 0 });
+	base64[WG_KEY_LEN_BASE64 - 2] = '=';
+	base64[WG_KEY_LEN_BASE64 - 1] = '\0';
+}
 
-	if (ch == pad64) {
-		ch = *src++;
-		switch (state) {
-		case 0:
-		case 1:
-			return -1;
+static inline int decode(const char src[4])
+{
+	int val = 0;
+	for (unsigned int i = 0; i < 4; ++i)
+		val |= (-1
+			    + ((((('A' - 1) - src[i]) & (src[i] - ('Z' + 1))) >> 8) & (src[i] - 64))
+			    + ((((('a' - 1) - src[i]) & (src[i] - ('z' + 1))) >> 8) & (src[i] - 70))
+			    + ((((('0' - 1) - src[i]) & (src[i] - ('9' + 1))) >> 8) & (src[i] + 5))
+			    + ((((('+' - 1) - src[i]) & (src[i] - ('+' + 1))) >> 8) & 63)
+			    + ((((('/' - 1) - src[i]) & (src[i] - ('/' + 1))) >> 8) & 64)
+			) << (18 - 6 * i);
+	return val;
+}
 
-		case 2:
-			for (; ch; ch = *src++) {
-				if (b64rmap[ch] != b64rmap_space)
-					break;
-			}
-			if (ch != pad64)
-				return -1;
-			ch = *src++;
-		case 3:
-			for (; ch; ch = *src++) {
-				if (b64rmap[ch] != b64rmap_space)
-					return -1;
-			}
-			if (target[tarindex] != 0)
-				return -1;
-		}
-	} else {
-		if (state != 0)
-			return -1;
+bool key_from_base64(uint8_t key[static WG_KEY_LEN], const char *base64)
+{
+	unsigned int i;
+	int val;
+	if (strlen(base64) != WG_KEY_LEN_BASE64 - 1 || base64[WG_KEY_LEN_BASE64 - 2] != '=')
+		return false;
+
+	for (i = 0; i < WG_KEY_LEN / 3; ++i) {
+		val = decode(&base64[i * 4]);
+		if (val < 0)
+			return false;
+		key[i * 3 + 0] = (val >> 16) & 0xff;
+		key[i * 3 + 1] = (val >> 8) & 0xff;
+		key[i * 3 + 2] = val & 0xff;
 	}
-
-	return tarindex;
+	val = decode((const char[]){ base64[i * 4 + 0], base64[i * 4 + 1], base64[i * 4 + 2], 'A' });
+	if (val < 0 || val & 0xff)
+		return false;
+	key[i * 3 + 0] = (val >> 16) & 0xff;
+	key[i * 3 + 1] = (val >> 8) & 0xff;
+	return true;
 }
-#endif
diff --git a/src/base64.h b/src/base64.h
index 4ad0ac3..37cf1b9 100644
--- a/src/base64.h
+++ b/src/base64.h
@@ -3,18 +3,13 @@
 #ifndef BASE64_H
 #define BASE64_H
 
-#include <resolv.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include "../uapi.h"
 
-#define b64_len(len) ((((len) + 2) / 3) * 4 + 1)
+#define WG_KEY_LEN_BASE64 ((((WG_KEY_LEN) + 2) / 3) * 4 + 1)
 
-#ifndef b64_ntop
-int b64_ntop(unsigned char const *, size_t, char *, size_t);
-#define NEED_B64_NTOP
-#endif
-
-#ifndef b64_pton
-int b64_pton(char const *, unsigned char *, size_t);
-#define NEED_B64_PTON
-#endif
+void key_to_base64(char base64[static WG_KEY_LEN_BASE64], const uint8_t key[static WG_KEY_LEN]);
+bool key_from_base64(uint8_t key[static WG_KEY_LEN], const char *base64);
 
 #endif
diff --git a/src/config.c b/src/config.c
index e95626c..8f75804 100644
--- a/src/config.c
+++ b/src/config.c
@@ -118,12 +118,10 @@ static inline bool parse_fwmark(uint32_t *fwmark, unsigned int *flags, const cha
 
 static inline bool parse_key(uint8_t key[static WG_KEY_LEN], const char *value)
 {
-	uint8_t tmp[WG_KEY_LEN + 1];
-	if (strlen(value) != b64_len(WG_KEY_LEN) - 1 || b64_pton(value, tmp, WG_KEY_LEN + 1) != WG_KEY_LEN) {
+	if (!key_from_base64(key, value)) {
 		fprintf(stderr, "Key is not the correct length or format: `%s`\n", value);
 		return false;
 	}
-	memcpy(key, tmp, WG_KEY_LEN);
 	return true;
 }
 
diff --git a/src/genkey.c b/src/genkey.c
index d3bc846..bf35aed 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -34,8 +34,8 @@ static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
 
 int genkey_main(int argc, char *argv[])
 {
-	unsigned char private_key[CURVE25519_POINT_SIZE];
-	char private_key_base64[b64_len(CURVE25519_POINT_SIZE)];
+	uint8_t key[WG_KEY_LEN];
+	char base64[WG_KEY_LEN_BASE64];
 	struct stat stat;
 
 	if (argc != 1) {
@@ -46,19 +46,14 @@ int genkey_main(int argc, char *argv[])
 	if (!fstat(STDOUT_FILENO, &stat) && S_ISREG(stat.st_mode) && stat.st_mode & S_IRWXO)
 		fputs("Warning: writing to world accessible file.\nConsider setting the umask to 077 and trying again.\n", stderr);
 
-	if (get_random_bytes(private_key, CURVE25519_POINT_SIZE) != CURVE25519_POINT_SIZE) {
+	if (get_random_bytes(key, WG_KEY_LEN) != WG_KEY_LEN) {
 		perror("getrandom");
 		return 1;
 	}
 	if (argc && !strcmp(argv[0], "genkey"))
-		curve25519_normalize_secret(private_key);
+		curve25519_normalize_secret(key);
 
-	if (b64_ntop(private_key, sizeof(private_key), private_key_base64, sizeof(private_key_base64)) != sizeof(private_key_base64) - 1) {
-		fprintf(stderr, "%s: Could not convert key to base64\n", PROG_NAME);
-		return 1;
-	}
-
-	puts(private_key_base64);
+	key_to_base64(base64, key);
+	puts(base64);
 	return 0;
-
 }
diff --git a/src/ipc.c b/src/ipc.c
index c26da21..ed18128 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -177,7 +177,7 @@ static int userspace_set_device(struct wgdevice *dev)
 	if (fd < 0)
 		return fd;
 	for_each_wgpeer(dev, peer, len);
-	len = (unsigned char *)peer - (unsigned char *)dev;
+	len = (uint8_t *)peer - (uint8_t *)dev;
 	ret = -EBADMSG;
 	if (!len)
 		goto out;
diff --git a/src/pubkey.c b/src/pubkey.c
index f567223..009cd15 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -1,7 +1,6 @@
 /* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <errno.h>
-#include <resolv.h>
 #include <stdio.h>
 #include <ctype.h>
 
@@ -11,8 +10,8 @@
 
 int pubkey_main(int argc, char *argv[])
 {
-	unsigned char private_key[CURVE25519_POINT_SIZE + 1] = { 0 }, public_key[CURVE25519_POINT_SIZE] = { 0 };
-	char private_key_base64[b64_len(CURVE25519_POINT_SIZE)] = { 0 }, public_key_base64[b64_len(CURVE25519_POINT_SIZE)] = { 0 };
+	uint8_t key[WG_KEY_LEN];
+	char base64[WG_KEY_LEN_BASE64];
 	int trailing_char;
 
 	if (argc != 1) {
@@ -20,11 +19,12 @@ int pubkey_main(int argc, char *argv[])
 		return 1;
 	}
 
-	if (fread(private_key_base64, 1, sizeof(private_key_base64) - 1, stdin) != sizeof(private_key_base64) - 1) {
+	if (fread(base64, 1, sizeof(base64) - 1, stdin) != sizeof(base64) - 1) {
 		errno = EINVAL;
 		fprintf(stderr, "%s: Key is not the correct length or format\n", PROG_NAME);
 		return 1;
 	}
+	base64[WG_KEY_LEN_BASE64 - 1] = '\0';
 
 	for (;;) {
 		trailing_char = getc(stdin);
@@ -36,15 +36,12 @@ int pubkey_main(int argc, char *argv[])
 		return 1;
 	}
 
-	if (b64_pton(private_key_base64, private_key, sizeof(private_key)) != sizeof(private_key) - 1) {
+	if (!key_from_base64(key, base64)) {
 		fprintf(stderr, "%s: Key is not the correct length or format\n", PROG_NAME);
 		return 1;
 	}
-	curve25519_generate_public(public_key, private_key);
-	if (b64_ntop(public_key, sizeof(public_key), public_key_base64, sizeof(public_key_base64)) != sizeof(public_key_base64) - 1) {
-		fprintf(stderr, "%s: Could not convert key to base64\n", PROG_NAME);
-		return 1;
-	}
-	puts(public_key_base64);
+	curve25519_generate_public(key, key);
+	key_to_base64(base64, key);
+	puts(base64);
 	return 0;
 }
diff --git a/src/show.c b/src/show.c
index 7b057cf..c9ba473 100644
--- a/src/show.c
+++ b/src/show.c
@@ -4,7 +4,6 @@
 #include <inttypes.h>
 #include <netinet/in.h>
 #include <net/if.h>
-#include <resolv.h>
 #include <stdbool.h>
 #include <stddef.h>
 #include <stdint.h>
@@ -78,17 +77,16 @@ static void sort_peers(struct wgdevice *device)
 
 static const uint8_t zero[WG_KEY_LEN] = { 0 };
 
-static char *key(const unsigned char key[static WG_KEY_LEN])
+static char *key(const uint8_t key[static WG_KEY_LEN])
 {
-	static char b64[b64_len(WG_KEY_LEN)];
+	static char base64[WG_KEY_LEN_BASE64];
 	if (!memcmp(key, zero, WG_KEY_LEN))
 		return "(none)";
-	memset(b64, 0, b64_len(WG_KEY_LEN));
-	b64_ntop(key, WG_KEY_LEN, b64, b64_len(WG_KEY_LEN));
-	return b64;
+	key_to_base64(base64, key);
+	return base64;
 }
 
-static char *masked_key(const unsigned char masked_key[static WG_KEY_LEN])
+static char *masked_key(const uint8_t masked_key[static WG_KEY_LEN])
 {
 	const char *var = getenv("WG_HIDE_KEYS");
 	if (var && !strcmp(var, "never"))
diff --git a/src/showconf.c b/src/showconf.c
index 585b08d..da48486 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -3,7 +3,6 @@
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <net/if.h>
-#include <resolv.h>
 #include <stddef.h>
 #include <stdio.h>
 #include <string.h>
@@ -18,7 +17,7 @@
 int showconf_main(int argc, char *argv[])
 {
 	static const uint8_t zero[WG_KEY_LEN] = { 0 };
-	char b64[b64_len(WG_KEY_LEN)] = { 0 };
+	char base64[WG_KEY_LEN_BASE64];
 	char ip[INET6_ADDRSTRLEN];
 	struct wgdevice *device = NULL;
 	struct wgpeer *peer;
@@ -48,17 +47,17 @@ int showconf_main(int argc, char *argv[])
 	if (device->fwmark)
 		printf("FwMark = 0x%x\n", device->fwmark);
 	if (memcmp(device->private_key, zero, WG_KEY_LEN)) {
-		b64_ntop(device->private_key, WG_KEY_LEN, b64, b64_len(WG_KEY_LEN));
-		printf("PrivateKey = %s\n", b64);
+		key_to_base64(base64, device->private_key);
+		printf("PrivateKey = %s\n", base64);
 	}
 	if (memcmp(device->preshared_key, zero, WG_KEY_LEN)) {
-		b64_ntop(device->preshared_key, WG_KEY_LEN, b64, b64_len(WG_KEY_LEN));
-		printf("PresharedKey = %s\n", b64);
+		key_to_base64(base64, device->preshared_key);
+		printf("PresharedKey = %s\n", base64);
 	}
 	printf("\n");
 	for_each_wgpeer(device, peer, i) {
-		b64_ntop(peer->public_key, WG_KEY_LEN, b64, b64_len(WG_KEY_LEN));
-		printf("[Peer]\nPublicKey = %s\n", b64);
+		key_to_base64(base64, peer->public_key);
+		printf("[Peer]\nPublicKey = %s\n", base64);
 		if (peer->num_ipmasks)
 			printf("AllowedIPs = ");
 		for_each_wgipmask(peer, ipmask, j) {

commit d42dd68add76d7f34e8b17c4ba61ddf210f1a269
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Mar 28 10:46:31 2017 +0200

    wg: do not use addrconfig with port in gai
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 20bd22a..e95626c 100644
--- a/src/config.c
+++ b/src/config.c
@@ -66,7 +66,7 @@ static inline uint16_t parse_port(const char *value)
 		.ai_family = AF_UNSPEC,
 		.ai_socktype = SOCK_DGRAM,
 		.ai_protocol = IPPROTO_UDP,
-		.ai_flags = AI_ADDRCONFIG | AI_PASSIVE
+		.ai_flags = AI_PASSIVE
 	};
 
 	if (!strlen(value)) {

commit 6d20c647d010e5075b277dc07d32f0c9b5cdae79
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Mar 24 04:01:25 2017 +0100

    uapi: add version magic
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index b9a65c1..20bd22a 100644
--- a/src/config.c
+++ b/src/config.c
@@ -465,7 +465,7 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 {
 	struct inflatable_device buf = { 0 };
 	size_t peer_offset = 0;
-	buf.dev = calloc(sizeof(struct wgdevice), 1);
+	buf.dev = calloc(1, sizeof(struct wgdevice));
 	if (!buf.dev) {
 		perror("calloc");
 		return false;
diff --git a/src/ipc.c b/src/ipc.c
index a926261..c26da21 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -42,6 +42,15 @@ struct inflatable_buffer {
 
 #define max(a, b) ((a) > (b) ? (a) : (b))
 
+static int check_version_magic(struct wgdevice *device, int ret)
+{
+	if (ret == -EPROTO || (!ret && device->version_magic != WG_API_VERSION_MAGIC)) {
+		fprintf(stderr, "This program was built for a different version of WireGuard than\nwhat is currently running. Either this version of wg(8) is out\nof date, or the currently loaded WireGuard module is out of date.\nIf you have just updated your WireGuard installation, you may have\nforgotten to unload the previous running WireGuard module. Try\nrunning `rmmod wireguard` as root, and then try re-adding the device\nand trying again.\n\n");
+		return -EPROTO;
+	}
+	return ret;
+}
+
 static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 {
 	size_t len, expand_to;
@@ -172,6 +181,7 @@ static int userspace_set_device(struct wgdevice *dev)
 	ret = -EBADMSG;
 	if (!len)
 		goto out;
+	dev->version_magic = WG_API_VERSION_MAGIC;
 	ret = write(fd, dev, len);
 	if (ret < 0)
 		goto out;
@@ -243,6 +253,9 @@ static int userspace_get_device(struct wgdevice **dev, const char *interface)
 		goto out;
 
 	len = ((struct wgdevice *)READ_BYTES(sizeof(struct wgdevice)))->num_peers;
+	ret = check_version_magic((struct wgdevice *)buffer, ret);
+	if (ret)
+		goto out;
 	for (i = 0; i < len; ++i)
 		READ_BYTES(sizeof(struct wgipmask) * ((struct wgpeer *)READ_BYTES(sizeof(struct wgpeer)))->num_ipmasks);
 	ret = 0;
@@ -361,7 +374,7 @@ static bool kernel_has_wireguard_interface(const char *interface)
 	char *this_interface;
 	struct inflatable_buffer buffer = { .len = 4096 };
 
-	buffer.buffer = calloc(buffer.len, 1);
+	buffer.buffer = calloc(1, buffer.len);
 	if (!buffer.buffer)
 		return false;
 	if (kernel_get_wireguard_interfaces(&buffer) < 0) {
@@ -382,12 +395,16 @@ static bool kernel_has_wireguard_interface(const char *interface)
 static int do_ioctl(int req, struct ifreq *ifreq)
 {
 	static int fd = -1;
+	int ret;
 	if (fd < 0) {
 		fd = socket(AF_INET, SOCK_DGRAM, 0);
 		if (fd < 0)
 			return fd;
 	}
-	return ioctl(fd, req, ifreq);
+	ret = ioctl(fd, req, ifreq);
+	if (ret == -1)
+		ret = -errno;
+	return ret;
 }
 
 static int kernel_set_device(struct wgdevice *dev)
@@ -395,6 +412,7 @@ static int kernel_set_device(struct wgdevice *dev)
 	struct ifreq ifreq = { .ifr_data = (char *)dev };
 	memcpy(&ifreq.ifr_name, dev->interface, IFNAMSIZ);
 	ifreq.ifr_name[IFNAMSIZ - 1] = 0;
+	dev->version_magic = WG_API_VERSION_MAGIC;
 	return do_ioctl(WG_SET_DEVICE, &ifreq);
 }
 
@@ -410,17 +428,18 @@ static int kernel_get_device(struct wgdevice **dev, const char *interface)
 		ret = do_ioctl(WG_GET_DEVICE, &ifreq);
 		if (ret < 0)
 			goto out;
-		*dev = calloc(ret + sizeof(struct wgdevice), 1);
-		if (!*dev) {
-			ret = -ENOMEM;
+		*dev = calloc(1, ret + sizeof(struct wgdevice));
+		ret = -ENOMEM;
+		if (!*dev)
 			goto out;
-		}
 		(*dev)->peers_size = ret;
+		(*dev)->version_magic = WG_API_VERSION_MAGIC;
 		ifreq.ifr_data = (char *)*dev;
 		memcpy(&ifreq.ifr_name, interface, IFNAMSIZ);
 		ifreq.ifr_name[IFNAMSIZ - 1] = 0;
 		ret = do_ioctl(WG_GET_DEVICE, &ifreq);
 	} while (ret == -EMSGSIZE);
+	ret = check_version_magic(*dev, ret);
 	if (ret < 0) {
 		free(*dev);
 		*dev = NULL;
@@ -438,7 +457,7 @@ char *ipc_list_devices(void)
 	int ret;
 
 	ret = -ENOMEM;
-	buffer.buffer = calloc(buffer.len, 1);
+	buffer.buffer = calloc(1, buffer.len);
 	if (!buffer.buffer)
 		goto cleanup;
 

commit a8803c17a71edfafbb7ce8edf633af4a30d845fb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Mar 23 15:44:10 2017 +0100

    wg-quick: various cleanups
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 73cfa25..257ea7d 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -79,9 +79,10 @@ add_if() {
 }
 
 del_if() {
-	local fwmark="$(wg show "$INTERFACE" fwmark)"
+	local fwmark
+	fwmark="$(wg show "$INTERFACE" fwmark)"
 	DEFAULT_TABLE=0
-	[[ $fwmark != off ]] && DEFAULT_TABLE=$(( $fwmark ))
+	[[ $fwmark != off ]] && DEFAULT_TABLE=$(( fwmark ))
 	if [[ $DEFAULT_TABLE -ne 0 ]]; then
 		while [[ $(ip -4 rule show) == *"lookup $DEFAULT_TABLE"* ]]; do
 			cmd ip -4 rule delete table $DEFAULT_TABLE
@@ -127,8 +128,8 @@ add_default() {
 	cmd ip $proto route add "$1" dev "$INTERFACE" table $DEFAULT_TABLE
 	cmd ip $proto rule add not fwmark $DEFAULT_TABLE table $DEFAULT_TABLE
 	cmd ip $proto rule add table main suppress_prefixlength 0
-	local key equals value
-	while read -r key equals value; do
+	local key value
+	while read -r key _ value; do
 		[[ $value -eq 1 ]] && sysctl -q "$key=2"
 	done < <(sysctl -a -r 'net\.ipv4.conf\..+\.rp_filter')
 	return 0
@@ -153,7 +154,7 @@ save_config() {
 	old_umask="$(umask)"
 	umask 077
 	current_config="$(cmd wg showconf "$INTERFACE")"
-	trap "rm -f '$CONFIG_FILE.tmp; exit'" INT TERM EXIT
+	trap 'rm -f "$CONFIG_FILE.tmp"; exit' INT TERM EXIT
 	echo "${current_config/\[Interface\]$'\n'/$new_config}" > "$CONFIG_FILE.tmp" || die "Could not write configuration file"
 	mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || die "Could not move configuration file"
 	trap - INT TERM EXIT

commit 3067b597980b94e01a8dca38b4e072fd55a9696c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Mar 22 13:11:41 2017 +0100

    wg: document # comments in wg(8) man page
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg.8 b/src/wg.8
index b9c1f79..b4f9599 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -164,7 +164,9 @@ interval of 25 seconds. If set to 0 or "off", this option is disabled. By defaul
 when unspecified, this option is off. Most users will not need this. Optional.
 
 .SH CONFIGURATION FILE FORMAT EXAMPLE
-This example may be used as a model for writing configuration files.
+This example may be used as a model for writing configuration files, following an
+INI-like syntax. Lines that start with a '#' are considered comments and are thus
+ignored.
 
     [Interface]
 .br

commit ef66ea99e4df861dfc0b8b382d2ca9d57989cd50
Author: Pim van Pelt <pim@ipng.nl>
Date:   Thu Mar 16 23:57:55 2017 +0100

    wg-quick: support old ip(8)
    
    Old versions of ip(8) do not accept arguments to `ip rule show.` This
    patch works around that limitation.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index bb7325c..73cfa25 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -83,13 +83,17 @@ del_if() {
 	DEFAULT_TABLE=0
 	[[ $fwmark != off ]] && DEFAULT_TABLE=$(( $fwmark ))
 	if [[ $DEFAULT_TABLE -ne 0 ]]; then
-		while [[ -n $(ip -4 rule show table $DEFAULT_TABLE) ]]; do
+		while [[ $(ip -4 rule show) == *"lookup $DEFAULT_TABLE"* ]]; do
 			cmd ip -4 rule delete table $DEFAULT_TABLE
-			[[ $(ip -4 rule show table main) == *"from all lookup main suppress_prefixlength 0"* ]] && cmd ip -4 rule delete table main suppress_prefixlength 0
 		done
-		while [[ -n $(ip -6 rule show table $DEFAULT_TABLE) ]]; do
+		while [[ $(ip -4 rule show) == *"from all lookup main suppress_prefixlength 0"* ]]; do
+			cmd ip -4 rule delete table main suppress_prefixlength 0
+		done
+		while [[ $(ip -6 rule show) == *"lookup $DEFAULT_TABLE"* ]]; do
 			cmd ip -6 rule delete table $DEFAULT_TABLE
-			[[ $(ip -6 rule show table main) == *"from all lookup main suppress_prefixlength 0"* ]] && cmd ip -6 rule delete table main suppress_prefixlength 0
+		done
+		while [[ $(ip -6 rule show) == *"from all lookup main suppress_prefixlength 0"* ]]; do
+			cmd ip -6 rule delete table main suppress_prefixlength 0
 		done
 	fi
 	cmd ip link delete dev "$INTERFACE"

commit 89cb1a18a445817caaf40269dfe464825ffb78a9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Feb 23 15:50:05 2017 +0100

    contrib: add wg-json utility
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/json/README b/contrib/json/README
new file mode 100644
index 0000000..dcd128a
--- /dev/null
+++ b/contrib/json/README
@@ -0,0 +1,8 @@
+wg-json
+=======
+
+This will dump all current WireGuard status as JSON output.
+
+Usage:
+
+    # wg-json
diff --git a/contrib/json/wg-json b/contrib/json/wg-json
new file mode 100755
index 0000000..90544e2
--- /dev/null
+++ b/contrib/json/wg-json
@@ -0,0 +1,51 @@
+#!/bin/bash
+
+# Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
+exec < <(exec wg show all dump)
+
+printf '{'
+while read -r -d $'\t' device; do
+	if [[ $device != "$last_device" ]]; then
+		[[ -z $last_device ]] && printf '\n' || printf '%s,\n' "$end"
+		last_device="$device"
+		read -r private_key public_key preshared_key listen_port fwmark
+		printf '\t"%s": {' "$device"
+		delim=$'\n'
+		[[ $private_key == "(none)" ]] || { printf '%s\t\t"privateKey": "%s"' "$delim" "$private_key"; delim=$',\n'; }
+		[[ $public_key == "(none)" ]] || { printf '%s\t\t"publicKey": "%s"' "$delim" "$public_key"; delim=$',\n'; }
+		[[ $preshared_key == "(none)" ]] || { printf '%s\t\t"presharedKey": "%s"' "$delim" "$preshared_key"; delim=$',\n'; }
+		[[ $listen_port == "0" ]] || { printf '%s\t\t"listenPort": %u' "$delim" $(( $listen_port )); delim=$',\n'; }
+		[[ $fwmark == "off" ]] || { printf '%s\t\t"fwmark": %u' "$delim" $(( $fwmark )); delim=$',\n'; }
+		printf '%s\t\t"peers": {' "$delim"; end=$'\n\t\t}\n\t}'
+		delim=$'\n'
+	else
+		read -r public_key endpoint allowed_ips latest_handshake transfer_rx transfer_tx persistent_keepalive
+		printf '%s\t\t\t"%s": {' "$delim" "$public_key"
+		delim=$'\n'
+		[[ $endpoint == "(none)" ]] || { printf '%s\t\t\t\t"endpoint": "%s"' "$delim" "$endpoint"; delim=$',\n'; }
+		[[ $latest_handshake == "0" ]] || { printf '%s\t\t\t\t"latestHandshake": %u' "$delim" $(( $latest_handshake )); delim=$',\n'; }
+		[[ $transfer_rx == "0" ]] || { printf '%s\t\t\t\t"transferRx": %u' "$delim" $(( $transfer_rx )); delim=$',\n'; }
+		[[ $transfer_tx == "0" ]] || { printf '%s\t\t\t\t"transferTx": %u' "$delim" $(( $transfer_tx )); delim=$',\n'; }
+		[[ $persistent_keepalive == "off" ]] || { printf '%s\t\t\t\t"persistentKeepalive": %u' "$delim" $(( $persistent_keepalive )); delim=$',\n'; }
+		printf '%s\t\t\t\t"allowedIps": [' "$delim"
+		delim=$'\n'
+		if [[ $allowed_ips != "(none)" ]]; then
+			old_ifs="$IFS"
+			IFS=,
+			for ip in $allowed_ips; do
+				printf '%s\t\t\t\t\t"%s"' "$delim" "$ip"
+				delim=$',\n'
+			done
+			IFS="$old_ifs"
+			delim=$'\n'
+		fi
+		printf '%s\t\t\t\t]' "$delim"
+		printf '\n\t\t\t}'
+		delim=$',\n'
+	fi
+
+
+done
+printf '%s\n' "$end"
+printf '}\n'

commit aefa5e8edc2d80c9da5d6960032bc122fcb96abb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Feb 23 04:39:06 2017 +0100

    wg: fix bash completion spaces
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/completion/wg-quick.bash-completion b/src/completion/wg-quick.bash-completion
index cf3e9a0..e0bdf9f 100644
--- a/src/completion/wg-quick.bash-completion
+++ b/src/completion/wg-quick.bash-completion
@@ -1,7 +1,7 @@
 # Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_quick_completion() {
-	local i
+	local i a
 	if [[ $COMP_CWORD -eq 1 ]]; then
 		COMPREPLY+=( $(compgen -W "up down" -- "${COMP_WORDS[1]}") )
 		return
@@ -10,10 +10,14 @@ _wg_quick_completion() {
 		shopt -s nullglob
 		for i in /etc/wireguard/*.conf; do
 			i="${i##*/}"; i="${i%.conf}"
-			COMPREPLY+=( $(compgen -W "$i" -- "${COMP_WORDS[2]}") )
+			mapfile -t a < <(compgen -W "$i" -- "${COMP_WORDS[2]}")
+			COMPREPLY+=( "${a[@]}" )
 		done
 		eval "$old_glob"
-		COMPREPLY+=( $(compgen -f -X '!*.conf' -- "${COMP_WORDS[2]}") $(compgen -d -- "${COMP_WORDS[2]}") )
+		mapfile -t a < <(compgen -f -X '!*.conf' -- "${COMP_WORDS[2]}")
+		COMPREPLY+=( "${a[@]}" )
+		mapfile -t a < <(compgen -d -- "${COMP_WORDS[2]}")
+		COMPREPLY+=( "${a[@]}" )
 	fi
 }
 
diff --git a/src/completion/wg.bash-completion b/src/completion/wg.bash-completion
index 1a2e059..355012c 100644
--- a/src/completion/wg.bash-completion
+++ b/src/completion/wg.bash-completion
@@ -1,6 +1,8 @@
 # Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 _wg_completion() {
+	local a
+
 	if [[ $COMP_CWORD -eq 1 ]]; then
 		COMPREPLY+=( $(compgen -W "show showconf set setconf addconf genkey genpsk pubkey" -- "${COMP_WORDS[1]}") )
 		return
@@ -25,7 +27,8 @@ _wg_completion() {
 
 	if [[ $COMP_CWORD -eq 3 && ( ${COMP_WORDS[1]} == setconf || ${COMP_WORDS[1]} == addconf ) ]]; then
 		compopt -o filenames
-		COMPREPLY+=( $(compgen -f -- "${COMP_WORDS[3]}") )
+		mapfile -t a < <(compgen -f -- "${COMP_WORDS[3]}")
+		COMPREPLY+=( "${a[@]}" )
 		return
 	fi
 
@@ -49,7 +52,8 @@ _wg_completion() {
 			COMPREPLY+=( $(compgen -W "${words[*]}" -- "${COMP_WORDS[COMP_CWORD]}") )
 		elif [[ ${COMP_WORDS[COMP_CWORD-1]} == *-key ]]; then
 			compopt -o filenames
-			COMPREPLY+=( $(compgen -f -- "${COMP_WORDS[COMP_CWORD]}") )
+			mapfile -t a < <(compgen -f -- "${COMP_WORDS[COMP_CWORD]}")
+			COMPREPLY+=( "${a[@]}" )
 		fi
 		return
 	fi

commit bda4b8c60b030727c49e291ca575cf6067c720d7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 22 21:53:55 2017 +0100

    wg: add wg show [interface] dump
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/completion/wg.bash-completion b/src/completion/wg.bash-completion
index 8822d01..1a2e059 100644
--- a/src/completion/wg.bash-completion
+++ b/src/completion/wg.bash-completion
@@ -19,7 +19,7 @@ _wg_completion() {
 	fi
 
 	if [[ $COMP_CWORD -eq 3 && ${COMP_WORDS[1]} == show && ${COMP_WORDS[2]} != interfaces ]]; then
-		COMPREPLY+=( $(compgen -W "public-key private-key preshared-key listen-port peers endpoints allowed-ips fwmark latest-handshakes persistent-keepalive transfer" -- "${COMP_WORDS[3]}") )
+		COMPREPLY+=( $(compgen -W "public-key private-key preshared-key listen-port peers endpoints allowed-ips fwmark latest-handshakes persistent-keepalive transfer dump" -- "${COMP_WORDS[3]}") )
 		return
 	fi
 
diff --git a/src/show.c b/src/show.c
index 6cf2b23..7b057cf 100644
--- a/src/show.c
+++ b/src/show.c
@@ -203,7 +203,7 @@ static char *bytes(uint64_t b)
 static const char *COMMAND_NAME = NULL;
 static void show_usage(void)
 {
-	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | fwmark | peers | endpoints | allowed-ips | latest-handshakes | transfer | persistent-keepalive]\n", PROG_NAME, COMMAND_NAME);
+	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | fwmark | peers | endpoints | allowed-ips | latest-handshakes | transfer | persistent-keepalive | dump]\n", PROG_NAME, COMMAND_NAME);
 }
 
 static void pretty_print(struct wgdevice *device)
@@ -252,6 +252,44 @@ static void pretty_print(struct wgdevice *device)
 	}
 }
 
+static void dump_print(struct wgdevice *device, bool with_interface)
+{
+	size_t i, j;
+	struct wgpeer *peer;
+	struct wgipmask *ipmask;
+
+	if (with_interface)
+		printf("%s\t", device->interface);
+	printf("%s\t", key(device->private_key));
+	printf("%s\t", key(device->public_key));
+	printf("%s\t", key(device->preshared_key));
+	printf("%u\t", device->port);
+	if (device->fwmark)
+		printf("0x%x\n", device->fwmark);
+	else
+		printf("off\n");
+	for_each_wgpeer(device, peer, i) {
+		if (with_interface)
+			printf("%s\t", device->interface);
+		printf("%s\t", key(peer->public_key));
+		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
+			printf("%s\t", endpoint(&peer->endpoint.addr));
+		else
+			printf("(none)\t");
+		if (peer->num_ipmasks) {
+			for_each_wgipmask(peer, ipmask, j)
+				printf("%s/%u%c", ip(ipmask), ipmask->cidr, j == (size_t)peer->num_ipmasks - 1 ? '\t' : ',');
+		} else
+			printf("(none)\t");
+		printf("%llu\t", (unsigned long long)peer->last_handshake_time.tv_sec);
+		printf("%" PRIu64 "\t%" PRIu64 "\t", (uint64_t)peer->rx_bytes, (uint64_t)peer->tx_bytes);
+		if (peer->persistent_keepalive_interval)
+			printf("%u\n", peer->persistent_keepalive_interval);
+		else
+			printf("off\n");
+	}
+}
+
 static bool ugly_print(struct wgdevice *device, const char *param, bool with_interface)
 {
 	size_t i, j;
@@ -328,7 +366,9 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 				printf("%s\t", device->interface);
 			printf("%s\n", key(peer->public_key));
 		}
-	} else {
+	} else if (!strcmp(param, "dump"))
+		dump_print(device, with_interface);
+	else {
 		fprintf(stderr, "Invalid parameter: `%s`\n", param);
 		show_usage();
 		return false;
diff --git a/src/wg.8 b/src/wg.8
index 2933761..b9c1f79 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -36,14 +36,20 @@ Sub-commands that take an INTERFACE must be passed a WireGuard interface.
 .SH COMMANDS
 
 .TP
-\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIfwmark\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fItransfer\fP]
+\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIfwmark\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fItransfer\fP | \fIdump\fP]
 Shows current WireGuard configuration of specified \fI<interface>\fP.
 If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
 If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,
 one per line, and quit. If no options are given after the interface
 specification, then prints a list of all attributes in a visually pleasing way
 meant for the terminal. Otherwise, prints specified information grouped by
-newlines and tabs, meant to be used in scripts.
+newlines and tabs, meant to be used in scripts. For this script-friendly display,
+if \fIall\fP is specified, then the first field for all categories of information
+is the interface name. If \fPdump\fP is specified, then several lines are printed;
+the first contains in order separated by tab: private-key, public-key, preshared-key,
+listen-port, fwmark. Subsequent lines are printed for each peer and contain in order
+separated by tab: public-key, endpoint, allowed-ips, latest-handshake, transfer-rx,
+transfer-tx, persistent-keepalive.
 .TP
 \fBshowconf\fP \fI<interface>\fP
 Shows the current configuration of \fI<interface>\fP in the format described

commit d4edc7baa8be10488b681fd329b2480ac6dc7f0e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 22 21:45:03 2017 +0100

    wg: give "off" value for fwmark
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index b3384da..b9a65c1 100644
--- a/src/config.c
+++ b/src/config.c
@@ -97,6 +97,12 @@ static inline bool parse_fwmark(uint32_t *fwmark, unsigned int *flags, const cha
 	char *end;
 	int base = 10;
 
+	if (!strcasecmp(value, "off")) {
+		*fwmark = 0;
+		*flags |= WGDEVICE_REMOVE_FWMARK;
+		return true;
+	}
+
 	if (value[0] == '0' && value[1] == 'x') {
 		value += 2;
 		base = 16;
diff --git a/src/show.c b/src/show.c
index c20d858..6cf2b23 100644
--- a/src/show.c
+++ b/src/show.c
@@ -276,7 +276,10 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 	} else if (!strcmp(param, "fwmark")) {
 		if (with_interface)
 			printf("%s\t", device->interface);
-		printf("0x%x\n", device->fwmark);
+		if (device->fwmark)
+			printf("0x%x\n", device->fwmark);
+		else
+			printf("off\n");
 	} else if (!strcmp(param, "endpoints")) {
 		if (with_interface)
 			printf("%s\t", device->interface);
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index ccf27a9..bb7325c 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -79,7 +79,9 @@ add_if() {
 }
 
 del_if() {
-	DEFAULT_TABLE=$(( $(wg show "$INTERFACE" fwmark) ))
+	local fwmark="$(wg show "$INTERFACE" fwmark)"
+	DEFAULT_TABLE=0
+	[[ $fwmark != off ]] && DEFAULT_TABLE=$(( $fwmark ))
 	if [[ $DEFAULT_TABLE -ne 0 ]]; then
 		while [[ -n $(ip -4 rule show table $DEFAULT_TABLE) ]]; do
 			cmd ip -4 rule delete table $DEFAULT_TABLE
diff --git a/src/wg.8 b/src/wg.8
index 9aa76cf..2933761 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -67,14 +67,16 @@ it adds an additional layer of symmetric-key cryptography to be mixed into
 the already existing public-key cryptography, for post-quantum resistance.
 If \fIallowed-ips\fP is specified, but the value is the empty string, all
 allowed ips are removed from the peer. The use of \fIpersistent-keepalive\fP
-is optional and is by default off; setting it to 0 or "off", disables it.
+is optional and is by default off; setting it to 0 or "off" disables it.
 Otherwise it represents, in seconds, between 1 and 65535 inclusive, how often
 to send an authenticated empty packet to the peer, for the purpose of keeping
 a stateful firewall or NAT mapping valid persistently. For example, if the
 interface very rarely sends traffic, but it might at anytime receive traffic
 from a peer, and it is behind NAT, the interface might benefit from having a
 persistent keepalive interval of 25 seconds; however, most users will not need
-this.
+this. The use of \fIfwmark\fP is optional and is by default off; setting it to
+0 or "off" disables it. Otherwise it is a 32-bit fwmark for outgoing packets
+and may be specified in hexadecimal by prepending "0x".
 .TP
 \fBsetconf\fP \fI<interface>\fP \fI<configuration-filename>\fP
 Sets the current configuration of \fI<interface>\fP to the contents of
@@ -126,7 +128,8 @@ for post-quantum resistance.
 ListenPort \(em a 16-bit port for listening. Optional; if not specified, chosen
 randomly.
 .IP \(bu
-FwMark \(em a 32-bit fwmark for outgoing packets. Optional.
+FwMark \(em a 32-bit fwmark for outgoing packets. If set to 0 or "off", this
+option is disabled. May be specified in hexadecimal by prepending "0x". Optional.
 .P
 The \fIPeer\fP sections may contain the following fields:
 .IP \(bu

commit a9bcd0d4017a168c5c277a6804bad081123b973a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 22 20:23:00 2017 +0100

    wg-quick: allow config files without trailing newline
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 275594e..ccf27a9 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -31,7 +31,7 @@ parse_options() {
 	((($(stat -c '%#a' "$CONFIG_FILE") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
 	INTERFACE="${BASH_REMATCH[1]}"
 	shopt -s nocasematch
-	while read -r line; do
+	while read -r line || [[ -n $line ]]; do
 		key="${line%%=*}"; key="${key##*( )}"; key="${key%%*( )}"
 		value="${line#*=}"; value="${value##*( )}"; value="${value%%*( )}"
 		[[ $key == "["* ]] && interface_section=0

commit b20702bfa344ea308999fa9ff6340b1a7797165e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Feb 20 21:55:44 2017 +0100

    extract-keys: respect compat directives
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/extract-keys/Makefile b/contrib/extract-keys/Makefile
index a1dd7a2..8f5901a 100644
--- a/contrib/extract-keys/Makefile
+++ b/contrib/extract-keys/Makefile
@@ -24,4 +24,8 @@ clean:
 .PHONY: clean
 else
 config-m := config.o
+oldsrc := $(src)
+src := $(src)/../../../src
+include $(src)/compat/Kbuild.include
+src := $(oldsrc)
 endif

commit 6448d5557c1283db905856d670e558182611271e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Feb 14 11:41:56 2017 +0100

    wg-quick: unquote fwmark for bash 4.3
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 00f0eda..275594e 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -79,7 +79,7 @@ add_if() {
 }
 
 del_if() {
-	DEFAULT_TABLE=$(("$(wg show "$INTERFACE" fwmark)"))
+	DEFAULT_TABLE=$(( $(wg show "$INTERFACE" fwmark) ))
 	if [[ $DEFAULT_TABLE -ne 0 ]]; then
 		while [[ -n $(ip -4 rule show table $DEFAULT_TABLE) ]]; do
 			cmd ip -4 rule delete table $DEFAULT_TABLE

commit f60ceb76e60ba30c50c1211621cab1c99af0158e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Feb 5 23:05:12 2017 +0100

    wg-quick: set LC_ALL for consistent regex
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 5db3485..00f0eda 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -5,6 +5,7 @@
 
 set -e -o pipefail
 shopt -s extglob
+export LC_ALL=C
 
 SELF="$(readlink -f "${BASH_SOURCE[0]}")"
 export PATH="${SELF%/*}:$PATH"

commit c8472e2dabc5ee1e9080093fd2252e7987b7f81c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 24 17:43:35 2017 +0100

    socket: enable setting of fwmark
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/completion/wg.bash-completion b/src/completion/wg.bash-completion
index 76a832a..8822d01 100644
--- a/src/completion/wg.bash-completion
+++ b/src/completion/wg.bash-completion
@@ -19,7 +19,7 @@ _wg_completion() {
 	fi
 
 	if [[ $COMP_CWORD -eq 3 && ${COMP_WORDS[1]} == show && ${COMP_WORDS[2]} != interfaces ]]; then
-		COMPREPLY+=( $(compgen -W "public-key private-key preshared-key listen-port peers endpoints allowed-ips latest-handshakes persistent-keepalive transfer" -- "${COMP_WORDS[3]}") )
+		COMPREPLY+=( $(compgen -W "public-key private-key preshared-key listen-port peers endpoints allowed-ips fwmark latest-handshakes persistent-keepalive transfer" -- "${COMP_WORDS[3]}") )
 		return
 	fi
 
@@ -31,9 +31,10 @@ _wg_completion() {
 
 	[[ ${COMP_WORDS[1]} == set ]] || return
 
-	local has_listen_port=0 has_private_key=0 has_preshared_key=0 has_peer=0 has_remove=0 has_endpoint=0 has_persistent_keepalive=0 has_allowed_ips=0 words=() i j
+	local has_listen_port=0 has_fwmark=0 has_private_key=0 has_preshared_key=0 has_peer=0 has_remove=0 has_endpoint=0 has_persistent_keepalive=0 has_allowed_ips=0 words=() i j
 	for ((i=3;i<COMP_CWORD;i+=2)); do
 		[[ ${COMP_WORDS[i]} == listen-port ]] && has_listen_port=1
+		[[ ${COMP_WORDS[i]} == fwmark ]] && has_fwmark=1
 		[[ ${COMP_WORDS[i]} == private-key ]] && has_private_key=1
 		[[ ${COMP_WORDS[i]} == preshared-key ]] && has_preshared_key=1
 		[[ ${COMP_WORDS[i]} == peer ]] && { has_peer=$i; break; }
@@ -41,6 +42,7 @@ _wg_completion() {
 	if [[ $has_peer -eq 0 ]]; then
 		if ((COMP_CWORD % 2 != 0)); then
 			[[ $has_listen_port -eq 1 ]] || words+=( listen-port )
+			[[ $has_fwmark -eq 1 ]] || words+=( fwmark )
 			[[ $has_private_key -eq 1 ]] || words+=( private-key )
 			[[ $has_preshared_key -eq 1 ]] || words+=( preshared-key )
 			words+=( peer )
diff --git a/src/config.c b/src/config.c
index da19cc3..b3384da 100644
--- a/src/config.c
+++ b/src/config.c
@@ -91,6 +91,25 @@ static inline uint16_t parse_port(const char *value)
 	return port;
 }
 
+static inline bool parse_fwmark(uint32_t *fwmark, unsigned int *flags, const char *value)
+{
+	unsigned long ret;
+	char *end;
+	int base = 10;
+
+	if (value[0] == '0' && value[1] == 'x') {
+		value += 2;
+		base = 16;
+	}
+	ret = strtoul(value, &end, base);
+	if (!*value || *end || ret > UINT32_MAX)
+		return false;
+	*fwmark = ret;
+	if (!ret)
+		*flags |= WGDEVICE_REMOVE_FWMARK;
+	return true;
+}
+
 static inline bool parse_key(uint8_t key[static WG_KEY_LEN], const char *value)
 {
 	uint8_t tmp[WG_KEY_LEN + 1];
@@ -281,6 +300,8 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 	if (ctx->is_device_section) {
 		if (key_match("ListenPort"))
 			ret = !!(ctx->buf.dev->port = parse_port(value));
+		else if (key_match("FwMark"))
+			ret = parse_fwmark(&ctx->buf.dev->fwmark, &ctx->buf.dev->flags, value);
 		else if (key_match("PrivateKey")) {
 			ret = parse_key(ctx->buf.dev->private_key, value);
 			if (!ret)
@@ -372,6 +393,8 @@ bool config_read_finish(struct config_ctx *ctx)
 	}
 	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !key_is_valid(ctx->buf.dev->preshared_key))
 		ctx->buf.dev->flags |= WGDEVICE_REMOVE_PRESHARED_KEY;
+	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !ctx->buf.dev->fwmark)
+		ctx->buf.dev->flags |= WGDEVICE_REMOVE_FWMARK;
 
 	for_each_wgpeer(ctx->buf.dev, peer, i) {
 		if (!key_is_valid(peer->public_key)) {
@@ -448,6 +471,11 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 				goto error;
 			argv += 2;
 			argc -= 2;
+		} else if (!strcmp(argv[0], "fwmark") && argc >= 2 && !buf.dev->num_peers) {
+			if (!parse_fwmark(&buf.dev->fwmark, &buf.dev->flags, argv[1]))
+				goto error;
+			argv += 2;
+			argc -= 2;
 		} else if (!strcmp(argv[0], "private-key") && argc >= 2 && !buf.dev->num_peers) {
 			char *line;
 			int ret = read_line(&line, argv[1]);
diff --git a/src/set.c b/src/set.c
index 48b0050..5e4291f 100644
--- a/src/set.c
+++ b/src/set.c
@@ -13,7 +13,7 @@ int set_main(int argc, char *argv[])
 	int ret = 1;
 
 	if (argc < 3) {
-		fprintf(stderr, "Usage: %s %s <interface> [listen-port <port>] [private-key <file path>] [peer <base64 public key> [remove] [endpoint <ip>:<port>] [persistent-keepalive <interval seconds>] [allowed-ips <ip1>/<cidr1>[,<ip2>/<cidr2>]...] ]...\n", PROG_NAME, argv[0]);
+		fprintf(stderr, "Usage: %s %s <interface> [listen-port <port>] [fwmark <mark>] [private-key <file path>] [peer <base64 public key> [remove] [endpoint <ip>:<port>] [persistent-keepalive <interval seconds>] [allowed-ips <ip1>/<cidr1>[,<ip2>/<cidr2>]...] ]...\n", PROG_NAME, argv[0]);
 		return 1;
 	}
 
diff --git a/src/show.c b/src/show.c
index 124e323..c20d858 100644
--- a/src/show.c
+++ b/src/show.c
@@ -203,7 +203,7 @@ static char *bytes(uint64_t b)
 static const char *COMMAND_NAME = NULL;
 static void show_usage(void)
 {
-	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | peers | endpoints | allowed-ips | latest-handshakes | transfer | persistent-keepalive]\n", PROG_NAME, COMMAND_NAME);
+	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | fwmark | peers | endpoints | allowed-ips | latest-handshakes | transfer | persistent-keepalive]\n", PROG_NAME, COMMAND_NAME);
 }
 
 static void pretty_print(struct wgdevice *device)
@@ -222,6 +222,8 @@ static void pretty_print(struct wgdevice *device)
 		terminal_printf("  " TERMINAL_BOLD "pre-shared key" TERMINAL_RESET ": %s\n", masked_key(device->preshared_key));
 	if (device->port)
 		terminal_printf("  " TERMINAL_BOLD "listening port" TERMINAL_RESET ": %u\n", device->port);
+	if (device->fwmark)
+		terminal_printf("  " TERMINAL_BOLD "fwmark" TERMINAL_RESET ": 0x%x\n", device->fwmark);
 	if (device->num_peers) {
 		sort_peers(device);
 		terminal_printf("\n");
@@ -271,6 +273,10 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 		if (with_interface)
 			printf("%s\t", device->interface);
 		printf("%u\n", device->port);
+	} else if (!strcmp(param, "fwmark")) {
+		if (with_interface)
+			printf("%s\t", device->interface);
+		printf("0x%x\n", device->fwmark);
 	} else if (!strcmp(param, "endpoints")) {
 		if (with_interface)
 			printf("%s\t", device->interface);
diff --git a/src/showconf.c b/src/showconf.c
index d2f36e0..585b08d 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -44,7 +44,9 @@ int showconf_main(int argc, char *argv[])
 
 	printf("[Interface]\n");
 	if (device->port)
-		printf("ListenPort = %d\n", device->port);
+		printf("ListenPort = %u\n", device->port);
+	if (device->fwmark)
+		printf("FwMark = 0x%x\n", device->fwmark);
 	if (memcmp(device->private_key, zero, WG_KEY_LEN)) {
 		b64_ntop(device->private_key, WG_KEY_LEN, b64, b64_len(WG_KEY_LEN));
 		printf("PrivateKey = %s\n", b64);
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index 1eb71b2..5db3485 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -78,10 +78,15 @@ add_if() {
 }
 
 del_if() {
-	if [[ $(ip route show table all) =~ .*\ dev\ $INTERFACE\ table\ ([0-9]+)\ .* ]]; then
-		while [[ -n $(ip rule show table ${BASH_REMATCH[1]}) ]]; do
-			cmd ip rule delete table "${BASH_REMATCH[1]}"
-			[[ $(ip rule show table main) == *"from all lookup main suppress_prefixlength 0"* ]] && cmd ip rule delete table main suppress_prefixlength 0
+	DEFAULT_TABLE=$(("$(wg show "$INTERFACE" fwmark)"))
+	if [[ $DEFAULT_TABLE -ne 0 ]]; then
+		while [[ -n $(ip -4 rule show table $DEFAULT_TABLE) ]]; do
+			cmd ip -4 rule delete table $DEFAULT_TABLE
+			[[ $(ip -4 rule show table main) == *"from all lookup main suppress_prefixlength 0"* ]] && cmd ip -4 rule delete table main suppress_prefixlength 0
+		done
+		while [[ -n $(ip -6 rule show table $DEFAULT_TABLE) ]]; do
+			cmd ip -6 rule delete table $DEFAULT_TABLE
+			[[ $(ip -6 rule show table main) == *"from all lookup main suppress_prefixlength 0"* ]] && cmd ip -6 rule delete table main suppress_prefixlength 0
 		done
 	fi
 	cmd ip link delete dev "$INTERFACE"
@@ -104,22 +109,22 @@ add_route() {
 }
 
 DEFAULT_TABLE=
-PREVIOUS_ENDPOINT=
 add_default() {
-	[[ $(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints)) =~ ([A-Za-z0-9/+=]{44})\ ([0-9a-f/.:]+ )*${1//./\\.}\ ([0-9a-f/.:]+ )*\[?([0-9.:a-f]+)\]?:[0-9]+ ]] && local endpoint="${BASH_REMATCH[4]}"
-	[[ -n $endpoint ]] || return 0
-	local first=0
 	if [[ -z $DEFAULT_TABLE ]]; then
-		first=1
 		DEFAULT_TABLE=51820
 		while [[ -n $(ip route show table $DEFAULT_TABLE) ]]; do ((DEFAULT_TABLE++)); done
 	fi
-	cmd ip route add "$1" dev "$INTERFACE" table $DEFAULT_TABLE
-	[[ $PREVIOUS_ENDPOINT == "$endpoint" ]] && return 0
-	PREVIOUS_ENDPOINT="$endpoint"
-	cmd ip rule add not to "$endpoint" table $DEFAULT_TABLE
-	[[ $first -eq 1 ]] || return 0
-	cmd ip rule add table main suppress_prefixlength 0
+	local proto=-4
+	[[ $1 == *:* ]] && proto=-6
+	cmd wg set "$INTERFACE" fwmark $DEFAULT_TABLE
+	cmd ip $proto route add "$1" dev "$INTERFACE" table $DEFAULT_TABLE
+	cmd ip $proto rule add not fwmark $DEFAULT_TABLE table $DEFAULT_TABLE
+	cmd ip $proto rule add table main suppress_prefixlength 0
+	local key equals value
+	while read -r key equals value; do
+		[[ $value -eq 1 ]] && sysctl -q "$key=2"
+	done < <(sysctl -a -r 'net\.ipv4.conf\..+\.rp_filter')
+	return 0
 }
 
 set_config() {
diff --git a/src/wg.8 b/src/wg.8
index be05acf..9aa76cf 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -36,7 +36,7 @@ Sub-commands that take an INTERFACE must be passed a WireGuard interface.
 .SH COMMANDS
 
 .TP
-\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fItransfer\fP]
+\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIfwmark\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fItransfer\fP]
 Shows current WireGuard configuration of specified \fI<interface>\fP.
 If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
 If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,
@@ -49,7 +49,7 @@ newlines and tabs, meant to be used in scripts.
 Shows the current configuration of \fI<interface>\fP in the format described
 by \fICONFIGURATION FILE FORMAT\fP below.
 .TP
-\fBset\fP \fI<interface>\fP [\fIlisten-port\fP \fI<port>\fP] [\fIprivate-key\fP \fI<file-path>\fP] [\fIpreshared-key\fP \fI<file-path>\fP] [\fIpeer\fP \fI<base64-public-key>\fP [\fIremove\fP] [\fIendpoint\fP \fI<ip>:<port>\fP] [\fIpersistent-keepalive\fP \fI<interval seconds>\fP] [\fIallowed-ips\fP \fI<ip1>/<cidr1>\fP[,\fI<ip2>/<cidr2>\fP]...] ]...
+\fBset\fP \fI<interface>\fP [\fIlisten-port\fP \fI<port>\fP] [\fIfwmark\fP \fI<fwmark>\fP] [\fIprivate-key\fP \fI<file-path>\fP] [\fIpreshared-key\fP \fI<file-path>\fP] [\fIpeer\fP \fI<base64-public-key>\fP [\fIremove\fP] [\fIendpoint\fP \fI<ip>:<port>\fP] [\fIpersistent-keepalive\fP \fI<interval seconds>\fP] [\fIallowed-ips\fP \fI<ip1>/<cidr1>\fP[,\fI<ip2>/<cidr2>\fP]...] ]...
 Sets configuration values for the specified \fI<interface>\fP. Multiple
 \fIpeer\fPs may be specified, and if the \fIremove\fP argument is given
 for a peer, that peer is removed, not configured. If \fIlisten-port\fP
@@ -125,6 +125,8 @@ for post-quantum resistance.
 .IP \(bu
 ListenPort \(em a 16-bit port for listening. Optional; if not specified, chosen
 randomly.
+.IP \(bu
+FwMark \(em a 32-bit fwmark for outgoing packets. Optional.
 .P
 The \fIPeer\fP sections may contain the following fields:
 .IP \(bu

commit ef29165cde75becac0966506962746d26d3efe17
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 24 05:59:17 2017 +0100

    socket: general ephemeral ports instead of name-based ports
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg.8 b/src/wg.8
index 2ec005c..be05acf 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -53,7 +53,7 @@ by \fICONFIGURATION FILE FORMAT\fP below.
 Sets configuration values for the specified \fI<interface>\fP. Multiple
 \fIpeer\fPs may be specified, and if the \fIremove\fP argument is given
 for a peer, that peer is removed, not configured. If \fIlisten-port\fP
-is not specified, the port will be automatically generated when the
+is not specified, the port will be chosen randomly when the
 interface comes up. Both \fIprivate-key\fP and \fIpreshared-key\fP must
 be a files, because command line arguments are not considered private on
 most systems but if you are using
@@ -123,8 +123,8 @@ and may be omitted. This option adds an additional layer of symmetric-key
 cryptography to be mixed into the already existing public-key cryptography,
 for post-quantum resistance.
 .IP \(bu
-ListenPort \(em a 16-bit port for listening. Optional; if not specified,
-automatically generated based on interface name.
+ListenPort \(em a 16-bit port for listening. Optional; if not specified, chosen
+randomly.
 .P
 The \fIPeer\fP sections may contain the following fields:
 .IP \(bu

commit cf2cb85a0878d617982566267045170d5120ed6a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 24 05:28:03 2017 +0100

    wg-quick: support v6 dual stack
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index b6fcef8..1eb71b2 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -79,8 +79,10 @@ add_if() {
 
 del_if() {
 	if [[ $(ip route show table all) =~ .*\ dev\ $INTERFACE\ table\ ([0-9]+)\ .* ]]; then
-		cmd ip rule delete table "${BASH_REMATCH[1]}"
-		[[ $(ip rule show table main) == *"from all lookup main suppress_prefixlength 0"* ]] && cmd ip rule delete table main suppress_prefixlength 0
+		while [[ -n $(ip rule show table ${BASH_REMATCH[1]}) ]]; do
+			cmd ip rule delete table "${BASH_REMATCH[1]}"
+			[[ $(ip rule show table main) == *"from all lookup main suppress_prefixlength 0"* ]] && cmd ip rule delete table main suppress_prefixlength 0
+		done
 	fi
 	cmd ip link delete dev "$INTERFACE"
 }
@@ -101,13 +103,22 @@ add_route() {
 	fi
 }
 
+DEFAULT_TABLE=
+PREVIOUS_ENDPOINT=
 add_default() {
-	[[ $(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints)) =~ .*\ ${1//./\\.}\ \[?([0-9.:a-f]+)\]?:[0-9]+$ ]] && local endpoint="${BASH_REMATCH[1]}"
+	[[ $(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints)) =~ ([A-Za-z0-9/+=]{44})\ ([0-9a-f/.:]+ )*${1//./\\.}\ ([0-9a-f/.:]+ )*\[?([0-9.:a-f]+)\]?:[0-9]+ ]] && local endpoint="${BASH_REMATCH[4]}"
 	[[ -n $endpoint ]] || return 0
-	local table=51820
-	while [[ -n $(ip route show table $table) ]]; do ((table++)); done
-	cmd ip route add "$1" dev "$INTERFACE" table $table
-	cmd ip rule add not to "$endpoint" table $table
+	local first=0
+	if [[ -z $DEFAULT_TABLE ]]; then
+		first=1
+		DEFAULT_TABLE=51820
+		while [[ -n $(ip route show table $DEFAULT_TABLE) ]]; do ((DEFAULT_TABLE++)); done
+	fi
+	cmd ip route add "$1" dev "$INTERFACE" table $DEFAULT_TABLE
+	[[ $PREVIOUS_ENDPOINT == "$endpoint" ]] && return 0
+	PREVIOUS_ENDPOINT="$endpoint"
+	cmd ip rule add not to "$endpoint" table $DEFAULT_TABLE
+	[[ $first -eq 1 ]] || return 0
 	cmd ip rule add table main suppress_prefixlength 0
 }
 

commit 3606898d231c7766e8271981e9d3d52310a6a43f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 24 04:20:05 2017 +0100

    wg: remove key for any empty file
    
    Rather than just using /dev/null to mean key removal, match on any empty
    file, so that this interface is cross platform.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index e6db6ad..da19cc3 100644
--- a/src/config.c
+++ b/src/config.c
@@ -390,7 +390,6 @@ static int read_line(char **dst, const char *path)
 {
 	FILE *f;
 	size_t n = 0;
-	struct stat stat;
 
 	*dst = NULL;
 
@@ -399,22 +398,15 @@ static int read_line(char **dst, const char *path)
 		perror("fopen");
 		return -1;
 	}
-	if (fstat(fileno(f), &stat) < 0) {
-		perror("fstat");
-		fclose(f);
-		return -1;
-	}
-	if (S_ISCHR(stat.st_mode) && stat.st_rdev == makedev(1, 3)) {
-		fclose(f);
-		return 1;
-	}
-	if (getline(dst, &n, f) < 0) {
+	if (getline(dst, &n, f) < 0 && errno) {
 		perror("getline");
 		fclose(f);
 		return -1;
 	}
 	fclose(f);
 	n = strlen(*dst);
+	if (!n)
+		return 1;
 	while (--n) {
 		if (isspace((*dst)[n]))
 			(*dst)[n] = '\0';
diff --git a/src/wg.8 b/src/wg.8
index 54ae378..2ec005c 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -60,20 +60,21 @@ most systems but if you are using
 .BR bash (1),
 you may safely pass in a string by specifying as \fIprivate-key\fP or
 \fIpreshared-key\fP the expression: <(echo PRIVATEKEYSTRING). If
-\fI/dev/null\fP is specified as the filename for either \fIprivate-key\fP or
-\fIpreshared-key\fP, the key is removed from the device. The use of
-\fIpreshared-key\fP is optional, and may be omitted; it adds an additional
-layer of symmetric-key cryptography to be mixed into the already existing
-public-key cryptography, for post-quantum resistance. If \fIallowed-ips\fP
-is specified, but the value is the empty string, all allowed ips are removed
-from the peer. The use of \fIpersistent-keepalive\fP is optional and is by
-default off; setting it to 0 or "off", disables it. Otherwise it represents,
-in seconds, between 1 and 65535 inclusive, how often to send an authenticated
-empty packet to the peer, for the purpose of keeping a stateful firewall or NAT
-mapping valid persistently. For example, if the interface very rarely sends
-traffic, but it might at anytime receive traffic from a peer, and it is behind
-NAT, the interface might benefit from having a persistent keepalive interval
-of 25 seconds; however, most users will not need this.
+\fI/dev/null\fP or another empty file is specified as the filename for
+either \fIprivate-key\fP or \fIpreshared-key\fP, the key is removed from
+the device. The use of \fIpreshared-key\fP is optional, and may be omitted;
+it adds an additional layer of symmetric-key cryptography to be mixed into
+the already existing public-key cryptography, for post-quantum resistance.
+If \fIallowed-ips\fP is specified, but the value is the empty string, all
+allowed ips are removed from the peer. The use of \fIpersistent-keepalive\fP
+is optional and is by default off; setting it to 0 or "off", disables it.
+Otherwise it represents, in seconds, between 1 and 65535 inclusive, how often
+to send an authenticated empty packet to the peer, for the purpose of keeping
+a stateful firewall or NAT mapping valid persistently. For example, if the
+interface very rarely sends traffic, but it might at anytime receive traffic
+from a peer, and it is behind NAT, the interface might benefit from having a
+persistent keepalive interval of 25 seconds; however, most users will not need
+this.
 .TP
 \fBsetconf\fP \fI<interface>\fP \fI<configuration-filename>\fP
 Sets the current configuration of \fI<interface>\fP to the contents of

commit 666623a82e32f82e9c165bffc691a21b4d47e739
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 24 04:11:56 2017 +0100

    wg: setconf should remove existing psk
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index ddeec15..e6db6ad 100644
--- a/src/config.c
+++ b/src/config.c
@@ -370,6 +370,9 @@ bool config_read_finish(struct config_ctx *ctx)
 		fprintf(stderr, "No private key configured\n");
 		goto err;
 	}
+	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !key_is_valid(ctx->buf.dev->preshared_key))
+		ctx->buf.dev->flags |= WGDEVICE_REMOVE_PRESHARED_KEY;
+
 	for_each_wgpeer(ctx->buf.dev, peer, i) {
 		if (!key_is_valid(peer->public_key)) {
 			fprintf(stderr, "A peer is missing a public key\n");

commit 4586e1474918185718457bcdd784f57e4dc60fc1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 19 00:07:31 2017 +0100

    wg-quick: recommend using resolvconf in exclusive mode
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index 37bbccc..40c6650 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -94,7 +94,7 @@ traffic:
 .br
     \fBAddress = 10.200.100.8/24\fP
 .br
-    \fBPostUp = echo nameserver 10.200.100.1 | resolvconf -a %i -m 0\fP
+    \fBPostUp = echo nameserver 10.200.100.1 | resolvconf -a %i -m 0 -x\fP
 .br
     \fBPostDown = resolvconf -d %i\fP
 .br

commit db4f06d1180645972a75f94de41e4a87e198313d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jan 15 22:22:45 2017 +0100

    wg: man: recommend correct port
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.8 b/src/wg-quick.8
index 2425926..37bbccc 100644
--- a/src/wg-quick.8
+++ b/src/wg-quick.8
@@ -132,7 +132,7 @@ Here is a more complicated example, fit for usage on a server:
 .br
     PrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk= 
 .br
-    ListenPort = 41414 
+    ListenPort = 51820 
 .br
      
 .br
diff --git a/src/wg.8 b/src/wg.8
index 9322509..54ae378 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -158,7 +158,7 @@ This example may be used as a model for writing configuration files.
 .br
     PrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=
 .br
-    ListenPort = 41414
+    ListenPort = 51820
 .br
     
 .br

commit 1d2091289893f6411a599184b5c36d023e6c8540
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jan 15 13:01:06 2017 +0100

    wg-quick: parse IPv6 endpoints correctly
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index d611a83..b6fcef8 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -102,7 +102,7 @@ add_route() {
 }
 
 add_default() {
-	[[ $(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints)) =~ .*\ ${1//./\\.}\ ([0-9.:a-f]+):[0-9]+$ ]] && local endpoint="${BASH_REMATCH[1]}"
+	[[ $(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints)) =~ .*\ ${1//./\\.}\ \[?([0-9.:a-f]+)\]?:[0-9]+$ ]] && local endpoint="${BASH_REMATCH[1]}"
 	[[ -n $endpoint ]] || return 0
 	local table=51820
 	while [[ -n $(ip route show table $table) ]]; do ((table++)); done

commit 035a6496417a0981b7511884daa7ff8ee64030c4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 11 00:29:58 2017 +0100

    wg-quick: better removal of suppress_prefix rule
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index baedd35..d611a83 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -80,7 +80,7 @@ add_if() {
 del_if() {
 	if [[ $(ip route show table all) =~ .*\ dev\ $INTERFACE\ table\ ([0-9]+)\ .* ]]; then
 		cmd ip rule delete table "${BASH_REMATCH[1]}"
-		cmd ip rule delete table main suppress_prefixlength 0 2>/dev/null
+		[[ $(ip rule show table main) == *"from all lookup main suppress_prefixlength 0"* ]] && cmd ip rule delete table main suppress_prefixlength 0
 	fi
 	cmd ip link delete dev "$INTERFACE"
 }

commit 396dc76a04508ca23f955f1dbd0b305d854149c2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 10 06:36:19 2017 +0100

    Update copyright
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 0f65ec4..11c2f86 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 package main
 
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index c75cded..232375c 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 extern crate screech;
 extern crate crypto;
diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index 4c0e9b4..abd435f 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 struct def {
 	const char *name;
diff --git a/contrib/extract-keys/extract-keys.c b/contrib/extract-keys/extract-keys.c
index 335f962..8a5f24e 100644
--- a/contrib/extract-keys/extract-keys.c
+++ b/contrib/extract-keys/extract-keys.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <endian.h>
 #include <errno.h>
diff --git a/contrib/nat-hole-punching/nat-punch-client.c b/contrib/nat-hole-punching/nat-punch-client.c
index 6d0b5f1..65f3249 100644
--- a/contrib/nat-hole-punching/nat-punch-client.c
+++ b/contrib/nat-hole-punching/nat-punch-client.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 /* Example only. Do not run in production. */
 
diff --git a/contrib/nat-hole-punching/nat-punch-server.c b/contrib/nat-hole-punching/nat-punch-server.c
index 425885e..ab5ddd7 100644
--- a/contrib/nat-hole-punching/nat-punch-server.c
+++ b/contrib/nat-hole-punching/nat-punch-server.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 /* Example only. Do not run in production. */
 
diff --git a/contrib/ncat-client-server/client.sh b/contrib/ncat-client-server/client.sh
index e59d9ce..b49a05e 100755
--- a/contrib/ncat-client-server/client.sh
+++ b/contrib/ncat-client-server/client.sh
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-# Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -e
 [[ $UID == 0 ]] || { echo "You must be root to run this."; exit 1; }
diff --git a/contrib/ncat-client-server/server.sh b/contrib/ncat-client-server/server.sh
index bb45718..b527cf5 100755
--- a/contrib/ncat-client-server/server.sh
+++ b/contrib/ncat-client-server/server.sh
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-# Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 if [[ -z $NCAT_REMOTE_ADDR ]]; then
 	ip link del dev wg0 2>/dev/null
diff --git a/contrib/synergy/synergy-client.sh b/contrib/synergy/synergy-client.sh
index 07b32d3..ee8727a 100755
--- a/contrib/synergy/synergy-client.sh
+++ b/contrib/synergy/synergy-client.sh
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-# Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
 if [[ $UID == 0 ]]; then
diff --git a/contrib/synergy/synergy-server.sh b/contrib/synergy/synergy-server.sh
index ac028ba..2832164 100755
--- a/contrib/synergy/synergy-server.sh
+++ b/contrib/synergy/synergy-server.sh
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-# Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 
 set -ex
 if [[ $UID == 0 ]]; then
diff --git a/src/base64.h b/src/base64.h
index 748b5d9..4ad0ac3 100644
--- a/src/base64.h
+++ b/src/base64.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef BASE64_H
 #define BASE64_H
diff --git a/src/config.c b/src/config.c
index 83c7db1..ddeec15 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 
 #include <arpa/inet.h>
diff --git a/src/config.h b/src/config.h
index 9338c72..5f7761f 100644
--- a/src/config.h
+++ b/src/config.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef CONFIG_H
 #define CONFIG_H
diff --git a/src/curve25519.c b/src/curve25519.c
index 3c147c8..29a4531 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -1,7 +1,7 @@
 /* Original author: Adam Langley <agl@imperialviolet.org>
  *
  * Copyright 2008 Google Inc. All Rights Reserved.
- * Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  *   Redistribution and use in source and binary forms of this file, with or
  *   without modification, are permitted provided that the following conditions
diff --git a/src/curve25519.h b/src/curve25519.h
index 45ae1ce..6e651e9 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef CURVE25519_H
 #define CURVE25519_H
diff --git a/src/genkey.c b/src/genkey.c
index 0bdcfbb..d3bc846 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <errno.h>
 #include <stdio.h>
diff --git a/src/ipc.c b/src/ipc.c
index 05609b4..a926261 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifdef __linux__
 #include <libmnl/libmnl.h>
diff --git a/src/ipc.h b/src/ipc.h
index 9571ff9..2412610 100644
--- a/src/ipc.h
+++ b/src/ipc.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef IPC_H
 #define IPC_H
diff --git a/src/pubkey.c b/src/pubkey.c
index d61df03..f567223 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <errno.h>
 #include <resolv.h>
diff --git a/src/set.c b/src/set.c
index 236504b..48b0050 100644
--- a/src/set.c
+++ b/src/set.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/src/setconf.c b/src/setconf.c
index 4de6117..c70edab 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <stddef.h>
 #include <stdio.h>
diff --git a/src/show.c b/src/show.c
index 04a634c..124e323 100644
--- a/src/show.c
+++ b/src/show.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <arpa/inet.h>
 #include <inttypes.h>
diff --git a/src/showconf.c b/src/showconf.c
index fe811e6..d2f36e0 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <arpa/inet.h>
 #include <netinet/in.h>
diff --git a/src/subcommands.h b/src/subcommands.h
index 5da0226..7bbf70a 100644
--- a/src/subcommands.h
+++ b/src/subcommands.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef SUBCOMMANDS_H
 #define SUBCOMMANDS_H
diff --git a/src/terminal.c b/src/terminal.c
index 139cc71..862bb4a 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #define _GNU_SOURCE
 #include <ctype.h>
diff --git a/src/terminal.h b/src/terminal.h
index ee03f8d..2c1fb37 100644
--- a/src/terminal.h
+++ b/src/terminal.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef TERMINAL_H
 #define TERMINAL_H
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index c9157ad..baedd35 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -1,6 +1,6 @@
 #!/bin/bash
 #
-# Copyright (c) 2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+# Copyright (C) 2016-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
 #
 
 set -e -o pipefail
diff --git a/src/wg.c b/src/wg.c
index 616107e..0ec64eb 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <stddef.h>
 #include <stdio.h>

commit f43b43376be6a400a0a7f5e8ec71f5d938befeef
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 10 05:52:06 2017 +0100

    uapi: use sockaddr union instead of sockaddr_storage
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index f326389..83c7db1 100644
--- a/src/config.c
+++ b/src/config.c
@@ -119,7 +119,7 @@ static inline bool parse_ip(struct wgipmask *ipmask, const char *value)
 	return true;
 }
 
-static inline bool parse_endpoint(struct sockaddr_storage *endpoint, const char *value)
+static inline bool parse_endpoint(struct sockaddr *endpoint, const char *value)
 {
 	char *mutable = strdup(value);
 	char *begin, *end;
@@ -293,7 +293,7 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 			goto error;
 	} else if (ctx->is_peer_section) {
 		if (key_match("Endpoint"))
-			ret = parse_endpoint(&peer_from_offset(ctx->buf.dev, ctx->peer_offset)->endpoint, value);
+			ret = parse_endpoint(&peer_from_offset(ctx->buf.dev, ctx->peer_offset)->endpoint.addr, value);
 		else if (key_match("PublicKey"))
 			ret = parse_key(peer_from_offset(ctx->buf.dev, ctx->peer_offset)->public_key, value);
 		else if (key_match("AllowedIPs"))
@@ -500,7 +500,7 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 			argv += 1;
 			argc -= 1;
 		} else if (!strcmp(argv[0], "endpoint") && argc >= 2 && buf.dev->num_peers) {
-			if (!parse_endpoint(&peer_from_offset(buf.dev, peer_offset)->endpoint, argv[1]))
+			if (!parse_endpoint(&peer_from_offset(buf.dev, peer_offset)->endpoint.addr, argv[1]))
 				goto error;
 			argv += 2;
 			argc -= 2;
diff --git a/src/show.c b/src/show.c
index 5257d43..04a634c 100644
--- a/src/show.c
+++ b/src/show.c
@@ -107,7 +107,7 @@ static char *ip(const struct wgipmask *ip)
 	return buf;
 }
 
-static char *endpoint(const struct sockaddr_storage *addr)
+static char *endpoint(const struct sockaddr *addr)
 {
 	char host[4096 + 1];
 	char service[512 + 1];
@@ -116,16 +116,16 @@ static char *endpoint(const struct sockaddr_storage *addr)
 	socklen_t addr_len = 0;
 
 	memset(buf, 0, sizeof(buf));
-	if (addr->ss_family == AF_INET)
+	if (addr->sa_family == AF_INET)
 		addr_len = sizeof(struct sockaddr_in);
-	else if (addr->ss_family == AF_INET6)
+	else if (addr->sa_family == AF_INET6)
 		addr_len = sizeof(struct sockaddr_in6);
 
-	ret = getnameinfo((struct sockaddr *)addr, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST);
+	ret = getnameinfo(addr, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST);
 	if (ret)
 		strncpy(buf, gai_strerror(ret), sizeof(buf) - 1);
 	else
-		snprintf(buf, sizeof(buf) - 1, (addr->ss_family == AF_INET6 && strchr(host, ':')) ? "[%s]:%s" : "%s:%s", host, service);
+		snprintf(buf, sizeof(buf) - 1, (addr->sa_family == AF_INET6 && strchr(host, ':')) ? "[%s]:%s" : "%s:%s", host, service);
 	return buf;
 }
 
@@ -228,8 +228,8 @@ static void pretty_print(struct wgdevice *device)
 	}
 	for_each_wgpeer(device, peer, i) {
 		terminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD "peer" TERMINAL_RESET ": " TERMINAL_FG_YELLOW "%s" TERMINAL_RESET "\n", key(peer->public_key));
-		if (peer->endpoint.ss_family == AF_INET || peer->endpoint.ss_family == AF_INET6)
-			terminal_printf("  " TERMINAL_BOLD "endpoint" TERMINAL_RESET ": %s\n", endpoint(&peer->endpoint));
+		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
+			terminal_printf("  " TERMINAL_BOLD "endpoint" TERMINAL_RESET ": %s\n", endpoint(&peer->endpoint.addr));
 		terminal_printf("  " TERMINAL_BOLD "allowed ips" TERMINAL_RESET ": ");
 		if (peer->num_ipmasks) {
 			for_each_wgipmask(peer, ipmask, j)
@@ -276,8 +276,8 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 			printf("%s\t", device->interface);
 		for_each_wgpeer(device, peer, i) {
 			printf("%s\t", key(peer->public_key));
-			if (peer->endpoint.ss_family == AF_INET || peer->endpoint.ss_family == AF_INET6)
-				printf("%s\n", endpoint(&peer->endpoint));
+			if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6)
+				printf("%s\n", endpoint(&peer->endpoint.addr));
 			else
 				printf("(none)\n");
 		}
diff --git a/src/showconf.c b/src/showconf.c
index f04caa1..fe811e6 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -75,18 +75,18 @@ int showconf_main(int argc, char *argv[])
 		if (peer->num_ipmasks)
 			printf("\n");
 
-		if (peer->endpoint.ss_family == AF_INET || peer->endpoint.ss_family == AF_INET6) {
+		if (peer->endpoint.addr.sa_family == AF_INET || peer->endpoint.addr.sa_family == AF_INET6) {
 			char host[4096 + 1];
 			char service[512 + 1];
 			static char buf[sizeof(host) + sizeof(service) + 4];
 			socklen_t addr_len = 0;
 			memset(buf, 0, sizeof(buf));
-			if (peer->endpoint.ss_family == AF_INET)
+			if (peer->endpoint.addr.sa_family == AF_INET)
 				addr_len = sizeof(struct sockaddr_in);
-			else if (peer->endpoint.ss_family == AF_INET6)
+			else if (peer->endpoint.addr.sa_family == AF_INET6)
 				addr_len = sizeof(struct sockaddr_in6);
-			if (!getnameinfo((struct sockaddr *)&peer->endpoint, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST)) {
-				snprintf(buf, sizeof(buf) - 1, (peer->endpoint.ss_family == AF_INET6 && strchr(host, ':')) ? "[%s]:%s" : "%s:%s", host, service);
+			if (!getnameinfo(&peer->endpoint.addr, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST)) {
+				snprintf(buf, sizeof(buf) - 1, (peer->endpoint.addr.sa_family == AF_INET6 && strchr(host, ':')) ? "[%s]:%s" : "%s:%s", host, service);
 				printf("Endpoint = %s\n", buf);
 			}
 		}

commit 48f7c3522ad47876c481dd39f4fd8f4547dd922b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jan 9 19:47:29 2017 -0800

    uapi: use flag instead of C bitfield for portability
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 50bc97c..f326389 100644
--- a/src/config.c
+++ b/src/config.c
@@ -213,7 +213,7 @@ static inline bool parse_ipmasks(struct inflatable_device *buf, size_t peer_offs
 		return false;
 	};
 	peer = peer_from_offset(buf->dev, peer_offset);
-	peer->replace_ipmasks = true;
+	peer->flags |= WGPEER_REPLACE_IPMASKS;
 	if (!strlen(value)) {
 		free(mutable);
 		return true;
@@ -271,7 +271,7 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 		++ctx->buf.dev->num_peers;
 		ctx->is_peer_section = true;
 		ctx->is_device_section = false;
-		peer_from_offset(ctx->buf.dev, ctx->peer_offset)->replace_ipmasks = true;
+		peer_from_offset(ctx->buf.dev, ctx->peer_offset)->flags |= WGPEER_REPLACE_IPMASKS;
 		peer_from_offset(ctx->buf.dev, ctx->peer_offset)->persistent_keepalive_interval = (__u16)-1;
 		return true;
 	}
@@ -347,7 +347,8 @@ bool config_read_init(struct config_ctx *ctx, struct wgdevice **device, bool app
 		perror("calloc");
 		return false;
 	}
-	ctx->buf.dev->replace_peer_list = !append;
+	if (!append)
+		ctx->buf.dev->flags |= WGDEVICE_REPLACE_PEERS;
 	return true;
 }
 
@@ -361,11 +362,11 @@ bool config_read_finish(struct config_ctx *ctx)
 {
 	size_t i;
 	struct wgpeer *peer;
-	if (ctx->buf.dev->replace_peer_list && !ctx->buf.dev->num_peers) {
+	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !ctx->buf.dev->num_peers) {
 		fprintf(stderr, "No peers configured\n");
 		goto err;
 	}
-	if (ctx->buf.dev->replace_peer_list && !key_is_valid(ctx->buf.dev->private_key)) {
+	if (ctx->buf.dev->flags & WGDEVICE_REPLACE_PEERS && !key_is_valid(ctx->buf.dev->private_key)) {
 		fprintf(stderr, "No private key configured\n");
 		goto err;
 	}
@@ -462,7 +463,7 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 				}
 				free(line);
 			} else if (ret == 1)
-				buf.dev->remove_private_key = true;
+				buf.dev->flags |= WGDEVICE_REMOVE_PRIVATE_KEY;
 			else
 				goto error;
 			argv += 2;
@@ -477,7 +478,7 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 				}
 				free(line);
 			} else if (ret == 1)
-				buf.dev->remove_preshared_key = true;
+				buf.dev->flags |= WGDEVICE_REMOVE_PRESHARED_KEY;
 			else
 				goto error;
 			argv += 2;
@@ -495,7 +496,7 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 			argv += 2;
 			argc -= 2;
 		} else if (!strcmp(argv[0], "remove") && argc >= 1 && buf.dev->num_peers) {
-			peer_from_offset(buf.dev, peer_offset)->remove_me = true;
+			peer_from_offset(buf.dev, peer_offset)->flags |= WGPEER_REMOVE_ME;
 			argv += 1;
 			argc -= 1;
 		} else if (!strcmp(argv[0], "endpoint") && argc >= 2 && buf.dev->num_peers) {

commit 12904a109514fcb9c02ceb2f1cf1e8abce4c936a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 10 04:50:42 2017 +0100

    wg: ipc: read from socket incrementally
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index fee7951..6502c3d 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -33,7 +33,7 @@ endif
 
 CFLAGS ?= -O3
 CFLAGS += -std=gnu11
-CFLAGS += -pedantic -Wall -Wextra
+CFLAGS += -Wall -Wextra
 CFLAGS += -MMD -MP
 CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
 LDLIBS += -lresolv
diff --git a/src/ipc.c b/src/ipc.c
index 6237961..05609b4 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -18,7 +18,6 @@
 #include <unistd.h>
 #include <time.h>
 #include <dirent.h>
-#include <poll.h>
 #include <signal.h>
 #include <sys/socket.h>
 #include <sys/types.h>
@@ -41,7 +40,7 @@ struct inflatable_buffer {
 	size_t pos;
 };
 
-#define max(a, b) (a > b ? a : b)
+#define max(a, b) ((a) > (b) ? (a) : (b))
 
 static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 {
@@ -190,68 +189,75 @@ out:
 	return (int)ret;
 }
 
+#define READ_BYTES(bytes) ({ \
+	void *__p; \
+	size_t __bytes = (bytes); \
+	if (bytes_left < __bytes) { \
+		offset = p - buffer; \
+		bytes_left += buffer_size; \
+		buffer_size *= 2; \
+		ret = -ENOMEM; \
+		p = realloc(buffer, buffer_size); \
+		if (!p) \
+			goto out; \
+		buffer = p; \
+		p += offset; \
+	} \
+	bytes_left -= __bytes; \
+	ret = read(fd, p, __bytes); \
+	if (ret < 0) \
+		goto out; \
+	if ((size_t)ret != __bytes) { \
+		ret = -EBADMSG; \
+		goto out; \
+	} \
+	__p = p; \
+	p += __bytes; \
+	__p; \
+})
 static int userspace_get_device(struct wgdevice **dev, const char *interface)
 {
-	struct pollfd pollfd = { .events = POLLIN };
-	int len;
-	char byte = 0;
-	size_t i;
-	struct wgpeer *peer;
+	unsigned int len = 0, i;
+	size_t buffer_size, bytes_left;
 	ssize_t ret;
+	ptrdiff_t offset;
+	uint8_t *buffer = NULL, *p, byte = 0;
+
 	int fd = userspace_interface_fd(interface);
 	if (fd < 0)
 		return fd;
-	*dev = NULL;
+
 	ret = write(fd, &byte, sizeof(byte));
 	if (ret < 0)
 		goto out;
-
-	pollfd.fd = fd;
-	if (poll(&pollfd, 1, -1) < 0)
-		goto out;
-	ret = -ECONNABORTED;
-	if (!(pollfd.revents & POLLIN))
-		goto out;
-
-	ret = ioctl(fd, FIONREAD, &len);
-	if (ret < 0) {
-		ret = -errno;
+	if (ret != sizeof(byte)) {
+		ret = -EBADMSG;
 		goto out;
 	}
-	ret = -EBADMSG;
-	if ((size_t)len < sizeof(struct wgdevice))
-		goto out;
 
+	ioctl(fd, FIONREAD, &len);
+	bytes_left = buffer_size = max(len, sizeof(struct wgdevice) + sizeof(struct wgpeer) + sizeof(struct wgipmask));
+	p = buffer = malloc(buffer_size);
 	ret = -ENOMEM;
-	*dev = malloc(len);
-	if (!*dev)
+	if (!buffer)
 		goto out;
 
-	ret = read(fd, *dev, len);
-	if (ret < 0)
-		goto out;
-	if (ret != len) {
-		ret = -EBADMSG;
-		goto out;
-	}
-
-	ret = -EBADMSG;
-	for_each_wgpeer(*dev, peer, i) {
-		if ((uint8_t *)peer + sizeof(struct wgpeer) > (uint8_t *)*dev + len)
-			goto out;
-		if ((uint8_t *)peer + sizeof(struct wgpeer) + sizeof(struct wgipmask) * peer->num_ipmasks > (uint8_t *)*dev + len)
-		goto out;
-	}
+	len = ((struct wgdevice *)READ_BYTES(sizeof(struct wgdevice)))->num_peers;
+	for (i = 0; i < len; ++i)
+		READ_BYTES(sizeof(struct wgipmask) * ((struct wgpeer *)READ_BYTES(sizeof(struct wgpeer)))->num_ipmasks);
 	ret = 0;
 out:
-	if (*dev && ret) {
-		free(*dev);
-		*dev = NULL;
+	if (buffer && ret) {
+		free(buffer);
+		buffer = NULL;
 	}
+	*dev = (struct wgdevice *)buffer;
 	close(fd);
 	errno = -ret;
 	return ret;
+
 }
+#undef READ_BYTES
 
 #ifdef __linux__
 static int parse_linkinfo(const struct nlattr *attr, void *data)

commit e92e0dca144b813b43c7e832dd10c83a381c4bcb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jan 8 23:00:41 2017 +0100

    wg: error on short ret reads
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index c8ca431..6237961 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -179,6 +179,10 @@ static int userspace_set_device(struct wgdevice *dev)
 	ret = read(fd, &ret_code, sizeof(ret_code));
 	if (ret < 0)
 		goto out;
+	if (ret != sizeof(ret_code)) {
+		ret = -EBADMSG;
+		goto out;
+	}
 	ret = ret_code;
 out:
 	close(fd);

commit 16060516bb9e1b3d2072d69c0a6500c99985031c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 5 19:57:50 2017 +0100

    wg-quick: enforce good permissions
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 8160cc9..fee7951 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,6 +1,7 @@
 PKG_CONFIG ?= pkg-config
 PREFIX ?= /usr
 DESTDIR ?=
+SYSCONFDIR ?= /etc
 BINDIR ?= $(PREFIX)/bin
 LIBDIR ?= $(PREFIX)/lib
 MANDIR ?= $(PREFIX)/share/man
@@ -54,7 +55,7 @@ install: wg
 	@[ "$(WITH_BASHCOMPLETION)" = "yes" ] || exit 0; \
 	install -v -d "$(DESTDIR)$(BASHCOMPDIR)" && install -m 0644 -v completion/wg.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg"
 	@[ "$(WITH_WGQUICK)" = "yes" ] || exit 0; \
-	install -m 0755 -v wg-quick.bash "$(DESTDIR)$(BINDIR)/wg-quick"
+	install -m 0755 -v wg-quick.bash "$(DESTDIR)$(BINDIR)/wg-quick" && install -m 0700 -v -d "$(DESTDIR)$(SYSCONFDIR)/wireguard"
 	@[ "$(WITH_WGQUICK)" = "yes" ] || exit 0; \
 	install -m 0644 -v wg-quick.8 "$(DESTDIR)$(MANDIR)/man8/wg-quick.8"
 	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_BASHCOMPLETION)" = "yes" ] || exit 0; \
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
index e686d73..c9157ad 100755
--- a/src/wg-quick.bash
+++ b/src/wg-quick.bash
@@ -27,6 +27,7 @@ parse_options() {
 	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,16}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
 	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
 	[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,16})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
+	((($(stat -c '%#a' "$CONFIG_FILE") & 0007) == 0)) || echo "Warning: \`$CONFIG_FILE' is world accessible" >&2
 	INTERFACE="${BASH_REMATCH[1]}"
 	shopt -s nocasematch
 	while read -r line; do

commit bf5d24eca4418379cdd25966da0876e689ee8487
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jan 5 19:41:20 2017 +0100

    wg: add installation note for distros
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/INSTALL b/src/INSTALL
index 55f0c5b..cc80df5 100644
--- a/src/INSTALL
+++ b/src/INSTALL
@@ -41,3 +41,8 @@ The first section is rather standard. The second section is not:
     wg-quick(8). If you don't use systemd, you certainly don't want this, and
     should set it to `no'. If systemd isn't auto-detected, but you still would
     like to install it, set this to `yes'.
+
+If you're a simple `make && make install` kind of user, you can get away with
+not setting these variables and relying on the auto-detection. However, if
+you're writing a package for a distro, you'll want to explicitly set these,
+depending on what you want.

commit d2f244b1360975738bfbc5bbf6d256974df999d2
Author: Christian Hesse <mail@eworm.de>
Date:   Wed Jan 4 21:14:16 2017 +0100

    wg: remove DESTDIR for autodetection
    
    DESTDIR is always empty, no need to check anything there. Check the main
    system instead.
    
    Signed-off-by: Christian Hesse <mail@eworm.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index fe483b9..8160cc9 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -12,12 +12,12 @@ WITH_WGQUICK ?=
 WITH_SYSTEMDUNITS ?=
 
 ifeq ($(WITH_BASHCOMPLETION),)
-ifneq ($(strip $(wildcard $(DESTDIR)$(BASHCOMPDIR))),)
+ifneq ($(strip $(wildcard $(BASHCOMPDIR))),)
 WITH_BASHCOMPLETION := yes
 endif
 endif
 ifeq ($(WITH_WGQUICK),)
-ifneq ($(strip $(wildcard $(DESTDIR)$(BINDIR)/bash)),)
+ifneq ($(strip $(wildcard $(BINDIR)/bash)),)
 WITH_WGQUICK := yes
 endif
 ifneq ($(strip $(wildcard $(DESTDIR)/bin/bash)),)
@@ -25,7 +25,7 @@ WITH_WGQUICK := yes
 endif
 endif
 ifeq ($(WITH_SYSTEMDUNITS),)
-ifneq ($(strip $(wildcard $(DESTDIR)$(SYSTEMDUNITDIR))),)
+ifneq ($(strip $(wildcard $(SYSTEMDUNITDIR))),)
 WITH_SYSTEMDUNITS := yes
 endif
 endif

commit 6b940830e96a585ed0d90fad35e3887d5d9098af
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 4 19:28:28 2017 +0100

    wg: add systemd unit and auto-detection
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/systemd/README b/contrib/systemd/README
deleted file mode 100644
index 1ef51aa..0000000
--- a/contrib/systemd/README
+++ /dev/null
@@ -1,5 +0,0 @@
-Until WireGuard receives full integration to the various network
-management utilities, there are a number of ways of setting up
-a WireGuard tunnel at boot time. This systemd unit file is one
-such way of doing things. Probably it should be tweaked before
-using.
diff --git a/contrib/systemd/wgserver.service b/contrib/systemd/wgserver.service
deleted file mode 100644
index dfce1e9..0000000
--- a/contrib/systemd/wgserver.service
+++ /dev/null
@@ -1,15 +0,0 @@
-[Unit]
-Description=WireGuard Server
-
-[Service]
-Type=oneshot
-RemainAfterExit=yes
-ExecStart=/bin/ip link add dev wgserver type wireguard
-ExecStart=/bin/ip address add 192.168.177.1/24 dev wgserver
-ExecStart=/usr/bin/wg setconf wgserver /etc/wireguard-server.conf
-ExecStart=/bin/ip link set up dev wgserver
-ExecStop=/bin/sh -c 'umask 077; /usr/bin/wg showconf wgserver > /etc/wireguard-server.conf.tmp && mv /etc/wireguard-server.conf.tmp /etc/wireguard-server.conf'
-ExecStop=/bin/ip link del dev wgserver
-
-[Install]
-WantedBy=multi-user.target
diff --git a/src/INSTALL b/src/INSTALL
index ea3be53..55f0c5b 100644
--- a/src/INSTALL
+++ b/src/INSTALL
@@ -14,15 +14,17 @@ This command takes into account several environment variables:
   * RUNSTATEDIR          default: /var/run
   * PKG_CONFIG           default: pkg-config
 
-  * WITH_BASHCOMPLETION  default: yes
-  * WITH_WGQUICK         default: yes
+  * WITH_BASHCOMPLETION  default: [auto-detect]
+  * WITH_WGQUICK         default: [auto-detect]
+  * WITH_SYSTEMDUNITS    default: [auto-detect]
 
 The first section is rather standard. The second section is not:
 
   * WITH_BASHCOMPLETION decides whether or not bash completion files for the
     tools are installed. This is just a nice thing for people who have bash.
     If you don't have bash, or don't want this, set the environment variable
-    to `no'.
+    to `no'. If you'd like to force its use, even if bash-completion isn't
+    detected in DESTDIR, then set it to `yes'.
 
   * WITH_WGQUICK decides whether or not the wg-quick(8) script is installed.
     This is a very quick and dirty bash script for reading a few extra
@@ -31,4 +33,11 @@ The first section is rather standard. The second section is not:
     this at all. Likewise, if you already have a working network management
     tool or configuration, you probably want to integrate wg(8) or the direct
     WireGuard API into your network manager, rather than using wg-quick(8).
-    But for folks who like simple quick&dirty scripts, this is nice.
+    But for folks who like simple quick&dirty scripts, this is nice. If you'd
+    like to force its use, even if bash isn't detected in DESTDIR, then set it
+    to `yes'.
+
+  * WITH_SYSTEMDUNITS decides whether or not systemd units are installed for
+    wg-quick(8). If you don't use systemd, you certainly don't want this, and
+    should set it to `no'. If systemd isn't auto-detected, but you still would
+    like to install it, set this to `yes'.
diff --git a/src/Makefile b/src/Makefile
index fb727d8..fe483b9 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,13 +1,34 @@
+PKG_CONFIG ?= pkg-config
 PREFIX ?= /usr
 DESTDIR ?=
 BINDIR ?= $(PREFIX)/bin
 LIBDIR ?= $(PREFIX)/lib
 MANDIR ?= $(PREFIX)/share/man
 BASHCOMPDIR ?= $(PREFIX)/share/bash-completion/completions
+SYSTEMDUNITDIR ?= $(shell $(PKG_CONFIG) --variable=systemdsystemunitdir systemd 2>/dev/null || echo "$(PREFIX)/lib/systemd/system")
 RUNSTATEDIR ?= /var/run
-PKG_CONFIG ?= pkg-config
-WITH_BASHCOMPLETION ?= yes
-WITH_WGQUICK ?= yes
+WITH_BASHCOMPLETION ?=
+WITH_WGQUICK ?=
+WITH_SYSTEMDUNITS ?=
+
+ifeq ($(WITH_BASHCOMPLETION),)
+ifneq ($(strip $(wildcard $(DESTDIR)$(BASHCOMPDIR))),)
+WITH_BASHCOMPLETION := yes
+endif
+endif
+ifeq ($(WITH_WGQUICK),)
+ifneq ($(strip $(wildcard $(DESTDIR)$(BINDIR)/bash)),)
+WITH_WGQUICK := yes
+endif
+ifneq ($(strip $(wildcard $(DESTDIR)/bin/bash)),)
+WITH_WGQUICK := yes
+endif
+endif
+ifeq ($(WITH_SYSTEMDUNITS),)
+ifneq ($(strip $(wildcard $(DESTDIR)$(SYSTEMDUNITDIR))),)
+WITH_SYSTEMDUNITS := yes
+endif
+endif
 
 CFLAGS ?= -O3
 CFLAGS += -std=gnu11
@@ -30,10 +51,16 @@ clean:
 install: wg
 	@install -v -d "$(DESTDIR)$(BINDIR)" && install -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"
 	@install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -m 0644 -v wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
-	@[ "$(WITH_BASHCOMPLETION)" = "yes" ] && install -v -d "$(BASHCOMPDIR)" && install -m 0644 -v completion/wg.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg"
-	@[ "$(WITH_WGQUICK)" = "yes" ] && install -m 0755 -v wg-quick.bash "$(DESTDIR)$(BINDIR)/wg-quick"
-	@[ "$(WITH_WGQUICK)" = "yes" ] && install -m 0644 -v wg-quick.8 "$(DESTDIR)$(MANDIR)/man8/wg-quick.8"
-	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_BASHCOMPLETION)" = "yes" ] && install -m 0644 -v completion/wg-quick.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg-quick"
+	@[ "$(WITH_BASHCOMPLETION)" = "yes" ] || exit 0; \
+	install -v -d "$(DESTDIR)$(BASHCOMPDIR)" && install -m 0644 -v completion/wg.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg"
+	@[ "$(WITH_WGQUICK)" = "yes" ] || exit 0; \
+	install -m 0755 -v wg-quick.bash "$(DESTDIR)$(BINDIR)/wg-quick"
+	@[ "$(WITH_WGQUICK)" = "yes" ] || exit 0; \
+	install -m 0644 -v wg-quick.8 "$(DESTDIR)$(MANDIR)/man8/wg-quick.8"
+	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_BASHCOMPLETION)" = "yes" ] || exit 0; \
+	install -m 0644 -v completion/wg-quick.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg-quick"
+	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_SYSTEMDUNITS)" = "yes" ] || exit 0; \
+	install -v -d "$(DESTDIR)$(SYSTEMDUNITDIR)" && install -m 0644 -v wg-quick@.service "$(DESTDIR)$(SYSTEMDUNITDIR)/wg-quick@.service"
 
 check: clean
 	CFLAGS=-g scan-build --view --keep-going $(MAKE) wg
diff --git a/src/wg-quick@.service b/src/wg-quick@.service
new file mode 100644
index 0000000..f5f4e8f
--- /dev/null
+++ b/src/wg-quick@.service
@@ -0,0 +1,19 @@
+[Unit]
+Description=WireGuard via wg-quick(8) for %I
+After=network-online.target
+Wants=network-online.target
+Documentation=man:wg-quick(8)
+Documentation=man:wg(8)
+Documentation=https://www.wireguard.io/
+Documentation=https://www.wireguard.io/quickstart/
+Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/wg-quick.8
+Documentation=https://git.zx2c4.com/WireGuard/about/src/tools/wg.8
+
+[Service]
+Type=oneshot
+RemainAfterExit=yes
+ExecStart=/usr/bin/wg-quick up %i
+ExecStop=/usr/bin/wg-quick down %i
+
+[Install]
+WantedBy=multi-user.target

commit 7c202eb5fc6ff25ded28708b5b91db09ff74ce9d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 4 18:20:08 2017 +0100

    wg: add makefile instructions
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/INSTALL b/src/INSTALL
new file mode 100644
index 0000000..ea3be53
--- /dev/null
+++ b/src/INSTALL
@@ -0,0 +1,34 @@
+Installation Makefile Target
+============================
+
+    # make install
+
+This command takes into account several environment variables:
+
+  * PREFIX               default: /usr
+  * DESTDIR              default:
+  * BINDIR               default: $(PREFIX)/bin
+  * LIBDIR               default: $(PREFIX)/lib
+  * MANDIR               default: $(PREFIX)/share/man
+  * BASHCOMPDIR          default: $(PREFIX)/share/bash-completion/completions
+  * RUNSTATEDIR          default: /var/run
+  * PKG_CONFIG           default: pkg-config
+
+  * WITH_BASHCOMPLETION  default: yes
+  * WITH_WGQUICK         default: yes
+
+The first section is rather standard. The second section is not:
+
+  * WITH_BASHCOMPLETION decides whether or not bash completion files for the
+    tools are installed. This is just a nice thing for people who have bash.
+    If you don't have bash, or don't want this, set the environment variable
+    to `no'.
+
+  * WITH_WGQUICK decides whether or not the wg-quick(8) script is installed.
+    This is a very quick and dirty bash script for reading a few extra
+    variables from wg(8)-style configuration files, and automatically
+    configures the interface. If you don't have bash, you probably don't want
+    this at all. Likewise, if you already have a working network management
+    tool or configuration, you probably want to integrate wg(8) or the direct
+    WireGuard API into your network manager, rather than using wg-quick(8).
+    But for folks who like simple quick&dirty scripts, this is nice.
diff --git a/src/Makefile b/src/Makefile
index cc11c9e..fb727d8 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -38,6 +38,9 @@ install: wg
 check: clean
 	CFLAGS=-g scan-build --view --keep-going $(MAKE) wg
 
-.PHONY: clean install check
+help:
+	@cat INSTALL
+
+.PHONY: clean install check help
 
 -include *.d

commit e975597e72a00be8680fdc783fcc8498b114aed4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jan 2 05:33:43 2017 +0100

    wg: add wg-quick
    
    This is based on wg-config, but is even easier to use, and now makes
    our full tools suite.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/wg-config/Makefile b/contrib/wg-config/Makefile
deleted file mode 100644
index 4fa264c..0000000
--- a/contrib/wg-config/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-PREFIX ?= /usr
-DESTDIR ?=
-SBINDIR ?= $(PREFIX)/sbin
-
-all:
-	@echo "This is a shell script, so there is nothing to do. Try \"make install\" instead."
-
-install:
-	@install -v -m0755 -D -t$(DESTDIR)$(SBINDIR) wg-config
-
-.PHONY: all install
diff --git a/contrib/wg-config/README b/contrib/wg-config/README
deleted file mode 100644
index 93da029..0000000
--- a/contrib/wg-config/README
+++ /dev/null
@@ -1,140 +0,0 @@
-== Installation ==
-
-    # make install
-
-== Usage ==
-
-wg-config is a very simple utility for adding and configuring WireGuard
-interfaces using ip(8) and wg(8).
-
-Usage: wg-config [ add | del ] INTERFACE [arguments...]
-
-  wg-config add INTERFACE --config=CONFIG_FILE [--address=ADDRESS/CIDR...]
-               [--route=ROUTE/CIDR...] [--no-auto-route-from-allowed-ips]
-               [--env-file=ENV_FILE]
-
-    The add subcommand adds a new WireGuard interface, INTERFACE, replacing
-    any existing interfaces of the same name. The --config argument is
-    required, and its argument is passed to wg(8)'s setconf subcommand. The
-    --address argument(s) is recommended for this utility to be useful. The
-    --route argument is purely optional, as by default this utility will
-    automatically add routes implied by --address and as implied by the
-    allowed-ip entries inside the --config file. To disable this automatic
-    route adding, you may use the option entitled --no-auto-route-from-allowed-ips.
-
-  wg-config del INTERFACE [--config=CONFIG_FILE_TO_SAVE] [--env-file=ENV_FILE]
-
-    The del subcommand removes an existing WireGuard interface. If the
-    optional --config is specified, then the existing configuration is
-    written out to the file specified, via wg(8)'s showconf subcommand.
-
-Both `add' and del' take the --env-file=ENV_FILE option. If specified,
-the contents of ENV_FILE are imported into wg-config. This can be used to
-set variables in a file, instead of needing to pass them on the command
-line. The following table shows the relation between the command line
-options described above, and variables that may be declared in ENV_FILE:
-
-  --address=A, --address=B, --address=C       ADDRESSES=( "A" "B" "C" )
-  --route=A, --route=B, --route=C             ADDITIONAL_ROUTES=( "A" "B" "C" )
-  --config-file=F                             CONFIG_FILE="F"
-  echo C > /tmp/F, --config-file=/tmp/F       CONFIG_FILE_CONTENTS="C"
-  --no-auto-route-from-allowed-ips            AUTO_ROUTE=0
-
-Additionally, ENV_FILE may define the bash functions pre_add, post_add,
-pre_del, and post_del, which will be called at their respective times.
-
-== Basic Example ==
-
-This basic example might be used by a server.
-
-/etc/wireguard/wg-server.conf:
-
-	[Interface]
-	PrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=
-	ListenPort = 41414
-
-	[Peer]
-	PublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=
-	AllowedIPs = 10.192.122.3/32, 10.192.124.1/24
-
-	[Peer]
-	PublicKey = TrMvSoP4jYQlY6RIzBgbssQqY3vxI2Pi+y71lOWWXX0=
-	AllowedIPs = 10.192.122.4/32, 192.168.0.0/16
-
-	[Peer]
-	PublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA=
-	AllowedIPs = 10.10.10.230/32
-
-/etc/wireguard/wg-server.env:
-
-	CONFIG_FILE="$(dirname "${BASH_SOURCE[0]}")/wg-server.conf"
-	ADDRESSES=( 10.192.122.1/34 10.10.0.1/16 )
-
-Run at startup:
-# wg-config add wgserver0 --env-file=/etc/wireguard/wg-server.env
-Run at shutdown:
-# wg-config del wgserver0 --env-file=/etc/wireguard/wg-server.env
-
-== Single File Advanced Example ==
-
-This type of configuration might be desirable for a personal access gateway
-VPN, connecting to a server like in the example above.
-
-/etc/wireguard/wg-vpn-gateway.env:
-
-	CONFIG_FILE_CONTENTS="
-	[Interface]
-	PrivateKey = 6JiA3fa+NG+x5m6aq7+lxlVaVqVf1mxK6/pDOZdNuXc=
-
-	[Peer]
-	PublicKey = 6NagfTu+s8+TkEKpxX7pNjJuTf4zYtoJme7iQFYIw0A=
-	AllowedIPs = 0.0.0.0/0
-	Endpoint = demo.wireguard.io:29912
-	"
-
-	ADDRESSES=( 10.200.100.2/32 )
-
-	post_add() {
-		printf 'nameserver 10.200.100.1' | cmd resolvconf -a "$INTERFACE" -m 0
-	}
-	post_del() {
-		cmd resolvconf -d "$INTERFACE"
-	}
-
-Run to flip on the VPN:
-# wg-config add wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
-Run to flip off the VPN:
-# wg-config del wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
-
-== Advanced Example ==
-
-This achieves the same as the above, but with an external file. It only sets the
-configuration file when the subcommand is add, to prevent it from being overwritten.
-The above is much simpler and probably preferred, but this example shows how powerful
-the tool can be.
-
-/etc/wireguard/wg-vpn-gateway.conf:
-
-	[Interface]
-	PrivateKey = 6JiA3fa+NG+x5m6aq7+lxlVaVqVf1mxK6/pDOZdNuXc=
-
-	[Peer]
-	PublicKey = 6NagfTu+s8+TkEKpxX7pNjJuTf4zYtoJme7iQFYIw0A=
-	AllowedIPs = 0.0.0.0/0
-	Endpoint = demo.wireguard.io:29912
-
-/etc/wireguard/wg-vpn-gateway.env:
-
-	[[ $SUBCOMMAND == add ]] && CONFIG_FILE="$(dirname "${BASH_SOURCE[0]}")/demo-vpn.conf" || true
-	ADDRESSES=( 10.200.100.2/32 )
-	post_add() {
-		printf 'nameserver 10.200.100.1' | cmd resolvconf -a "$INTERFACE" -m 0
-	}
-	post_del() {
-		cmd resolvconf -d "$INTERFACE"
-	}
-
-Run to flip on the VPN:
-# wg-config add wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
-The config file is not overwritten on shutdown, due to the conditional in the env file:
-# wg-config del wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
diff --git a/contrib/wg-config/wg-config b/contrib/wg-config/wg-config
deleted file mode 100755
index 8d8d4e7..0000000
--- a/contrib/wg-config/wg-config
+++ /dev/null
@@ -1,183 +0,0 @@
-#!/bin/bash
-set -e -o pipefail
-
-SELF="$(readlink -f "${BASH_SOURCE[0]}")"
-export PATH="${SELF%/*}:$PATH"
-
-cmd() {
-	echo "[#] $*" >&2
-	"$@"
-}
-
-auto_su() {
-	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$SELF" "${ARGS[@]}"
-}
-
-unwind() {
-	set +e
-	[[ -n $INTERFACE && -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] && del_if
-	exit
-}
-
-add_if() {
-	ip link delete dev "$INTERFACE" 2>/dev/null || true
-	cmd ip link add "$INTERFACE" type wireguard
-}
-
-del_if() {
-	[[ -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] || { echo "$PROGRAM: \`$INTERFACE' is not a WireGuard interface" >&2; exit 1; }
-	if [[ $(ip route show table all) =~ .*\ dev\ $INTERFACE\ table\ ([0-9]+)\ .* ]]; then
-		cmd ip rule delete table ${BASH_REMATCH[1]}
-	fi
-	cmd ip link delete dev "$INTERFACE"
-}
-
-up_if() {
-	cmd ip link set "$INTERFACE" up
-}
-
-add_addr() {
-	cmd ip address add "$1" dev "$INTERFACE"
-}
-
-add_route() {
-	if [[ $1 == 0.0.0.0/0 || $1 == ::/0 ]]; then
-		add_default "$1"
-	else
-		cmd ip route add "$1" dev "$INTERFACE"
-	fi
-}
-
-add_default() {
-	[[ $(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints)) =~ .*\ ${1//./\\.}\ ([0-9.:a-f]+):[0-9]+$ ]] && local endpoint="${BASH_REMATCH[1]}"
-	[[ -n $endpoint ]] || return 0
-	local table=51820
-	while [[ -n $(ip route show table $table) ]]; do ((table++)); done
-	cmd ip route add "$1" dev "$INTERFACE" table $table
-	cmd ip rule add not to "$endpoint" table $table
-}
-
-set_config() {
-	if [[ -n $CONFIG_FILE_CONTENTS ]]; then
-		cmd wg setconf "$INTERFACE" <(echo "$CONFIG_FILE_CONTENTS")
-	else
-		cmd wg setconf "$INTERFACE" "$CONFIG_FILE"
-	fi
-}
-
-save_config() {
-	local old_umask="$(umask)"
-	umask 077
-	cmd wg showconf "$INTERFACE" > "$CONFIG_FILE.tmp" || { rm -f "$CONFIG_FILE.tmp"; exit 1; }
-	mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || { rm -f "$CONFIG_FILE.tmp"; exit 1; }
-	umask "$old_umask"
-}
-
-cmd_usage() {
-	cat >&2 <<-_EOF
-	Usage: $PROGRAM [ add | del ] INTERFACE [arguments...]
-
-	  $PROGRAM add INTERFACE --config=CONFIG_FILE [--address=ADDRESS/CIDR...]
-	               [--route=ROUTE/CIDR...] [--no-auto-route-from-allowed-ips]
-	               [--env-file=ENV_FILE]
-
-	    The add subcommand adds a new WireGuard interface, INTERFACE, replacing
-	    any existing interfaces of the same name. The --config argument is
-	    required, and its argument is passed to wg(8)'s setconf subcommand. The
-	    --address argument(s) is recommended for this utility to be useful. The
-	    --route argument is purely optional, as by default this utility will
-	    automatically add routes implied by --address and as implied by the
-	    allowed-ip entries inside the --config file. To disable this automatic
-	    route adding, you may use the option entitled --no-auto-route-from-allowed-ips.
-
-	  $PROGRAM del INTERFACE [--config=CONFIG_FILE_TO_SAVE] [--env-file=ENV_FILE]
-
-	    The del subcommand removes an existing WireGuard interface. If the
-	    optional --config is specified, then the existing configuration is
-	    written out to the file specified, via wg(8)'s showconf subcommand.
-
-	  $PROGRAM help
-
-	    Show this message.
-
-	Both \`add' and ``del' take the --env-file=ENV_FILE option. If specified,
-	the contents of ENV_FILE are imported into $PROGRAM. This can be used to
-	set variables in a file, instead of needing to pass them on the command
-	line. The following table shows the relation between the command line
-	options described above, and variables that may be declared in ENV_FILE:
-
-	  --address=A, --address=B, --address=C       ADDRESSES=( "A" "B" "C" )
-	  --route=A, --route=B, --route=C             ADDITIONAL_ROUTES=( "A" "B" "C" )
-	  --config-file=F                             CONFIG_FILE="F"
-	  echo C > /tmp/F, --config-file=/tmp/F       CONFIG_FILE_CONTENTS="C"
-	  --no-auto-route-from-allowed-ips            AUTO_ROUTE=0
-
-	Additionally, ENV_FILE may define the bash functions pre_add, post_add,
-	pre_del, and post_del, which will be called at their respective times.
-	_EOF
-}
-
-cmd_add() {
-	local i
-	[[ -n $CONFIG_FILE || -n $CONFIG_FILE_CONTENTS ]] || { echo "$PROGRAM: --config is required for add subcommand" >&2; exit 1; }
-	auto_su
-	trap unwind INT TERM EXIT
-	[[ $(type -t pre_add) != function ]] || pre_add
-	add_if
-	set_config
-	for i in "${ADDRESSES[@]}"; do
-		add_addr "$i"
-	done
-	up_if
-	if [[ $AUTO_ROUTE -eq 1 ]]; then
-		for i in $(wg show "$INTERFACE" allowed-ips | grep -Po '(?<=[\t ])[0-9.:/a-f]+' | sort -nr -k 2 -t /); do
-			[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"
-		done
-	fi
-	for i in "${ADDITIONAL_ROUTES[@]}"; do
-		add_route "$i"
-	done
-	[[ $(type -t post_add) != function ]] || post_add
-	trap - INT TERM EXIT
-}
-
-cmd_del() {
-	auto_su
-	[[ $(type -t pre_del) != function ]] || pre_del
-	[[ -n $CONFIG_FILE ]] && save_config
-	del_if
-        [[ $(type -t post_del) != function ]] || post_del
-}
-
-declare INTERFACE="$2"
-declare SUBCOMMAND="$1"
-declare -a ADDRESSES
-declare -a ADDITIONAL_ROUTES
-declare AUTO_ROUTE=1
-declare CONFIG_FILE
-declare CONFIG_FILE_CONTENTS
-declare PROGRAM="${0##*/}"
-declare -a ARGS=( "$@" )
-
-[[ -n $INTERFACE && -n $SUBCOMMAND ]] || { cmd_usage; exit 1; }
-
-shift 2
-
-for arg; do
-	case "$arg" in
-	--env-file=*) source "${arg#*=}" ;;
-	--config=*) CONFIG_FILE="${arg#*=}" ;;
-	--address=*) ADDRESSES+=( ${arg#*=} ) ;;
-	--route=*) ADDITIONAL_ROUTES+=( ${arg#*=} ) ;;
-	--no-auto-route-from-allowed-ips) AUTO_ROUTE=0 ;;
-	*) cmd_usage; exit 1 ;;
-	esac
-done
-
-case "$SUBCOMMAND" in
-add) cmd_add ;;
-del) cmd_del ;;
-*) cmd_usage; exit 1 ;;
-esac
-
-exit 0
diff --git a/src/Makefile b/src/Makefile
index 5b72879..cc11c9e 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -7,6 +7,7 @@ BASHCOMPDIR ?= $(PREFIX)/share/bash-completion/completions
 RUNSTATEDIR ?= /var/run
 PKG_CONFIG ?= pkg-config
 WITH_BASHCOMPLETION ?= yes
+WITH_WGQUICK ?= yes
 
 CFLAGS ?= -O3
 CFLAGS += -std=gnu11
@@ -30,6 +31,9 @@ install: wg
 	@install -v -d "$(DESTDIR)$(BINDIR)" && install -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"
 	@install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -m 0644 -v wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
 	@[ "$(WITH_BASHCOMPLETION)" = "yes" ] && install -v -d "$(BASHCOMPDIR)" && install -m 0644 -v completion/wg.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg"
+	@[ "$(WITH_WGQUICK)" = "yes" ] && install -m 0755 -v wg-quick.bash "$(DESTDIR)$(BINDIR)/wg-quick"
+	@[ "$(WITH_WGQUICK)" = "yes" ] && install -m 0644 -v wg-quick.8 "$(DESTDIR)$(MANDIR)/man8/wg-quick.8"
+	@[ "$(WITH_WGQUICK)" = "yes" -a "$(WITH_BASHCOMPLETION)" = "yes" ] && install -m 0644 -v completion/wg-quick.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg-quick"
 
 check: clean
 	CFLAGS=-g scan-build --view --keep-going $(MAKE) wg
diff --git a/src/completion/wg-quick.bash-completion b/src/completion/wg-quick.bash-completion
new file mode 100644
index 0000000..cf3e9a0
--- /dev/null
+++ b/src/completion/wg-quick.bash-completion
@@ -0,0 +1,20 @@
+# Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
+_wg_quick_completion() {
+	local i
+	if [[ $COMP_CWORD -eq 1 ]]; then
+		COMPREPLY+=( $(compgen -W "up down" -- "${COMP_WORDS[1]}") )
+		return
+	elif [[ $COMP_CWORD -eq 2 ]]; then
+		local old_glob="$(shopt -p nullglob)"
+		shopt -s nullglob
+		for i in /etc/wireguard/*.conf; do
+			i="${i##*/}"; i="${i%.conf}"
+			COMPREPLY+=( $(compgen -W "$i" -- "${COMP_WORDS[2]}") )
+		done
+		eval "$old_glob"
+		COMPREPLY+=( $(compgen -f -X '!*.conf' -- "${COMP_WORDS[2]}") $(compgen -d -- "${COMP_WORDS[2]}") )
+	fi
+}
+
+complete -o filenames -o nosort -F _wg_quick_completion wg-quick
diff --git a/src/wg-quick.8 b/src/wg-quick.8
new file mode 100644
index 0000000..2425926
--- /dev/null
+++ b/src/wg-quick.8
@@ -0,0 +1,194 @@
+.TH WG-QUICK 8 "2016 January 1" ZX2C4 "WireGuard"
+
+.SH NAME
+wg-quick - set up a WireGuard interface simply
+
+.SH SYNOPSIS
+.B wg-quick
+[
+.I up
+|
+.I down
+] [
+.I CONFIG_FILE
+|
+.I INTERFACE
+]
+
+.SH DESCRIPTION
+
+This is an extremely simple script for easily bringing up a WireGuard interface,
+suitable for a few common use cases.
+
+Use \fIup\fP to add and set up an interface, and use \fIdown\fP to tear down and remove
+an interface. Running \fIup\fP adds a WireGuard interface, brings up the interface with the
+supplied IP addresses, sets up routes, and optionally runs pre/post up scripts. Running \fIdown\fP
+optionally saves the current configuration, removes the WireGuard interface, and optionally
+runs pre/post down scripts.
+
+\fICONFIG_FILE\fP is a configuration file, whose filename is the interface name
+followed by `.conf'. Otherwise, \fIINTERFACE\fP is an interface name, with configuration
+found at `/etc/wireguard/\fIINTERFACE\fP.conf'.
+
+Generally speaking, this utility is just a simple script that wraps invocations to
+.BR wg (8)
+and
+.BR ip (8)
+in order to set up a WireGuard interface. It is designed for users with simple
+needs, and users with more advanced needs are highly encouraged to use a more
+specific tool, a more complete network manager, or otherwise just use
+.BR wg (8)
+and
+.BR ip (8),
+as usual.
+
+.SH CONFIGURATION
+
+The configuration file adds a few extra configuration values to the format understood by
+.BR wg (8)
+in order to configure additional attribute of an interface. It handles the
+values that it understands, and then it passes the remaining ones directly to
+.BR wg (8)
+for further processing.
+
+It infers all routes from the list of peers' allowed IPs, and automatically adds
+them to the system routing table. If one of those routes is the default route
+(0.0.0.0/0 or ::/0), then it uses
+.BR ip-rule (8)
+to handle overriding of the default gateway.
+
+The configuration file will be passed directly to \fBwg\fP(8)'s `setconf'
+sub-command, with the exception of the following additions to the \fIInterface\fP section,
+which are handled by this tool:
+
+.IP \(bu
+Address \(em a comma-separated list of ip (v4 or v6) addresses (optionally with CIDR masks)
+to be assigned to the interface. May be specified multiple times.
+.IP \(bu
+PreUp, PostUp, PreDown, PostDown \(em script snippets which will be executed by
+.BR bash (1)
+before/after setting up/tearing down the interface, most commonly used
+to configure DNS. The special string `%i' is expanded to \fIINTERFACE\fP.
+.IP \(bu
+SaveConfig \(em if set to `true', the configuration is saved from the current state of the
+interface upon shutdown.
+
+.P
+Recommended \fIINTERFACE\fP names include `wg0' or `wgvpn0' or even `wgmgmtlan0'.
+However, the number at the end is in fact optional, and really
+any free-form string [a-zA-Z0-9_=+.-]{1,16} will work. So even interface names corresponding
+to geographic locations would suffice, such as `cincinnati', `nyc', or `paris', if that's
+somehow desirable.
+
+.SH EXAMPLES
+
+These examples draw on the same syntax found for
+.BR wg (8),
+and a more complete description may be found there. Bold lines below are for options that extend
+.BR wg (8).
+
+The following might be used for connecting as a client to a VPN gateway for tunneling all
+traffic:
+
+    [Interface] 
+.br
+    \fBAddress = 10.200.100.8/24\fP
+.br
+    \fBPostUp = echo nameserver 10.200.100.1 | resolvconf -a %i -m 0\fP
+.br
+    \fBPostDown = resolvconf -d %i\fP
+.br
+    PrivateKey = oK56DE9Ue9zK76rAc8pBl6opph+1v36lm7cXXsQKrQM= 
+.br
+    PresharedKey = /UwcSPg38hW/D9Y3tcS1FOV0K1wuURMbS0sesJEP5ak= 
+.br
+     
+.br
+    [Peer] 
+.br
+    PublicKey = GtL7fZc/bLnqZldpVofMCD6hDjrK28SsdLxevJ+qtKU= 
+.br
+    AllowedIPs = 0.0.0.0/0 
+.br
+    Endpoint = demo.wireguard.io:51820 
+.br
+
+Notice that the `PostUp` and `PostDown` commands are used here to configure DNS using
+.BR resolvconf (8),
+which is one of the many options for DNS configuration. The `Address` field is added
+here in order to set up the address for the interface. The peer's allowed IPs entry
+implies that this interface should be configured as the default gateway, which this
+script does.
+
+Here is a more complicated example, fit for usage on a server:
+    
+    [Interface]
+.br
+    \fBAddress = 10.192.122.1/24\fP
+.br
+    \fBAddress = 10.10.0.1/16\fP
+.br
+    \fBSaveConfig = true\fP
+.br
+    PrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk= 
+.br
+    ListenPort = 41414 
+.br
+     
+.br
+    [Peer] 
+.br
+    PublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg= 
+.br
+    AllowedIPs = 10.192.122.3/32, 10.192.124.1/24 
+.br
+     
+.br
+    [Peer] 
+.br
+    PublicKey = TrMvSoP4jYQlY6RIzBgbssQqY3vxI2Pi+y71lOWWXX0= 
+.br
+    AllowedIPs = 10.192.122.4/32, 192.168.0.0/16 
+.br
+     
+.br
+    [Peer] 
+.br
+    PublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA= 
+.br
+    AllowedIPs = 10.10.10.230/32
+
+Notice the two `Address' lines at the top, and that `SaveConfig' is set to `true', indicating
+that the configuration file should be saved on shutdown using the current status of the
+interface.
+
+These configuration files may be placed in any directory, putting the desired interface name
+in the filename:
+
+\fB    # wg-quick up /path/to/wgnet0.conf\fP
+
+For convienence, if only an interface name is supplied, it automatically chooses a path in
+`/etc/wireguard/':
+
+\fB    # wg-quick up wgnet0\fP
+
+This will load the configuration file `/etc/wireguard/wgnet0.conf'.
+
+.SH SEE ALSO
+.BR wg (8),
+.BR ip (8),
+.BR ip-link (8),
+.BR ip-address (8),
+.BR ip-route (8),
+.BR ip-rule (8).
+
+.SH AUTHOR
+.B wg-quick
+was written by
+.MT Jason@zx2c4.com
+Jason A. Donenfeld
+.ME .
+For updates and more information, a project page is available on the
+.UR https://\:www.wireguard.io/
+World Wide Web
+.UE .
diff --git a/src/wg-quick.bash b/src/wg-quick.bash
new file mode 100755
index 0000000..e686d73
--- /dev/null
+++ b/src/wg-quick.bash
@@ -0,0 +1,209 @@
+#!/bin/bash
+#
+# Copyright (c) 2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+#
+
+set -e -o pipefail
+shopt -s extglob
+
+SELF="$(readlink -f "${BASH_SOURCE[0]}")"
+export PATH="${SELF%/*}:$PATH"
+
+WG_CONFIG=""
+INTERFACE=""
+ADDRESSES=( )
+PRE_UP=""
+POST_UP=""
+PRE_DOWN=""
+POST_DOWN=""
+SAVE_CONFIG=0
+CONFIG_FILE=""
+PROGRAM="${0##*/}"
+ARGS=( "$@" )
+
+parse_options() {
+	local interface_section=0 line key value
+	CONFIG_FILE="$1"
+	[[ $CONFIG_FILE =~ ^[a-zA-Z0-9_=+.-]{1,16}$ ]] && CONFIG_FILE="/etc/wireguard/$CONFIG_FILE.conf"
+	[[ -e $CONFIG_FILE ]] || die "\`$CONFIG_FILE' does not exist"
+	[[ $CONFIG_FILE =~ /?([a-zA-Z0-9_=+.-]{1,16})\.conf$ ]] || die "The config file must be a valid interface name, followed by .conf"
+	INTERFACE="${BASH_REMATCH[1]}"
+	shopt -s nocasematch
+	while read -r line; do
+		key="${line%%=*}"; key="${key##*( )}"; key="${key%%*( )}"
+		value="${line#*=}"; value="${value##*( )}"; value="${value%%*( )}"
+		[[ $key == "["* ]] && interface_section=0
+		[[ $key == "[Interface]" ]] && interface_section=1
+		if [[ $interface_section -eq 1 ]]; then
+			case "$key" in
+			Address) ADDRESSES+=( ${value//,/ } ); continue ;;
+			PreUp) PRE_UP="$value"; continue ;;
+			PreDown) PRE_DOWN="$value"; continue ;;
+			PostUp) POST_UP="$value"; continue ;;
+			PostDown) POST_DOWN="$value"; continue ;;
+			SaveConfig) read_bool SAVE_CONFIG "$value"; continue ;;
+			esac
+		fi
+		WG_CONFIG+="$line"$'\n'
+	done < "$CONFIG_FILE"
+	shopt -u nocasematch
+}
+
+read_bool() {
+	local -n out="$1"
+	case "$2" in
+	true) out=1 ;;
+	false) out=0 ;;
+	*) die "\`$2' is neither true nor false"
+	esac
+}
+
+cmd() {
+	echo "[#] $*" >&2
+	"$@"
+}
+
+die() {
+	echo "$PROGRAM: $*" >&2
+	exit 1
+}
+
+auto_su() {
+	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$SELF" "${ARGS[@]}"
+}
+
+add_if() {
+	cmd ip link add "$INTERFACE" type wireguard
+}
+
+del_if() {
+	if [[ $(ip route show table all) =~ .*\ dev\ $INTERFACE\ table\ ([0-9]+)\ .* ]]; then
+		cmd ip rule delete table "${BASH_REMATCH[1]}"
+		cmd ip rule delete table main suppress_prefixlength 0 2>/dev/null
+	fi
+	cmd ip link delete dev "$INTERFACE"
+}
+
+up_if() {
+	cmd ip link set "$INTERFACE" up
+}
+
+add_addr() {
+	cmd ip address add "$1" dev "$INTERFACE"
+}
+
+add_route() {
+	if [[ $1 == 0.0.0.0/0 || $1 == ::/0 ]]; then
+		add_default "$1"
+	else
+		cmd ip route add "$1" dev "$INTERFACE"
+	fi
+}
+
+add_default() {
+	[[ $(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints)) =~ .*\ ${1//./\\.}\ ([0-9.:a-f]+):[0-9]+$ ]] && local endpoint="${BASH_REMATCH[1]}"
+	[[ -n $endpoint ]] || return 0
+	local table=51820
+	while [[ -n $(ip route show table $table) ]]; do ((table++)); done
+	cmd ip route add "$1" dev "$INTERFACE" table $table
+	cmd ip rule add not to "$endpoint" table $table
+	cmd ip rule add table main suppress_prefixlength 0
+}
+
+set_config() {
+	cmd wg setconf "$INTERFACE" <(echo "$WG_CONFIG")
+}
+
+save_config() {
+	local old_umask new_config current_config address
+	[[ $(ip -all -brief address show dev "$INTERFACE") =~ ^$INTERFACE\ +\ [A-Z]+\ +(.+)$ ]] || true
+	new_config=$'[Interface]\n'
+	for address in ${BASH_REMATCH[1]}; do
+		new_config+="Address = $address"$'\n'
+	done
+	[[ $SAVE_CONFIG -eq 0 ]] || new_config+=$'SaveConfig = true\n'
+	[[ -z $PRE_UP ]] || new_config+="PreUp = $PRE_UP"$'\n'
+	[[ -z $POST_UP ]] || new_config+="PostUp = $POST_UP"$'\n'
+	[[ -z $PRE_DOWN ]] || new_config+="PreDown = $PRE_DOWN"$'\n'
+	[[ -z $POST_DOWN ]] || new_config+="PostDown = $POST_DOWN"$'\n'
+	old_umask="$(umask)"
+	umask 077
+	current_config="$(cmd wg showconf "$INTERFACE")"
+	trap "rm -f '$CONFIG_FILE.tmp; exit'" INT TERM EXIT
+	echo "${current_config/\[Interface\]$'\n'/$new_config}" > "$CONFIG_FILE.tmp" || die "Could not write configuration file"
+	mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || die "Could not move configuration file"
+	trap - INT TERM EXIT
+	umask "$old_umask"
+}
+
+execute_hook() {
+	[[ -n $1 ]] || return 0
+	local hook="${1//%i/$INTERFACE}"
+	echo "[#] $hook" >&2
+	(eval "$hook")
+}
+
+cmd_usage() {
+	cat >&2 <<-_EOF
+	Usage: $PROGRAM [ up | down ] [ CONFIG_FILE | INTERFACE ]
+
+	  CONFIG_FILE is a configuration file, whose filename is the interface name
+	  followed by \`.conf'. Otherwise, INTERFACE is an interface name, with
+	  configuration found at /etc/wireguard/INTERFACE.conf. It is to be readable
+	  by wg(8)'s \`setconf' sub-command, with the exception of the following additions
+	  to the [Interface] section, which are handled by $PROGRAM:
+
+	  - Address: may be specified one or more times and contains one or more
+	    IP addresses (with an optional CIDR mask) to be set for the interface.
+	  - PreUp, PostUp, PreDown, PostDown: script snippets which will be executed
+	    by bash(1) at the corresponding phases of the link, most commonly used
+	    to configure DNS. The string \`%i' is expanded to INTERFACE.
+	  - SaveConfig: if set to \`true', the configuration is saved from the current
+	    state of the interface upon shutdown.
+
+	 See wg-quick(8) for more info and examples.
+	_EOF
+}
+
+cmd_up() {
+	local i
+	[[ -z $(ip link show dev "$INTERFACE" 2>/dev/null) ]] || die "\`$INTERFACE' already exists"
+	trap 'del_if; exit' INT TERM EXIT
+	execute_hook "$PRE_UP"
+	add_if
+	set_config
+	for i in "${ADDRESSES[@]}"; do
+		add_addr "$i"
+	done
+	up_if
+	for i in $(wg show "$INTERFACE" allowed-ips | grep -Po '(?<=[\t ])[0-9.:/a-f]+' | sort -nr -k 2 -t /); do
+		[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"
+	done
+	execute_hook "$POST_UP"
+	trap - INT TERM EXIT
+}
+
+cmd_down() {
+	[[ -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] || die "\`$INTERFACE' is not a WireGuard interface"
+	execute_hook "$PRE_DOWN"
+	[[ $SAVE_CONFIG -eq 0 ]] || save_config
+	del_if
+	execute_hook "$POST_DOWN"
+}
+
+if [[ $# -eq 1 && ( $1 == --help || $1 == -h || $1 == help ) ]]; then
+	cmd_usage
+elif [[ $# -eq 2 && $1 == up ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_up
+elif [[ $# -eq 2 && $1 == down ]]; then
+	auto_su
+	parse_options "$2"
+	cmd_down
+else
+	cmd_usage
+	exit 1
+fi
+
+exit 0
diff --git a/src/wg.8 b/src/wg.8
index 18edba3..9322509 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -131,11 +131,12 @@ PublicKey \(em a base64 public key calculated by \fIwg pubkey\fP from a
 private key, and usually transmitted out of band to the author of the
 configuration file. Required.
 .IP \(bu
-AllowedIPs \(em a comma-separated list of IP (v4 or v6) addresses with
+AllowedIPs \(em a comma-separated list of ip (v4 or v6) addresses with
 CIDR masks from which this peer is allowed to send incoming traffic and
 to which outgoing traffic for this peer is directed. The catch-all
 \fI0.0.0.0/0\fP may be specified for matching all IPv4 addresses, and
-\fI::/0\fP may be specified for matching all IPv6 addresses. Required.
+\fI::/0\fP may be specified for matching all IPv6 addresses. May be specified
+multiple times. Required.
 .IP \(bu
 Endpoint \(em an endpoint IP or hostname, followed by a colon, and then a
 port number. This endpoint will be updated automatically to the most recent
@@ -152,7 +153,6 @@ when unspecified, this option is off. Most users will not need this. Optional.
 
 .SH CONFIGURATION FILE FORMAT EXAMPLE
 This example may be used as a model for writing configuration files.
-Note that not all keys are required.
 
     [Interface]
 .br

commit bf158a73fedafd0f24fb6433807fa7e5bdec402e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jan 4 07:05:56 2017 +0100

    wg: add bash completion for wg(8)
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 2d2ad03..5b72879 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -3,8 +3,10 @@ DESTDIR ?=
 BINDIR ?= $(PREFIX)/bin
 LIBDIR ?= $(PREFIX)/lib
 MANDIR ?= $(PREFIX)/share/man
+BASHCOMPDIR ?= $(PREFIX)/share/bash-completion/completions
 RUNSTATEDIR ?= /var/run
 PKG_CONFIG ?= pkg-config
+WITH_BASHCOMPLETION ?= yes
 
 CFLAGS ?= -O3
 CFLAGS += -std=gnu11
@@ -25,8 +27,9 @@ clean:
 	rm -f wg *.o *.d
 
 install: wg
-	install -v -d "$(DESTDIR)$(BINDIR)" && install -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"
-	install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -m 0644 -v wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
+	@install -v -d "$(DESTDIR)$(BINDIR)" && install -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"
+	@install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -m 0644 -v wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
+	@[ "$(WITH_BASHCOMPLETION)" = "yes" ] && install -v -d "$(BASHCOMPDIR)" && install -m 0644 -v completion/wg.bash-completion "$(DESTDIR)$(BASHCOMPDIR)/wg"
 
 check: clean
 	CFLAGS=-g scan-build --view --keep-going $(MAKE) wg
diff --git a/src/completion/wg.bash-completion b/src/completion/wg.bash-completion
new file mode 100644
index 0000000..76a832a
--- /dev/null
+++ b/src/completion/wg.bash-completion
@@ -0,0 +1,91 @@
+# Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
+_wg_completion() {
+	if [[ $COMP_CWORD -eq 1 ]]; then
+		COMPREPLY+=( $(compgen -W "show showconf set setconf addconf genkey genpsk pubkey" -- "${COMP_WORDS[1]}") )
+		return
+	fi
+	case "${COMP_WORDS[1]}" in
+		genkey|genpsk|pubkey|help) return; ;;
+		show|showconf|set|setconf|addconf) ;;
+		*) return;
+	esac
+
+	if [[ $COMP_CWORD -eq 2 ]]; then
+		local extra
+		[[ ${COMP_WORDS[1]} == show ]] && extra=" all interfaces"
+		COMPREPLY+=( $(compgen -W "$(wg show interfaces 2>/dev/null)$extra" -- "${COMP_WORDS[2]}") )
+		return
+	fi
+
+	if [[ $COMP_CWORD -eq 3 && ${COMP_WORDS[1]} == show && ${COMP_WORDS[2]} != interfaces ]]; then
+		COMPREPLY+=( $(compgen -W "public-key private-key preshared-key listen-port peers endpoints allowed-ips latest-handshakes persistent-keepalive transfer" -- "${COMP_WORDS[3]}") )
+		return
+	fi
+
+	if [[ $COMP_CWORD -eq 3 && ( ${COMP_WORDS[1]} == setconf || ${COMP_WORDS[1]} == addconf ) ]]; then
+		compopt -o filenames
+		COMPREPLY+=( $(compgen -f -- "${COMP_WORDS[3]}") )
+		return
+	fi
+
+	[[ ${COMP_WORDS[1]} == set ]] || return
+
+	local has_listen_port=0 has_private_key=0 has_preshared_key=0 has_peer=0 has_remove=0 has_endpoint=0 has_persistent_keepalive=0 has_allowed_ips=0 words=() i j
+	for ((i=3;i<COMP_CWORD;i+=2)); do
+		[[ ${COMP_WORDS[i]} == listen-port ]] && has_listen_port=1
+		[[ ${COMP_WORDS[i]} == private-key ]] && has_private_key=1
+		[[ ${COMP_WORDS[i]} == preshared-key ]] && has_preshared_key=1
+		[[ ${COMP_WORDS[i]} == peer ]] && { has_peer=$i; break; }
+	done
+	if [[ $has_peer -eq 0 ]]; then
+		if ((COMP_CWORD % 2 != 0)); then
+			[[ $has_listen_port -eq 1 ]] || words+=( listen-port )
+			[[ $has_private_key -eq 1 ]] || words+=( private-key )
+			[[ $has_preshared_key -eq 1 ]] || words+=( preshared-key )
+			words+=( peer )
+			COMPREPLY+=( $(compgen -W "${words[*]}" -- "${COMP_WORDS[COMP_CWORD]}") )
+		elif [[ ${COMP_WORDS[COMP_CWORD-1]} == *-key ]]; then
+			compopt -o filenames
+			COMPREPLY+=( $(compgen -f -- "${COMP_WORDS[COMP_CWORD]}") )
+		fi
+		return
+	fi
+
+	if [[ ${COMP_WORDS[COMP_CWORD-1]} == peer ]]; then
+		COMPREPLY+=( $(compgen -W "$(wg show "${COMP_WORDS[2]}" peers 2>/dev/null)" -- "${COMP_WORDS[COMP_CWORD]}") )
+		return
+	fi
+
+	for ((i=has_peer;i<COMP_CWORD;i++)); do
+		j=i
+		if [[ ${COMP_WORDS[i]} == peer ]]; then
+			has_remove=0
+			has_endpoint=0
+			has_persistent_keepalive=0
+			has_allowed_ips=0
+			[[ ${COMP_WORDS[i+2]} == = ]] && ((i+=2)) || ((i++))
+			continue
+		fi
+		[[ ${COMP_WORDS[i]} == remove ]] && has_remove=1
+		[[ ${COMP_WORDS[i]} == endpoint ]] && has_endpoint=1
+		[[ ${COMP_WORDS[i]} == persistent-keepalive ]] && has_persistent_keepalive=1
+		[[ ${COMP_WORDS[i]} == allowed-ips ]] && has_allowed_ips=1
+
+		[[ ${COMP_WORDS[i]} == remove ]] || ((i++))
+	done
+
+	((COMP_CWORD == j)) || return
+
+	if [[ $has_remove -ne 1 ]]; then
+		[[ $has_endpoint -eq 1 ]] || words+=( endpoint )
+		[[ $has_allowed_ips -eq 1 ]] || words+=( allowed-ips )
+		[[ $has_persistent_keepalive -eq 1 ]] || words+=( persistent-keepalive )
+		words+=( remove )
+	fi
+	words+=( peer )
+
+	COMPREPLY+=( $(compgen -W "${words[*]}" -- "${COMP_WORDS[COMP_CWORD]}") )
+}
+
+complete -o nosort -F _wg_completion wg

commit fd9e737c72fc7b41cb2a21a85fc05e0e543086e4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jan 3 05:23:17 2017 +0100

    contrib: slight ncat tweak
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/ncat-client-server/server.sh b/contrib/ncat-client-server/server.sh
index 2680afd..bb45718 100755
--- a/contrib/ncat-client-server/server.sh
+++ b/contrib/ncat-client-server/server.sh
@@ -12,6 +12,6 @@ if [[ -z $NCAT_REMOTE_ADDR ]]; then
 	exec ncat -e "$(readlink -f "$0")" -k -l -p 42912 -v
 fi
 read -r public_key
-[[ $(wg show wg0 | grep peer | wc -l) -ge 253 ]] && wg set wg0 peer $(wg show wg0 latest-handshakes | sort -k 2 -b -n | head -n 1 | cut -f 1) remove
+[[ $(wg show wg0 peers | wc -l) -ge 253 ]] && wg set wg0 peer $(wg show wg0 latest-handshakes | sort -k 2 -b -n | head -n 1 | cut -f 1) remove
 next_ip=$(all="$(wg show wg0 allowed-ips)"; for ((i=2; i<=254; i++)); do ip="192.168.4.$i"; [[ $all != *$ip/32* ]] && echo $ip && break; done)
 wg set wg0 peer "$public_key" allowed-ips $next_ip/32 2>/dev/null && echo "OK:$(wg show wg0 private-key | wg pubkey):$(wg show wg0 listen-port):$next_ip" || echo ERROR

commit ae82dcfed37dbc22b675b8ef9cc4473dcc84a1fa
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 30 17:53:05 2016 +0100

    wg: syscall.h should actually be sys/syscall.h
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/genkey.c b/src/genkey.c
index d029527..0bdcfbb 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -8,7 +8,7 @@
 #include <string.h>
 #include <fcntl.h>
 #ifdef __linux
-#include <syscall.h>
+#include <sys/syscall.h>
 #endif
 
 #include "curve25519.h"

commit 87abf354f17c0468491bb91146f0acdf0236d6d0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Dec 30 17:50:19 2016 +0100

    wg-config: use ip rules instead of tungate
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/wg-config/Makefile b/contrib/wg-config/Makefile
index aa81848..4fa264c 100644
--- a/contrib/wg-config/Makefile
+++ b/contrib/wg-config/Makefile
@@ -2,12 +2,10 @@ PREFIX ?= /usr
 DESTDIR ?=
 SBINDIR ?= $(PREFIX)/sbin
 
-SCRIPTS := wg-config tungate
-
 all:
-	@echo "These are shell scripts, so there is nothing to do. Try \"make install\" instead."
+	@echo "This is a shell script, so there is nothing to do. Try \"make install\" instead."
 
 install:
-	@install -v -m0755 -D -t$(DESTDIR)$(SBINDIR) $(SCRIPTS)
+	@install -v -m0755 -D -t$(DESTDIR)$(SBINDIR) wg-config
 
 .PHONY: all install
diff --git a/contrib/wg-config/README b/contrib/wg-config/README
index 2e594c6..93da029 100644
--- a/contrib/wg-config/README
+++ b/contrib/wg-config/README
@@ -43,17 +43,9 @@ options described above, and variables that may be declared in ENV_FILE:
 Additionally, ENV_FILE may define the bash functions pre_add, post_add,
 pre_del, and post_del, which will be called at their respective times.
 
+== Basic Example ==
 
-== Helper Tool ==
-
-tungate is a separate utility, developed originally not explicitly for
-WireGuard, which acts as a poor man's way of ensuring 0/1 and 128/1 default
-route overrides still work with an endpoint going over the original default
-route. It's quite handy, and wg-config makes use of it for dealing with
-0.0.0.0/0 routes. At the moment it only supports IPv4, but adding IPv6
-should be pretty easy.
-
-== Example ==
+This basic example might be used by a server.
 
 /etc/wireguard/wg-server.conf:
 
@@ -83,10 +75,14 @@ Run at startup:
 Run at shutdown:
 # wg-config del wgserver0 --env-file=/etc/wireguard/wg-server.env
 
-== Advanced Example ==
+== Single File Advanced Example ==
 
-/etc/wireguard/wg-vpn-gateway.conf:
+This type of configuration might be desirable for a personal access gateway
+VPN, connecting to a server like in the example above.
+
+/etc/wireguard/wg-vpn-gateway.env:
 
+	CONFIG_FILE_CONTENTS="
 	[Interface]
 	PrivateKey = 6JiA3fa+NG+x5m6aq7+lxlVaVqVf1mxK6/pDOZdNuXc=
 
@@ -94,11 +90,10 @@ Run at shutdown:
 	PublicKey = 6NagfTu+s8+TkEKpxX7pNjJuTf4zYtoJme7iQFYIw0A=
 	AllowedIPs = 0.0.0.0/0
 	Endpoint = demo.wireguard.io:29912
+	"
 
-/etc/wireguard/wg-vpn-gateway.env:
-
-	[[ $SUBCOMMAND == add ]] && CONFIG_FILE="$(dirname "${BASH_SOURCE[0]}")/demo-vpn.conf" || true
 	ADDRESSES=( 10.200.100.2/32 )
+
 	post_add() {
 		printf 'nameserver 10.200.100.1' | cmd resolvconf -a "$INTERFACE" -m 0
 	}
@@ -108,14 +103,18 @@ Run at shutdown:
 
 Run to flip on the VPN:
 # wg-config add wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
-The config file is not overwritten on shutdown, due to the conditional in the env file:
+Run to flip off the VPN:
 # wg-config del wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
 
-== Single File Advanced Example ==
+== Advanced Example ==
 
-/etc/wireguard/wg-vpn-gateway.env:
+This achieves the same as the above, but with an external file. It only sets the
+configuration file when the subcommand is add, to prevent it from being overwritten.
+The above is much simpler and probably preferred, but this example shows how powerful
+the tool can be.
+
+/etc/wireguard/wg-vpn-gateway.conf:
 
-	CONFIG_FILE_CONTENTS="
 	[Interface]
 	PrivateKey = 6JiA3fa+NG+x5m6aq7+lxlVaVqVf1mxK6/pDOZdNuXc=
 
@@ -123,10 +122,11 @@ The config file is not overwritten on shutdown, due to the conditional in the en
 	PublicKey = 6NagfTu+s8+TkEKpxX7pNjJuTf4zYtoJme7iQFYIw0A=
 	AllowedIPs = 0.0.0.0/0
 	Endpoint = demo.wireguard.io:29912
-	"
 
-	ADDRESSES=( 10.200.100.2/32 )
+/etc/wireguard/wg-vpn-gateway.env:
 
+	[[ $SUBCOMMAND == add ]] && CONFIG_FILE="$(dirname "${BASH_SOURCE[0]}")/demo-vpn.conf" || true
+	ADDRESSES=( 10.200.100.2/32 )
 	post_add() {
 		printf 'nameserver 10.200.100.1' | cmd resolvconf -a "$INTERFACE" -m 0
 	}
@@ -136,5 +136,5 @@ The config file is not overwritten on shutdown, due to the conditional in the en
 
 Run to flip on the VPN:
 # wg-config add wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
-Run to flip off the VPN:
+The config file is not overwritten on shutdown, due to the conditional in the env file:
 # wg-config del wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
diff --git a/contrib/wg-config/tungate b/contrib/wg-config/tungate
deleted file mode 100755
index 034e8b8..0000000
--- a/contrib/wg-config/tungate
+++ /dev/null
@@ -1,43 +0,0 @@
-#!/bin/bash
-
-unwind() {
-	ip route del "$1/32" 2>/dev/null
-	exit
-}
-
-short_route() {
-	ip route | sed -n "s/$1 \\(.* dev [^ ]\\+\\).*/\\1/p" | head -n 1
-}
-
-resolve_ip() {
-	local filter='/^[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}$/{p;q;}'
-	[[ $(sed -n "$filter" <<<"$1") == "$1" ]] && echo "$1" ||
-		host -t a "$1" | cut -d ' ' -f 4 | sed -n "$filter"
-}
-
-set_route() {
-	local default_route="$(short_route default)"
-	[[ -n $default_route ]] || { echo "[-] Could not determine default route"; return; }
-	echo "[+] Adding route for $1 to be $default_route"
-	ip route del "$1/32" 2>/dev/null
-	ip route add "$1/32" $default_route
-}
-
-check_loop() {
-	local ip="$(resolve_ip "$1")"
-	[[ -n $ip ]] || { echo "[-] Could not determine IP of '$1'" && return 1; }
-	echo "[+] Making sure $ip goes over the default (non-0/1,128/1) route"
-
-	set_route "$ip"
-	trap unwind INT TERM EXIT
-
-	while read -r; do
-		[[ $(short_route "$ip") != "$(short_route default)" ]] && set_route "$ip"
-	done < <(exec ip monitor route)
-}
-
-[[ $# -ne 1 ]] && { echo "Usage: $0 IP|HOST" >&2; exit 1; }
-[[ $UID -ne 0 ]] && exec sudo "$(readlink -f "$0")" "$@"
-
-check_loop "$1"
-exit $?
diff --git a/contrib/wg-config/wg-config b/contrib/wg-config/wg-config
index d6447eb..8d8d4e7 100755
--- a/contrib/wg-config/wg-config
+++ b/contrib/wg-config/wg-config
@@ -15,7 +15,7 @@ auto_su() {
 
 unwind() {
 	set +e
-	[[ -n $INTERFACE && -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] && cmd ip link delete dev "$INTERFACE"
+	[[ -n $INTERFACE && -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] && del_if
 	exit
 }
 
@@ -26,6 +26,9 @@ add_if() {
 
 del_if() {
 	[[ -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] || { echo "$PROGRAM: \`$INTERFACE' is not a WireGuard interface" >&2; exit 1; }
+	if [[ $(ip route show table all) =~ .*\ dev\ $INTERFACE\ table\ ([0-9]+)\ .* ]]; then
+		cmd ip rule delete table ${BASH_REMATCH[1]}
+	fi
 	cmd ip link delete dev "$INTERFACE"
 }
 
@@ -38,23 +41,20 @@ add_addr() {
 }
 
 add_route() {
-	cmd ip route add "$1" dev "$INTERFACE"
+	if [[ $1 == 0.0.0.0/0 || $1 == ::/0 ]]; then
+		add_default "$1"
+	else
+		cmd ip route add "$1" dev "$INTERFACE"
+	fi
 }
 
 add_default() {
-	if [[ $1 == ::/0 ]]; then
-		echo "tungate: does not yet support IPv6, skipping ::/0" >&2
-		return 0
-	elif [[ $1 == 0.0.0.0/0 ]]; then
-		local endpoint="$(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints) | sed -n 's/.* 0\.0\.0\.0\/0.* \([0-9.:\/a-z]\+\):[0-9]\+$/\1/p')"
-		add_route 0/1
-		add_route 128/1
-		killall tungate 2>/dev/null || true
-		echo "[&] Forking \`tungate' for $endpoint to background" >&2
-		tungate "$endpoint" >/dev/null 2>&1 & disown
-		return 0
-	fi
-	return 1
+	[[ $(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints)) =~ .*\ ${1//./\\.}\ ([0-9.:a-f]+):[0-9]+$ ]] && local endpoint="${BASH_REMATCH[1]}"
+	[[ -n $endpoint ]] || return 0
+	local table=51820
+	while [[ -n $(ip route show table $table) ]]; do ((table++)); done
+	cmd ip route add "$1" dev "$INTERFACE" table $table
+	cmd ip rule add not to "$endpoint" table $table
 }
 
 set_config() {
@@ -130,16 +130,12 @@ cmd_add() {
 	done
 	up_if
 	if [[ $AUTO_ROUTE -eq 1 ]]; then
-		for i in $(wg show "$INTERFACE" allowed-ips | grep -Po '(?<=[\t ])[0-9.:/a-z]+' | sort -nr -k 2 -t /); do
-			if ! add_default "$i" && [[ $(ip route get "$i") != *dev\ $INTERFACE\ * ]]; then
-				add_route "$i"
-			fi
+		for i in $(wg show "$INTERFACE" allowed-ips | grep -Po '(?<=[\t ])[0-9.:/a-f]+' | sort -nr -k 2 -t /); do
+			[[ $(ip route get "$i" 2>/dev/null) == *dev\ $INTERFACE\ * ]] || add_route "$i"
 		done
 	fi
 	for i in "${ADDITIONAL_ROUTES[@]}"; do
-		if ! add_default "$i"; then
-			add_route "$i"
-		fi
+		add_route "$i"
 	done
 	[[ $(type -t post_add) != function ]] || post_add
 	trap - INT TERM EXIT
@@ -148,7 +144,6 @@ cmd_add() {
 cmd_del() {
 	auto_su
 	[[ $(type -t pre_del) != function ]] || pre_del
-	killall tungate 2>/dev/null || true
 	[[ -n $CONFIG_FILE ]] && save_config
 	del_if
         [[ $(type -t post_del) != function ]] || post_del

commit 09c726a72fc726d7d33f49a0b710f0e65ea5e845
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Dec 25 21:01:06 2016 +0100

    external-tests: update to latest
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index b259212..0f65ec4 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -61,9 +61,12 @@ func main() {
 	tai64n := make([]byte, 12)
 	binary.BigEndian.PutUint64(tai64n[:], 4611686018427387914+uint64(now.Unix()))
 	binary.BigEndian.PutUint32(tai64n[8:], uint32(now.UnixNano()))
-	initiationPacket := make([]byte, 5)
-	initiationPacket[0] = 1                                 // Type: Initiation
-	binary.LittleEndian.PutUint32(initiationPacket[1:], 28) // Sender index: 28 (arbitrary)
+	initiationPacket := make([]byte, 8)
+	initiationPacket[0] = 1 // Type: Initiation
+	initiationPacket[1] = 0 // Reserved
+	initiationPacket[2] = 0	// Reserved
+	initiationPacket[3] = 0	// Reserved
+	binary.LittleEndian.PutUint32(initiationPacket[4:], 28) // Sender index: 28 (arbitrary)
 	initiationPacket, _, _ = hs.WriteMessage(initiationPacket, tai64n)
 	hasher, _ := blake2s.New(&blake2s.Config{Size: 16, Key: preshared})
 	hasher.Write(theirPublic)
@@ -75,7 +78,7 @@ func main() {
 	}
 
 	// read handshake response packet
-	responsePacket := make([]byte, 89)
+	responsePacket := make([]byte, 92)
 	n, err := conn.Read(responsePacket)
 	if err != nil {
 		log.Fatalf("error reading response packet: %s", err)
@@ -86,12 +89,15 @@ func main() {
 	if responsePacket[0] != 2 { // Type: Response
 		log.Fatalf("response packet type wrong: want %d, got %d", 2, responsePacket[0])
 	}
-	theirIndex := binary.LittleEndian.Uint32(responsePacket[1:])
-	ourIndex := binary.LittleEndian.Uint32(responsePacket[5:])
+	if responsePacket[1] != 0 || responsePacket[2] != 0 || responsePacket[3] != 0 {
+		log.Fatalf("response packet has non-zero reserved fields")
+	}
+	theirIndex := binary.LittleEndian.Uint32(responsePacket[4:])
+	ourIndex := binary.LittleEndian.Uint32(responsePacket[8:])
 	if ourIndex != 28 {
 		log.Fatalf("response packet index wrong: want %d, got %d", 28, ourIndex)
 	}
-	payload, sendCipher, receiveCipher, err := hs.ReadMessage(nil, responsePacket[9:57])
+	payload, sendCipher, receiveCipher, err := hs.ReadMessage(nil, responsePacket[12:60])
 	if err != nil {
 		log.Fatalf("error reading handshake message: %s", err)
 	}
@@ -120,10 +126,13 @@ func main() {
 	binary.BigEndian.PutUint16(pingHeader[2:], uint16(ipv4.HeaderLen+len(pingMessage))) // fix the length endianness on BSDs
 	pingData := append(pingHeader, pingMessage...)
 	binary.BigEndian.PutUint16(pingData[10:], ipChecksum(pingData))
-	pingPacket := make([]byte, 13)
+	pingPacket := make([]byte, 16)
 	pingPacket[0] = 4 // Type: Data
-	binary.LittleEndian.PutUint32(pingPacket[1:], theirIndex)
-	binary.LittleEndian.PutUint64(pingPacket[5:], 0) // Nonce
+	pingPacket[1] = 0 // Reserved
+	pingPacket[2] = 0 // Reserved
+	pingPacket[3] = 0 // Reserved
+	binary.LittleEndian.PutUint32(pingPacket[4:], theirIndex)
+	binary.LittleEndian.PutUint64(pingPacket[8:], 0) // Nonce
 	pingPacket = sendCipher.Encrypt(pingPacket, nil, pingData)
 	if _, err := conn.Write(pingPacket); err != nil {
 		log.Fatalf("error writing ping message: %s", err)
@@ -139,7 +148,10 @@ func main() {
 	if replyPacket[0] != 4 { // Type: Data
 		log.Fatalf("unexpected reply packet type: %d", replyPacket[0])
 	}
-	replyPacket, err = receiveCipher.Decrypt(nil, nil, replyPacket[13:])
+	if replyPacket[1] != 0 || replyPacket[2] != 0 || replyPacket[3] != 0 {
+		log.Fatalf("reply packet has non-zero reserved fields")
+	}
+	replyPacket, err = receiveCipher.Decrypt(nil, nil, replyPacket[16:])
 	if err != nil {
 		log.Fatalf("error decrypting reply packet: %s", err)
 	}
diff --git a/contrib/external-tests/haskell/src/Main.hs b/contrib/external-tests/haskell/src/Main.hs
index 20aeb2e..820e2f1 100644
--- a/contrib/external-tests/haskell/src/Main.hs
+++ b/contrib/external-tests/haskell/src/Main.hs
@@ -33,7 +33,7 @@ w :: PublicKey Curve25519
   -> ByteString
   -> IO ()
 w theirPub (Plaintext myPSK) sock addr msg = do
-  let x      = "\x01\x00\x00" `mappend` msg
+  let x      = "\x01\x00\x00\x00\x00\x00" `mappend` msg
       mac    = hash 16 myPSK (sbToBS' (curvePubToBytes theirPub) `mappend` sbToBS' x)
   void $ NBS.sendTo sock (x `mappend` mac `mappend` replicate 16 '\0') addr
 
@@ -41,7 +41,7 @@ r :: MVar ByteString -> Socket -> IO ByteString
 r smv sock = do
   (r, _) <- NBS.recvFrom sock 1024
   putMVar smv $ (take 2 . drop 1) r
-  return . take 48 . drop 5 $ r
+  return . take 48 . drop 8 $ r
 
 payload :: IO Plaintext
 payload = do
@@ -78,4 +78,4 @@ main = do
 
   let (keepAlive, encryption') = encryptPayload "" encryption
   senderindex <- takeMVar senderindexmv
-  void $ NBS.sendTo sock ("\x04" `mappend` senderindex `mappend` replicate 8 '\0' `mappend` keepAlive) addr
+  void $ NBS.sendTo sock ("\x04\x00\x00\x00" `mappend` senderindex `mappend` replicate 8 '\0' `mappend` keepAlive) addr
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index c5a78fe..c75cded 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -1,4 +1,5 @@
 /* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
 extern crate screech;
 extern crate crypto;
 extern crate time;
@@ -44,31 +45,40 @@ fn main() {
 	let mut tai64n = [0; 12];
 	BigEndian::write_i64(&mut tai64n[0..], 4611686018427387914ULL + now.sec);
 	BigEndian::write_i32(&mut tai64n[8..], now.nsec);
-	let mut initiation_packet = [0; 145];
+	let mut initiation_packet = [0; 148];
 	initiation_packet[0] = 1; /* Type: Initiation */
-	LittleEndian::write_u32(&mut initiation_packet[1..], 28); /* Sender index: 28 (arbitrary) */
-	handshake.write_message(&tai64n, &mut initiation_packet[5..]);
-	let mut mac_material = [0; 143];
+	initiation_packet[1] = 0; /* Reserved */
+	initiation_packet[2] = 0; /* Reserved */
+	initiation_packet[3] = 0; /* Reserved */
+	LittleEndian::write_u32(&mut initiation_packet[4..], 28); /* Sender index: 28 (arbitrary) */
+	handshake.write_message(&tai64n, &mut initiation_packet[8..]);
+	let mut mac_material = [0; 148];
 	memcpy(&mut mac_material, &their_public);
-	memcpy(&mut mac_material[32..], &initiation_packet[0..113]);
+	memcpy(&mut mac_material[32..], &initiation_packet[0..116]);
 	let mut mac = [0; 16];
 	Blake2s::blake2s(&mut mac, &mac_material, &my_preshared);
-	memcpy(&mut initiation_packet[113..], &mac);
+	memcpy(&mut initiation_packet[116..], &mac);
 	socket.send_to(&initiation_packet, &send_addr).unwrap();
 
-	let mut response_packet = [0; 89];
+	let mut response_packet = [0; 92];
 	socket.recv_from(&mut response_packet).unwrap();
 	assert!(response_packet[0] == 2 /* Type: Response */);
-	let their_index = LittleEndian::read_u32(&response_packet[1..]);
-	let our_index = LittleEndian::read_u32(&response_packet[5..]);
+	assert!(response_packet[1] == 0 /* Reserved */);
+	assert!(response_packet[2] == 0 /* Reserved */);
+	assert!(response_packet[3] == 0 /* Reserved */);
+	let their_index = LittleEndian::read_u32(&response_packet[4..]);
+	let our_index = LittleEndian::read_u32(&response_packet[8..]);
 	assert!(our_index == 28);
-	let (payload_len, last) = handshake.read_message(&response_packet[9..57], &mut empty_payload).unwrap();
+	let (payload_len, last) = handshake.read_message(&response_packet[12..60], &mut empty_payload).unwrap();
 	assert!(payload_len == 0 && last);
 
-	let mut keepalive_packet = [0; 29];
+	let mut keepalive_packet = [0; 32];
 	keepalive_packet[0] = 4; /* Type: Data */
-	LittleEndian::write_u32(&mut keepalive_packet[1..], their_index);
-	LittleEndian::write_u64(&mut keepalive_packet[5..], cipherstate1.n);
-	cipherstate1.encrypt(&empty_payload, &mut keepalive_packet[13..]); /* Empty payload means keepalive */
+	keepalive_packet[1] = 0; /* Reserved */
+	keepalive_packet[2] = 0; /* Reserved */
+	keepalive_packet[3] = 0; /* Reserved */
+	LittleEndian::write_u32(&mut keepalive_packet[4..], their_index);
+	LittleEndian::write_u64(&mut keepalive_packet[8..], cipherstate1.n);
+	cipherstate1.encrypt(&empty_payload, &mut keepalive_packet[16..]); /* Empty payload means keepalive */
 	socket.send_to(&keepalive_packet, &send_addr).unwrap();
 }

commit f3a1f15186d72e32aa8037d8f4fd5dd24c1e7e6a
Author: Tomasz Torcz <tomek@pipebreaker.pl>
Date:   Fri Dec 23 20:25:55 2016 +0100

    wg: rename 'bandwidth' to 'transfer' in output
    
    'bandwidth' is a measure of speed, but wg's output shows only the
    number of bytes transferred. Thus 'transfer' is a better label.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/show.c b/src/show.c
index 7c32af9..5257d43 100644
--- a/src/show.c
+++ b/src/show.c
@@ -203,7 +203,7 @@ static char *bytes(uint64_t b)
 static const char *COMMAND_NAME = NULL;
 static void show_usage(void)
 {
-	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | peers | endpoints | allowed-ips | latest-handshakes | bandwidth | persistent-keepalive]\n", PROG_NAME, COMMAND_NAME);
+	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | peers | endpoints | allowed-ips | latest-handshakes | transfer | persistent-keepalive]\n", PROG_NAME, COMMAND_NAME);
 }
 
 static void pretty_print(struct wgdevice *device)
@@ -239,7 +239,7 @@ static void pretty_print(struct wgdevice *device)
 		if (peer->last_handshake_time.tv_sec)
 			terminal_printf("  " TERMINAL_BOLD "latest handshake" TERMINAL_RESET ": %s\n", ago(&peer->last_handshake_time));
 		if (peer->rx_bytes || peer->tx_bytes) {
-			terminal_printf("  " TERMINAL_BOLD "bandwidth" TERMINAL_RESET ": ");
+			terminal_printf("  " TERMINAL_BOLD "transfer" TERMINAL_RESET ": ");
 			terminal_printf("%s received, ", bytes(peer->rx_bytes));
 			terminal_printf("%s sent\n", bytes(peer->tx_bytes));
 		}
@@ -298,7 +298,7 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 				printf("%s\t", device->interface);
 			printf("%s\t%llu\n", key(peer->public_key), (unsigned long long)peer->last_handshake_time.tv_sec);
 		}
-	} else if (!strcmp(param, "bandwidth")) {
+	} else if (!strcmp(param, "transfer")) {
 		for_each_wgpeer(device, peer, i) {
 			if (with_interface)
 				printf("%s\t", device->interface);
diff --git a/src/wg.8 b/src/wg.8
index 1ec7ec4..18edba3 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -36,7 +36,7 @@ Sub-commands that take an INTERFACE must be passed a WireGuard interface.
 .SH COMMANDS
 
 .TP
-\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fIbandwidth\fP]
+\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fItransfer\fP]
 Shows current WireGuard configuration of specified \fI<interface>\fP.
 If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
 If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,

commit f4cf3ae124651918aaa46528cb9b07a34f874f90
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Dec 21 06:15:57 2016 +0100

    wg-config: cleanups
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/wg-config/tungate b/contrib/wg-config/tungate
index b537b81..034e8b8 100755
--- a/contrib/wg-config/tungate
+++ b/contrib/wg-config/tungate
@@ -31,7 +31,7 @@ check_loop() {
 	set_route "$ip"
 	trap unwind INT TERM EXIT
 
-	while read; do
+	while read -r; do
 		[[ $(short_route "$ip") != "$(short_route default)" ]] && set_route "$ip"
 	done < <(exec ip monitor route)
 }
diff --git a/contrib/wg-config/wg-config b/contrib/wg-config/wg-config
index d7ea38c..d6447eb 100755
--- a/contrib/wg-config/wg-config
+++ b/contrib/wg-config/wg-config
@@ -1,7 +1,8 @@
 #!/bin/bash
 set -e -o pipefail
 
-export PATH="$(dirname "$(readlink -f "$0")"):$PATH"
+SELF="$(readlink -f "${BASH_SOURCE[0]}")"
+export PATH="${SELF%/*}:$PATH"
 
 cmd() {
 	echo "[#] $*" >&2
@@ -9,7 +10,7 @@ cmd() {
 }
 
 auto_su() {
-	[[ $UID != 0 ]] && exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$(readlink -f "$0")" "${ARGS[@]}" || true
+	[[ $UID == 0 ]] || exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$SELF" "${ARGS[@]}"
 }
 
 unwind() {
@@ -121,7 +122,7 @@ cmd_add() {
 	[[ -n $CONFIG_FILE || -n $CONFIG_FILE_CONTENTS ]] || { echo "$PROGRAM: --config is required for add subcommand" >&2; exit 1; }
 	auto_su
 	trap unwind INT TERM EXIT
-	[[ $(type -t pre_add) == function ]] && pre_add || true
+	[[ $(type -t pre_add) != function ]] || pre_add
 	add_if
 	set_config
 	for i in "${ADDRESSES[@]}"; do
@@ -140,17 +141,17 @@ cmd_add() {
 			add_route "$i"
 		fi
 	done
-	[[ $(type -t post_add) == function ]] && post_add || true
+	[[ $(type -t post_add) != function ]] || post_add
 	trap - INT TERM EXIT
 }
 
 cmd_del() {
 	auto_su
-	[[ $(type -t pre_del) == function ]] && pre_del || true
+	[[ $(type -t pre_del) != function ]] || pre_del
 	killall tungate 2>/dev/null || true
 	[[ -n $CONFIG_FILE ]] && save_config
 	del_if
-        [[ $(type -t post_del) == function ]] && post_del || true
+        [[ $(type -t post_del) != function ]] || post_del
 }
 
 declare INTERFACE="$2"

commit a488f1b08492e6bb6e6d23251e57edc5ba5616b2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Dec 20 21:50:29 2016 +0100

    wg: do not use AI_ADDRCONFIG
    
    Some people run wg(8) using hard coded v6 addresses before interfaces
    have v6 addresses, causing getaddrinfo to fail. Since AI_ADDRCONFIG
    doesn't actualy change the sorting, but just the queries made, we don't
    really need AI_ADDRCONFIG anyway, since we're always only taking the
    first result.
    
    Reported-by: Benedikt Morbach <benedikt.morbach@googlemail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 52acc78..50bc97c 100644
--- a/src/config.c
+++ b/src/config.c
@@ -128,8 +128,7 @@ static inline bool parse_endpoint(struct sockaddr_storage *endpoint, const char
 	struct addrinfo hints = {
 		.ai_family = AF_UNSPEC,
 		.ai_socktype = SOCK_DGRAM,
-		.ai_protocol = IPPROTO_UDP,
-		.ai_flags = AI_ADDRCONFIG
+		.ai_protocol = IPPROTO_UDP
 	};
 	if (!strlen(value)) {
 		free(mutable);

commit b5415c0b653deb38a4a3750cf28bf31ff2e1a710
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Dec 20 19:14:19 2016 +0100

    wg: allowed-ips is easier to parse with spaces instead of ", "
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/wg-config/wg-config b/contrib/wg-config/wg-config
index f2272b3..d7ea38c 100755
--- a/contrib/wg-config/wg-config
+++ b/contrib/wg-config/wg-config
@@ -129,7 +129,7 @@ cmd_add() {
 	done
 	up_if
 	if [[ $AUTO_ROUTE -eq 1 ]]; then
-		for i in $(wg show "$INTERFACE" allowed-ips | grep -Po '(?<=[\t ])[0-9.:/a-z]+(?<=,)?' | sort -nr -k 2 -t /); do
+		for i in $(wg show "$INTERFACE" allowed-ips | grep -Po '(?<=[\t ])[0-9.:/a-z]+' | sort -nr -k 2 -t /); do
 			if ! add_default "$i" && [[ $(ip route get "$i") != *dev\ $INTERFACE\ * ]]; then
 				add_route "$i"
 			fi
diff --git a/src/show.c b/src/show.c
index 624f789..7c32af9 100644
--- a/src/show.c
+++ b/src/show.c
@@ -288,7 +288,7 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 			printf("%s\t", key(peer->public_key));
 			if (peer->num_ipmasks) {
 				for_each_wgipmask(peer, ipmask, j)
-					printf("%s/%u%s", ip(ipmask), ipmask->cidr, j == (size_t)peer->num_ipmasks - 1 ? "\n" : ", ");
+					printf("%s/%u%c", ip(ipmask), ipmask->cidr, j == (size_t)peer->num_ipmasks - 1 ? '\n' : ' ');
 			} else
 				printf("(none)\n");
 		}

commit 50e1f58fde7d54a4ff640a8361632cd5b646e57d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Dec 20 04:08:41 2016 +0100

    wg-config: cleanup ip parsing
    
    This also sorts routes by cidr.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/wg-config/wg-config b/contrib/wg-config/wg-config
index eaa45f2..f2272b3 100755
--- a/contrib/wg-config/wg-config
+++ b/contrib/wg-config/wg-config
@@ -45,7 +45,7 @@ add_default() {
 		echo "tungate: does not yet support IPv6, skipping ::/0" >&2
 		return 0
 	elif [[ $1 == 0.0.0.0/0 ]]; then
-		local endpoint="$(wg show "$INTERFACE" endpoints | grep "^$(wg show "$INTERFACE" allowed-ips | grep 0.0.0.0/0 | head -n 1 | cut -f 1)" | cut -f 2 | cut -d : -f 1)"
+		local endpoint="$(join <(wg show "$INTERFACE" allowed-ips) <(wg show "$INTERFACE" endpoints) | sed -n 's/.* 0\.0\.0\.0\/0.* \([0-9.:\/a-z]\+\):[0-9]\+$/\1/p')"
 		add_route 0/1
 		add_route 128/1
 		killall tungate 2>/dev/null || true
@@ -129,7 +129,7 @@ cmd_add() {
 	done
 	up_if
 	if [[ $AUTO_ROUTE -eq 1 ]]; then
-		for i in $(wg show "$INTERFACE" allowed-ips | cut -f 2 | tr -d ,); do
+		for i in $(wg show "$INTERFACE" allowed-ips | grep -Po '(?<=[\t ])[0-9.:/a-z]+(?<=,)?' | sort -nr -k 2 -t /); do
 			if ! add_default "$i" && [[ $(ip route get "$i") != *dev\ $INTERFACE\ * ]]; then
 				add_route "$i"
 			fi

commit 187bf98339e49f74b72fba73d406c2b4bfd46190
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Dec 14 22:18:29 2016 +0100

    wg: fix latest-handshake typo in documentation
    
    Reported-by: Dan Ldtke <mail@danrl.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/show.c b/src/show.c
index ec92098..624f789 100644
--- a/src/show.c
+++ b/src/show.c
@@ -203,7 +203,7 @@ static char *bytes(uint64_t b)
 static const char *COMMAND_NAME = NULL;
 static void show_usage(void)
 {
-	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | peers | endpoints | allowed-ips | latest-handshake | bandwidth | persistent-keepalive]\n", PROG_NAME, COMMAND_NAME);
+	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | peers | endpoints | allowed-ips | latest-handshakes | bandwidth | persistent-keepalive]\n", PROG_NAME, COMMAND_NAME);
 }
 
 static void pretty_print(struct wgdevice *device)
diff --git a/src/wg.8 b/src/wg.8
index 4e7e4c2..1ec7ec4 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -36,7 +36,7 @@ Sub-commands that take an INTERFACE must be passed a WireGuard interface.
 .SH COMMANDS
 
 .TP
-\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshake\fP | \fIpersistent-keepalive\fP | \fIbandwidth\fP]
+\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshakes\fP | \fIpersistent-keepalive\fP | \fIbandwidth\fP]
 Shows current WireGuard configuration of specified \fI<interface>\fP.
 If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
 If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,

commit f03aea75744537c2c26f7322216681620d578b5d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Dec 8 16:13:25 2016 +0100

    contrib: add wg-config
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/wg-config/Makefile b/contrib/wg-config/Makefile
new file mode 100644
index 0000000..aa81848
--- /dev/null
+++ b/contrib/wg-config/Makefile
@@ -0,0 +1,13 @@
+PREFIX ?= /usr
+DESTDIR ?=
+SBINDIR ?= $(PREFIX)/sbin
+
+SCRIPTS := wg-config tungate
+
+all:
+	@echo "These are shell scripts, so there is nothing to do. Try \"make install\" instead."
+
+install:
+	@install -v -m0755 -D -t$(DESTDIR)$(SBINDIR) $(SCRIPTS)
+
+.PHONY: all install
diff --git a/contrib/wg-config/README b/contrib/wg-config/README
new file mode 100644
index 0000000..2e594c6
--- /dev/null
+++ b/contrib/wg-config/README
@@ -0,0 +1,140 @@
+== Installation ==
+
+    # make install
+
+== Usage ==
+
+wg-config is a very simple utility for adding and configuring WireGuard
+interfaces using ip(8) and wg(8).
+
+Usage: wg-config [ add | del ] INTERFACE [arguments...]
+
+  wg-config add INTERFACE --config=CONFIG_FILE [--address=ADDRESS/CIDR...]
+               [--route=ROUTE/CIDR...] [--no-auto-route-from-allowed-ips]
+               [--env-file=ENV_FILE]
+
+    The add subcommand adds a new WireGuard interface, INTERFACE, replacing
+    any existing interfaces of the same name. The --config argument is
+    required, and its argument is passed to wg(8)'s setconf subcommand. The
+    --address argument(s) is recommended for this utility to be useful. The
+    --route argument is purely optional, as by default this utility will
+    automatically add routes implied by --address and as implied by the
+    allowed-ip entries inside the --config file. To disable this automatic
+    route adding, you may use the option entitled --no-auto-route-from-allowed-ips.
+
+  wg-config del INTERFACE [--config=CONFIG_FILE_TO_SAVE] [--env-file=ENV_FILE]
+
+    The del subcommand removes an existing WireGuard interface. If the
+    optional --config is specified, then the existing configuration is
+    written out to the file specified, via wg(8)'s showconf subcommand.
+
+Both `add' and del' take the --env-file=ENV_FILE option. If specified,
+the contents of ENV_FILE are imported into wg-config. This can be used to
+set variables in a file, instead of needing to pass them on the command
+line. The following table shows the relation between the command line
+options described above, and variables that may be declared in ENV_FILE:
+
+  --address=A, --address=B, --address=C       ADDRESSES=( "A" "B" "C" )
+  --route=A, --route=B, --route=C             ADDITIONAL_ROUTES=( "A" "B" "C" )
+  --config-file=F                             CONFIG_FILE="F"
+  echo C > /tmp/F, --config-file=/tmp/F       CONFIG_FILE_CONTENTS="C"
+  --no-auto-route-from-allowed-ips            AUTO_ROUTE=0
+
+Additionally, ENV_FILE may define the bash functions pre_add, post_add,
+pre_del, and post_del, which will be called at their respective times.
+
+
+== Helper Tool ==
+
+tungate is a separate utility, developed originally not explicitly for
+WireGuard, which acts as a poor man's way of ensuring 0/1 and 128/1 default
+route overrides still work with an endpoint going over the original default
+route. It's quite handy, and wg-config makes use of it for dealing with
+0.0.0.0/0 routes. At the moment it only supports IPv4, but adding IPv6
+should be pretty easy.
+
+== Example ==
+
+/etc/wireguard/wg-server.conf:
+
+	[Interface]
+	PrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=
+	ListenPort = 41414
+
+	[Peer]
+	PublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=
+	AllowedIPs = 10.192.122.3/32, 10.192.124.1/24
+
+	[Peer]
+	PublicKey = TrMvSoP4jYQlY6RIzBgbssQqY3vxI2Pi+y71lOWWXX0=
+	AllowedIPs = 10.192.122.4/32, 192.168.0.0/16
+
+	[Peer]
+	PublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA=
+	AllowedIPs = 10.10.10.230/32
+
+/etc/wireguard/wg-server.env:
+
+	CONFIG_FILE="$(dirname "${BASH_SOURCE[0]}")/wg-server.conf"
+	ADDRESSES=( 10.192.122.1/34 10.10.0.1/16 )
+
+Run at startup:
+# wg-config add wgserver0 --env-file=/etc/wireguard/wg-server.env
+Run at shutdown:
+# wg-config del wgserver0 --env-file=/etc/wireguard/wg-server.env
+
+== Advanced Example ==
+
+/etc/wireguard/wg-vpn-gateway.conf:
+
+	[Interface]
+	PrivateKey = 6JiA3fa+NG+x5m6aq7+lxlVaVqVf1mxK6/pDOZdNuXc=
+
+	[Peer]
+	PublicKey = 6NagfTu+s8+TkEKpxX7pNjJuTf4zYtoJme7iQFYIw0A=
+	AllowedIPs = 0.0.0.0/0
+	Endpoint = demo.wireguard.io:29912
+
+/etc/wireguard/wg-vpn-gateway.env:
+
+	[[ $SUBCOMMAND == add ]] && CONFIG_FILE="$(dirname "${BASH_SOURCE[0]}")/demo-vpn.conf" || true
+	ADDRESSES=( 10.200.100.2/32 )
+	post_add() {
+		printf 'nameserver 10.200.100.1' | cmd resolvconf -a "$INTERFACE" -m 0
+	}
+	post_del() {
+		cmd resolvconf -d "$INTERFACE"
+	}
+
+Run to flip on the VPN:
+# wg-config add wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
+The config file is not overwritten on shutdown, due to the conditional in the env file:
+# wg-config del wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
+
+== Single File Advanced Example ==
+
+/etc/wireguard/wg-vpn-gateway.env:
+
+	CONFIG_FILE_CONTENTS="
+	[Interface]
+	PrivateKey = 6JiA3fa+NG+x5m6aq7+lxlVaVqVf1mxK6/pDOZdNuXc=
+
+	[Peer]
+	PublicKey = 6NagfTu+s8+TkEKpxX7pNjJuTf4zYtoJme7iQFYIw0A=
+	AllowedIPs = 0.0.0.0/0
+	Endpoint = demo.wireguard.io:29912
+	"
+
+	ADDRESSES=( 10.200.100.2/32 )
+
+	post_add() {
+		printf 'nameserver 10.200.100.1' | cmd resolvconf -a "$INTERFACE" -m 0
+	}
+	post_del() {
+		cmd resolvconf -d "$INTERFACE"
+	}
+
+Run to flip on the VPN:
+# wg-config add wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
+Run to flip off the VPN:
+# wg-config del wgvpn0 --env-file=/etc/wireguard/wg-vpn-gateway.env
diff --git a/contrib/wg-config/tungate b/contrib/wg-config/tungate
new file mode 100755
index 0000000..b537b81
--- /dev/null
+++ b/contrib/wg-config/tungate
@@ -0,0 +1,43 @@
+#!/bin/bash
+
+unwind() {
+	ip route del "$1/32" 2>/dev/null
+	exit
+}
+
+short_route() {
+	ip route | sed -n "s/$1 \\(.* dev [^ ]\\+\\).*/\\1/p" | head -n 1
+}
+
+resolve_ip() {
+	local filter='/^[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}$/{p;q;}'
+	[[ $(sed -n "$filter" <<<"$1") == "$1" ]] && echo "$1" ||
+		host -t a "$1" | cut -d ' ' -f 4 | sed -n "$filter"
+}
+
+set_route() {
+	local default_route="$(short_route default)"
+	[[ -n $default_route ]] || { echo "[-] Could not determine default route"; return; }
+	echo "[+] Adding route for $1 to be $default_route"
+	ip route del "$1/32" 2>/dev/null
+	ip route add "$1/32" $default_route
+}
+
+check_loop() {
+	local ip="$(resolve_ip "$1")"
+	[[ -n $ip ]] || { echo "[-] Could not determine IP of '$1'" && return 1; }
+	echo "[+] Making sure $ip goes over the default (non-0/1,128/1) route"
+
+	set_route "$ip"
+	trap unwind INT TERM EXIT
+
+	while read; do
+		[[ $(short_route "$ip") != "$(short_route default)" ]] && set_route "$ip"
+	done < <(exec ip monitor route)
+}
+
+[[ $# -ne 1 ]] && { echo "Usage: $0 IP|HOST" >&2; exit 1; }
+[[ $UID -ne 0 ]] && exec sudo "$(readlink -f "$0")" "$@"
+
+check_loop "$1"
+exit $?
diff --git a/contrib/wg-config/wg-config b/contrib/wg-config/wg-config
new file mode 100755
index 0000000..eaa45f2
--- /dev/null
+++ b/contrib/wg-config/wg-config
@@ -0,0 +1,187 @@
+#!/bin/bash
+set -e -o pipefail
+
+export PATH="$(dirname "$(readlink -f "$0")"):$PATH"
+
+cmd() {
+	echo "[#] $*" >&2
+	"$@"
+}
+
+auto_su() {
+	[[ $UID != 0 ]] && exec sudo -p "$PROGRAM must be run as root. Please enter the password for %u to continue: " "$(readlink -f "$0")" "${ARGS[@]}" || true
+}
+
+unwind() {
+	set +e
+	[[ -n $INTERFACE && -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] && cmd ip link delete dev "$INTERFACE"
+	exit
+}
+
+add_if() {
+	ip link delete dev "$INTERFACE" 2>/dev/null || true
+	cmd ip link add "$INTERFACE" type wireguard
+}
+
+del_if() {
+	[[ -n $(ip link show dev "$INTERFACE" type wireguard 2>/dev/null) ]] || { echo "$PROGRAM: \`$INTERFACE' is not a WireGuard interface" >&2; exit 1; }
+	cmd ip link delete dev "$INTERFACE"
+}
+
+up_if() {
+	cmd ip link set "$INTERFACE" up
+}
+
+add_addr() {
+	cmd ip address add "$1" dev "$INTERFACE"
+}
+
+add_route() {
+	cmd ip route add "$1" dev "$INTERFACE"
+}
+
+add_default() {
+	if [[ $1 == ::/0 ]]; then
+		echo "tungate: does not yet support IPv6, skipping ::/0" >&2
+		return 0
+	elif [[ $1 == 0.0.0.0/0 ]]; then
+		local endpoint="$(wg show "$INTERFACE" endpoints | grep "^$(wg show "$INTERFACE" allowed-ips | grep 0.0.0.0/0 | head -n 1 | cut -f 1)" | cut -f 2 | cut -d : -f 1)"
+		add_route 0/1
+		add_route 128/1
+		killall tungate 2>/dev/null || true
+		echo "[&] Forking \`tungate' for $endpoint to background" >&2
+		tungate "$endpoint" >/dev/null 2>&1 & disown
+		return 0
+	fi
+	return 1
+}
+
+set_config() {
+	if [[ -n $CONFIG_FILE_CONTENTS ]]; then
+		cmd wg setconf "$INTERFACE" <(echo "$CONFIG_FILE_CONTENTS")
+	else
+		cmd wg setconf "$INTERFACE" "$CONFIG_FILE"
+	fi
+}
+
+save_config() {
+	local old_umask="$(umask)"
+	umask 077
+	cmd wg showconf "$INTERFACE" > "$CONFIG_FILE.tmp" || { rm -f "$CONFIG_FILE.tmp"; exit 1; }
+	mv "$CONFIG_FILE.tmp" "$CONFIG_FILE" || { rm -f "$CONFIG_FILE.tmp"; exit 1; }
+	umask "$old_umask"
+}
+
+cmd_usage() {
+	cat >&2 <<-_EOF
+	Usage: $PROGRAM [ add | del ] INTERFACE [arguments...]
+
+	  $PROGRAM add INTERFACE --config=CONFIG_FILE [--address=ADDRESS/CIDR...]
+	               [--route=ROUTE/CIDR...] [--no-auto-route-from-allowed-ips]
+	               [--env-file=ENV_FILE]
+
+	    The add subcommand adds a new WireGuard interface, INTERFACE, replacing
+	    any existing interfaces of the same name. The --config argument is
+	    required, and its argument is passed to wg(8)'s setconf subcommand. The
+	    --address argument(s) is recommended for this utility to be useful. The
+	    --route argument is purely optional, as by default this utility will
+	    automatically add routes implied by --address and as implied by the
+	    allowed-ip entries inside the --config file. To disable this automatic
+	    route adding, you may use the option entitled --no-auto-route-from-allowed-ips.
+
+	  $PROGRAM del INTERFACE [--config=CONFIG_FILE_TO_SAVE] [--env-file=ENV_FILE]
+
+	    The del subcommand removes an existing WireGuard interface. If the
+	    optional --config is specified, then the existing configuration is
+	    written out to the file specified, via wg(8)'s showconf subcommand.
+
+	  $PROGRAM help
+
+	    Show this message.
+
+	Both \`add' and ``del' take the --env-file=ENV_FILE option. If specified,
+	the contents of ENV_FILE are imported into $PROGRAM. This can be used to
+	set variables in a file, instead of needing to pass them on the command
+	line. The following table shows the relation between the command line
+	options described above, and variables that may be declared in ENV_FILE:
+
+	  --address=A, --address=B, --address=C       ADDRESSES=( "A" "B" "C" )
+	  --route=A, --route=B, --route=C             ADDITIONAL_ROUTES=( "A" "B" "C" )
+	  --config-file=F                             CONFIG_FILE="F"
+	  echo C > /tmp/F, --config-file=/tmp/F       CONFIG_FILE_CONTENTS="C"
+	  --no-auto-route-from-allowed-ips            AUTO_ROUTE=0
+
+	Additionally, ENV_FILE may define the bash functions pre_add, post_add,
+	pre_del, and post_del, which will be called at their respective times.
+	_EOF
+}
+
+cmd_add() {
+	local i
+	[[ -n $CONFIG_FILE || -n $CONFIG_FILE_CONTENTS ]] || { echo "$PROGRAM: --config is required for add subcommand" >&2; exit 1; }
+	auto_su
+	trap unwind INT TERM EXIT
+	[[ $(type -t pre_add) == function ]] && pre_add || true
+	add_if
+	set_config
+	for i in "${ADDRESSES[@]}"; do
+		add_addr "$i"
+	done
+	up_if
+	if [[ $AUTO_ROUTE -eq 1 ]]; then
+		for i in $(wg show "$INTERFACE" allowed-ips | cut -f 2 | tr -d ,); do
+			if ! add_default "$i" && [[ $(ip route get "$i") != *dev\ $INTERFACE\ * ]]; then
+				add_route "$i"
+			fi
+		done
+	fi
+	for i in "${ADDITIONAL_ROUTES[@]}"; do
+		if ! add_default "$i"; then
+			add_route "$i"
+		fi
+	done
+	[[ $(type -t post_add) == function ]] && post_add || true
+	trap - INT TERM EXIT
+}
+
+cmd_del() {
+	auto_su
+	[[ $(type -t pre_del) == function ]] && pre_del || true
+	killall tungate 2>/dev/null || true
+	[[ -n $CONFIG_FILE ]] && save_config
+	del_if
+        [[ $(type -t post_del) == function ]] && post_del || true
+}
+
+declare INTERFACE="$2"
+declare SUBCOMMAND="$1"
+declare -a ADDRESSES
+declare -a ADDITIONAL_ROUTES
+declare AUTO_ROUTE=1
+declare CONFIG_FILE
+declare CONFIG_FILE_CONTENTS
+declare PROGRAM="${0##*/}"
+declare -a ARGS=( "$@" )
+
+[[ -n $INTERFACE && -n $SUBCOMMAND ]] || { cmd_usage; exit 1; }
+
+shift 2
+
+for arg; do
+	case "$arg" in
+	--env-file=*) source "${arg#*=}" ;;
+	--config=*) CONFIG_FILE="${arg#*=}" ;;
+	--address=*) ADDRESSES+=( ${arg#*=} ) ;;
+	--route=*) ADDITIONAL_ROUTES+=( ${arg#*=} ) ;;
+	--no-auto-route-from-allowed-ips) AUTO_ROUTE=0 ;;
+	*) cmd_usage; exit 1 ;;
+	esac
+done
+
+case "$SUBCOMMAND" in
+add) cmd_add ;;
+del) cmd_del ;;
+*) cmd_usage; exit 1 ;;
+esac
+
+exit 0

commit 9707e5d6af40320a854ef86f806ca588bdd2f0eb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Nov 29 13:38:59 2016 +0100

    wg: warn about clock going backward
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/show.c b/src/show.c
index c734152..ec92098 100644
--- a/src/show.c
+++ b/src/show.c
@@ -144,15 +144,15 @@ static size_t pretty_time(char *buf, const size_t len, unsigned long long left)
 	seconds = left % 60;
 
 	if (years)
-		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN "year%s" TERMINAL_RESET, offset ? ", " : "", years, years == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN "year%s" TERMINAL_RESET, offset ? ", " : "", years, years == 1 ? "" : "s");
 	if (days)
-		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN  "day%s" TERMINAL_RESET, offset ? ", " : "", days, days == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN  "day%s" TERMINAL_RESET, offset ? ", " : "", days, days == 1 ? "" : "s");
 	if (hours)
-		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN  "hour%s" TERMINAL_RESET, offset ? ", " : "", hours, hours == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN  "hour%s" TERMINAL_RESET, offset ? ", " : "", hours, hours == 1 ? "" : "s");
 	if (minutes)
-		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN "minute%s" TERMINAL_RESET, offset ? ", " : "", minutes, minutes == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN "minute%s" TERMINAL_RESET, offset ? ", " : "", minutes, minutes == 1 ? "" : "s");
 	if (seconds)
-		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN  "second%s" TERMINAL_RESET, offset ? ", " : "", seconds, seconds == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset - 1, "%s%llu " TERMINAL_FG_CYAN  "second%s" TERMINAL_RESET, offset ? ", " : "", seconds, seconds == 1 ? "" : "s");
 
 	return offset;
 }
@@ -161,12 +161,16 @@ static char *ago(const struct timeval *t)
 {
 	static char buf[1024];
 	size_t offset;
+	time_t now = time(NULL);
 
-	offset = pretty_time(buf, sizeof(buf), time(NULL) - t->tv_sec);
-	if (offset)
-		snprintf(buf + offset, sizeof(buf) - offset, " ago");
-	else
-		snprintf(buf, sizeof(buf), "Now");
+	if (now == t->tv_sec)
+		strncpy(buf, "Now", sizeof(buf) - 1);
+	else if (now < t->tv_sec)
+		strncpy(buf, "(" TERMINAL_FG_RED "System clock wound backward; connection problems may ensue." TERMINAL_RESET ")", sizeof(buf) - 1);
+	else {
+		offset = pretty_time(buf, sizeof(buf), now - t->tv_sec);
+		strncpy(buf + offset, " ago", sizeof(buf) - offset - 1);
+	}
 
 	return buf;
 }
@@ -174,7 +178,7 @@ static char *ago(const struct timeval *t)
 static char *every(uint16_t seconds)
 {
 	static char buf[1024] = "every ";
-	pretty_time(buf + strlen("every "), sizeof(buf) - strlen("every "), seconds);
+	pretty_time(buf + strlen("every "), sizeof(buf) - strlen("every ") - 1, seconds);
 	return buf;
 }
 
@@ -183,15 +187,15 @@ static char *bytes(uint64_t b)
 	static char buf[1024];
 
 	if (b < 1024ULL)
-		snprintf(buf, sizeof(buf), "%u " TERMINAL_FG_CYAN "B" TERMINAL_RESET, (unsigned)b);
+		snprintf(buf, sizeof(buf) - 1, "%u " TERMINAL_FG_CYAN "B" TERMINAL_RESET, (unsigned)b);
 	else if (b < 1024ULL * 1024ULL)
-		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "KiB" TERMINAL_RESET, (double)b / 1024);
+		snprintf(buf, sizeof(buf) - 1, "%.2f " TERMINAL_FG_CYAN "KiB" TERMINAL_RESET, (double)b / 1024);
 	else if (b < 1024ULL * 1024ULL * 1024ULL)
-		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "MiB" TERMINAL_RESET, (double)b / (1024 * 1024));
+		snprintf(buf, sizeof(buf) - 1, "%.2f " TERMINAL_FG_CYAN "MiB" TERMINAL_RESET, (double)b / (1024 * 1024));
 	else if (b < 1024ULL * 1024ULL * 1024ULL * 1024ULL)
-		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "GiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024));
+		snprintf(buf, sizeof(buf) - 1, "%.2f " TERMINAL_FG_CYAN "GiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024));
 	else
-		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "TiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024) / 1024);
+		snprintf(buf, sizeof(buf) - 1, "%.2f " TERMINAL_FG_CYAN "TiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024) / 1024);
 
 	return buf;
 }

commit 16a6972bb60d3aded954945e8b8c8cf4e002b73c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Nov 18 06:22:00 2016 +0100

    headers: cleanup notices
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index c1aa293..b259212 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 package main
 
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index 73e19b3..c5a78fe 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 extern crate screech;
 extern crate crypto;
 extern crate time;
diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index 7852dcf..4c0e9b4 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -1,3 +1,5 @@
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
 struct def {
 	const char *name;
 	long long value;
diff --git a/contrib/extract-keys/extract-keys.c b/contrib/extract-keys/extract-keys.c
index 5d7de32..335f962 100644
--- a/contrib/extract-keys/extract-keys.c
+++ b/contrib/extract-keys/extract-keys.c
@@ -1,3 +1,5 @@
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
 #include <endian.h>
 #include <errno.h>
 #include <fcntl.h>
diff --git a/contrib/nat-hole-punching/nat-punch-client.c b/contrib/nat-hole-punching/nat-punch-client.c
index a72b5f6..6d0b5f1 100644
--- a/contrib/nat-hole-punching/nat-punch-client.c
+++ b/contrib/nat-hole-punching/nat-punch-client.c
@@ -1,3 +1,5 @@
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
 /* Example only. Do not run in production. */
 
 #include <stdio.h>
diff --git a/contrib/nat-hole-punching/nat-punch-server.c b/contrib/nat-hole-punching/nat-punch-server.c
index 198e0f8..425885e 100644
--- a/contrib/nat-hole-punching/nat-punch-server.c
+++ b/contrib/nat-hole-punching/nat-punch-server.c
@@ -1,3 +1,5 @@
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
 /* Example only. Do not run in production. */
 
 #include <stdio.h>
diff --git a/contrib/ncat-client-server/client.sh b/contrib/ncat-client-server/client.sh
index ab9fe88..e59d9ce 100755
--- a/contrib/ncat-client-server/client.sh
+++ b/contrib/ncat-client-server/client.sh
@@ -1,4 +1,7 @@
 #!/bin/bash
+
+# Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
 set -e
 [[ $UID == 0 ]] || { echo "You must be root to run this."; exit 1; }
 umask 077
diff --git a/contrib/ncat-client-server/server.sh b/contrib/ncat-client-server/server.sh
index e37861f..2680afd 100755
--- a/contrib/ncat-client-server/server.sh
+++ b/contrib/ncat-client-server/server.sh
@@ -1,4 +1,7 @@
 #!/bin/bash
+
+# Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
 if [[ -z $NCAT_REMOTE_ADDR ]]; then
 	ip link del dev wg0 2>/dev/null
 	set -e
diff --git a/contrib/synergy/synergy-client.sh b/contrib/synergy/synergy-client.sh
index 56cfdb2..07b32d3 100755
--- a/contrib/synergy/synergy-client.sh
+++ b/contrib/synergy/synergy-client.sh
@@ -1,4 +1,7 @@
 #!/bin/bash
+
+# Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
 set -ex
 if [[ $UID == 0 ]]; then
 	ip link del dev synergy || true
diff --git a/contrib/synergy/synergy-server.sh b/contrib/synergy/synergy-server.sh
index 6bef423..ac028ba 100755
--- a/contrib/synergy/synergy-server.sh
+++ b/contrib/synergy/synergy-server.sh
@@ -1,4 +1,7 @@
 #!/bin/bash
+
+# Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+
 set -ex
 if [[ $UID == 0 ]]; then
 	ip link del dev synergy || true
diff --git a/src/base64.h b/src/base64.h
index 5cc94e1..748b5d9 100644
--- a/src/base64.h
+++ b/src/base64.h
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef BASE64_H
 #define BASE64_H
diff --git a/src/config.c b/src/config.c
index 860845e..52acc78 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 
 #include <arpa/inet.h>
diff --git a/src/config.h b/src/config.h
index 268e3f6..9338c72 100644
--- a/src/config.h
+++ b/src/config.h
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef CONFIG_H
 #define CONFIG_H
diff --git a/src/curve25519.c b/src/curve25519.c
index 3d0b615..3c147c8 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -1,7 +1,7 @@
 /* Original author: Adam Langley <agl@imperialviolet.org>
  *
  * Copyright 2008 Google Inc. All Rights Reserved.
- * Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
  *
  *   Redistribution and use in source and binary forms of this file, with or
  *   without modification, are permitted provided that the following conditions
diff --git a/src/curve25519.h b/src/curve25519.h
index 0be59b7..45ae1ce 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef CURVE25519_H
 #define CURVE25519_H
diff --git a/src/genkey.c b/src/genkey.c
index af2765f..d029527 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <errno.h>
 #include <stdio.h>
diff --git a/src/ipc.c b/src/ipc.c
index 3b96e6a..c8ca431 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifdef __linux__
 #include <libmnl/libmnl.h>
diff --git a/src/ipc.h b/src/ipc.h
index 9cb9db2..9571ff9 100644
--- a/src/ipc.h
+++ b/src/ipc.h
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef IPC_H
 #define IPC_H
diff --git a/src/pubkey.c b/src/pubkey.c
index 452c8fa..d61df03 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <errno.h>
 #include <resolv.h>
diff --git a/src/set.c b/src/set.c
index 65f3ff6..236504b 100644
--- a/src/set.c
+++ b/src/set.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/src/setconf.c b/src/setconf.c
index a3105e1..4de6117 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <stddef.h>
 #include <stdio.h>
diff --git a/src/show.c b/src/show.c
index 05a8e3e..c734152 100644
--- a/src/show.c
+++ b/src/show.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <arpa/inet.h>
 #include <inttypes.h>
diff --git a/src/showconf.c b/src/showconf.c
index 75d78e0..f04caa1 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <arpa/inet.h>
 #include <netinet/in.h>
diff --git a/src/subcommands.h b/src/subcommands.h
index 8351f8f..5da0226 100644
--- a/src/subcommands.h
+++ b/src/subcommands.h
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef SUBCOMMANDS_H
 #define SUBCOMMANDS_H
diff --git a/src/terminal.c b/src/terminal.c
index c6f3f7f..139cc71 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #define _GNU_SOURCE
 #include <ctype.h>
diff --git a/src/terminal.h b/src/terminal.h
index 825c057..ee03f8d 100644
--- a/src/terminal.h
+++ b/src/terminal.h
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #ifndef TERMINAL_H
 #define TERMINAL_H
diff --git a/src/wg.c b/src/wg.c
index ee19387..616107e 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -1,4 +1,4 @@
-/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+/* Copyright (C) 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
 #include <stddef.h>
 #include <stdio.h>

commit 3338bb11e83462ffc64c6bfb03851f0abcb50aff
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Nov 5 21:35:33 2016 +0100

    wg: chill modern gcc out
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 24296f8..860845e 100644
--- a/src/config.c
+++ b/src/config.c
@@ -2,6 +2,7 @@
 
 
 #include <arpa/inet.h>
+#include <limits.h>
 #include <ctype.h>
 #include <netdb.h>
 #include <stdio.h>
@@ -220,7 +221,7 @@ static inline bool parse_ipmasks(struct inflatable_device *buf, size_t peer_offs
 	}
 	sep = mutable;
 	while ((mask = strsep(&sep, ","))) {
-		unsigned long cidr;
+		unsigned long cidr = ULONG_MAX;
 		char *end, *ip = strsep(&mask, "/");
 		if (use_space(buf, sizeof(struct wgipmask)) < 0) {
 			perror("use_space");
@@ -234,27 +235,16 @@ static inline bool parse_ipmasks(struct inflatable_device *buf, size_t peer_offs
 			free(mutable);
 			return false;
 		}
-		if (ipmask->family == AF_INET) {
-			if (mask) {
-				cidr = strtoul(mask, &end, 10);
-				if (*end)
-					mask = NULL;
-				if (cidr > 32)
-					mask = NULL;
-			}
-			if (!mask)
-				cidr = 32;
-		} else if (ipmask->family == AF_INET6) {
-			if (mask) {
-				cidr = strtoul(mask, &end, 10);
-				if (*end)
-					mask = NULL;
-				if (cidr > 128)
-					mask = NULL;
-			}
-			if (!mask)
-				cidr = 128;
-		} else
+		if (mask && *mask) {
+			cidr = strtoul(mask, &end, 10);
+			if (*end)
+				cidr = ULONG_MAX;
+		}
+		if (ipmask->family == AF_INET)
+			cidr = cidr > 32 ? 32 : cidr;
+		else if (ipmask->family == AF_INET6)
+			cidr = cidr > 128 ? 128 : cidr;
+		else
 			continue;
 		ipmask->cidr = cidr;
 		++peer->num_ipmasks;

commit ff52c3e3a48f9b849e147f981e4cb5cf70871fa1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Nov 5 13:22:55 2016 +0100

    qemu: move build outside of kernel dir to avoid kernel's make clean
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/.gitignore b/.gitignore
index fa4eb8c..cba889d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,7 +1,9 @@
 cscope.out
 *.o
+*.d
 *.ko
 *.mod.c
+src/tools/wg
 Module.symvers
 *.cmd
 .tmp_versions
@@ -9,3 +11,11 @@ Module.symvers
 modules.order
 modules.builtin
 maint/
+qemu-build/
+src/tests/qemu/distfiles/
+*.id0
+*.id1
+*.id2
+*.nam
+*.til
+*.pro.user
diff --git a/src/.gitignore b/src/.gitignore
deleted file mode 100644
index 359f8b5..0000000
--- a/src/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-*.d
-*.o
-wg

commit a97901e4fd60e70f38c55867f4e0b1cb728ade07
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Nov 2 11:50:52 2016 +0100

    wg: abstract pkg-config to PKG_CONFIG
    
    Distros like Exherbo have multitarget setups with toolnames prefixed by
    the arch.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 0d3a2e4..2d2ad03 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -4,6 +4,7 @@ BINDIR ?= $(PREFIX)/bin
 LIBDIR ?= $(PREFIX)/lib
 MANDIR ?= $(PREFIX)/share/man
 RUNSTATEDIR ?= /var/run
+PKG_CONFIG ?= pkg-config
 
 CFLAGS ?= -O3
 CFLAGS += -std=gnu11
@@ -12,8 +13,8 @@ CFLAGS += -MMD -MP
 CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
 LDLIBS += -lresolv
 ifeq ($(shell uname -s),Linux)
-LIBMNL_CFLAGS := $(shell pkg-config --cflags libmnl 2>/dev/null)
-LIBMNL_LDLIBS := $(shell pkg-config --libs libmnl 2>/dev/null || echo -lmnl)
+LIBMNL_CFLAGS := $(shell $(PKG_CONFIG) --cflags libmnl 2>/dev/null)
+LIBMNL_LDLIBS := $(shell $(PKG_CONFIG) --libs libmnl 2>/dev/null || echo -lmnl)
 CFLAGS += $(LIBMNL_CFLAGS)
 LDLIBS += $(LIBMNL_LDLIBS)
 endif

commit 971c792ba9d0b36fcb05726ab4bdd48fa2f906d3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Nov 2 11:49:07 2016 +0100

    wg: everybody hates automatic stripping
    
    I happen to like it, but package managers don't. The GNU standard [1]
    says there should be a separate install-strip target. I don't like
    duplicating code like that. So, instead, I'll just remove stripping all
    together.
    
    [1] https://www.gnu.org/prep/standards/html_node/Standard-Targets.html
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index fc0c0f3..0d3a2e4 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -24,7 +24,7 @@ clean:
 	rm -f wg *.o *.d
 
 install: wg
-	install -v -d "$(DESTDIR)$(BINDIR)" && install -s -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"
+	install -v -d "$(DESTDIR)$(BINDIR)" && install -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"
 	install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -m 0644 -v wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
 
 check: clean

commit 17aa3e35c68da898aac1475fd528f1cbc2dfa3fb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Sep 29 19:31:22 2016 +0200

    git: organize ignore files
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/.gitignore b/.gitignore
index 7e37082..fa4eb8c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -8,5 +8,4 @@ Module.symvers
 *.swp
 modules.order
 modules.builtin
-src/tests/qemu/build/
-src/tests/qemu/distfiles/
+maint/
diff --git a/contrib/external-tests/go/.gitignore b/contrib/external-tests/go/.gitignore
new file mode 100644
index 0000000..4023f20
--- /dev/null
+++ b/contrib/external-tests/go/.gitignore
@@ -0,0 +1 @@
+go
diff --git a/contrib/external-tests/haskell/.gitignore b/contrib/external-tests/haskell/.gitignore
new file mode 100644
index 0000000..1159ea5
--- /dev/null
+++ b/contrib/external-tests/haskell/.gitignore
@@ -0,0 +1,2 @@
+.cabal-sandbox/
+dist
diff --git a/contrib/extract-keys/.gitignore b/contrib/extract-keys/.gitignore
new file mode 100644
index 0000000..a4e358b
--- /dev/null
+++ b/contrib/extract-keys/.gitignore
@@ -0,0 +1,4 @@
+config.h
+extract-keys
+config.h
+config

commit 8a57a2cefbeaf9e42b7a8e603f7a0bc6582a1aae
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Sep 29 04:36:14 2016 +0200

    Rework headers and includes
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
index 0dc4841..7852dcf 100644
--- a/contrib/extract-keys/config.c
+++ b/contrib/extract-keys/config.c
@@ -5,7 +5,9 @@ struct def {
 extern const struct def defs[];
 
 #ifdef __KERNEL__
-#include "../../../src/wireguard.h"
+#include "../../../src/device.h"
+#include "../../../src/peer.h"
+#include "../../../src/noise.h"
 const struct def defs[] = {
 	{ "SOCK_DEVICE_OFFSET", offsetof(struct sock, sk_user_data) },
 	{ "DEVICE_NAME_OFFSET", -ALIGN(sizeof(struct net_device), NETDEV_ALIGN) + offsetof(struct net_device, name) },

commit 967ea8c7128e87627e1da2de00f3901c3de63eb1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Aug 30 04:35:51 2016 +0200

    wg: allow multiple AllowedIPs invocations
    
    It turns out this is a somewhat natural thing to do in config files.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index d307007..24296f8 100644
--- a/src/config.c
+++ b/src/config.c
@@ -213,7 +213,6 @@ static inline bool parse_ipmasks(struct inflatable_device *buf, size_t peer_offs
 		return false;
 	};
 	peer = peer_from_offset(buf->dev, peer_offset);
-	peer->num_ipmasks = 0;
 	peer->replace_ipmasks = true;
 	if (!strlen(value)) {
 		free(mutable);

commit cb8be29c1801cc835017ce67facf509a06839508
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Aug 24 17:44:41 2016 +0200

    examples: add key extractor
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/extract-keys/Makefile b/contrib/extract-keys/Makefile
new file mode 100644
index 0000000..a1dd7a2
--- /dev/null
+++ b/contrib/extract-keys/Makefile
@@ -0,0 +1,27 @@
+ifeq ($(KERNELRELEASE),)
+KERNELDIR ?= /lib/modules/$(shell uname -r)/build
+PWD := $(shell pwd)
+CFLAGS ?= -O3 -march=native
+CFLAGS += -Wall -pedantic -std=gnu11
+
+extract-keys: extract-keys.c config.h
+	$(CC) $(CFLAGS) $(CPPFLAGS) -D_FILE_OFFSET_BITS=64 -o $@ -lresolv $<
+
+config.o: config.c
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@
+	objcopy -j '.rodata*' $@ $@
+
+config: config.c config.o
+	$(CC) $(CFLAGS) $(CPPFLAGS) -o $@ $^
+
+config.h: config
+	./$< > $@
+
+clean:
+	rm -f extract-keys config config.h
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) clean
+
+.PHONY: clean
+else
+config-m := config.o
+endif
diff --git a/contrib/extract-keys/README b/contrib/extract-keys/README
new file mode 100644
index 0000000..a91363d
--- /dev/null
+++ b/contrib/extract-keys/README
@@ -0,0 +1,23 @@
+Key Extractor
+=============
+
+This will extract the symmetric ChaCha20Poly1305 session keys from the kernel
+for a WireGuard interface, for use in making packet dissectors.
+
+
+Build:
+    $ make
+
+Run (as root):
+    # ./extract-keys INTERFACE
+
+Output:
+    REMOTE_KEY_ID SENDING_KEY
+    LOCAL_KEY_ID RECEIVING_KEY
+
+Example:
+    # ./extract-keys wg0
+    0x57b56068 tMTSEOJpEYFAQV2UviDiYooX0A1AD/ONqrzoQVHa1rQ=
+    0xa182fd19 xvQSkQ5HTX5RUeJ74eAAb/xfNhdrDThxG91GXZIPKmY=
+    0x01662508 LbMc84JULzXJiHotSkdSOPZ0bHh6IDwOrbxWLfwosTs=
+    0xbd819021 4VA8lZ3I1HjnJcWTmhEzBdC92W1Aag9Lnyy2GkroOYI=
diff --git a/contrib/extract-keys/config.c b/contrib/extract-keys/config.c
new file mode 100644
index 0000000..0dc4841
--- /dev/null
+++ b/contrib/extract-keys/config.c
@@ -0,0 +1,32 @@
+struct def {
+	const char *name;
+	long long value;
+};
+extern const struct def defs[];
+
+#ifdef __KERNEL__
+#include "../../../src/wireguard.h"
+const struct def defs[] = {
+	{ "SOCK_DEVICE_OFFSET", offsetof(struct sock, sk_user_data) },
+	{ "DEVICE_NAME_OFFSET", -ALIGN(sizeof(struct net_device), NETDEV_ALIGN) + offsetof(struct net_device, name) },
+	{ "IFNAMSIZ", IFNAMSIZ },
+	{ "DEVICE_PEERS_OFFSET", offsetof(struct wireguard_device, peer_list) },
+	{ "PEERS_PEER_OFFSET", -offsetof(struct wireguard_peer, peer_list) },
+	{ "PEER_CURRENTKEY_OFFSET", offsetof(struct wireguard_peer, keypairs.current_keypair) },
+	{ "PEER_PREVIOUSKEY_OFFSET", offsetof(struct wireguard_peer, keypairs.previous_keypair) },
+	{ "PEER_NEXTKEY_OFFSET", offsetof(struct wireguard_peer, keypairs.next_keypair) },
+	{ "KEY_LOCALID_OFFSET", offsetof(struct noise_keypair, entry.index) },
+	{ "KEY_REMOTEID_OFFSET", offsetof(struct noise_keypair, remote_index) },
+	{ "KEY_SENDING_OFFSET", offsetof(struct noise_keypair, sending.key) },
+	{ "KEY_RECEIVING_OFFSET", offsetof(struct noise_keypair, receiving.key) },
+	{ NULL, 0 }
+};
+#else
+#include <stdio.h>
+int main(int argc, char *argv[])
+{
+	for (const struct def *def = defs; def->name; ++def)
+		printf("#define %s %lld\n", def->name, def->value);
+	return 0;
+}
+#endif
diff --git a/contrib/extract-keys/extract-keys.c b/contrib/extract-keys/extract-keys.c
new file mode 100644
index 0000000..5d7de32
--- /dev/null
+++ b/contrib/extract-keys/extract-keys.c
@@ -0,0 +1,139 @@
+#include <endian.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <resolv.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include "config.h"
+
+static int fd;
+
+static void open_kmem(void)
+{
+	fd = open("/dev/kmem", O_RDONLY);
+	if (fd < 0) {
+		perror("open(/dev/kmem)");
+		exit(errno);
+	}
+}
+
+static void read_kmem(void *buffer, size_t len, unsigned long addr)
+{
+	if (lseek(fd, addr, SEEK_SET) == (off_t)-1) {
+		perror("lseek");
+		exit(errno);
+	}
+	if (read(fd, buffer, len) != len) {
+		perror("read");
+		exit(errno);
+	}
+}
+
+static inline unsigned int read_int(unsigned long addr)
+{
+	unsigned int ret;
+	read_kmem(&ret, sizeof(ret), addr);
+	return ret;
+}
+
+static inline unsigned long read_long(unsigned long addr)
+{
+	unsigned long ret;
+	read_kmem(&ret, sizeof(ret), addr);
+	return ret;
+}
+
+static unsigned long find_interface(const char *interface)
+{
+	FILE *f = fopen("/proc/net/udp", "r");
+	char line[256], *ptr;
+	unsigned long addr = 0;
+	char name[IFNAMSIZ + 1] = { 0 };
+
+	if (!f) {
+		perror("fopen(/proc/net/udp)");
+		exit(errno);
+	}
+	if (!fgets(line, 256, f))
+		goto out;
+	while (fgets(line, 256, f)) {
+		ptr = line + strlen(line) - 1;
+		while (*--ptr == ' ');
+		while (*--ptr != ' ');
+		while (*(--ptr - 1) != ' ');
+		addr = strtoul(ptr, NULL, 16);
+		if (!addr)
+			continue;
+		addr = read_long(addr + SOCK_DEVICE_OFFSET);
+		if (!addr)
+			continue;
+		read_kmem(name, IFNAMSIZ, addr + DEVICE_NAME_OFFSET);
+		if (!strcmp(name, interface))
+			goto out;
+	}
+	addr = 0;
+out:
+	fclose(f);
+	return addr;
+}
+
+static bool print_key(unsigned long key)
+{
+	unsigned char sending[32], receiving[32];
+	char sending_b64[45], receiving_b64[45];
+	unsigned int local_index, remote_index;
+
+	if (!key)
+		return false;
+
+	local_index = le32toh(read_int(key + KEY_LOCALID_OFFSET));
+	remote_index = le32toh(read_int(key + KEY_REMOTEID_OFFSET));
+	read_kmem(sending, 32, key + KEY_SENDING_OFFSET);
+	read_kmem(receiving, 32, key + KEY_RECEIVING_OFFSET);
+
+	b64_ntop(sending, 32, sending_b64, 45);
+	b64_ntop(receiving, 32, receiving_b64, 45);
+
+	printf("0x%08x %s\n", local_index, receiving_b64);
+	printf("0x%08x %s\n", remote_index, sending_b64);
+	return true;
+}
+
+static bool walk_peers(unsigned long peer_head)
+{
+	unsigned long peer, peer_entry;
+	bool found = false;
+	for (peer_entry = read_long(peer_head); peer_entry != peer_head; peer_entry = read_long(peer_entry)) {
+		peer = peer_entry + PEERS_PEER_OFFSET;
+		if (print_key(read_long(peer + PEER_CURRENTKEY_OFFSET)))
+			found = true;
+		if (print_key(read_long(peer + PEER_PREVIOUSKEY_OFFSET)))
+			found = true;
+		if (print_key(read_long(peer + PEER_NEXTKEY_OFFSET)))
+			found = true;
+	}
+	return found;
+}
+
+int main(int argc, char *argv[])
+{
+	unsigned long wireguard_device;
+	if (argc < 2) {
+		fprintf(stderr, "Usage: %s WIREGUARD_INTERFACE\n", argv[0]);
+		return EINVAL;
+	}
+	open_kmem();
+	wireguard_device = find_interface(argv[1]);
+	if (!wireguard_device) {
+		fprintf(stderr, "Could not find interface %s\n", argv[1]);
+		return EBADSLT;
+	}
+	if (!walk_peers(wireguard_device + DEVICE_PEERS_OFFSET)) {
+		fprintf(stderr, "No active sessions\n");
+		return ENOKEY;
+	}
+	return 0;
+}

commit 62fe72133c8a2f22c65b5b854201e0caa80b3efe
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Aug 23 03:56:42 2016 +0200

    examples: add nat-hole-punching
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/nat-hole-punching/README b/contrib/nat-hole-punching/README
new file mode 100644
index 0000000..46e6201
--- /dev/null
+++ b/contrib/nat-hole-punching/README
@@ -0,0 +1,41 @@
+== NAT Hole Punching Example ==
+
+This code should never be used, ever. But, it's a nice demonstration of how
+to punch holes and have two NAT'd peers talk to each other.
+
+Compile with:
+    $ gcc nat-punch-client.c -o client -lresolv
+    $ gcc nat-punch-server.c -o server
+
+
+Server is 1.2.3.4 and is on the public internet accepting UDP:49918.
+Client A is NAT'd and doesnt't know its IP address.
+Client B is NAT'd and doesnt't know its IP address.
+
+
+Server runs:
+   $ ./server
+
+Client A runs:
+   # ip link add wg0 type wireguard
+   # ip addr add 10.200.200.1 peer 10.200.200.2 dev wg0
+   # wg set wg0 private-key ... peer ... allowed-ips 10.200.200.2/32
+   # ./client 1.2.3.4 wg0
+   # ping 10.200.200.2
+
+Client B runs:
+   # ip link add wg0 type wireguard
+   # ip addr add 10.200.200.2 peer 10.200.200.1 dev wg0
+   # wg set wg0 private-key ... peer ... allowed-ips 10.200.200.1/32
+   # ./client 1.2.3.4 wg0
+   # ping 10.200.200.1
+
+And voila! Client A and Client B can speak from behind NAT.
+
+
+
+-----
+Keep in mind that this is proof-of-concept example code. It is not code that
+should be used in production, ever. It is woefully insecure, and is unsuitable
+for any real usage. With that said, this is useful as a learning example of
+how NAT hole punching might work within a more developed solution.
diff --git a/contrib/nat-hole-punching/nat-punch-client.c b/contrib/nat-hole-punching/nat-punch-client.c
new file mode 100644
index 0000000..a72b5f6
--- /dev/null
+++ b/contrib/nat-hole-punching/nat-punch-client.c
@@ -0,0 +1,203 @@
+/* Example only. Do not run in production. */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/udp.h>
+#include <netinet/ip.h>
+#include <linux/filter.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdarg.h>
+#include <string.h>
+#include <resolv.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+enum { MAX_PEERS = 65536, PORT = 49918 };
+
+static struct {
+	uint8_t base64_key[45];
+	bool have_seen;
+} peers[MAX_PEERS];
+static unsigned int total_peers;
+
+static const char *cmd(const char *line, ...)
+{
+	static char buf[2048];
+	char full_cmd[2048] = { 0 };
+	size_t len;
+	FILE *f;
+	va_list args;
+	va_start(args, line);
+	vsnprintf(full_cmd, 2047, line, args);
+	va_end(args);
+	f = popen(full_cmd, "r");
+	if (!f) {
+		perror("popen");
+		exit(errno);
+	}
+	if (!fgets(buf, 2048, f)) {
+		pclose(f);
+		return NULL;
+	}
+	pclose(f);
+	len = strlen(buf);
+	if (!len)
+		return NULL;
+	if (buf[len - 1] == '\n')
+		buf[len - 1] = '\0';
+	return buf;
+}
+
+static void read_peers(const char *interface)
+{
+	char full_cmd[2048] = { 0 };
+	size_t len;
+	FILE *f;
+	snprintf(full_cmd, 2047, "wg show %s peers", interface);
+	f = popen(full_cmd, "r");
+	if (!f) {
+		perror("popen");
+		exit(errno);
+	}
+	for (;;) {
+		if (!fgets(peers[total_peers].base64_key, 45, f))
+			break;
+		len = strlen(peers[total_peers].base64_key);
+		if (len != 44 && len != 45)
+			continue;
+		if (peers[total_peers].base64_key[len - 1] == '\n')
+			peers[total_peers].base64_key[len - 1] = '\0';
+		++total_peers;
+	}
+	pclose(f);
+}
+
+static void unbase64(uint8_t dstkey[32], const char *srckey)
+{
+	uint8_t buf[33];
+	if (b64_pton(srckey, buf, 33) != 32) {
+		fprintf(stderr, "Could not parse base64 key: %s\n", srckey);
+		exit(EINVAL);
+	}
+	memcpy(dstkey, buf, 32);
+}
+
+static void apply_bpf(int sock, uint16_t port, uint32_t ip)
+{
+	struct sock_filter filter[] = {
+		BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 12 /* src ip */),
+		BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ip, 0, 5),
+		BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 20 /* src port */),
+		BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, PORT, 0, 3),
+		BPF_STMT(BPF_LD + BPF_H + BPF_ABS, 22 /* dst port */),
+		BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, port, 0, 1),
+		BPF_STMT(BPF_RET + BPF_K, -1),
+		BPF_STMT(BPF_RET + BPF_K, 0)
+	};
+	struct sock_fprog filter_prog = {
+		.len = sizeof(filter) / sizeof(filter[0]),
+		.filter = filter
+	};
+	if (setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &filter_prog, sizeof(filter_prog)) < 0) {
+		perror("setsockopt(bpf)");
+		exit(errno);
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	struct sockaddr_in addr = {
+		.sin_family = AF_INET
+	};
+	struct {
+		struct udphdr udp;
+		uint8_t my_pubkey[32];
+		uint8_t their_pubkey[32];
+	} __attribute__((packed)) packet = {
+		.udp = {
+			.len = htons(sizeof(packet)),
+			.dest = htons(PORT)
+		}
+	};
+	struct {
+		struct iphdr iphdr;
+		struct udphdr udp;
+		uint32_t ip;
+		uint16_t port;
+	} __attribute__((packed)) reply;
+	ssize_t len;
+	int sock, i;
+	bool repeat;
+	struct hostent *ent;
+	const char *server = argv[1], *interface = argv[2];
+
+	if (argc < 3) {
+		fprintf(stderr, "Usage: %s SERVER WIREGUARD_INTERFACE\nExample:\n    %s demo.wireguard.io wg0\n", argv[0], argv[0]);
+		return EINVAL;
+	}
+
+	if (getuid() != 0) {
+		fprintf(stderr, "Must be root!\n");
+		return EPERM;
+	}
+
+	ent = gethostbyname2(server, AF_INET);
+	if (!ent) {
+		herror("gethostbyname2");
+		return h_errno;
+	}
+	addr.sin_addr = *(struct in_addr *)ent->h_addr;
+	read_peers(interface);
+	cmd("ip link set %s up", interface);
+	unbase64(packet.my_pubkey, cmd("wg show %s public-key", interface));
+	packet.udp.source = htons(atoi(cmd("wg show %s listen-port", interface)));
+
+	/* We use raw sockets so that the WireGuard interface can actually own the real socket. */
+	sock = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
+	if (sock < 0) {
+		perror("socket");
+		return errno;
+	}
+	apply_bpf(sock, ntohs(packet.udp.source), ntohl(addr.sin_addr.s_addr));
+
+check_again:
+	repeat = false;
+	for (i = 0; i < total_peers; ++i) {
+		if (peers[i].have_seen)
+			continue;
+		printf("[+] Requesting IP and port of %s: ", peers[i].base64_key);
+		unbase64(packet.their_pubkey, peers[i].base64_key);
+		if (sendto(sock, &packet, sizeof(packet), 0, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+			putchar('\n');
+			perror("sendto");
+			return errno;
+		}
+		len = recv(sock, &reply, sizeof(reply), 0);
+		if (len < 0) {
+			putchar('\n');
+			perror("recv");
+			return errno;
+		}
+		if (len != sizeof(reply)) {
+			printf("server does not yet have it\n");
+			repeat = true;
+		} else {
+			printf("%s:%d\n", inet_ntoa(*(struct in_addr *)&reply.ip), ntohs(reply.port));
+			peers[i].have_seen = true;
+			cmd("wg set %s peer %s persistent-keepalive 25 endpoint %s:%d", interface, peers[i].base64_key, inet_ntoa(*(struct in_addr *)&reply.ip), ntohs(reply.port));
+		}
+	}
+	if (repeat) {
+		sleep(2);
+		goto check_again;
+	}
+
+	close(sock);
+	return 0;
+}
diff --git a/contrib/nat-hole-punching/nat-punch-server.c b/contrib/nat-hole-punching/nat-punch-server.c
new file mode 100644
index 0000000..198e0f8
--- /dev/null
+++ b/contrib/nat-hole-punching/nat-punch-server.c
@@ -0,0 +1,110 @@
+/* Example only. Do not run in production. */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+struct entry {
+	uint8_t pubkey[32];
+	uint32_t ip;
+	uint16_t port;
+};
+
+enum { MAX_ENTRIES = 65536, PORT = 49918 };
+
+static struct entry entries[MAX_ENTRIES];
+static unsigned int next_entry;
+
+/* XX: this should use a hash table */
+static struct entry *find_entry(uint8_t key[32])
+{
+	int i;
+	for (i = 0; i < MAX_ENTRIES; ++i) {
+		if (!memcmp(entries[i].pubkey, key, 32))
+			return &entries[i];
+	}
+	return NULL;
+}
+
+/* XX: this is obviously vulnerable to DoS */
+static struct entry *find_or_insert_entry(uint8_t key[32])
+{
+	struct entry *entry = find_entry(key);
+	if (!entry) {
+		entry = &entries[next_entry++ % MAX_ENTRIES];
+		memcpy(entry->pubkey, key, 32);
+	}
+	return entry;
+}
+
+int main(int argc, char *argv[])
+{
+	struct sockaddr_in addr = {
+		.sin_family = AF_INET,
+		.sin_addr = { .s_addr = htonl(INADDR_ANY) },
+		.sin_port = htons(PORT)
+	};
+	struct {
+		uint8_t my_pubkey[32];
+		uint8_t their_pubkey[32];
+	} __attribute__((packed)) packet;
+	struct {
+		uint32_t ip;
+		uint16_t port;
+	} __attribute__((packed)) reply;
+	struct entry *entry;
+	socklen_t len;
+	ssize_t retlen;
+	int optval;
+	int sock = socket(AF_INET, SOCK_DGRAM, 0);
+	if (sock < 0) {
+		perror("socket");
+		return errno;
+	}
+
+	optval = 1;
+	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
+		perror("setsockopt");
+		return errno;
+	}
+
+	if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return errno;
+	}
+
+	for (;;) {
+		len = sizeof(addr);
+		if (recvfrom(sock, &packet, sizeof(packet), 0, (struct sockaddr *)&addr, &len) != sizeof(packet)) {
+			perror("recvfrom");
+			continue;
+		}
+		entry = find_or_insert_entry(packet.my_pubkey);
+		entry->ip = addr.sin_addr.s_addr;
+		entry->port = addr.sin_port;
+		entry = find_entry(packet.their_pubkey);
+		if (entry) {
+			reply.ip = entry->ip;
+			reply.port = entry->port;
+			if (sendto(sock, &reply, sizeof(reply), 0, (struct sockaddr *)&addr, len) < 0) {
+				perror("sendto");
+				continue;
+			}
+		} else {
+			if (sendto(sock, NULL, 0, 0, (struct sockaddr *)&addr, len) < 0) {
+				perror("sendto");
+				continue;
+			}
+		}
+	}
+
+	close(sock);
+	return 0;
+}

commit aae568937e84b819a3593d0f9950f881043b0469
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jul 25 14:17:11 2016 +0200

    tests: use makefile and expand greatly
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/.gitignore b/.gitignore
index 7a4b600..7e37082 100644
--- a/.gitignore
+++ b/.gitignore
@@ -8,3 +8,5 @@ Module.symvers
 *.swp
 modules.order
 modules.builtin
+src/tests/qemu/build/
+src/tests/qemu/distfiles/

commit 822ae991d808c394932237ecd121e5b8d75e31db
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Aug 8 13:53:00 2016 +0200

    persistent-keepalive: change range to [1,65535]
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 55a8ab5..d307007 100644
--- a/src/config.c
+++ b/src/config.c
@@ -193,8 +193,8 @@ static inline bool parse_persistent_keepalive(__u16 *interval, const char *value
 	}
 
 	ret = strtoul(value, &end, 10);
-	if (!*value || *value == '-' || *end || (ret && (ret < 10 || ret > 3600))) {
-		fprintf(stderr, "The persistent keepalive interval must be 0/off or 10-3600. Found: `%s`\n", value);
+	if (!*value || *value == '-' || *end || ret > 65535) {
+		fprintf(stderr, "The persistent keepalive interval must be 0/off or 1-65535. Found: `%s`\n", value);
 		return false;
 	}
 
diff --git a/src/wg.8 b/src/wg.8
index 0795fdf..4e7e4c2 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -68,7 +68,7 @@ public-key cryptography, for post-quantum resistance. If \fIallowed-ips\fP
 is specified, but the value is the empty string, all allowed ips are removed
 from the peer. The use of \fIpersistent-keepalive\fP is optional and is by
 default off; setting it to 0 or "off", disables it. Otherwise it represents,
-in seconds, between 10 and 3600 inclusive, how often to send an authenticated
+in seconds, between 1 and 65535 inclusive, how often to send an authenticated
 empty packet to the peer, for the purpose of keeping a stateful firewall or NAT
 mapping valid persistently. For example, if the interface very rarely sends
 traffic, but it might at anytime receive traffic from a peer, and it is behind
@@ -142,7 +142,7 @@ port number. This endpoint will be updated automatically to the most recent
 source IP address and port of correctly authenticated packets from the peer.
 Optional.
 .IP \(bu
-PersistentKeepalive \(em a seconds interval, between 10 and 3600 inclusive, of
+PersistentKeepalive \(em a seconds interval, between 1 and 65535 inclusive, of
 how often to send an authenticated empty packet to the peer for the purpose of keeping a
 stateful firewall or NAT mapping valid persistently. For example, if the interface
 very rarely sends traffic, but it might at anytime receive traffic from a peer,

commit e9382638866929cf1accdd34ed62eccde40ca8a8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Aug 1 21:31:07 2016 +0200

    wg: use correct headers in ipc
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 4203448..3b96e6a 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -18,14 +18,14 @@
 #include <unistd.h>
 #include <time.h>
 #include <dirent.h>
+#include <poll.h>
+#include <signal.h>
 #include <sys/socket.h>
 #include <sys/types.h>
-#include <sys/poll.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/un.h>
-#include <sys/signal.h>
 
 #include "ipc.h"
 #include "../uapi.h"

commit db69cc711940c9167add6efab375fa7958d2f881
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 28 17:18:17 2016 +0200

    wg: do not show private keys in pretty output
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/show.c b/src/show.c
index 3a32cb8..05a8e3e 100644
--- a/src/show.c
+++ b/src/show.c
@@ -88,6 +88,14 @@ static char *key(const unsigned char key[static WG_KEY_LEN])
 	return b64;
 }
 
+static char *masked_key(const unsigned char masked_key[static WG_KEY_LEN])
+{
+	const char *var = getenv("WG_HIDE_KEYS");
+	if (var && !strcmp(var, "never"))
+		return key(masked_key);
+	return "(hidden)";
+}
+
 static char *ip(const struct wgipmask *ip)
 {
 	static char buf[INET6_ADDRSTRLEN + 1];
@@ -205,9 +213,9 @@ static void pretty_print(struct wgdevice *device)
 	if (memcmp(device->public_key, zero, WG_KEY_LEN))
 		terminal_printf("  " TERMINAL_BOLD "public key" TERMINAL_RESET ": %s\n", key(device->public_key));
 	if (memcmp(device->private_key, zero, WG_KEY_LEN))
-		terminal_printf("  " TERMINAL_BOLD "private key" TERMINAL_RESET ": %s\n", key(device->private_key));
+		terminal_printf("  " TERMINAL_BOLD "private key" TERMINAL_RESET ": %s\n", masked_key(device->private_key));
 	if (memcmp(device->preshared_key, zero, WG_KEY_LEN))
-		terminal_printf("  " TERMINAL_BOLD "pre-shared key" TERMINAL_RESET ": %s\n", key(device->preshared_key));
+		terminal_printf("  " TERMINAL_BOLD "pre-shared key" TERMINAL_RESET ": %s\n", masked_key(device->preshared_key));
 	if (device->port)
 		terminal_printf("  " TERMINAL_BOLD "listening port" TERMINAL_RESET ": %u\n", device->port);
 	if (device->num_peers) {
diff --git a/src/terminal.c b/src/terminal.c
index 74d04c2..c6f3f7f 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -13,7 +13,7 @@
 static bool color_mode(FILE *file)
 {
 	static int mode = -1;
-	char *var;
+	const char *var;
 	if (mode != -1)
 		return mode;
 	var = getenv("WG_COLOR_MODE");
diff --git a/src/wg.8 b/src/wg.8
index b8e6596..0795fdf 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -194,6 +194,9 @@ Note that not all keys are required.
 .TP
 .I WG_COLOR_MODE
 If set to \fIalways\fP, always print ANSI colorized output. If set to \fInever\fP, never print ANSI colorized output. If set to \fIauto\fP, something invalid, or unset, then print ANSI colorized output only when writing to a TTY.
+.TP
+.I WG_HIDE_KEYS
+If set to \fInever\fP, then the pretty-printing \fBshow\fP sub-command will show private and pre-shared keys in the output. If set to \fIalways\fP, something invalid, or unset, then private and pre-shared keys will be printed as "(hidden)".
 
 .SH SEE ALSO
 .BR ip (8),

commit 1b9a83c852d40d0c11ea963520825a205e0d9ae2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jul 27 11:30:05 2016 +0200

    c: specify static array size in function params
    
    The C standard states:
    
      A declaration of a parameter as ``array of type'' shall be adjusted to ``qualified pointer to
      type'', where the type qualifiers (if any) are those specified within the [ and ] of the
      array type derivation. If the keyword static also appears within the [ and ] of the
      array type derivation, then for each call to the function, the value of the corresponding
      actual argument shall provide access to the first element of an array with at least as many
      elements as specified by the size expression.
    
    By changing void func(int array[4]) to void func(int array[static 4]),
    we automatically get the compiler checking argument sizes for us, which
    is quite nice.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 611207e..55a8ab5 100644
--- a/src/config.c
+++ b/src/config.c
@@ -90,7 +90,7 @@ static inline uint16_t parse_port(const char *value)
 	return port;
 }
 
-static inline bool parse_key(uint8_t key[WG_KEY_LEN], const char *value)
+static inline bool parse_key(uint8_t key[static WG_KEY_LEN], const char *value)
 {
 	uint8_t tmp[WG_KEY_LEN + 1];
 	if (strlen(value) != b64_len(WG_KEY_LEN) - 1 || b64_pton(value, tmp, WG_KEY_LEN + 1) != WG_KEY_LEN) {
diff --git a/src/curve25519.c b/src/curve25519.c
index 6c26535..3d0b615 100644
--- a/src/curve25519.c
+++ b/src/curve25519.c
@@ -337,7 +337,7 @@ static void fmonty(limb *x2, limb *z2, /* output 2Q */
  * This function performs the swap without leaking any side-channel
  * information.
  */
-static void swap_conditional(limb a[5], limb b[5], limb iswap)
+static void swap_conditional(limb a[static 5], limb b[static 5], limb iswap)
 {
 	unsigned i;
 	const limb swap = -iswap;
@@ -430,7 +430,7 @@ static void crecip(felem out, const felem z)
 	/* 2^255 - 21 */ fmul(out, t0, a);
 }
 
-void curve25519(uint8_t mypublic[CURVE25519_POINT_SIZE], const uint8_t secret[CURVE25519_POINT_SIZE], const uint8_t basepoint[CURVE25519_POINT_SIZE])
+void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE])
 {
 	limb bp[5], x[5], z[5], zmone[5];
 	uint8_t e[32];
@@ -1104,7 +1104,7 @@ static void fmonty(limb *x2, limb *z2,  /* output 2Q */
  * reduced-degree form: the values in a[10..19] or b[10..19] aren't swapped,
  * and all all values in a[0..9],b[0..9] must have magnitude less than
  * INT32_MAX. */
-static void swap_conditional(limb a[19], limb b[19], limb iswap)
+static void swap_conditional(limb a[static 19], limb b[static 19], limb iswap)
 {
 	unsigned i;
 	const int32_t swap = (int32_t) -iswap;
@@ -1235,7 +1235,7 @@ static void crecip(limb *out, const limb *z)
 	/* 2^255 - 21 */ fmul(out,t1,z11);
 }
 
-void curve25519(uint8_t mypublic[CURVE25519_POINT_SIZE], const uint8_t secret[CURVE25519_POINT_SIZE], const uint8_t basepoint[CURVE25519_POINT_SIZE])
+void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE])
 {
 	limb bp[10], x[10], z[11], zmone[10];
 	uint8_t e[32];
@@ -1251,7 +1251,7 @@ void curve25519(uint8_t mypublic[CURVE25519_POINT_SIZE], const uint8_t secret[CU
 }
 #endif
 
-void curve25519_generate_public(uint8_t *pub, const uint8_t *secret)
+void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE])
 {
 	static const uint8_t basepoint[CURVE25519_POINT_SIZE] = { 9 };
 	curve25519(pub, secret, basepoint);
diff --git a/src/curve25519.h b/src/curve25519.h
index 3c1404a..0be59b7 100644
--- a/src/curve25519.h
+++ b/src/curve25519.h
@@ -10,9 +10,9 @@ enum curve25519_lengths {
 	CURVE25519_POINT_SIZE = 32,
 };
 
-void curve25519(uint8_t *mypublic, const uint8_t *secret, const uint8_t *basepoint);
-void curve25519_generate_public(uint8_t *pub, const uint8_t *secret);
-static inline void curve25519_normalize_secret(uint8_t secret[CURVE25519_POINT_SIZE])
+void curve25519(uint8_t mypublic[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE], const uint8_t basepoint[static CURVE25519_POINT_SIZE]);
+void curve25519_generate_public(uint8_t pub[static CURVE25519_POINT_SIZE], const uint8_t secret[static CURVE25519_POINT_SIZE]);
+static inline void curve25519_normalize_secret(uint8_t secret[static CURVE25519_POINT_SIZE])
 {
 	secret[0] &= 248;
 	secret[31] &= 127;
diff --git a/src/show.c b/src/show.c
index ddda6c3..3a32cb8 100644
--- a/src/show.c
+++ b/src/show.c
@@ -78,7 +78,7 @@ static void sort_peers(struct wgdevice *device)
 
 static const uint8_t zero[WG_KEY_LEN] = { 0 };
 
-static char *key(const unsigned char key[WG_KEY_LEN])
+static char *key(const unsigned char key[static WG_KEY_LEN])
 {
 	static char b64[b64_len(WG_KEY_LEN)];
 	if (!memcmp(key, zero, WG_KEY_LEN))

commit d6b3bc69483e6e49961d2cae52d0d0adf219c88b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 22 21:07:12 2016 +0200

    wg: use stream instead of seqpacket
    
    To support OS X and Windows, we have to. Ugh.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index c4d1128..4203448 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -20,6 +20,7 @@
 #include <dirent.h>
 #include <sys/socket.h>
 #include <sys/types.h>
+#include <sys/poll.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -99,7 +100,7 @@ static int userspace_interface_fd(const char *interface)
 	if (!S_ISSOCK(sbuf.st_mode))
 		goto out;
 
-	ret = fd = socket(AF_UNIX, SOCK_SEQPACKET, 0);
+	ret = fd = socket(AF_UNIX, SOCK_STREAM, 0);
 	if (ret < 0)
 		goto out;
 
@@ -172,10 +173,10 @@ static int userspace_set_device(struct wgdevice *dev)
 	ret = -EBADMSG;
 	if (!len)
 		goto out;
-	ret = send(fd, dev, len, 0);
+	ret = write(fd, dev, len);
 	if (ret < 0)
 		goto out;
-	ret = recv(fd, &ret_code, sizeof(ret_code), 0);
+	ret = read(fd, &ret_code, sizeof(ret_code));
 	if (ret < 0)
 		goto out;
 	ret = ret_code;
@@ -187,50 +188,62 @@ out:
 
 static int userspace_get_device(struct wgdevice **dev, const char *interface)
 {
-#ifdef __linux__
-	ssize_t len;
-#else
+	struct pollfd pollfd = { .events = POLLIN };
 	int len;
-#endif
+	char byte = 0;
+	size_t i;
+	struct wgpeer *peer;
 	ssize_t ret;
 	int fd = userspace_interface_fd(interface);
 	if (fd < 0)
 		return fd;
 	*dev = NULL;
-	ret = send(fd, NULL, 0, 0);
+	ret = write(fd, &byte, sizeof(byte));
 	if (ret < 0)
 		goto out;
 
-#ifdef __linux__
-	ret = len = recv(fd, NULL, 0, MSG_PEEK | MSG_TRUNC);
-	if (len < 0)
+	pollfd.fd = fd;
+	if (poll(&pollfd, 1, -1) < 0)
 		goto out;
-#else
-	ret = recv(fd, &ret, 1, MSG_PEEK);
-	if (ret < 0)
+	ret = -ECONNABORTED;
+	if (!(pollfd.revents & POLLIN))
 		goto out;
+
 	ret = ioctl(fd, FIONREAD, &len);
 	if (ret < 0) {
 		ret = -errno;
 		goto out;
 	}
-#endif
 	ret = -EBADMSG;
 	if ((size_t)len < sizeof(struct wgdevice))
 		goto out;
 
 	ret = -ENOMEM;
-	*dev = calloc(len, 1);
+	*dev = malloc(len);
 	if (!*dev)
 		goto out;
 
-	ret = recv(fd, *dev, len, 0);
+	ret = read(fd, *dev, len);
 	if (ret < 0)
 		goto out;
+	if (ret != len) {
+		ret = -EBADMSG;
+		goto out;
+	}
+
+	ret = -EBADMSG;
+	for_each_wgpeer(*dev, peer, i) {
+		if ((uint8_t *)peer + sizeof(struct wgpeer) > (uint8_t *)*dev + len)
+			goto out;
+		if ((uint8_t *)peer + sizeof(struct wgpeer) + sizeof(struct wgipmask) * peer->num_ipmasks > (uint8_t *)*dev + len)
+		goto out;
+	}
 	ret = 0;
 out:
-	if (*dev && ret)
+	if (*dev && ret) {
 		free(*dev);
+		*dev = NULL;
+	}
 	close(fd);
 	errno = -ret;
 	return ret;

commit ec890556e4fb900030963cb7a751d2844381a728
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 22 20:30:34 2016 +0200

    wg: Use seqpacket instead of dgram
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index cc70fd1..c4d1128 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -80,21 +80,10 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
-static void close_and_unlink(int fd)
-{
-	struct sockaddr_un addr;
-	socklen_t len = sizeof(addr);
-
-	if (!getsockname(fd, (struct sockaddr *)&addr, &len))
-		unlink(addr.sun_path);
-	close(fd);
-}
-
 static int userspace_interface_fd(const char *interface)
 {
 	struct stat sbuf;
-	struct sockaddr_un addr = { .sun_family = AF_UNIX }, bind_addr = { .sun_family = AF_UNIX };
-	mode_t old_umask;
+	struct sockaddr_un addr = { .sun_family = AF_UNIX };
 	int fd = -1, ret;
 
 	ret = -EINVAL;
@@ -103,10 +92,6 @@ static int userspace_interface_fd(const char *interface)
 	ret = snprintf(addr.sun_path, sizeof(addr.sun_path) - 1, SOCK_PATH "%s" SOCK_SUFFIX, interface);
 	if (ret < 0)
 		goto out;
-	ret = snprintf(bind_addr.sun_path, sizeof(bind_addr.sun_path) - 1, SOCK_PATH ".wg-tool-%s-%d.client", interface, getpid());
-	if (ret < 0)
-		goto out;
-	unlink(bind_addr.sun_path);
 	ret = stat(addr.sun_path, &sbuf);
 	if (ret < 0)
 		goto out;
@@ -114,12 +99,7 @@ static int userspace_interface_fd(const char *interface)
 	if (!S_ISSOCK(sbuf.st_mode))
 		goto out;
 
-	ret = fd = socket(AF_UNIX, SOCK_DGRAM, 0);
-	if (ret < 0)
-		goto out;
-	old_umask = umask(0077);
-	ret = bind(fd, (struct sockaddr *)&bind_addr, sizeof(bind_addr));
-	umask(old_umask);
+	ret = fd = socket(AF_UNIX, SOCK_SEQPACKET, 0);
 	if (ret < 0)
 		goto out;
 
@@ -131,7 +111,7 @@ static int userspace_interface_fd(const char *interface)
 	}
 out:
 	if (ret && fd >= 0)
-		close_and_unlink(fd);
+		close(fd);
 	if (!ret)
 		ret = fd;
 	return ret;
@@ -142,7 +122,7 @@ static bool userspace_has_wireguard_interface(const char *interface)
 	int fd = userspace_interface_fd(interface);
 	if (fd < 0)
 		return false;
-	close_and_unlink(fd);
+	close(fd);
 	return true;
 }
 
@@ -200,7 +180,7 @@ static int userspace_set_device(struct wgdevice *dev)
 		goto out;
 	ret = ret_code;
 out:
-	close_and_unlink(fd);
+	close(fd);
 	errno = -ret;
 	return (int)ret;
 }
@@ -251,7 +231,7 @@ static int userspace_get_device(struct wgdevice **dev, const char *interface)
 out:
 	if (*dev && ret)
 		free(*dev);
-	close_and_unlink(fd);
+	close(fd);
 	errno = -ret;
 	return ret;
 }
diff --git a/src/ipc.h b/src/ipc.h
index b2312ad..9cb9db2 100644
--- a/src/ipc.h
+++ b/src/ipc.h
@@ -12,13 +12,4 @@ int ipc_get_device(struct wgdevice **dev, const char *interface);
 char *ipc_list_devices(void);
 bool ipc_has_device(const char *interface);
 
-
-#define for_each_wgpeer(__dev, __peer, __i) for ((__i) = 0, (__peer) = (typeof(__peer))((uint8_t *)(__dev) + sizeof(struct wgdevice)); \
-						 (__i) < (__dev)->num_peers; \
-						 ++(__i), (__peer) = (typeof(__peer))((uint8_t *)(__peer) + sizeof(struct wgpeer) + (sizeof(struct wgipmask) * (__peer)->num_ipmasks)))
-
-#define for_each_wgipmask(__peer, __ipmask, __i) for ((__i) = 0, (__ipmask) = (typeof(__ipmask))((uint8_t *)(__peer) + sizeof(struct wgpeer)); \
-						 (__i) < (__peer)->num_ipmasks; \
-						 ++(__i), (__ipmask) = (typeof(__ipmask))((uint8_t *)(__ipmask) + sizeof(struct wgipmask)))
-
 #endif

commit f304bc3199970b676eee23f9c7850f946448994f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 22 14:58:30 2016 +0200

    wg: add -MP to makefile
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 512d7fe..fc0c0f3 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -8,7 +8,7 @@ RUNSTATEDIR ?= /var/run
 CFLAGS ?= -O3
 CFLAGS += -std=gnu11
 CFLAGS += -pedantic -Wall -Wextra
-CFLAGS += -MMD
+CFLAGS += -MMD -MP
 CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
 LDLIBS += -lresolv
 ifeq ($(shell uname -s),Linux)

commit fc725109371fb8c8fd81a7f00489ca9564ba37aa
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 21 16:38:56 2016 +0200

    wg: add default cflag
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 0436f69..512d7fe 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -5,6 +5,7 @@ LIBDIR ?= $(PREFIX)/lib
 MANDIR ?= $(PREFIX)/share/man
 RUNSTATEDIR ?= /var/run
 
+CFLAGS ?= -O3
 CFLAGS += -std=gnu11
 CFLAGS += -pedantic -Wall -Wextra
 CFLAGS += -MMD

commit a8baff2ab3a5a2306da41ae20ed0f96fa93f00e9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 21 13:33:20 2016 +0200

    wg: propagate set errno
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 2fb1246..cc70fd1 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -201,6 +201,7 @@ static int userspace_set_device(struct wgdevice *dev)
 	ret = ret_code;
 out:
 	close_and_unlink(fd);
+	errno = -ret;
 	return (int)ret;
 }
 

commit a773a23c75ea42bb296f8b7a3b229b247f2e896b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 21 12:27:54 2016 +0200

    wg: abstract sockets are dangerous
    
    They have no permissions, so we're probably better off just creating a
    socket file with the umask set, as we do in BSD.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/ipc.c b/src/ipc.c
index 3243fcb..2fb1246 100644
--- a/src/ipc.c
+++ b/src/ipc.c
@@ -80,7 +80,6 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
-#ifndef __linux__
 static void close_and_unlink(int fd)
 {
 	struct sockaddr_un addr;
@@ -90,16 +89,12 @@ static void close_and_unlink(int fd)
 		unlink(addr.sun_path);
 	close(fd);
 }
-#endif
 
 static int userspace_interface_fd(const char *interface)
 {
 	struct stat sbuf;
-	struct sockaddr_un addr = { .sun_family = AF_UNIX };
-#ifndef __linux__
-	struct sockaddr_un bind_addr = { .sun_family = AF_UNIX };
+	struct sockaddr_un addr = { .sun_family = AF_UNIX }, bind_addr = { .sun_family = AF_UNIX };
 	mode_t old_umask;
-#endif
 	int fd = -1, ret;
 
 	ret = -EINVAL;
@@ -108,12 +103,10 @@ static int userspace_interface_fd(const char *interface)
 	ret = snprintf(addr.sun_path, sizeof(addr.sun_path) - 1, SOCK_PATH "%s" SOCK_SUFFIX, interface);
 	if (ret < 0)
 		goto out;
-#ifndef __linux__
 	ret = snprintf(bind_addr.sun_path, sizeof(bind_addr.sun_path) - 1, SOCK_PATH ".wg-tool-%s-%d.client", interface, getpid());
 	if (ret < 0)
 		goto out;
 	unlink(bind_addr.sun_path);
-#endif
 	ret = stat(addr.sun_path, &sbuf);
 	if (ret < 0)
 		goto out;
@@ -124,13 +117,9 @@ static int userspace_interface_fd(const char *interface)
 	ret = fd = socket(AF_UNIX, SOCK_DGRAM, 0);
 	if (ret < 0)
 		goto out;
-#ifdef __linux__
-	ret = bind(fd, (struct sockaddr *)&addr, sizeof(sa_family_t));
-#else
 	old_umask = umask(0077);
 	ret = bind(fd, (struct sockaddr *)&bind_addr, sizeof(bind_addr));
 	umask(old_umask);
-#endif
 	if (ret < 0)
 		goto out;
 
@@ -142,11 +131,7 @@ static int userspace_interface_fd(const char *interface)
 	}
 out:
 	if (ret && fd >= 0)
-#ifdef __linux__
-		close(fd);
-#else
 		close_and_unlink(fd);
-#endif
 	if (!ret)
 		ret = fd;
 	return ret;
@@ -157,11 +142,7 @@ static bool userspace_has_wireguard_interface(const char *interface)
 	int fd = userspace_interface_fd(interface);
 	if (fd < 0)
 		return false;
-#ifdef __linux__
-	close(fd);
-#else
 	close_and_unlink(fd);
-#endif
 	return true;
 }
 
@@ -219,11 +200,7 @@ static int userspace_set_device(struct wgdevice *dev)
 		goto out;
 	ret = ret_code;
 out:
-#ifdef __linux__
-	close(fd);
-#else
 	close_and_unlink(fd);
-#endif
 	return (int)ret;
 }
 
@@ -273,11 +250,7 @@ static int userspace_get_device(struct wgdevice **dev, const char *interface)
 out:
 	if (*dev && ret)
 		free(*dev);
-#ifdef __linux__
-	close(fd);
-#else
 	close_and_unlink(fd);
-#endif
 	errno = -ret;
 	return ret;
 }

commit b318e81cd0849ef7725f6776a680eccc7fcfdc06
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jul 20 21:24:27 2016 +0200

    wg: rename kernel to ipc
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index c24aa87..611207e 100644
--- a/src/config.c
+++ b/src/config.c
@@ -12,7 +12,7 @@
 #include <errno.h>
 
 #include "config.h"
-#include "kernel.h"
+#include "ipc.h"
 #include "base64.h"
 
 #define COMMENT_CHAR '#'
diff --git a/src/kernel.c b/src/ipc.c
similarity index 98%
rename from src/kernel.c
rename to src/ipc.c
index ad5d1fe..3243fcb 100644
--- a/src/kernel.c
+++ b/src/ipc.c
@@ -26,7 +26,7 @@
 #include <sys/un.h>
 #include <sys/signal.h>
 
-#include "kernel.h"
+#include "ipc.h"
 #include "../uapi.h"
 
 #define SOCK_PATH RUNSTATEDIR "/wireguard/"
@@ -455,7 +455,7 @@ out:
 #endif
 
 /* first\0second\0third\0forth\0last\0\0 */
-char *get_wireguard_interfaces(void)
+char *ipc_list_devices(void)
 {
 	struct inflatable_buffer buffer = { .len = 4096 };
 	int ret;
@@ -484,7 +484,7 @@ cleanup:
 	return buffer.buffer;
 }
 
-int get_device(struct wgdevice **dev, const char *interface)
+int ipc_get_device(struct wgdevice **dev, const char *interface)
 {
 #ifdef __linux__
 	if (userspace_has_wireguard_interface(interface))
@@ -495,7 +495,7 @@ int get_device(struct wgdevice **dev, const char *interface)
 #endif
 }
 
-int set_device(struct wgdevice *dev)
+int ipc_set_device(struct wgdevice *dev)
 {
 #ifdef __linux__
 	if (userspace_has_wireguard_interface(dev->interface))
@@ -506,7 +506,7 @@ int set_device(struct wgdevice *dev)
 #endif
 }
 
-bool has_wireguard_interface(const char *interface)
+bool ipc_has_device(const char *interface)
 {
 #ifdef __linux__
 	return userspace_has_wireguard_interface(interface) || kernel_has_wireguard_interface(interface);
diff --git a/src/kernel.h b/src/ipc.h
similarity index 76%
rename from src/kernel.h
rename to src/ipc.h
index 8aa0f82..b2312ad 100644
--- a/src/kernel.h
+++ b/src/ipc.h
@@ -1,16 +1,16 @@
 /* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
-#ifndef KERNEL_H
-#define KERNEL_H
+#ifndef IPC_H
+#define IPC_H
 
 #include <stdbool.h>
 
 struct wgdevice;
 
-int set_device(struct wgdevice *dev);
-int get_device(struct wgdevice **dev, const char *interface);
-char *get_wireguard_interfaces(void);
-bool has_wireguard_interface(const char *interface);
+int ipc_set_device(struct wgdevice *dev);
+int ipc_get_device(struct wgdevice **dev, const char *interface);
+char *ipc_list_devices(void);
+bool ipc_has_device(const char *interface);
 
 
 #define for_each_wgpeer(__dev, __peer, __i) for ((__i) = 0, (__peer) = (typeof(__peer))((uint8_t *)(__dev) + sizeof(struct wgdevice)); \
diff --git a/src/set.c b/src/set.c
index 8278151..65f3ff6 100644
--- a/src/set.c
+++ b/src/set.c
@@ -5,7 +5,7 @@
 #include <string.h>
 #include "subcommands.h"
 #include "config.h"
-#include "kernel.h"
+#include "ipc.h"
 
 int set_main(int argc, char *argv[])
 {
@@ -22,7 +22,7 @@ int set_main(int argc, char *argv[])
 	strncpy(device->interface, argv[1], IFNAMSIZ -  1);
 	device->interface[IFNAMSIZ - 1] = 0;
 
-	if (set_device(device) != 0) {
+	if (ipc_set_device(device) != 0) {
 		perror("Unable to set device");
 		goto cleanup;
 	}
diff --git a/src/setconf.c b/src/setconf.c
index a9787eb..a3105e1 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -6,7 +6,7 @@
 #include <string.h>
 
 #include "config.h"
-#include "kernel.h"
+#include "ipc.h"
 #include "subcommands.h"
 
 int setconf_main(int argc, char *argv[])
@@ -45,7 +45,7 @@ int setconf_main(int argc, char *argv[])
 	strncpy(device->interface, argv[1], IFNAMSIZ - 1);
 	device->interface[IFNAMSIZ - 1] = 0;
 
-	if (set_device(device) != 0) {
+	if (ipc_set_device(device) != 0) {
 		perror("Unable to set device");
 		goto cleanup;
 	}
diff --git a/src/show.c b/src/show.c
index d606b4e..ddda6c3 100644
--- a/src/show.c
+++ b/src/show.c
@@ -14,7 +14,7 @@
 #include <time.h>
 #include <netdb.h>
 
-#include "kernel.h"
+#include "ipc.h"
 #include "subcommands.h"
 #include "terminal.h"
 #include "base64.h"
@@ -326,7 +326,7 @@ int show_main(int argc, char *argv[])
 	}
 
 	if (argc == 1 || !strcmp(argv[1], "all")) {
-		char *interfaces = get_wireguard_interfaces(), *interface;
+		char *interfaces = ipc_list_devices(), *interface;
 		if (!interfaces) {
 			perror("Unable to get devices");
 			return 1;
@@ -334,7 +334,7 @@ int show_main(int argc, char *argv[])
 		interface = interfaces;
 		for (size_t len = 0; (len = strlen(interface)); interface += len + 1) {
 			struct wgdevice *device = NULL;
-			if (get_device(&device, interface) < 0) {
+			if (ipc_get_device(&device, interface) < 0) {
 				perror("Unable to get device");
 				continue;
 			}
@@ -358,7 +358,7 @@ int show_main(int argc, char *argv[])
 			show_usage();
 			return 1;
 		}
-		interfaces = get_wireguard_interfaces();
+		interfaces = ipc_list_devices();
 		if (!interfaces) {
 			perror("Unable to get devices");
 			return 1;
@@ -371,12 +371,12 @@ int show_main(int argc, char *argv[])
 		show_usage();
 	else {
 		struct wgdevice *device = NULL;
-		if (!has_wireguard_interface(argv[1])) {
+		if (!ipc_has_device(argv[1])) {
 			fprintf(stderr, "`%s` is not a valid WireGuard interface\n", argv[1]);
 			show_usage();
 			return 1;
 		}
-		if (get_device(&device, argv[1]) < 0) {
+		if (ipc_get_device(&device, argv[1]) < 0) {
 			perror("Unable to get device");
 			show_usage();
 			return 1;
diff --git a/src/showconf.c b/src/showconf.c
index 68084c0..75d78e0 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -12,7 +12,7 @@
 
 #include "subcommands.h"
 #include "base64.h"
-#include "kernel.h"
+#include "ipc.h"
 #include "../uapi.h"
 
 int showconf_main(int argc, char *argv[])
@@ -31,13 +31,13 @@ int showconf_main(int argc, char *argv[])
 		return 1;
 	}
 
-	if (!has_wireguard_interface(argv[1])) {
+	if (!ipc_has_device(argv[1])) {
 		fprintf(stderr, "`%s` is not a valid WireGuard interface\n", argv[1]);
 		fprintf(stderr, "Usage: %s %s <interface>\n", PROG_NAME, argv[0]);
 		return 1;
 	}
 
-	if (get_device(&device, argv[1])) {
+	if (ipc_get_device(&device, argv[1])) {
 		perror("Unable to get device");
 		goto cleanup;
 	}

commit 9889b427887f8c865aef35f1b00f5dc244f23f5b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jul 20 20:52:11 2016 +0200

    wg: support horrible freebsd/osx/unix semantics
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/kernel.c b/src/kernel.c
index da80d95..ad5d1fe 100644
--- a/src/kernel.c
+++ b/src/kernel.c
@@ -80,14 +80,40 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	return 0;
 }
 
+#ifndef __linux__
+static void close_and_unlink(int fd)
+{
+	struct sockaddr_un addr;
+	socklen_t len = sizeof(addr);
+
+	if (!getsockname(fd, (struct sockaddr *)&addr, &len))
+		unlink(addr.sun_path);
+	close(fd);
+}
+#endif
+
 static int userspace_interface_fd(const char *interface)
 {
 	struct stat sbuf;
 	struct sockaddr_un addr = { .sun_family = AF_UNIX };
+#ifndef __linux__
+	struct sockaddr_un bind_addr = { .sun_family = AF_UNIX };
+	mode_t old_umask;
+#endif
 	int fd = -1, ret;
+
+	ret = -EINVAL;
+	if (strchr(interface, '/'))
+		goto out;
 	ret = snprintf(addr.sun_path, sizeof(addr.sun_path) - 1, SOCK_PATH "%s" SOCK_SUFFIX, interface);
 	if (ret < 0)
 		goto out;
+#ifndef __linux__
+	ret = snprintf(bind_addr.sun_path, sizeof(bind_addr.sun_path) - 1, SOCK_PATH ".wg-tool-%s-%d.client", interface, getpid());
+	if (ret < 0)
+		goto out;
+	unlink(bind_addr.sun_path);
+#endif
 	ret = stat(addr.sun_path, &sbuf);
 	if (ret < 0)
 		goto out;
@@ -98,9 +124,16 @@ static int userspace_interface_fd(const char *interface)
 	ret = fd = socket(AF_UNIX, SOCK_DGRAM, 0);
 	if (ret < 0)
 		goto out;
+#ifdef __linux__
 	ret = bind(fd, (struct sockaddr *)&addr, sizeof(sa_family_t));
+#else
+	old_umask = umask(0077);
+	ret = bind(fd, (struct sockaddr *)&bind_addr, sizeof(bind_addr));
+	umask(old_umask);
+#endif
 	if (ret < 0)
 		goto out;
+
 	ret = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
 	if (ret < 0) {
 		if (errno == ECONNREFUSED) /* If the process is gone, we try to clean up the socket. */
@@ -109,7 +142,11 @@ static int userspace_interface_fd(const char *interface)
 	}
 out:
 	if (ret && fd >= 0)
+#ifdef __linux__
 		close(fd);
+#else
+		close_and_unlink(fd);
+#endif
 	if (!ret)
 		ret = fd;
 	return ret;
@@ -120,7 +157,11 @@ static bool userspace_has_wireguard_interface(const char *interface)
 	int fd = userspace_interface_fd(interface);
 	if (fd < 0)
 		return false;
+#ifdef __linux__
 	close(fd);
+#else
+	close_and_unlink(fd);
+#endif
 	return true;
 }
 
@@ -178,14 +219,23 @@ static int userspace_set_device(struct wgdevice *dev)
 		goto out;
 	ret = ret_code;
 out:
+#ifdef __linux__
 	close(fd);
+#else
+	close_and_unlink(fd);
+#endif
 	return (int)ret;
 }
 
 static int userspace_get_device(struct wgdevice **dev, const char *interface)
 {
+#ifdef __linux__
 	ssize_t len;
-	int ret, fd = userspace_interface_fd(interface);
+#else
+	int len;
+#endif
+	ssize_t ret;
+	int fd = userspace_interface_fd(interface);
 	if (fd < 0)
 		return fd;
 	*dev = NULL;
@@ -193,9 +243,20 @@ static int userspace_get_device(struct wgdevice **dev, const char *interface)
 	if (ret < 0)
 		goto out;
 
+#ifdef __linux__
 	ret = len = recv(fd, NULL, 0, MSG_PEEK | MSG_TRUNC);
 	if (len < 0)
 		goto out;
+#else
+	ret = recv(fd, &ret, 1, MSG_PEEK);
+	if (ret < 0)
+		goto out;
+	ret = ioctl(fd, FIONREAD, &len);
+	if (ret < 0) {
+		ret = -errno;
+		goto out;
+	}
+#endif
 	ret = -EBADMSG;
 	if ((size_t)len < sizeof(struct wgdevice))
 		goto out;
@@ -212,7 +273,11 @@ static int userspace_get_device(struct wgdevice **dev, const char *interface)
 out:
 	if (*dev && ret)
 		free(*dev);
+#ifdef __linux__
 	close(fd);
+#else
+	close_and_unlink(fd);
+#endif
 	errno = -ret;
 	return ret;
 }

commit b16641e30c6d9d3de356ce8ba29fc84157ba07f0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jul 19 15:26:56 2016 +0200

    wg: first additions of userspace integration
    
    This is designed to work with a server that follows this:
    
      struct sockaddr_un addr = {
          .sun_family = AF_UNIX,
          .sun_path = "/var/run/wireguard/wguserspace0.sock"
      };
      int fd, ret;
      ssize_t len;
      socklen_t socklen;
      struct wgdevice *device;
    
      fd = socket(AF_UNIX, SOCK_DGRAM, 0);
      if (fd < 0)
          exit(1);
      if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
          exit(1);
    
      for (;;) {
          /* First we look at how big the next message is, so we know how much to
           * allocate. Note on BSD you can instead use ioctl(fd, FIONREAD, &len). */
          len = recv(fd, NULL, 0, MSG_PEEK | MSG_TRUNC);
          if (len < 0) {
              handle_error();
              continue;
          }
          /* Next we allocate a buffer for the received data. */
          device = NULL;
          if (len) {
              device = malloc(len);
              if (!device) {
                  handle_error();
                  continue;
              }
          }
          /* Finally we receive the data, storing too the return address. */
          socklen = sizeof(addr);
          len = recvfrom(fd, device, len, 0, (struct sockaddr *)&addr, (socklen_t *)&socklen);
          if (len < 0) {
              handle_error();
              free(device);
              continue;
          }
          if (!len) { /* If len is zero, it's a "get" request, so we send our device back. */
              device = get_current_wireguard_device(&len);
              sendto(fd, device, len, 0, (struct sockaddr *)&addr, socklen);
          } else { /* Otherwise, we just received a wgdevice, so we should "set" and send back the return status. */
              ret = set_current_wireguard_device(device);
              sendto(fd, &ret, sizeof(ret), 0, (struct sockaddr *)&addr, socklen);
              free(device);
          }
      }
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 060ae18..0436f69 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -3,12 +3,19 @@ DESTDIR ?=
 BINDIR ?= $(PREFIX)/bin
 LIBDIR ?= $(PREFIX)/lib
 MANDIR ?= $(PREFIX)/share/man
+RUNSTATEDIR ?= /var/run
 
-CFLAGS += $(shell pkg-config --cflags libmnl 2>/dev/null)
 CFLAGS += -std=gnu11
 CFLAGS += -pedantic -Wall -Wextra
 CFLAGS += -MMD
-LDLIBS += -lresolv $(shell pkg-config --libs libmnl 2>/dev/null || echo -lmnl)
+CFLAGS += -DRUNSTATEDIR="\"$(RUNSTATEDIR)\""
+LDLIBS += -lresolv
+ifeq ($(shell uname -s),Linux)
+LIBMNL_CFLAGS := $(shell pkg-config --cflags libmnl 2>/dev/null)
+LIBMNL_LDLIBS := $(shell pkg-config --libs libmnl 2>/dev/null || echo -lmnl)
+CFLAGS += $(LIBMNL_CFLAGS)
+LDLIBS += $(LIBMNL_LDLIBS)
+endif
 
 wg: $(patsubst %.c,%.o,$(wildcard *.c))
 
diff --git a/src/genkey.c b/src/genkey.c
index a312b46..af2765f 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -5,9 +5,11 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <syscall.h>
 #include <string.h>
 #include <fcntl.h>
+#ifdef __linux
+#include <syscall.h>
+#endif
 
 #include "curve25519.h"
 #include "base64.h"
@@ -17,7 +19,7 @@ static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
 {
 	ssize_t ret;
 	int fd;
-#ifdef __NR_getrandom
+#if defined(__NR_getrandom) && defined(__linux__)
 	ret = syscall(__NR_getrandom, out, len, 0);
 	if (ret >= 0)
 		return ret;
diff --git a/src/kernel.c b/src/kernel.c
index 0448308..da80d95 100644
--- a/src/kernel.c
+++ b/src/kernel.c
@@ -1,25 +1,37 @@
 /* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
 
-#include <errno.h>
+#ifdef __linux__
 #include <libmnl/libmnl.h>
 #include <linux/if_link.h>
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
+#endif
 #include <netinet/in.h>
 #include <net/if.h>
+#include <errno.h>
 #include <stdbool.h>
 #include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <time.h>
+#include <dirent.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
-#include <time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <sys/signal.h>
 
 #include "kernel.h"
 #include "../uapi.h"
 
+#define SOCK_PATH RUNSTATEDIR "/wireguard/"
+#define SOCK_SUFFIX ".sock"
+
 struct inflatable_buffer {
 	char *buffer;
 	char *next;
@@ -37,19 +49,24 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 
 	if (!buffer->good || !buffer->next) {
 		free(buffer->next);
+		buffer->good = false;
 		return 0;
 	}
 
 	len = strlen(buffer->next) + 1;
 
-	if (len == 1)
+	if (len == 1) {
+		free(buffer->next);
+		buffer->good = false;
 		return 0;
+	}
 
 	if (buffer->len - buffer->pos <= len) {
 		expand_to = max(buffer->len * 2, buffer->len + len + 1);
 		new_buffer = realloc(buffer->buffer, expand_to);
 		if (!new_buffer) {
 			free(buffer->next);
+			buffer->good = false;
 			return -errno;
 		}
 		memset(&new_buffer[buffer->len], 0, expand_to - buffer->len);
@@ -58,10 +75,149 @@ static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
 	}
 	memcpy(&buffer->buffer[buffer->pos], buffer->next, len);
 	free(buffer->next);
+	buffer->good = false;
 	buffer->pos += len;
 	return 0;
 }
 
+static int userspace_interface_fd(const char *interface)
+{
+	struct stat sbuf;
+	struct sockaddr_un addr = { .sun_family = AF_UNIX };
+	int fd = -1, ret;
+	ret = snprintf(addr.sun_path, sizeof(addr.sun_path) - 1, SOCK_PATH "%s" SOCK_SUFFIX, interface);
+	if (ret < 0)
+		goto out;
+	ret = stat(addr.sun_path, &sbuf);
+	if (ret < 0)
+		goto out;
+	ret = -EBADF;
+	if (!S_ISSOCK(sbuf.st_mode))
+		goto out;
+
+	ret = fd = socket(AF_UNIX, SOCK_DGRAM, 0);
+	if (ret < 0)
+		goto out;
+	ret = bind(fd, (struct sockaddr *)&addr, sizeof(sa_family_t));
+	if (ret < 0)
+		goto out;
+	ret = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
+	if (ret < 0) {
+		if (errno == ECONNREFUSED) /* If the process is gone, we try to clean up the socket. */
+			unlink(addr.sun_path);
+		goto out;
+	}
+out:
+	if (ret && fd >= 0)
+		close(fd);
+	if (!ret)
+		ret = fd;
+	return ret;
+}
+
+static bool userspace_has_wireguard_interface(const char *interface)
+{
+	int fd = userspace_interface_fd(interface);
+	if (fd < 0)
+		return false;
+	close(fd);
+	return true;
+}
+
+static int userspace_get_wireguard_interfaces(struct inflatable_buffer *buffer)
+{
+	DIR *dir;
+	struct dirent *ent;
+	size_t len;
+	char *end;
+	int ret = 0;
+
+	dir = opendir(SOCK_PATH);
+	if (!dir)
+		return errno == ENOENT ? 0 : errno;
+	while ((ent = readdir(dir))) {
+		len = strlen(ent->d_name);
+		if (len <= strlen(SOCK_SUFFIX))
+			continue;
+		end = &ent->d_name[len - strlen(SOCK_SUFFIX)];
+		if (strncmp(end, SOCK_SUFFIX, strlen(SOCK_SUFFIX)))
+			continue;
+		*end = '\0';
+		if (!userspace_has_wireguard_interface(ent->d_name))
+			continue;
+		buffer->next = strdup(ent->d_name);
+		buffer->good = true;
+		ret = add_next_to_inflatable_buffer(buffer);
+		if (ret < 0)
+			goto out;
+	}
+out:
+	closedir(dir);
+	return ret;
+}
+
+static int userspace_set_device(struct wgdevice *dev)
+{
+	struct wgpeer *peer;
+	size_t len;
+	ssize_t ret;
+	int ret_code;
+	int fd = userspace_interface_fd(dev->interface);
+	if (fd < 0)
+		return fd;
+	for_each_wgpeer(dev, peer, len);
+	len = (unsigned char *)peer - (unsigned char *)dev;
+	ret = -EBADMSG;
+	if (!len)
+		goto out;
+	ret = send(fd, dev, len, 0);
+	if (ret < 0)
+		goto out;
+	ret = recv(fd, &ret_code, sizeof(ret_code), 0);
+	if (ret < 0)
+		goto out;
+	ret = ret_code;
+out:
+	close(fd);
+	return (int)ret;
+}
+
+static int userspace_get_device(struct wgdevice **dev, const char *interface)
+{
+	ssize_t len;
+	int ret, fd = userspace_interface_fd(interface);
+	if (fd < 0)
+		return fd;
+	*dev = NULL;
+	ret = send(fd, NULL, 0, 0);
+	if (ret < 0)
+		goto out;
+
+	ret = len = recv(fd, NULL, 0, MSG_PEEK | MSG_TRUNC);
+	if (len < 0)
+		goto out;
+	ret = -EBADMSG;
+	if ((size_t)len < sizeof(struct wgdevice))
+		goto out;
+
+	ret = -ENOMEM;
+	*dev = calloc(len, 1);
+	if (!*dev)
+		goto out;
+
+	ret = recv(fd, *dev, len, 0);
+	if (ret < 0)
+		goto out;
+	ret = 0;
+out:
+	if (*dev && ret)
+		free(*dev);
+	close(fd);
+	errno = -ret;
+	return ret;
+}
+
+#ifdef __linux__
 static int parse_linkinfo(const struct nlattr *attr, void *data)
 {
 	struct inflatable_buffer *buffer = data;
@@ -96,8 +252,7 @@ static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
 	return MNL_CB_OK;
 }
 
-/* first\0second\0third\0forth\0last\0\0 */
-char *kernel_get_wireguard_interfaces(void)
+static int kernel_get_wireguard_interfaces(struct inflatable_buffer *buffer)
 {
 	struct mnl_socket *nl = NULL;
 	char *rtnl_buffer = NULL;
@@ -105,22 +260,13 @@ char *kernel_get_wireguard_interfaces(void)
 	unsigned int portid, seq;
 	ssize_t len;
 	int ret = 0;
-	struct inflatable_buffer buffer = { 0 };
 	struct nlmsghdr *nlh;
 	struct ifinfomsg *ifm;
 
-	buffer.len = 4096;
-	buffer.buffer = calloc(buffer.len, 1);
-	if (!buffer.buffer) {
-		ret = -errno;
-		goto cleanup;
-	}
-
+	ret = -ENOMEM;
 	rtnl_buffer = calloc(4096, 1);
-	if (!rtnl_buffer) {
-		ret = -errno;
+	if (!rtnl_buffer)
 		goto cleanup;
-	}
 
 	nl = mnl_socket_open(NETLINK_ROUTE);
 	if (!nl) {
@@ -153,39 +299,41 @@ another:
 		ret = -errno;
 		goto cleanup;
 	}
-	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, &buffer)) < 0) {
+	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, buffer)) < 0) {
 		ret = -errno;
 		goto cleanup;
 	}
 	if (len == MNL_CB_OK + 1)
 		goto another;
+	ret = 0;
 
 cleanup:
 	free(rtnl_buffer);
 	if (nl)
 		mnl_socket_close(nl);
-	errno = -ret;
-	if (errno) {
-		perror("Error when trying to get a list of Wireguard interfaces");
-		free(buffer.buffer);
-		return NULL;
-	}
-	return buffer.buffer;
+	return ret;
 }
 
-bool kernel_has_wireguard_interface(const char *interface)
+static bool kernel_has_wireguard_interface(const char *interface)
 {
-	char *interfaces, *this_interface;
-	this_interface = interfaces = kernel_get_wireguard_interfaces();
-	if (!interfaces)
+	char *this_interface;
+	struct inflatable_buffer buffer = { .len = 4096 };
+
+	buffer.buffer = calloc(buffer.len, 1);
+	if (!buffer.buffer)
 		return false;
+	if (kernel_get_wireguard_interfaces(&buffer) < 0) {
+		free(buffer.buffer);
+		return false;
+	}
+	this_interface = buffer.buffer;
 	for (size_t len = 0; (len = strlen(this_interface)); this_interface += len + 1) {
 		if (!strcmp(interface, this_interface)) {
-			free(interfaces);
+			free(buffer.buffer);
 			return true;
 		}
 	}
-	free(interfaces);
+	free(buffer.buffer);
 	return false;
 }
 
@@ -200,7 +348,7 @@ static int do_ioctl(int req, struct ifreq *ifreq)
 	return ioctl(fd, req, ifreq);
 }
 
-int kernel_set_device(struct wgdevice *dev)
+static int kernel_set_device(struct wgdevice *dev)
 {
 	struct ifreq ifreq = { .ifr_data = (char *)dev };
 	memcpy(&ifreq.ifr_name, dev->interface, IFNAMSIZ);
@@ -208,7 +356,7 @@ int kernel_set_device(struct wgdevice *dev)
 	return do_ioctl(WG_SET_DEVICE, &ifreq);
 }
 
-int kernel_get_device(struct wgdevice **dev, const char *interface)
+static int kernel_get_device(struct wgdevice **dev, const char *interface)
 {
 	int ret;
 	struct ifreq ifreq = { 0 };
@@ -222,7 +370,6 @@ int kernel_get_device(struct wgdevice **dev, const char *interface)
 			goto out;
 		*dev = calloc(ret + sizeof(struct wgdevice), 1);
 		if (!*dev) {
-			perror("calloc");
 			ret = -ENOMEM;
 			goto out;
 		}
@@ -240,3 +387,65 @@ out:
 	errno = -ret;
 	return ret;
 }
+#endif
+
+/* first\0second\0third\0forth\0last\0\0 */
+char *get_wireguard_interfaces(void)
+{
+	struct inflatable_buffer buffer = { .len = 4096 };
+	int ret;
+
+	ret = -ENOMEM;
+	buffer.buffer = calloc(buffer.len, 1);
+	if (!buffer.buffer)
+		goto cleanup;
+
+#ifdef __linux__
+	ret = kernel_get_wireguard_interfaces(&buffer);
+	if (ret < 0)
+		goto cleanup;
+#endif
+	ret = userspace_get_wireguard_interfaces(&buffer);
+	if (ret < 0)
+		goto cleanup;
+
+cleanup:
+	errno = -ret;
+	if (errno) {
+		perror("Error when trying to get a list of WireGuard interfaces");
+		free(buffer.buffer);
+		return NULL;
+	}
+	return buffer.buffer;
+}
+
+int get_device(struct wgdevice **dev, const char *interface)
+{
+#ifdef __linux__
+	if (userspace_has_wireguard_interface(interface))
+		return userspace_get_device(dev, interface);
+	return kernel_get_device(dev, interface);
+#else
+	return userspace_get_device(dev, interface);
+#endif
+}
+
+int set_device(struct wgdevice *dev)
+{
+#ifdef __linux__
+	if (userspace_has_wireguard_interface(dev->interface))
+		return userspace_set_device(dev);
+	return kernel_set_device(dev);
+#else
+	return userspace_set_device(dev);
+#endif
+}
+
+bool has_wireguard_interface(const char *interface)
+{
+#ifdef __linux__
+	return userspace_has_wireguard_interface(interface) || kernel_has_wireguard_interface(interface);
+#else
+	return userspace_has_wireguard_interface(interface);
+#endif
+}
diff --git a/src/kernel.h b/src/kernel.h
index 0525ce1..8aa0f82 100644
--- a/src/kernel.h
+++ b/src/kernel.h
@@ -7,10 +7,10 @@
 
 struct wgdevice;
 
-int kernel_set_device(struct wgdevice *dev);
-int kernel_get_device(struct wgdevice **dev, const char *interface);
-char *kernel_get_wireguard_interfaces(void);
-bool kernel_has_wireguard_interface(const char *interface);
+int set_device(struct wgdevice *dev);
+int get_device(struct wgdevice **dev, const char *interface);
+char *get_wireguard_interfaces(void);
+bool has_wireguard_interface(const char *interface);
 
 
 #define for_each_wgpeer(__dev, __peer, __i) for ((__i) = 0, (__peer) = (typeof(__peer))((uint8_t *)(__dev) + sizeof(struct wgdevice)); \
diff --git a/src/set.c b/src/set.c
index c7656e8..8278151 100644
--- a/src/set.c
+++ b/src/set.c
@@ -22,7 +22,7 @@ int set_main(int argc, char *argv[])
 	strncpy(device->interface, argv[1], IFNAMSIZ -  1);
 	device->interface[IFNAMSIZ - 1] = 0;
 
-	if (kernel_set_device(device) != 0) {
+	if (set_device(device) != 0) {
 		perror("Unable to set device");
 		goto cleanup;
 	}
diff --git a/src/setconf.c b/src/setconf.c
index 81faa64..a9787eb 100644
--- a/src/setconf.c
+++ b/src/setconf.c
@@ -45,7 +45,7 @@ int setconf_main(int argc, char *argv[])
 	strncpy(device->interface, argv[1], IFNAMSIZ - 1);
 	device->interface[IFNAMSIZ - 1] = 0;
 
-	if (kernel_set_device(device) != 0) {
+	if (set_device(device) != 0) {
 		perror("Unable to set device");
 		goto cleanup;
 	}
diff --git a/src/show.c b/src/show.c
index 7927534..d606b4e 100644
--- a/src/show.c
+++ b/src/show.c
@@ -326,7 +326,7 @@ int show_main(int argc, char *argv[])
 	}
 
 	if (argc == 1 || !strcmp(argv[1], "all")) {
-		char *interfaces = kernel_get_wireguard_interfaces(), *interface;
+		char *interfaces = get_wireguard_interfaces(), *interface;
 		if (!interfaces) {
 			perror("Unable to get devices");
 			return 1;
@@ -334,7 +334,7 @@ int show_main(int argc, char *argv[])
 		interface = interfaces;
 		for (size_t len = 0; (len = strlen(interface)); interface += len + 1) {
 			struct wgdevice *device = NULL;
-			if (kernel_get_device(&device, interface) < 0) {
+			if (get_device(&device, interface) < 0) {
 				perror("Unable to get device");
 				continue;
 			}
@@ -358,7 +358,7 @@ int show_main(int argc, char *argv[])
 			show_usage();
 			return 1;
 		}
-		interfaces = kernel_get_wireguard_interfaces();
+		interfaces = get_wireguard_interfaces();
 		if (!interfaces) {
 			perror("Unable to get devices");
 			return 1;
@@ -371,12 +371,12 @@ int show_main(int argc, char *argv[])
 		show_usage();
 	else {
 		struct wgdevice *device = NULL;
-		if (!kernel_has_wireguard_interface(argv[1])) {
+		if (!has_wireguard_interface(argv[1])) {
 			fprintf(stderr, "`%s` is not a valid WireGuard interface\n", argv[1]);
 			show_usage();
 			return 1;
 		}
-		if (kernel_get_device(&device, argv[1]) < 0) {
+		if (get_device(&device, argv[1]) < 0) {
 			perror("Unable to get device");
 			show_usage();
 			return 1;
diff --git a/src/showconf.c b/src/showconf.c
index 95d2e17..68084c0 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -31,13 +31,13 @@ int showconf_main(int argc, char *argv[])
 		return 1;
 	}
 
-	if (!kernel_has_wireguard_interface(argv[1])) {
+	if (!has_wireguard_interface(argv[1])) {
 		fprintf(stderr, "`%s` is not a valid WireGuard interface\n", argv[1]);
 		fprintf(stderr, "Usage: %s %s <interface>\n", PROG_NAME, argv[0]);
 		return 1;
 	}
 
-	if (kernel_get_device(&device, argv[1])) {
+	if (get_device(&device, argv[1])) {
 		perror("Unable to get device");
 		goto cleanup;
 	}

commit fd14807259226e9a97f46d70988ff2b9b5051613
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jul 11 12:49:47 2016 +0200

    wg: fix numbering in man page
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg.8 b/src/wg.8
index 4f5d8f5..b8e6596 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -113,7 +113,7 @@ The configuration file format is based on \fIINI\fP. There are two top level sec
 only one \fIInterface\fP section may be specified.
 
 .P
-The \fIInterface\fP section contains two fields:
+The \fIInterface\fP section may contain the following fields:
 .IP \(bu
 PrivateKey \(em a base64 private key generated by \fIwg genkey\fP. Required.
 .IP \(bu
@@ -125,7 +125,7 @@ for post-quantum resistance.
 ListenPort \(em a 16-bit port for listening. Optional; if not specified,
 automatically generated based on interface name.
 .P
-The \fIPeer\fP sections contain three fields each:
+The \fIPeer\fP sections may contain the following fields:
 .IP \(bu
 PublicKey \(em a base64 public key calculated by \fIwg pubkey\fP from a
 private key, and usually transmitted out of band to the author of the

commit 46a6bf3a520634490175814437d19a1085aa8716
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 8 20:34:32 2016 +0200

    persistent keepalive: use authenticated keepalives
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg.8 b/src/wg.8
index 347fb27..4f5d8f5 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -68,12 +68,12 @@ public-key cryptography, for post-quantum resistance. If \fIallowed-ips\fP
 is specified, but the value is the empty string, all allowed ips are removed
 from the peer. The use of \fIpersistent-keepalive\fP is optional and is by
 default off; setting it to 0 or "off", disables it. Otherwise it represents,
-in seconds, between 10 and 3600 inclusive, how often to send an empty UDP
-packet to the peer, for the purpose of keeping a stateful firewall or NAT
+in seconds, between 10 and 3600 inclusive, how often to send an authenticated
+empty packet to the peer, for the purpose of keeping a stateful firewall or NAT
 mapping valid persistently. For example, if the interface very rarely sends
 traffic, but it might at anytime receive traffic from a peer, and it is behind
 NAT, the interface might benefit from having a persistent keepalive interval
-of 25 seconds.
+of 25 seconds; however, most users will not need this.
 .TP
 \fBsetconf\fP \fI<interface>\fP \fI<configuration-filename>\fP
 Sets the current configuration of \fI<interface>\fP to the contents of
@@ -143,12 +143,12 @@ source IP address and port of correctly authenticated packets from the peer.
 Optional.
 .IP \(bu
 PersistentKeepalive \(em a seconds interval, between 10 and 3600 inclusive, of
-how often to send an empty UDP packet to the peer for the purpose of keeping a
+how often to send an authenticated empty packet to the peer for the purpose of keeping a
 stateful firewall or NAT mapping valid persistently. For example, if the interface
 very rarely sends traffic, but it might at anytime receive traffic from a peer,
 and it is behind NAT, the interface might benefit from having a persistent keepalive
 interval of 25 seconds. If set to 0 or "off", this option is disabled. By default or
-when unspecified, this option is off. Optional.
+when unspecified, this option is off. Most users will not need this. Optional.
 
 .SH CONFIGURATION FILE FORMAT EXAMPLE
 This example may be used as a model for writing configuration files.

commit 2fd253ff1ffbdb12d244108bcafde2fdadbb74fd
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 8 23:41:45 2016 +0200

    examples: update ncat-client-server readme
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/ncat-client-server/README b/contrib/ncat-client-server/README
index fd3088a..f584829 100644
--- a/contrib/ncat-client-server/README
+++ b/contrib/ncat-client-server/README
@@ -5,12 +5,12 @@ demonstration of how easy the `wg(8)` tool is at the command
 line, but by no means should you actually attempt to use
 these. They are horribly insecure and defeat the purpose
 of WireGuard.
-
                      STAY AWAY!
 
-Distros: do not distribute these with your packages.
-
-
-
 That all said, this is a pretty cool example of just how
 darn easy WireGuard can be.
+
+Disclaimer:
+  The `demo.wireguard.io` server in client.sh is for testing
+  purposes only. You may not use this server for abusive or
+  illegal purposes.

commit e2cc7743d5614193a275c08e533da7982470458b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 8 12:36:04 2016 +0200

    persistent keepalive: enable in an example
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/ncat-client-server/client.sh b/contrib/ncat-client-server/client.sh
index fbae46a..ab9fe88 100755
--- a/contrib/ncat-client-server/client.sh
+++ b/contrib/ncat-client-server/client.sh
@@ -9,7 +9,7 @@ IFS=: read -r status server_pubkey server_port internal_ip <&3
 [[ $status == OK ]]
 ip link del dev wg0 2>/dev/null || true
 ip link add dev wg0 type wireguard
-wg set wg0 private-key /tmp/wg_private_key peer "$server_pubkey" allowed-ips 0.0.0.0/0 endpoint "demo.wireguard.io:$server_port"
+wg set wg0 private-key /tmp/wg_private_key peer "$server_pubkey" allowed-ips 0.0.0.0/0 endpoint "demo.wireguard.io:$server_port" persistent-keepalive 25
 ip address add "$internal_ip"/24 dev wg0
 ip link set up dev wg0
 if [ "$1" == "default-route" ]; then

commit d81cafde7f523b095df593475b17d0c0bd3a42ee
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 8 02:52:41 2016 +0200

    persistent keepalive: documentation
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg.8 b/src/wg.8
index eee6d7b..347fb27 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -36,7 +36,7 @@ Sub-commands that take an INTERFACE must be passed a WireGuard interface.
 .SH COMMANDS
 
 .TP
-\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshake\fP | \fIbandwidth\fP]
+\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshake\fP | \fIpersistent-keepalive\fP | \fIbandwidth\fP]
 Shows current WireGuard configuration of specified \fI<interface>\fP.
 If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
 If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,
@@ -49,7 +49,7 @@ newlines and tabs, meant to be used in scripts.
 Shows the current configuration of \fI<interface>\fP in the format described
 by \fICONFIGURATION FILE FORMAT\fP below.
 .TP
-\fBset\fP \fI<interface>\fP [\fIlisten-port\fP \fI<port>\fP] [\fIprivate-key\fP \fI<file-path>\fP] [\fIpreshared-key\fP \fI<file-path>\fP] [\fIpeer\fP \fI<base64-public-key>\fP [\fIremove\fP] [\fIendpoint\fP \fI<ip>:<port>\fP] [\fIallowed-ips\fP \fI<ip1>/<cidr1>\fP[,\fI<ip2>/<cidr2>\fP]...] ]...
+\fBset\fP \fI<interface>\fP [\fIlisten-port\fP \fI<port>\fP] [\fIprivate-key\fP \fI<file-path>\fP] [\fIpreshared-key\fP \fI<file-path>\fP] [\fIpeer\fP \fI<base64-public-key>\fP [\fIremove\fP] [\fIendpoint\fP \fI<ip>:<port>\fP] [\fIpersistent-keepalive\fP \fI<interval seconds>\fP] [\fIallowed-ips\fP \fI<ip1>/<cidr1>\fP[,\fI<ip2>/<cidr2>\fP]...] ]...
 Sets configuration values for the specified \fI<interface>\fP. Multiple
 \fIpeer\fPs may be specified, and if the \fIremove\fP argument is given
 for a peer, that peer is removed, not configured. If \fIlisten-port\fP
@@ -66,7 +66,14 @@ you may safely pass in a string by specifying as \fIprivate-key\fP or
 layer of symmetric-key cryptography to be mixed into the already existing
 public-key cryptography, for post-quantum resistance. If \fIallowed-ips\fP
 is specified, but the value is the empty string, all allowed ips are removed
-from the peer.
+from the peer. The use of \fIpersistent-keepalive\fP is optional and is by
+default off; setting it to 0 or "off", disables it. Otherwise it represents,
+in seconds, between 10 and 3600 inclusive, how often to send an empty UDP
+packet to the peer, for the purpose of keeping a stateful firewall or NAT
+mapping valid persistently. For example, if the interface very rarely sends
+traffic, but it might at anytime receive traffic from a peer, and it is behind
+NAT, the interface might benefit from having a persistent keepalive interval
+of 25 seconds.
 .TP
 \fBsetconf\fP \fI<interface>\fP \fI<configuration-filename>\fP
 Sets the current configuration of \fI<interface>\fP to the contents of
@@ -134,6 +141,14 @@ Endpoint \(em an endpoint IP or hostname, followed by a colon, and then a
 port number. This endpoint will be updated automatically to the most recent
 source IP address and port of correctly authenticated packets from the peer.
 Optional.
+.IP \(bu
+PersistentKeepalive \(em a seconds interval, between 10 and 3600 inclusive, of
+how often to send an empty UDP packet to the peer for the purpose of keeping a
+stateful firewall or NAT mapping valid persistently. For example, if the interface
+very rarely sends traffic, but it might at anytime receive traffic from a peer,
+and it is behind NAT, the interface might benefit from having a persistent keepalive
+interval of 25 seconds. If set to 0 or "off", this option is disabled. By default or
+when unspecified, this option is off. Optional.
 
 .SH CONFIGURATION FILE FORMAT EXAMPLE
 This example may be used as a model for writing configuration files.

commit fc743caf3bcc45da705ac10b656279558db28955
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 8 02:30:03 2016 +0200

    persistent keepalive: add userspace support
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 9066178..c24aa87 100644
--- a/src/config.c
+++ b/src/config.c
@@ -182,6 +182,27 @@ static inline bool parse_endpoint(struct sockaddr_storage *endpoint, const char
 	return true;
 }
 
+static inline bool parse_persistent_keepalive(__u16 *interval, const char *value)
+{
+	unsigned long ret;
+	char *end;
+
+	if (!strcasecmp(value, "off")) {
+		*interval = 0;
+		return true;
+	}
+
+	ret = strtoul(value, &end, 10);
+	if (!*value || *value == '-' || *end || (ret && (ret < 10 || ret > 3600))) {
+		fprintf(stderr, "The persistent keepalive interval must be 0/off or 10-3600. Found: `%s`\n", value);
+		return false;
+	}
+
+	*interval = (__u16)ret;
+	return true;
+}
+
+
 static inline bool parse_ipmasks(struct inflatable_device *buf, size_t peer_offset, const char *value)
 {
 	struct wgpeer *peer;
@@ -263,6 +284,7 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 		ctx->is_peer_section = true;
 		ctx->is_device_section = false;
 		peer_from_offset(ctx->buf.dev, ctx->peer_offset)->replace_ipmasks = true;
+		peer_from_offset(ctx->buf.dev, ctx->peer_offset)->persistent_keepalive_interval = (__u16)-1;
 		return true;
 	}
 
@@ -288,6 +310,8 @@ static bool process_line(struct config_ctx *ctx, const char *line)
 			ret = parse_key(peer_from_offset(ctx->buf.dev, ctx->peer_offset)->public_key, value);
 		else if (key_match("AllowedIPs"))
 			ret = parse_ipmasks(&ctx->buf, ctx->peer_offset, value);
+		else if (key_match("PersistentKeepalive"))
+			ret = parse_persistent_keepalive(&peer_from_offset(ctx->buf.dev, ctx->peer_offset)->persistent_keepalive_interval, value);
 		else
 			goto error;
 	} else
@@ -476,6 +500,7 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 				perror("use_space");
 				goto error;
 			}
+			peer_from_offset(buf.dev, peer_offset)->persistent_keepalive_interval = (__u16)-1;
 			++buf.dev->num_peers;
 			if (!parse_key(peer_from_offset(buf.dev, peer_offset)->public_key, argv[1]))
 				goto error;
@@ -501,6 +526,11 @@ bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
 			free(line);
 			argv += 2;
 			argc -= 2;
+		} else if (!strcmp(argv[0], "persistent-keepalive") && argc >= 2 && buf.dev->num_peers) {
+			if (!parse_persistent_keepalive(&peer_from_offset(buf.dev, peer_offset)->persistent_keepalive_interval, argv[1]))
+				goto error;
+			argv += 2;
+			argc -= 2;
 		} else {
 			fprintf(stderr, "Invalid argument: %s\n", argv[0]);
 			goto error;
diff --git a/src/set.c b/src/set.c
index f85162d..c7656e8 100644
--- a/src/set.c
+++ b/src/set.c
@@ -13,7 +13,7 @@ int set_main(int argc, char *argv[])
 	int ret = 1;
 
 	if (argc < 3) {
-		fprintf(stderr, "Usage: %s %s <interface> [listen-port <port>] [private-key <file path>] [peer <base64 public key> [remove] [endpoint <ip>:<port>] [allowed-ips <ip1>/<cidr1>[,<ip2>/<cidr2>]...] ]...\n", PROG_NAME, argv[0]);
+		fprintf(stderr, "Usage: %s %s <interface> [listen-port <port>] [private-key <file path>] [peer <base64 public key> [remove] [endpoint <ip>:<port>] [persistent-keepalive <interval seconds>] [allowed-ips <ip1>/<cidr1>[,<ip2>/<cidr2>]...] ]...\n", PROG_NAME, argv[0]);
 		return 1;
 	}
 
diff --git a/src/show.c b/src/show.c
index 1662751..7927534 100644
--- a/src/show.c
+++ b/src/show.c
@@ -121,13 +121,11 @@ static char *endpoint(const struct sockaddr_storage *addr)
 	return buf;
 }
 
-static char *ago(const struct timeval *t)
+static size_t pretty_time(char *buf, const size_t len, unsigned long long left)
 {
-	static char buf[1024];
-	unsigned long long left, years, days, hours, minutes, seconds;
 	size_t offset = 0;
+	unsigned long long years, days, hours, minutes, seconds;
 
-	left = time(NULL) - t->tv_sec;
 	years = left / (365 * 24 * 60 * 60);
 	left = left % (365 * 24 * 60 * 60);
 	days = left / (24 * 60 * 60);
@@ -138,15 +136,25 @@ static char *ago(const struct timeval *t)
 	seconds = left % 60;
 
 	if (years)
-		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN "year%s" TERMINAL_RESET, offset ? ", " : "", years, years == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN "year%s" TERMINAL_RESET, offset ? ", " : "", years, years == 1 ? "" : "s");
 	if (days)
-		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN  "day%s" TERMINAL_RESET, offset ? ", " : "", days, days == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN  "day%s" TERMINAL_RESET, offset ? ", " : "", days, days == 1 ? "" : "s");
 	if (hours)
-		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN  "hour%s" TERMINAL_RESET, offset ? ", " : "", hours, hours == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN  "hour%s" TERMINAL_RESET, offset ? ", " : "", hours, hours == 1 ? "" : "s");
 	if (minutes)
-		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN "minute%s" TERMINAL_RESET, offset ? ", " : "", minutes, minutes == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN "minute%s" TERMINAL_RESET, offset ? ", " : "", minutes, minutes == 1 ? "" : "s");
 	if (seconds)
-		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN  "second%s" TERMINAL_RESET, offset ? ", " : "", seconds, seconds == 1 ? "" : "s");
+		offset += snprintf(buf + offset, len - offset, "%s%llu " TERMINAL_FG_CYAN  "second%s" TERMINAL_RESET, offset ? ", " : "", seconds, seconds == 1 ? "" : "s");
+
+	return offset;
+}
+
+static char *ago(const struct timeval *t)
+{
+	static char buf[1024];
+	size_t offset;
+
+	offset = pretty_time(buf, sizeof(buf), time(NULL) - t->tv_sec);
 	if (offset)
 		snprintf(buf + offset, sizeof(buf) - offset, " ago");
 	else
@@ -155,6 +163,13 @@ static char *ago(const struct timeval *t)
 	return buf;
 }
 
+static char *every(uint16_t seconds)
+{
+	static char buf[1024] = "every ";
+	pretty_time(buf + strlen("every "), sizeof(buf) - strlen("every "), seconds);
+	return buf;
+}
+
 static char *bytes(uint64_t b)
 {
 	static char buf[1024];
@@ -176,7 +191,7 @@ static char *bytes(uint64_t b)
 static const char *COMMAND_NAME = NULL;
 static void show_usage(void)
 {
-	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | peers | endpoints | allowed-ips | latest-handshake | bandwidth]\n", PROG_NAME, COMMAND_NAME);
+	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | peers | endpoints | allowed-ips | latest-handshake | bandwidth | persistent-keepalive]\n", PROG_NAME, COMMAND_NAME);
 }
 
 static void pretty_print(struct wgdevice *device)
@@ -216,6 +231,8 @@ static void pretty_print(struct wgdevice *device)
 			terminal_printf("%s received, ", bytes(peer->rx_bytes));
 			terminal_printf("%s sent\n", bytes(peer->tx_bytes));
 		}
+		if (peer->persistent_keepalive_interval)
+			terminal_printf("  " TERMINAL_BOLD "persistent keepalive" TERMINAL_RESET ": %s\n", every(peer->persistent_keepalive_interval));
 		if (i + 1 < device->num_peers)
 			terminal_printf("\n");
 	}
@@ -275,6 +292,15 @@ static bool ugly_print(struct wgdevice *device, const char *param, bool with_int
 				printf("%s\t", device->interface);
 			printf("%s\t%" PRIu64 "\t%" PRIu64 "\n", key(peer->public_key), (uint64_t)peer->rx_bytes, (uint64_t)peer->tx_bytes);
 		}
+	} else if (!strcmp(param, "persistent-keepalive")) {
+		for_each_wgpeer(device, peer, i) {
+			if (with_interface)
+				printf("%s\t", device->interface);
+			if (peer->persistent_keepalive_interval)
+				printf("%s\t%u\n", key(peer->public_key), peer->persistent_keepalive_interval);
+			else
+				printf("%s\toff\n", key(peer->public_key));
+		}
 	} else if (!strcmp(param, "peers")) {
 		for_each_wgpeer(device, peer, i) {
 			if (with_interface)
diff --git a/src/showconf.c b/src/showconf.c
index faf2482..95d2e17 100644
--- a/src/showconf.c
+++ b/src/showconf.c
@@ -91,6 +91,9 @@ int showconf_main(int argc, char *argv[])
 			}
 		}
 
+		if (peer->persistent_keepalive_interval)
+			printf("PersistentKeepalive = %u\n", peer->persistent_keepalive_interval);
+
 		if (i + 1 < device->num_peers)
 			printf("\n");
 	}

commit 2a9625acf6363e16528d38cd8abd924cfde7d0c5
Author: Jonathan Rudenberg <jonathan@titanous.com>
Date:   Thu Jul 7 07:58:30 2016 -0400

    go test: don't rely on undefined append behavior
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 8e3c195..c1aa293 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -118,15 +118,13 @@ func main() {
 		Dst:      net.IPv4(10, 189, 129, 1),
 	}).Marshal()
 	binary.BigEndian.PutUint16(pingHeader[2:], uint16(ipv4.HeaderLen+len(pingMessage))) // fix the length endianness on BSDs
-	binary.BigEndian.PutUint16(pingHeader[10:], ipChecksum(append(pingHeader, pingMessage...)))
-	if err != nil {
-		panic(err)
-	}
+	pingData := append(pingHeader, pingMessage...)
+	binary.BigEndian.PutUint16(pingData[10:], ipChecksum(pingData))
 	pingPacket := make([]byte, 13)
 	pingPacket[0] = 4 // Type: Data
 	binary.LittleEndian.PutUint32(pingPacket[1:], theirIndex)
 	binary.LittleEndian.PutUint64(pingPacket[5:], 0) // Nonce
-	pingPacket = sendCipher.Encrypt(pingPacket, nil, append(pingHeader, pingMessage...))
+	pingPacket = sendCipher.Encrypt(pingPacket, nil, pingData)
 	if _, err := conn.Write(pingPacket); err != nil {
 		log.Fatalf("error writing ping message: %s", err)
 	}

commit 49ea3d5cf45ada3d8f897b23b3afe9b6a760882b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 7 13:48:04 2016 +0200

    rust test: actually use tai64n
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index eccb987..73e19b3 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -42,7 +42,7 @@ fn main() {
 
 	let now = time::get_time();
 	let mut tai64n = [0; 12];
-	BigEndian::write_i64(&mut tai64n[0..], now.sec);
+	BigEndian::write_i64(&mut tai64n[0..], 4611686018427387914ULL + now.sec);
 	BigEndian::write_i32(&mut tai64n[8..], now.nsec);
 	let mut initiation_packet = [0; 145];
 	initiation_packet[0] = 1; /* Type: Initiation */

commit cb3d5626e08dab2e4e50d9c407686921ceca0d00
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 7 13:47:32 2016 +0200

    go test: actually use TAI64N
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index ad9b4d1..8e3c195 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -59,7 +59,7 @@ func main() {
 	// write handshake initiation packet
 	now := time.Now()
 	tai64n := make([]byte, 12)
-	binary.BigEndian.PutUint64(tai64n[:], uint64(now.Unix()))
+	binary.BigEndian.PutUint64(tai64n[:], 4611686018427387914+uint64(now.Unix()))
 	binary.BigEndian.PutUint32(tai64n[8:], uint32(now.UnixNano()))
 	initiationPacket := make([]byte, 5)
 	initiationPacket[0] = 1                                 // Type: Initiation

commit 0e583e8770e3a0bf48de790544ed65c7931d0a58
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 7 13:44:01 2016 +0200

    go test: don't use 1 as icmp ids
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index ba0e3ac..ad9b4d1 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -103,8 +103,8 @@ func main() {
 	pingMessage, _ := (&icmp.Message{
 		Type: ipv4.ICMPTypeEcho,
 		Body: &icmp.Echo{
-			ID:   1,
-			Seq:  1,
+			ID:   921,
+			Seq:  438,
 			Data: []byte("WireGuard"),
 		},
 	}).Marshal(nil)
@@ -156,7 +156,7 @@ func main() {
 		log.Fatalf("unexpected reply body type %T", replyMessage.Body)
 	}
 
-	if echo.ID != 1 || echo.Seq != 1 || string(echo.Data) != "WireGuard" {
+	if echo.ID != 921 || echo.Seq != 438 || string(echo.Data) != "WireGuard" {
 		log.Fatalf("incorrect echo response: %#v", echo)
 	}
 }

commit 554d77fbd7b832fd7e31af153ad563361948081d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 7 13:42:35 2016 +0200

    go test: dynamically calculate ip checksum
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 68447fe..ba0e3ac 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -16,6 +16,24 @@ import (
 	"golang.org/x/net/ipv4"
 )
 
+func ipChecksum(buf []byte) uint16 {
+	sum := uint32(0)
+	for ; len(buf) >= 2; buf = buf[2:] {
+		sum += uint32(buf[0])<<8 | uint32(buf[1])
+	}
+	if len(buf) > 0 {
+		sum += uint32(buf[0]) << 8
+	}
+	for sum > 0xffff {
+		sum = (sum >> 16) + (sum & 0xffff)
+	}
+	csum := ^uint16(sum)
+	if csum == 0 {
+		csum = 0xffff
+	}
+	return csum
+}
+
 func main() {
 	ourPrivate, _ := base64.StdEncoding.DecodeString("WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=")
 	ourPublic, _ := base64.StdEncoding.DecodeString("K5sF9yESrSBsOXPd6TcpKNgqoy1Ik3ZFKl4FolzrRyI=")
@@ -95,12 +113,12 @@ func main() {
 		Len:      ipv4.HeaderLen,
 		TotalLen: ipv4.HeaderLen + len(pingMessage),
 		Protocol: 1, // ICMP
-		TTL:      2,
-		Checksum: 0xa15b, // the packet is always the same, hard-code checksum
+		TTL:      20,
 		Src:      net.IPv4(10, 189, 129, 2),
 		Dst:      net.IPv4(10, 189, 129, 1),
 	}).Marshal()
 	binary.BigEndian.PutUint16(pingHeader[2:], uint16(ipv4.HeaderLen+len(pingMessage))) // fix the length endianness on BSDs
+	binary.BigEndian.PutUint16(pingHeader[10:], ipChecksum(append(pingHeader, pingMessage...)))
 	if err != nil {
 		panic(err)
 	}

commit 35a61c32fa080ca761169458c1ae191bd5bbb331
Author: Jonathan Rudenberg <jonathan@titanous.com>
Date:   Wed Jul 6 22:57:08 2016 -0400

    go test: add ICMP ping
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 16632bb..68447fe 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -12,6 +12,8 @@ import (
 
 	"github.com/dchest/blake2s"
 	"github.com/titanous/noise"
+	"golang.org/x/net/icmp"
+	"golang.org/x/net/ipv4"
 )
 
 func main() {
@@ -36,6 +38,7 @@ func main() {
 	}
 	defer conn.Close()
 
+	// write handshake initiation packet
 	now := time.Now()
 	tai64n := make([]byte, 12)
 	binary.BigEndian.PutUint64(tai64n[:], uint64(now.Unix()))
@@ -53,6 +56,7 @@ func main() {
 		log.Fatalf("error writing initiation packet: %s", err)
 	}
 
+	// read handshake response packet
 	responsePacket := make([]byte, 89)
 	n, err := conn.Read(responsePacket)
 	if err != nil {
@@ -69,7 +73,7 @@ func main() {
 	if ourIndex != 28 {
 		log.Fatalf("response packet index wrong: want %d, got %d", 28, ourIndex)
 	}
-	payload, sendCipher, _, err := hs.ReadMessage(nil, responsePacket[9:57])
+	payload, sendCipher, receiveCipher, err := hs.ReadMessage(nil, responsePacket[9:57])
 	if err != nil {
 		log.Fatalf("error reading handshake message: %s", err)
 	}
@@ -77,12 +81,64 @@ func main() {
 		log.Fatalf("unexpected payload: %x", payload)
 	}
 
-	keepalivePacket := make([]byte, 13)
-	keepalivePacket[0] = 4 // Type: Data
-	binary.LittleEndian.PutUint32(keepalivePacket[1:], theirIndex)
-	binary.LittleEndian.PutUint64(keepalivePacket[5:], 0) // Nonce
-	keepalivePacket = sendCipher.Encrypt(keepalivePacket, nil, nil)
-	if _, err := conn.Write(keepalivePacket); err != nil {
-		log.Fatalf("error writing keepalive packet: %s", err)
+	// write ICMP Echo packet
+	pingMessage, _ := (&icmp.Message{
+		Type: ipv4.ICMPTypeEcho,
+		Body: &icmp.Echo{
+			ID:   1,
+			Seq:  1,
+			Data: []byte("WireGuard"),
+		},
+	}).Marshal(nil)
+	pingHeader, err := (&ipv4.Header{
+		Version:  ipv4.Version,
+		Len:      ipv4.HeaderLen,
+		TotalLen: ipv4.HeaderLen + len(pingMessage),
+		Protocol: 1, // ICMP
+		TTL:      2,
+		Checksum: 0xa15b, // the packet is always the same, hard-code checksum
+		Src:      net.IPv4(10, 189, 129, 2),
+		Dst:      net.IPv4(10, 189, 129, 1),
+	}).Marshal()
+	binary.BigEndian.PutUint16(pingHeader[2:], uint16(ipv4.HeaderLen+len(pingMessage))) // fix the length endianness on BSDs
+	if err != nil {
+		panic(err)
+	}
+	pingPacket := make([]byte, 13)
+	pingPacket[0] = 4 // Type: Data
+	binary.LittleEndian.PutUint32(pingPacket[1:], theirIndex)
+	binary.LittleEndian.PutUint64(pingPacket[5:], 0) // Nonce
+	pingPacket = sendCipher.Encrypt(pingPacket, nil, append(pingHeader, pingMessage...))
+	if _, err := conn.Write(pingPacket); err != nil {
+		log.Fatalf("error writing ping message: %s", err)
+	}
+
+	// read ICMP Echo Reply packet
+	replyPacket := make([]byte, 128)
+	n, err = conn.Read(replyPacket)
+	if err != nil {
+		log.Fatalf("error reading ping reply message: %s", err)
+	}
+	replyPacket = replyPacket[:n]
+	if replyPacket[0] != 4 { // Type: Data
+		log.Fatalf("unexpected reply packet type: %d", replyPacket[0])
+	}
+	replyPacket, err = receiveCipher.Decrypt(nil, nil, replyPacket[13:])
+	if err != nil {
+		log.Fatalf("error decrypting reply packet: %s", err)
+	}
+	replyHeaderLen := int(replyPacket[0]&0x0f) << 2
+	replyLen := binary.BigEndian.Uint16(replyPacket[2:])
+	replyMessage, err := icmp.ParseMessage(1, replyPacket[replyHeaderLen:replyLen])
+	if err != nil {
+		log.Fatalf("error parsing echo: %s", err)
+	}
+	echo, ok := replyMessage.Body.(*icmp.Echo)
+	if !ok {
+		log.Fatalf("unexpected reply body type %T", replyMessage.Body)
+	}
+
+	if echo.ID != 1 || echo.Seq != 1 || string(echo.Data) != "WireGuard" {
+		log.Fatalf("incorrect echo response: %#v", echo)
 	}
 }

commit 1f349aa10193aabc15d26efc3ea4b86b86bc4b61
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 7 03:52:21 2016 +0200

    external-tests: switch to demo server
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index a06b565..16632bb 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -30,7 +30,7 @@ func main() {
 		StaticKeypair: noise.DHKey{Private: ourPrivate, Public: ourPublic},
 		PeerStatic:    theirPublic,
 	})
-	conn, err := net.Dial("udp", "test.wireguard.io:51820")
+	conn, err := net.Dial("udp", "demo.wireguard.io:12913")
 	if err != nil {
 		log.Fatalf("error dialing udp socket: %s", err)
 	}
diff --git a/contrib/external-tests/haskell/src/Main.hs b/contrib/external-tests/haskell/src/Main.hs
index f78305d..20aeb2e 100644
--- a/contrib/external-tests/haskell/src/Main.hs
+++ b/contrib/external-tests/haskell/src/Main.hs
@@ -50,8 +50,8 @@ payload = do
 
 main :: IO ()
 main = do
-  let ip = "test.wireguard.io"
-  let port = "51820"
+  let ip = "demo.wireguard.io"
+  let port = "12913"
   let mykey = "WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo="
   let serverkey = "qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM="
   let psk = "FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE="
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
index fa468af..eccb987 100644
--- a/contrib/external-tests/rust/src/main.rs
+++ b/contrib/external-tests/rust/src/main.rs
@@ -19,7 +19,7 @@ fn memcpy(out: &mut [u8], data: &[u8]) {
 }
 
 fn main() {
-	let send_addr = "test.wireguard.io:51820".to_socket_addrs().unwrap().next().unwrap();
+	let send_addr = "demo.wireguard.io:12913".to_socket_addrs().unwrap().next().unwrap();
 	let listen_addr = "0.0.0.0:0".to_socket_addrs().unwrap().next().unwrap();
 	let socket = UdpSocket::bind(listen_addr).unwrap();
 	let mut empty_payload = [0; 0];

commit 5a427c702421458c41890cd610c27d197f677082
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jul 7 02:32:40 2016 +0200

    go test: put nonce at correct location
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index 86fe192..a06b565 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -80,7 +80,7 @@ func main() {
 	keepalivePacket := make([]byte, 13)
 	keepalivePacket[0] = 4 // Type: Data
 	binary.LittleEndian.PutUint32(keepalivePacket[1:], theirIndex)
-	binary.LittleEndian.PutUint64(keepalivePacket[3:], 0) // Nonce
+	binary.LittleEndian.PutUint64(keepalivePacket[5:], 0) // Nonce
 	keepalivePacket = sendCipher.Encrypt(keepalivePacket, nil, nil)
 	if _, err := conn.Write(keepalivePacket); err != nil {
 		log.Fatalf("error writing keepalive packet: %s", err)

commit 85a14af6b0fe06482247b94b0c499df9096acfd7
Author: Jonathan Rudenberg <jonathan@titanous.com>
Date:   Wed Jul 6 19:49:30 2016 -0400

    go test: make more idiomatic
    
    - gofmt
    - Give config struct one line per field
    - Use camel case
    - Check errors
    - Log invariants with detail
    - Use consistent pronouns
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
index de7337b..86fe192 100644
--- a/contrib/external-tests/go/main.go
+++ b/contrib/external-tests/go/main.go
@@ -3,61 +3,86 @@
 package main
 
 import (
-	"github.com/titanous/noise"
-	"net"
-	"time"
-	"bytes"
 	"crypto/rand"
 	"encoding/base64"
 	"encoding/binary"
+	"log"
+	"net"
+	"time"
+
 	"github.com/dchest/blake2s"
+	"github.com/titanous/noise"
 )
 
-func assert(exp bool) {
-	if !exp {
-		panic("Assertion failed.")
-	}
-}
-
 func main() {
-	my_private, _ := base64.StdEncoding.DecodeString("WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=")
-	my_public, _ := base64.StdEncoding.DecodeString("K5sF9yESrSBsOXPd6TcpKNgqoy1Ik3ZFKl4FolzrRyI=")
+	ourPrivate, _ := base64.StdEncoding.DecodeString("WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=")
+	ourPublic, _ := base64.StdEncoding.DecodeString("K5sF9yESrSBsOXPd6TcpKNgqoy1Ik3ZFKl4FolzrRyI=")
 	preshared, _ := base64.StdEncoding.DecodeString("FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=")
-	their_public, _ := base64.StdEncoding.DecodeString("qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=")
+	theirPublic, _ := base64.StdEncoding.DecodeString("qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=")
 	cs := noise.NewCipherSuite(noise.DH25519, noise.CipherChaChaPoly, noise.HashBLAKE2s)
-	hs := noise.NewHandshakeState(noise.Config{CipherSuite: cs, Random: rand.Reader, Pattern: noise.HandshakeIK, Initiator: true, Prologue: []byte("WireGuard v0 zx2c4 Jason@zx2c4.com"), PresharedKey: preshared, StaticKeypair: noise.DHKey{Private: my_private, Public: my_public}, PeerStatic: their_public})
-	conn, _ := net.Dial("udp", "test.wireguard.io:51820")
+	hs := noise.NewHandshakeState(noise.Config{
+		CipherSuite:   cs,
+		Random:        rand.Reader,
+		Pattern:       noise.HandshakeIK,
+		Initiator:     true,
+		Prologue:      []byte("WireGuard v0 zx2c4 Jason@zx2c4.com"),
+		PresharedKey:  preshared,
+		StaticKeypair: noise.DHKey{Private: ourPrivate, Public: ourPublic},
+		PeerStatic:    theirPublic,
+	})
+	conn, err := net.Dial("udp", "test.wireguard.io:51820")
+	if err != nil {
+		log.Fatalf("error dialing udp socket: %s", err)
+	}
+	defer conn.Close()
 
 	now := time.Now()
 	tai64n := make([]byte, 12)
 	binary.BigEndian.PutUint64(tai64n[:], uint64(now.Unix()))
 	binary.BigEndian.PutUint32(tai64n[8:], uint32(now.UnixNano()))
-	initiation_packet := make([]byte, 5)
-	initiation_packet[0] = 1 /* Type: Initiation */
-	binary.LittleEndian.PutUint32(initiation_packet[1:], 28) /* Sender index: 28 (arbitrary) */
-	initiation_packet, _, _ = hs.WriteMessage(initiation_packet, tai64n)
+	initiationPacket := make([]byte, 5)
+	initiationPacket[0] = 1                                 // Type: Initiation
+	binary.LittleEndian.PutUint32(initiationPacket[1:], 28) // Sender index: 28 (arbitrary)
+	initiationPacket, _, _ = hs.WriteMessage(initiationPacket, tai64n)
 	hasher, _ := blake2s.New(&blake2s.Config{Size: 16, Key: preshared})
-	hasher.Write(their_public)
-	hasher.Write(initiation_packet)
-	initiation_packet = append(initiation_packet, hasher.Sum(nil)[:16]...)
-	initiation_packet = append(initiation_packet, bytes.Repeat([]byte{ 0 }, 16)...)
-	conn.Write(initiation_packet)
-
-	response_packet := make([]byte, 89)
-	conn.Read(response_packet)
-	assert(response_packet[0] == 2 /* Type: Response */)
-	their_index := binary.LittleEndian.Uint32(response_packet[1:])
-	our_index := binary.LittleEndian.Uint32(response_packet[5:])
-	assert(our_index == 28)
-	payload, send_cs, _, err := hs.ReadMessage(nil, response_packet[9:57])
-	assert(len(payload) == 0 && err == nil)
+	hasher.Write(theirPublic)
+	hasher.Write(initiationPacket)
+	initiationPacket = append(initiationPacket, hasher.Sum(nil)[:16]...)
+	initiationPacket = append(initiationPacket, make([]byte, 16)...)
+	if _, err := conn.Write(initiationPacket); err != nil {
+		log.Fatalf("error writing initiation packet: %s", err)
+	}
 
-	keepalive_packet := make([]byte, 13)
-	keepalive_packet[0] = 4 /* Type: Data */
-	binary.LittleEndian.PutUint32(keepalive_packet[1:], their_index)
-	binary.LittleEndian.PutUint64(keepalive_packet[3:], 0) /* Nonce */
-	keepalive_packet = send_cs.Encrypt(keepalive_packet, nil, nil)
-	conn.Write(keepalive_packet)
+	responsePacket := make([]byte, 89)
+	n, err := conn.Read(responsePacket)
+	if err != nil {
+		log.Fatalf("error reading response packet: %s", err)
+	}
+	if n != len(responsePacket) {
+		log.Fatalf("response packet too short: want %d, got %d", len(responsePacket), n)
+	}
+	if responsePacket[0] != 2 { // Type: Response
+		log.Fatalf("response packet type wrong: want %d, got %d", 2, responsePacket[0])
+	}
+	theirIndex := binary.LittleEndian.Uint32(responsePacket[1:])
+	ourIndex := binary.LittleEndian.Uint32(responsePacket[5:])
+	if ourIndex != 28 {
+		log.Fatalf("response packet index wrong: want %d, got %d", 28, ourIndex)
+	}
+	payload, sendCipher, _, err := hs.ReadMessage(nil, responsePacket[9:57])
+	if err != nil {
+		log.Fatalf("error reading handshake message: %s", err)
+	}
+	if len(payload) > 0 {
+		log.Fatalf("unexpected payload: %x", payload)
+	}
 
-	conn.Close()
+	keepalivePacket := make([]byte, 13)
+	keepalivePacket[0] = 4 // Type: Data
+	binary.LittleEndian.PutUint32(keepalivePacket[1:], theirIndex)
+	binary.LittleEndian.PutUint64(keepalivePacket[3:], 0) // Nonce
+	keepalivePacket = sendCipher.Encrypt(keepalivePacket, nil, nil)
+	if _, err := conn.Write(keepalivePacket); err != nil {
+		log.Fatalf("error writing keepalive packet: %s", err)
+	}
 }

commit 7887d8024cc075b092cf063577db22c8e280dcdb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jul 6 23:51:00 2016 +0200

    wg: use pkg-config in Makefile
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/Makefile b/src/Makefile
index 4eddd25..060ae18 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -4,10 +4,11 @@ BINDIR ?= $(PREFIX)/bin
 LIBDIR ?= $(PREFIX)/lib
 MANDIR ?= $(PREFIX)/share/man
 
+CFLAGS += $(shell pkg-config --cflags libmnl 2>/dev/null)
 CFLAGS += -std=gnu11
 CFLAGS += -pedantic -Wall -Wextra
 CFLAGS += -MMD
-LDLIBS += -lresolv -lmnl
+LDLIBS += -lresolv $(shell pkg-config --libs libmnl 2>/dev/null || echo -lmnl)
 
 wg: $(patsubst %.c,%.o,$(wildcard *.c))
 

commit 4e04bee9152657a33a787e41625ed37ea0f4380d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jul 5 16:01:31 2016 +0200

    contrib: organize example scripts and add synergy
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/client-server-example/README b/contrib/ncat-client-server/README
similarity index 100%
rename from contrib/client-server-example/README
rename to contrib/ncat-client-server/README
diff --git a/contrib/client-server-example/client.sh b/contrib/ncat-client-server/client.sh
similarity index 100%
rename from contrib/client-server-example/client.sh
rename to contrib/ncat-client-server/client.sh
diff --git a/contrib/client-server-example/server.sh b/contrib/ncat-client-server/server.sh
similarity index 100%
rename from contrib/client-server-example/server.sh
rename to contrib/ncat-client-server/server.sh
diff --git a/contrib/synergy/README b/contrib/synergy/README
new file mode 100644
index 0000000..b75fb77
--- /dev/null
+++ b/contrib/synergy/README
@@ -0,0 +1,3 @@
+These scripts should be modified according to your precise setup.
+They provide a very simple way of tunneling synergy inside of a
+WireGuard tunnel, to protect your data in transit.
diff --git a/contrib/synergy/synergy-client.sh b/contrib/synergy/synergy-client.sh
new file mode 100755
index 0000000..56cfdb2
--- /dev/null
+++ b/contrib/synergy/synergy-client.sh
@@ -0,0 +1,18 @@
+#!/bin/bash
+set -ex
+if [[ $UID == 0 ]]; then
+	ip link del dev synergy || true
+	ip link add dev synergy type wireguard
+	ip address add 10.193.125.39/32 peer 10.193.125.38/32 dev synergy
+	wg set synergy \
+		listen-port 29184 \
+		private-key <(echo oNcsXA5Ma56q9xHmvvKuzLfwXYy7Uqy+bTmmXg/XtVs=) \
+		peer m321UMZXoJ6qw8Jli2spbAVBc2MdOzV/EHDKfZQy0g0= \
+			allowed-ips 10.193.125.38/32 \
+			endpoint 10.10.10.100:29184
+	ip link set up dev synergy
+else
+	sudo "$(readlink -f "$0")"
+	killall synergyc || true
+	synergyc 10.193.125.38:38382
+fi
diff --git a/contrib/synergy/synergy-server.sh b/contrib/synergy/synergy-server.sh
new file mode 100755
index 0000000..6bef423
--- /dev/null
+++ b/contrib/synergy/synergy-server.sh
@@ -0,0 +1,17 @@
+#!/bin/bash
+set -ex
+if [[ $UID == 0 ]]; then
+	ip link del dev synergy || true
+	ip link add dev synergy type wireguard
+	ip address add 10.193.125.38/32 peer 10.193.125.39/32 dev synergy
+	wg set synergy \
+		listen-port 29184 \
+		private-key <(echo 2InSrlZA5eQfI/MvnvPieqNTBo9cd+udc3SOO9yFpXo=) \
+		peer CBnoidQLjlbRsrqrI56WQbANWwkll41w/rVUIW9zISI= \
+			allowed-ips 10.193.125.39/32
+	ip link set up dev synergy
+else
+	sudo "$(readlink -f "$0")"
+	killall synergys || true
+	synergys -a 10.193.125.38:38382
+fi
diff --git a/contrib/systemd/README b/contrib/systemd/README
new file mode 100644
index 0000000..1ef51aa
--- /dev/null
+++ b/contrib/systemd/README
@@ -0,0 +1,5 @@
+Until WireGuard receives full integration to the various network
+management utilities, there are a number of ways of setting up
+a WireGuard tunnel at boot time. This systemd unit file is one
+such way of doing things. Probably it should be tweaked before
+using.
diff --git a/contrib/wgserver.service b/contrib/systemd/wgserver.service
similarity index 100%
rename from contrib/wgserver.service
rename to contrib/systemd/wgserver.service

commit be4f3cd7c2df12f219d3e6a40559602a053df4e2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 3 20:39:47 2016 +0200

    wg: always fallback to /dev/urandom
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/genkey.c b/src/genkey.c
index 8e63108..a312b46 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -6,31 +6,29 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <syscall.h>
-#include <unistd.h>
 #include <string.h>
+#include <fcntl.h>
 
 #include "curve25519.h"
 #include "base64.h"
 #include "subcommands.h"
 
-#ifdef __NR_getrandom
-static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
-{
-	return syscall(__NR_getrandom, out, len, 0);
-}
-#else
-#include <fcntl.h>
 static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
 {
 	ssize_t ret;
-	int fd = open("/dev/urandom", O_RDONLY);
+	int fd;
+#ifdef __NR_getrandom
+	ret = syscall(__NR_getrandom, out, len, 0);
+	if (ret >= 0)
+		return ret;
+#endif
+	fd = open("/dev/urandom", O_RDONLY);
 	if (fd < 0)
 		return fd;
 	ret = read(fd, out, len);
 	close(fd);
 	return ret;
 }
-#endif
 
 int genkey_main(int argc, char *argv[])
 {

commit 742f038fc2d57b15d1539c3cfc7d0c2fe45ac530
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 3 20:06:33 2016 +0200

    wg: improve error reporting and detection
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/config.c b/src/config.c
index 0cec30e..9066178 100644
--- a/src/config.c
+++ b/src/config.c
@@ -93,12 +93,8 @@ static inline uint16_t parse_port(const char *value)
 static inline bool parse_key(uint8_t key[WG_KEY_LEN], const char *value)
 {
 	uint8_t tmp[WG_KEY_LEN + 1];
-	if (strlen(value) != b64_len(WG_KEY_LEN) - 1) {
-		fprintf(stderr, "Key is not the correct length: `%s`\n", value);
-		return false;
-	}
-	if (b64_pton(value, tmp, WG_KEY_LEN + 1) < 0) {
-		fprintf(stderr, "Could not parse base64 key: `%s`\n", value);
+	if (strlen(value) != b64_len(WG_KEY_LEN) - 1 || b64_pton(value, tmp, WG_KEY_LEN + 1) != WG_KEY_LEN) {
+		fprintf(stderr, "Key is not the correct length or format: `%s`\n", value);
 		return false;
 	}
 	memcpy(key, tmp, WG_KEY_LEN);
diff --git a/src/genkey.c b/src/genkey.c
index 1602ae1..8e63108 100644
--- a/src/genkey.c
+++ b/src/genkey.c
@@ -11,6 +11,7 @@
 
 #include "curve25519.h"
 #include "base64.h"
+#include "subcommands.h"
 
 #ifdef __NR_getrandom
 static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
@@ -37,6 +38,11 @@ int genkey_main(int argc, char *argv[])
 	char private_key_base64[b64_len(CURVE25519_POINT_SIZE)];
 	struct stat stat;
 
+	if (argc != 1) {
+		fprintf(stderr, "Usage: %s %s\n", PROG_NAME, argv[0]);
+		return 1;
+	}
+
 	if (!fstat(STDOUT_FILENO, &stat) && S_ISREG(stat.st_mode) && stat.st_mode & S_IRWXO)
 		fputs("Warning: writing to world accessible file.\nConsider setting the umask to 077 and trying again.\n", stderr);
 
@@ -47,9 +53,8 @@ int genkey_main(int argc, char *argv[])
 	if (argc && !strcmp(argv[0], "genkey"))
 		curve25519_normalize_secret(private_key);
 
-	if (b64_ntop(private_key, sizeof(private_key), private_key_base64, sizeof(private_key_base64)) < 0) {
-		errno = EINVAL;
-		perror("b64");
+	if (b64_ntop(private_key, sizeof(private_key), private_key_base64, sizeof(private_key_base64)) != sizeof(private_key_base64) - 1) {
+		fprintf(stderr, "%s: Could not convert key to base64\n", PROG_NAME);
 		return 1;
 	}
 
diff --git a/src/pubkey.c b/src/pubkey.c
index d9a97d9..452c8fa 100644
--- a/src/pubkey.c
+++ b/src/pubkey.c
@@ -3,29 +3,46 @@
 #include <errno.h>
 #include <resolv.h>
 #include <stdio.h>
+#include <ctype.h>
 
 #include "curve25519.h"
 #include "base64.h"
+#include "subcommands.h"
 
-int pubkey_main(__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
+int pubkey_main(int argc, char *argv[])
 {
 	unsigned char private_key[CURVE25519_POINT_SIZE + 1] = { 0 }, public_key[CURVE25519_POINT_SIZE] = { 0 };
 	char private_key_base64[b64_len(CURVE25519_POINT_SIZE)] = { 0 }, public_key_base64[b64_len(CURVE25519_POINT_SIZE)] = { 0 };
+	int trailing_char;
+
+	if (argc != 1) {
+		fprintf(stderr, "Usage: %s %s\n", PROG_NAME, argv[0]);
+		return 1;
+	}
 
 	if (fread(private_key_base64, 1, sizeof(private_key_base64) - 1, stdin) != sizeof(private_key_base64) - 1) {
 		errno = EINVAL;
-		perror("fread(private key)");
+		fprintf(stderr, "%s: Key is not the correct length or format\n", PROG_NAME);
 		return 1;
 	}
-	if (b64_pton(private_key_base64, private_key, sizeof(private_key)) < 0) {
-		errno = EINVAL;
-		perror("b64");
+
+	for (;;) {
+		trailing_char = getc(stdin);
+		if (!trailing_char || isspace(trailing_char) || isblank(trailing_char))
+			continue;
+		if (trailing_char == EOF)
+			break;
+		fprintf(stderr, "%s: Trailing characters found after key\n", PROG_NAME);
+		return 1;
+	}
+
+	if (b64_pton(private_key_base64, private_key, sizeof(private_key)) != sizeof(private_key) - 1) {
+		fprintf(stderr, "%s: Key is not the correct length or format\n", PROG_NAME);
 		return 1;
 	}
 	curve25519_generate_public(public_key, private_key);
-	if (b64_ntop(public_key, sizeof(public_key), public_key_base64, sizeof(public_key_base64)) < 0) {
-		errno = EINVAL;
-		perror("b64");
+	if (b64_ntop(public_key, sizeof(public_key), public_key_base64, sizeof(public_key_base64)) != sizeof(public_key_base64) - 1) {
+		fprintf(stderr, "%s: Could not convert key to base64\n", PROG_NAME);
 		return 1;
 	}
 	puts(public_key_base64);
diff --git a/src/wg.c b/src/wg.c
index d4d2965..ee19387 100644
--- a/src/wg.c
+++ b/src/wg.c
@@ -23,12 +23,13 @@ static const struct {
 	{ "pubkey", pubkey_main, "Reads a private key from stdin and writes a public key to stdout" }
 };
 
-static void show_usage(void)
+static void show_usage(FILE *file)
 {
-	fprintf(stderr, "Usage: %s <cmd> [<args>]\n\n", PROG_NAME);
-	fprintf(stderr, "Available subcommands:\n");
+	fprintf(file, "Usage: %s <cmd> [<args>]\n\n", PROG_NAME);
+	fprintf(file, "Available subcommands:\n");
 	for (size_t i = 0; i < sizeof(subcommands) / sizeof(subcommands[0]); ++i)
-		fprintf(stderr, "  %s: %s\n", subcommands[i].subcommand, subcommands[i].description);
+		fprintf(file, "  %s: %s\n", subcommands[i].subcommand, subcommands[i].description);
+	fprintf(file, "You may pass `--help' to any of these subcommands to view usage.\n");
 }
 
 int main(int argc, char *argv[])
@@ -37,8 +38,8 @@ int main(int argc, char *argv[])
 	PROG_NAME = argv[0];
 
 	if (argc == 2 && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "help"))) {
-		show_usage();
-		return 1;
+		show_usage(stdout);
+		return 0;
 	}
 
 	if (argc == 1) {
@@ -61,6 +62,6 @@ findsubcommand:
 	}
 
 	fprintf(stderr, "Invalid subcommand: `%s`\n", argv[1]);
-	show_usage();
+	show_usage(stderr);
 	return 1;
 }

commit 1a64438b21836df64f5236809fc57b8cbbe83d1e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 1 23:36:59 2016 +0200

    contrib: remove extraneous cruft
    
    We don't want people packaging these or even using these scripts, which
    are only useful for limited development circumstances, so get rid of
    them. More widespread development testing techniques still exist in
    src/debug.mk and src/netns.sh
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/contrib/benchmarking/configs/other.conf b/contrib/benchmarking/configs/other.conf
deleted file mode 100644
index 4257914..0000000
--- a/contrib/benchmarking/configs/other.conf
+++ /dev/null
@@ -1,8 +0,0 @@
-[Interface]
-ListenPort = 27183
-PrivateKey = oHilodMrwJSD1UUIkAkyCek2yqy1Frs5XuN47ShGFk0=
-
-[Peer]
-PublicKey = S8hEvD+dam+PrwG4GrSPtE2Pl3ylO/oiUnUDXw3vnx0=
-AllowedIPs = 192.168.2.2/32
-Endpoint = 10.10.10.100:38292
\ No newline at end of file
diff --git a/contrib/benchmarking/configs/thinkpad.conf b/contrib/benchmarking/configs/thinkpad.conf
deleted file mode 100644
index df02b2b..0000000
--- a/contrib/benchmarking/configs/thinkpad.conf
+++ /dev/null
@@ -1,8 +0,0 @@
-[Interface]
-ListenPort = 38292
-PrivateKey = MPCo/WSBkm/DCkbEXUhtjc5u//IeD6wEeaw3Q2HxFGw=
-
-[Peer]
-PublicKey = c5PwaIZcVZFDuoDdQJGnYe+fk+wt0qANARpnZDOvqhw=
-AllowedIPs = 0.0.0.0/0
-Endpoint = 172.16.48.128:27183
diff --git a/contrib/benchmarking/openvpn-config.txt b/contrib/benchmarking/openvpn-config.txt
deleted file mode 100644
index f51eabd..0000000
--- a/contrib/benchmarking/openvpn-config.txt
+++ /dev/null
@@ -1,2 +0,0 @@
-Server: openvpn --dev tun --ifconfig 192.168.3.1 192.168.3.2 --secret static.key --cipher AES-256-CBC --auth SHA256 --port 61721
-Client: openvpn --dev tun --ifconfig 192.168.3.2 192.168.3.1 --secret static.key --cipher AES-256-CBC --auth SHA256 --port 61721 --remote 10.10.10.1
diff --git a/contrib/benchmarking/static.key b/contrib/benchmarking/static.key
deleted file mode 100644
index 53075fe..0000000
--- a/contrib/benchmarking/static.key
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-# 2048 bit OpenVPN static key
-#
------BEGIN OpenVPN Static key V1-----
-12abb34ac1cb716576642c7e4c9719af
-b311929f6bb5a7b9082c9ac3a02dc77a
-26fc65ba97e67d1dc5b273e72760caba
-6c8a3321acdf89bfd0469528bfc9ed89
-1c9c3762d1e18786c8b6dd590456f158
-d1f625810da1225864c23d7e848ca5d7
-18a49c4b7e640f8e51001ace9222de75
-e05177fd01b32d702bd12b45b085678c
-239e3927d98912174ac648d0e37a3247
-45cabcbea7cf70832f8800a8b863a35a
-933c5921fd65882b050bd1096a0c6c60
-638fb22eafb9f49c13573236d0427441
-c98869ba8de30e597452237527e7dcc6
-519058a919de4432203dc1d7622fb4d0
-f8f20c5350256cdf17bb3b85c5c838fc
-6ddeb4da9dae8b0b882cb043db483a9d
------END OpenVPN Static key V1-----
diff --git a/contrib/client-server-example/README b/contrib/client-server-example/README
new file mode 100644
index 0000000..fd3088a
--- /dev/null
+++ b/contrib/client-server-example/README
@@ -0,0 +1,16 @@
+                === IMPORTANT NOTE ===
+
+Do not use these scripts in production. They are simply a
+demonstration of how easy the `wg(8)` tool is at the command
+line, but by no means should you actually attempt to use
+these. They are horribly insecure and defeat the purpose
+of WireGuard.
+
+                     STAY AWAY!
+
+Distros: do not distribute these with your packages.
+
+
+
+That all said, this is a pretty cool example of just how
+darn easy WireGuard can be.
diff --git a/contrib/stress-testing/badpacket.c b/contrib/stress-testing/badpacket.c
deleted file mode 100644
index eee61fc..0000000
--- a/contrib/stress-testing/badpacket.c
+++ /dev/null
@@ -1,27 +0,0 @@
-#include <stdlib.h>
-#include <unistd.h>
-#include <arpa/inet.h>
-#include <sys/socket.h>
-#include <sys/ioctl.h>
-#include <net/if.h>
-#include <netinet/in.h>
-#include <linux/limits.h>
-
-int main(int argc, char *argv[])
-{
-	static const unsigned char handshake1[143] = { 1, 0 };
-	int fd = socket(AF_INET, SOCK_DGRAM, 0);
-	struct sockaddr_in addr = {
-		.sin_family = AF_INET,
-		.sin_port = htons(atoi(argv[2])),
-		.sin_addr = inet_addr(argv[1])
-	};
-	connect(fd, (struct sockaddr *)&addr, sizeof(addr));
-
-	for (;;)
-		send(fd, handshake1, sizeof(handshake1), 0);
-
-	close(fd);
-
-	return 0;
-}
diff --git a/contrib/stress-testing/peg.c b/contrib/stress-testing/peg.c
deleted file mode 100644
index 6b539fa..0000000
--- a/contrib/stress-testing/peg.c
+++ /dev/null
@@ -1,50 +0,0 @@
-#include <sys/socket.h>
-#include <sys/ioctl.h>
-#include <net/if.h>
-#include <netinet/in.h>
-#include <linux/limits.h>
-#include <time.h>
-#include <stdio.h>
-#include <string.h>
-
-static unsigned long long interface_tx_bytes(const char *interface)
-{
-	char buf[PATH_MAX];
-	FILE *f;
-	unsigned long long ret;
-	snprintf(buf, PATH_MAX - 1, "/sys/class/net/%s/statistics/tx_bytes", interface);
-	f = fopen(buf, "r");
-	fscanf(f, "%llu", &ret);
-	fclose(f);
-	return ret;
-}
-
-int main(int argc, char *argv[])
-{
-	char buf[1500] = { 0 };
-	unsigned long long before, after, i;
-	struct timespec begin, end;
-	double elapsed;
-	struct ifreq req;
-	int fd = socket(AF_INET, SOCK_DGRAM, 0);
-	struct sockaddr_in addr = {
-		.sin_family = AF_INET,
-		.sin_port = htons(7271),
-		.sin_addr = inet_addr(argv[3])
-	};
-	strcpy(req.ifr_name, argv[1]);
-	ioctl(fd, SIOCGIFMTU, &req);
-
-	connect(fd, (struct sockaddr *)&addr, sizeof(addr));
-
-	before = interface_tx_bytes(argv[2]);
-	clock_gettime(CLOCK_MONOTONIC, &begin);
-	for (i = 0; i < 10000000; ++i)
-		send(fd, buf, req.ifr_mtu - 28, 0);
-	clock_gettime(CLOCK_MONOTONIC, &end);
-	after = interface_tx_bytes(argv[2]);
-	elapsed = end.tv_sec - begin.tv_sec + (end.tv_nsec - begin.tv_nsec) / 1000000000.0;
-
-	printf("%.4f mbps\n", ((after - before) * 8) / elapsed / 1000000.0);
-	return 0;
-}
diff --git a/contrib/stress-testing/self-send.sh b/contrib/stress-testing/self-send.sh
deleted file mode 100755
index eb7947b..0000000
--- a/contrib/stress-testing/self-send.sh
+++ /dev/null
@@ -1,48 +0,0 @@
-#!/bin/bash
-set -e
-
-PRIVATE_KEYS=("")
-PUBLIC_KEYS=("")
-
-resetwg() {
-	for i in {1..64}; do
-		ip link delete dev wg${i} 2>/dev/null >/dev/null || true
-	done
-}
-
-for i in {1..64}; do
-	next_key="$(wg genkey)"
-	PRIVATE_KEYS+=("$next_key")
-	PUBLIC_KEYS+=($(wg pubkey <<<"$next_key"))
-done
-
-resetwg
-trap resetwg INT TERM EXIT
-
-for i in {1..64}; do
-	{ echo "[Interface]"
-	  echo "ListenPort = $(( $i + 31222 ))"
-	  echo "PrivateKey = ${PRIVATE_KEYS[$i]}"
-
-	for j in {1..64}; do
-		[[ $i == $j ]] && continue
-		echo "[Peer]"
-		echo "PublicKey = ${PUBLIC_KEYS[$j]}"
-		echo "AllowedIPs = 192.168.8.${j}/32"
-		echo "Endpoint = 127.0.0.1:$(( $j + 31222 ))"
-	  done
-	} > "/tmp/deviceload.conf"
-
-	ip link add dev wg${i} type wireguard
-	wg setconf wg${i} "/tmp/deviceload.conf"
-	ip link set up dev wg${i}
-	rm "/tmp/deviceload.conf"
-done
-
-ip address add dev wg1 192.168.8.1/24
-
-while true; do
-	for i in {2..64}; do
-		echo hello | ncat -u 192.168.8.${i} 1234
-	done
-done
diff --git a/contrib/stress-testing/threewayiperf.sh b/contrib/stress-testing/threewayiperf.sh
deleted file mode 100755
index 932d666..0000000
--- a/contrib/stress-testing/threewayiperf.sh
+++ /dev/null
@@ -1,30 +0,0 @@
-#!/bin/bash
-set -e
-
-if [[ $(hostname) == "thinkpad" ]]; then
-	make -C "$(dirname "$0")/../../src" remote-run
-	for i in 128 129 130; do
-		scp "$0" root@172.16.48.${i}:
-	done
-	for i in 128 129 130; do
-		konsole --new-tab -e ssh -t root@172.16.48.${i} "./$(basename "$0")"
-	done
-	exit
-fi
-
-# perf top -U --dsos '[wireguard]'
-
-tmux new-session -s bigtest -d
-tmux new-window -n "server 6000" -t bigtest "iperf3 -p 6000 -s"
-tmux new-window -n "server 6001" -t bigtest "iperf3 -p 6001 -s"
-sleep 5
-me=$(ip -o -4 address show dev wg0 | sed 's/.*inet \([^ ]*\)\/.*/\1/' | cut -d . -f 4)
-for i in 1 2 3; do
-	[[ $i == $me ]] && continue
-	[[ $me == "1" ]] && port=6000
-	[[ $me == "3" ]] && port=6001
-	[[ $me == "2" && $i == "1" ]] && port=6000
-	[[ $me == "2" && $i == "3" ]] && port=6001
-	tmux new-window -n "client 192.168.2.${i}" -t bigtest "iperf3 -n 300000G -i 1 -p $port -c 192.168.2.${i}"
-done
-tmux attach -t bigtest
diff --git a/src/wg.8 b/src/wg.8
index 67b4cf7..eee6d7b 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -131,7 +131,9 @@ to which outgoing traffic for this peer is directed. The catch-all
 \fI::/0\fP may be specified for matching all IPv6 addresses. Required.
 .IP \(bu
 Endpoint \(em an endpoint IP or hostname, followed by a colon, and then a
-port number. Optional.
+port number. This endpoint will be updated automatically to the most recent
+source IP address and port of correctly authenticated packets from the peer.
+Optional.
 
 .SH CONFIGURATION FILE FORMAT EXAMPLE
 This example may be used as a model for writing configuration files.

commit abb1128785fc8e0602820acc95fc0fa370508a84
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jul 1 04:08:29 2016 +0200

    wg.8: wording tweaks
    
    Suggested-by: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/src/wg.8 b/src/wg.8
index c9401f0..67b4cf7 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -55,7 +55,8 @@ Sets configuration values for the specified \fI<interface>\fP. Multiple
 for a peer, that peer is removed, not configured. If \fIlisten-port\fP
 is not specified, the port will be automatically generated when the
 interface comes up. Both \fIprivate-key\fP and \fIpreshared-key\fP must
-be a files, for security reasons, but if you're using
+be a files, because command line arguments are not considered private on
+most systems but if you are using
 .BR bash (1),
 you may safely pass in a string by specifying as \fIprivate-key\fP or
 \fIpreshared-key\fP the expression: <(echo PRIVATEKEYSTRING). If
@@ -124,11 +125,12 @@ private key, and usually transmitted out of band to the author of the
 configuration file. Required.
 .IP \(bu
 AllowedIPs \(em a comma-separated list of IP (v4 or v6) addresses with
-CIDR masks. The catch-all \fI0.0.0.0/0\fP may be specified for matching
-all IPv4 addresses, and \fI::/0\fP may be specified for matching all
-IPv6 addresses. Required.
+CIDR masks from which this peer is allowed to send incoming traffic and
+to which outgoing traffic for this peer is directed. The catch-all
+\fI0.0.0.0/0\fP may be specified for matching all IPv4 addresses, and
+\fI::/0\fP may be specified for matching all IPv6 addresses. Required.
 .IP \(bu
-Endpoint \(em an endpoint IP or hostname, followed by a comma, and then a
+Endpoint \(em an endpoint IP or hostname, followed by a colon, and then a
 port number. Optional.
 
 .SH CONFIGURATION FILE FORMAT EXAMPLE

commit 3b900f17b988818b0d0d0039fb16c7ff0e0582b1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Thu Jun 30 21:45:42 2016 +0200

    Readme: the documentation moved to .io
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/README.md b/README.md
index 0c0ad1c..0f6e1c5 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 # WireGuard &mdash; fast, modern, secure kernel VPN tunnel
 #### by [Jason A. Donenfeld](mailto:Jason@zx2c4.com) of [Edge Security](https://www.edgesecurity.com/)
 
-WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes **state-of-the-art [cryptography](doc/protocol.md)**. It aims to be faster, simpler, leaner, and more useful than IPSec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. It runs over UDP.
+WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes **state-of-the-art cryptography**. It aims to be faster, simpler, leaner, and more useful than IPSec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. It runs over UDP.
 
 **More information may be found at [WireGuard.io](https://www.wireguard.io/).**
 

commit 397040101760f63c75b29769ad8afc1eea231d34
Author: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
Date:   Thu Jun 30 14:47:09 2016 -0400

    Readme: use https instead of http
    
    For the websites referenced that offer https instead of http, use
    https.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/README.md b/README.md
index 79c1daa..0c0ad1c 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,5 @@
 # WireGuard &mdash; fast, modern, secure kernel VPN tunnel
-#### by [Jason A. Donenfeld](mailto:Jason@zx2c4.com) of [Edge Security](http://www.edgesecurity.com/)
+#### by [Jason A. Donenfeld](mailto:Jason@zx2c4.com) of [Edge Security](https://www.edgesecurity.com/)
 
 WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes **state-of-the-art [cryptography](doc/protocol.md)**. It aims to be faster, simpler, leaner, and more useful than IPSec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. It runs over UDP.
 
diff --git a/contrib/external-tests/haskell/cacophony-wg.cabal b/contrib/external-tests/haskell/cacophony-wg.cabal
index 62e2485..90f519d 100644
--- a/contrib/external-tests/haskell/cacophony-wg.cabal
+++ b/contrib/external-tests/haskell/cacophony-wg.cabal
@@ -1,5 +1,5 @@
 -- Initial cacophony-wg.cabal generated by cabal init.  For further 
--- documentation, see http://haskell.org/cabal/users-guide/
+-- documentation, see https://www.haskell.org/cabal/users-guide/
 
 name:                cacophony-wg
 version:             0.1.0
diff --git a/src/wg.8 b/src/wg.8
index 4ee5027..c9401f0 100644
--- a/src/wg.8
+++ b/src/wg.8
@@ -189,6 +189,6 @@ was written by
 Jason A. Donenfeld
 .ME .
 For updates and more information, a project page is available on the
-.UR http://\:www.wireguard.io/
+.UR https://\:www.wireguard.io/
 World Wide Web
 .UE .

commit 8132305e54d45dbad65bf9ef6f6c5805c841d1da
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 5 15:58:00 2015 +0200

    Initial commit
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..7a4b600
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,10 @@
+cscope.out
+*.o
+*.ko
+*.mod.c
+Module.symvers
+*.cmd
+.tmp_versions
+*.swp
+modules.order
+modules.builtin
diff --git a/COPYING b/COPYING
new file mode 100644
index 0000000..d159169
--- /dev/null
+++ b/COPYING
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..79c1daa
--- /dev/null
+++ b/README.md
@@ -0,0 +1,10 @@
+# WireGuard &mdash; fast, modern, secure kernel VPN tunnel
+#### by [Jason A. Donenfeld](mailto:Jason@zx2c4.com) of [Edge Security](http://www.edgesecurity.com/)
+
+WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes **state-of-the-art [cryptography](doc/protocol.md)**. It aims to be faster, simpler, leaner, and more useful than IPSec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. It runs over UDP.
+
+**More information may be found at [WireGuard.io](https://www.wireguard.io/).**
+
+## License
+
+This project is released under the [GPLv2](COPYING).
diff --git a/contrib/benchmarking/configs/other.conf b/contrib/benchmarking/configs/other.conf
new file mode 100644
index 0000000..4257914
--- /dev/null
+++ b/contrib/benchmarking/configs/other.conf
@@ -0,0 +1,8 @@
+[Interface]
+ListenPort = 27183
+PrivateKey = oHilodMrwJSD1UUIkAkyCek2yqy1Frs5XuN47ShGFk0=
+
+[Peer]
+PublicKey = S8hEvD+dam+PrwG4GrSPtE2Pl3ylO/oiUnUDXw3vnx0=
+AllowedIPs = 192.168.2.2/32
+Endpoint = 10.10.10.100:38292
\ No newline at end of file
diff --git a/contrib/benchmarking/configs/thinkpad.conf b/contrib/benchmarking/configs/thinkpad.conf
new file mode 100644
index 0000000..df02b2b
--- /dev/null
+++ b/contrib/benchmarking/configs/thinkpad.conf
@@ -0,0 +1,8 @@
+[Interface]
+ListenPort = 38292
+PrivateKey = MPCo/WSBkm/DCkbEXUhtjc5u//IeD6wEeaw3Q2HxFGw=
+
+[Peer]
+PublicKey = c5PwaIZcVZFDuoDdQJGnYe+fk+wt0qANARpnZDOvqhw=
+AllowedIPs = 0.0.0.0/0
+Endpoint = 172.16.48.128:27183
diff --git a/contrib/benchmarking/openvpn-config.txt b/contrib/benchmarking/openvpn-config.txt
new file mode 100644
index 0000000..f51eabd
--- /dev/null
+++ b/contrib/benchmarking/openvpn-config.txt
@@ -0,0 +1,2 @@
+Server: openvpn --dev tun --ifconfig 192.168.3.1 192.168.3.2 --secret static.key --cipher AES-256-CBC --auth SHA256 --port 61721
+Client: openvpn --dev tun --ifconfig 192.168.3.2 192.168.3.1 --secret static.key --cipher AES-256-CBC --auth SHA256 --port 61721 --remote 10.10.10.1
diff --git a/contrib/benchmarking/static.key b/contrib/benchmarking/static.key
new file mode 100644
index 0000000..53075fe
--- /dev/null
+++ b/contrib/benchmarking/static.key
@@ -0,0 +1,21 @@
+#
+# 2048 bit OpenVPN static key
+#
+-----BEGIN OpenVPN Static key V1-----
+12abb34ac1cb716576642c7e4c9719af
+b311929f6bb5a7b9082c9ac3a02dc77a
+26fc65ba97e67d1dc5b273e72760caba
+6c8a3321acdf89bfd0469528bfc9ed89
+1c9c3762d1e18786c8b6dd590456f158
+d1f625810da1225864c23d7e848ca5d7
+18a49c4b7e640f8e51001ace9222de75
+e05177fd01b32d702bd12b45b085678c
+239e3927d98912174ac648d0e37a3247
+45cabcbea7cf70832f8800a8b863a35a
+933c5921fd65882b050bd1096a0c6c60
+638fb22eafb9f49c13573236d0427441
+c98869ba8de30e597452237527e7dcc6
+519058a919de4432203dc1d7622fb4d0
+f8f20c5350256cdf17bb3b85c5c838fc
+6ddeb4da9dae8b0b882cb043db483a9d
+-----END OpenVPN Static key V1-----
diff --git a/contrib/client-server-example/client.sh b/contrib/client-server-example/client.sh
new file mode 100755
index 0000000..fbae46a
--- /dev/null
+++ b/contrib/client-server-example/client.sh
@@ -0,0 +1,20 @@
+#!/bin/bash
+set -e
+[[ $UID == 0 ]] || { echo "You must be root to run this."; exit 1; }
+umask 077
+trap 'rm -f /tmp/wg_private_key' EXIT INT TERM
+exec 3<>/dev/tcp/demo.wireguard.io/42912
+wg genkey | tee /tmp/wg_private_key | wg pubkey >&3
+IFS=: read -r status server_pubkey server_port internal_ip <&3
+[[ $status == OK ]]
+ip link del dev wg0 2>/dev/null || true
+ip link add dev wg0 type wireguard
+wg set wg0 private-key /tmp/wg_private_key peer "$server_pubkey" allowed-ips 0.0.0.0/0 endpoint "demo.wireguard.io:$server_port"
+ip address add "$internal_ip"/24 dev wg0
+ip link set up dev wg0
+if [ "$1" == "default-route" ]; then
+	host="$(wg show wg0 endpoints | sed -n 's/.*\t\(.*\):.*/\1/p')"
+	ip route add $(ip route get $host | sed '/ via [0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}/{s/^\(.* via [0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\).*/\1/}' | head -n 1) 2>/dev/null || true
+	ip route add 0/1 dev wg0
+	ip route add 128/1 dev wg0
+fi
diff --git a/contrib/client-server-example/server.sh b/contrib/client-server-example/server.sh
new file mode 100755
index 0000000..e37861f
--- /dev/null
+++ b/contrib/client-server-example/server.sh
@@ -0,0 +1,14 @@
+#!/bin/bash
+if [[ -z $NCAT_REMOTE_ADDR ]]; then
+	ip link del dev wg0 2>/dev/null
+	set -e
+	ip link add dev wg0 type wireguard
+	ip address add 192.168.4.1/24 dev wg0
+	wg set wg0 private-key <(wg genkey) listen-port 12912
+	ip link set up dev wg0
+	exec ncat -e "$(readlink -f "$0")" -k -l -p 42912 -v
+fi
+read -r public_key
+[[ $(wg show wg0 | grep peer | wc -l) -ge 253 ]] && wg set wg0 peer $(wg show wg0 latest-handshakes | sort -k 2 -b -n | head -n 1 | cut -f 1) remove
+next_ip=$(all="$(wg show wg0 allowed-ips)"; for ((i=2; i<=254; i++)); do ip="192.168.4.$i"; [[ $all != *$ip/32* ]] && echo $ip && break; done)
+wg set wg0 peer "$public_key" allowed-ips $next_ip/32 2>/dev/null && echo "OK:$(wg show wg0 private-key | wg pubkey):$(wg show wg0 listen-port):$next_ip" || echo ERROR
diff --git a/contrib/external-tests/go/main.go b/contrib/external-tests/go/main.go
new file mode 100644
index 0000000..de7337b
--- /dev/null
+++ b/contrib/external-tests/go/main.go
@@ -0,0 +1,63 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+package main
+
+import (
+	"github.com/titanous/noise"
+	"net"
+	"time"
+	"bytes"
+	"crypto/rand"
+	"encoding/base64"
+	"encoding/binary"
+	"github.com/dchest/blake2s"
+)
+
+func assert(exp bool) {
+	if !exp {
+		panic("Assertion failed.")
+	}
+}
+
+func main() {
+	my_private, _ := base64.StdEncoding.DecodeString("WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=")
+	my_public, _ := base64.StdEncoding.DecodeString("K5sF9yESrSBsOXPd6TcpKNgqoy1Ik3ZFKl4FolzrRyI=")
+	preshared, _ := base64.StdEncoding.DecodeString("FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=")
+	their_public, _ := base64.StdEncoding.DecodeString("qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=")
+	cs := noise.NewCipherSuite(noise.DH25519, noise.CipherChaChaPoly, noise.HashBLAKE2s)
+	hs := noise.NewHandshakeState(noise.Config{CipherSuite: cs, Random: rand.Reader, Pattern: noise.HandshakeIK, Initiator: true, Prologue: []byte("WireGuard v0 zx2c4 Jason@zx2c4.com"), PresharedKey: preshared, StaticKeypair: noise.DHKey{Private: my_private, Public: my_public}, PeerStatic: their_public})
+	conn, _ := net.Dial("udp", "test.wireguard.io:51820")
+
+	now := time.Now()
+	tai64n := make([]byte, 12)
+	binary.BigEndian.PutUint64(tai64n[:], uint64(now.Unix()))
+	binary.BigEndian.PutUint32(tai64n[8:], uint32(now.UnixNano()))
+	initiation_packet := make([]byte, 5)
+	initiation_packet[0] = 1 /* Type: Initiation */
+	binary.LittleEndian.PutUint32(initiation_packet[1:], 28) /* Sender index: 28 (arbitrary) */
+	initiation_packet, _, _ = hs.WriteMessage(initiation_packet, tai64n)
+	hasher, _ := blake2s.New(&blake2s.Config{Size: 16, Key: preshared})
+	hasher.Write(their_public)
+	hasher.Write(initiation_packet)
+	initiation_packet = append(initiation_packet, hasher.Sum(nil)[:16]...)
+	initiation_packet = append(initiation_packet, bytes.Repeat([]byte{ 0 }, 16)...)
+	conn.Write(initiation_packet)
+
+	response_packet := make([]byte, 89)
+	conn.Read(response_packet)
+	assert(response_packet[0] == 2 /* Type: Response */)
+	their_index := binary.LittleEndian.Uint32(response_packet[1:])
+	our_index := binary.LittleEndian.Uint32(response_packet[5:])
+	assert(our_index == 28)
+	payload, send_cs, _, err := hs.ReadMessage(nil, response_packet[9:57])
+	assert(len(payload) == 0 && err == nil)
+
+	keepalive_packet := make([]byte, 13)
+	keepalive_packet[0] = 4 /* Type: Data */
+	binary.LittleEndian.PutUint32(keepalive_packet[1:], their_index)
+	binary.LittleEndian.PutUint64(keepalive_packet[3:], 0) /* Nonce */
+	keepalive_packet = send_cs.Encrypt(keepalive_packet, nil, nil)
+	conn.Write(keepalive_packet)
+
+	conn.Close()
+}
diff --git a/contrib/external-tests/haskell/Setup.hs b/contrib/external-tests/haskell/Setup.hs
new file mode 100644
index 0000000..9a994af
--- /dev/null
+++ b/contrib/external-tests/haskell/Setup.hs
@@ -0,0 +1,2 @@
+import Distribution.Simple
+main = defaultMain
diff --git a/contrib/external-tests/haskell/cacophony-wg.cabal b/contrib/external-tests/haskell/cacophony-wg.cabal
new file mode 100644
index 0000000..62e2485
--- /dev/null
+++ b/contrib/external-tests/haskell/cacophony-wg.cabal
@@ -0,0 +1,34 @@
+-- Initial cacophony-wg.cabal generated by cabal init.  For further 
+-- documentation, see http://haskell.org/cabal/users-guide/
+
+name:                cacophony-wg
+version:             0.1.0
+-- synopsis:            
+-- description:         
+license:             PublicDomain
+license-file:        LICENSE
+author:              John Galt
+maintainer:          centromere@users.noreply.github.com
+-- copyright:           
+-- category:            
+build-type:          Simple
+-- extra-source-files:  
+cabal-version:       >=1.10
+
+executable cacophony-wg
+  main-is:             Main.hs
+  other-modules:
+    Data.Time.TAI64
+  build-depends:
+    base >=4.8 && <4.9,
+    base16-bytestring,
+    base64-bytestring,
+    blake2,
+    bytestring,
+    cacophony,
+    cereal,
+    cryptonite,
+    network,
+    time
+  hs-source-dirs:      src
+  default-language:    Haskell2010
diff --git a/contrib/external-tests/haskell/src/Data/Time/TAI64.hs b/contrib/external-tests/haskell/src/Data/Time/TAI64.hs
new file mode 100644
index 0000000..37a90e6
--- /dev/null
+++ b/contrib/external-tests/haskell/src/Data/Time/TAI64.hs
@@ -0,0 +1,86 @@
+module Data.Time.TAI64 (
+    TAI64(..)
+  , TAI64N(..)
+  , TAI64NA(..)
+  , posixToTAI64
+  , posixToTAI64N
+  , posixToTAI64NA
+  , getCurrentTAI64
+  , getCurrentTAI64N
+  , getCurrentTAI64NA
+  , tAI64ToPosix
+  , tAI64NToPosix
+  , tAI64NAToPosix
+) where
+
+import Data.Serialize
+import Control.Monad
+import Data.Word
+
+import Data.Time.Clock
+import Data.Time.Clock.POSIX
+
+import Numeric
+
+data TAI64 = TAI64
+  {-# UNPACK #-} !Word64
+  deriving (Eq, Ord)
+
+data TAI64N = TAI64N
+  {-# UNPACK #-} !TAI64
+  {-# UNPACK #-} !Word32
+  deriving (Eq, Ord, Show)
+
+data TAI64NA = TAI64NA
+  {-# UNPACK #-} !TAI64N
+  {-# UNPACK #-} !Word32
+  deriving (Eq, Ord, Show)
+
+instance Show TAI64   where
+  show (TAI64 t) = "TAI64 0x" ++ showHex t ""
+
+instance Serialize TAI64 where
+  put (TAI64 t) = putWord64be t
+  get = liftM TAI64 get
+
+instance Serialize TAI64N where
+  put (TAI64N  t' nt) = put t' >> putWord32be nt
+  get = liftM2 TAI64N  get get
+
+instance Serialize TAI64NA where
+  put (TAI64NA t' at) = put t' >> putWord32be at
+  get = liftM2 TAI64NA get get
+
+
+posixToTAI64 :: POSIXTime -> TAI64
+posixToTAI64 = TAI64 . (2^62 +) . truncate . realToFrac
+
+posixToTAI64N :: POSIXTime -> TAI64N
+posixToTAI64N pt = TAI64N t' ns where
+  t' = posixToTAI64 pt
+  ns = (`mod` 10^9) $ truncate (pts * 10**9)
+  pts = realToFrac pt
+
+posixToTAI64NA :: POSIXTime -> TAI64NA -- | PICOsecond precision
+posixToTAI64NA pt = TAI64NA t' as where
+  t' = posixToTAI64N pt
+  as = (`mod` 10^9) $ truncate (pts * 10**18)
+  pts = realToFrac pt
+
+getCurrentTAI64   :: IO TAI64
+getCurrentTAI64N  :: IO TAI64N
+getCurrentTAI64NA :: IO TAI64NA
+getCurrentTAI64   = liftM posixToTAI64   getPOSIXTime
+getCurrentTAI64N  = liftM posixToTAI64N  getPOSIXTime
+getCurrentTAI64NA = liftM posixToTAI64NA getPOSIXTime
+
+tAI64ToPosix :: TAI64 -> POSIXTime
+tAI64ToPosix (TAI64 s) = fromRational . fromIntegral $ s - 2^62
+
+tAI64NToPosix :: TAI64N -> POSIXTime
+tAI64NToPosix (TAI64N t' n) = tAI64ToPosix t' + nanopart where
+  nanopart = fromRational $ (toRational $ 10**(-9)) * toRational n -- TODO: optimize?
+
+tAI64NAToPosix :: TAI64NA -> POSIXTime
+tAI64NAToPosix (TAI64NA t' a) = tAI64NToPosix t' + attopart where
+  attopart = fromRational $ (toRational $ 10**(-18)) * toRational a
diff --git a/contrib/external-tests/haskell/src/Main.hs b/contrib/external-tests/haskell/src/Main.hs
new file mode 100644
index 0000000..f78305d
--- /dev/null
+++ b/contrib/external-tests/haskell/src/Main.hs
@@ -0,0 +1,81 @@
+{-# LANGUAGE OverloadedStrings #-}
+module Main where
+
+import Control.Applicative ((<$>))
+import Control.Concurrent.MVar
+import Control.Monad       (void)
+import Data.ByteString.Char8 (pack, unpack, take, drop, replicate)
+import Data.ByteString (ByteString)
+import qualified Data.ByteString.Base16 as Hex
+import qualified Data.ByteString.Base64 as B64
+import qualified Data.Serialize         as S
+import Prelude hiding (take, drop, replicate)
+import System.Environment
+import Network.Socket
+import qualified Network.Socket.ByteString as NBS
+
+import Crypto.Hash.BLAKE2.BLAKE2s
+import Crypto.Noise.Cipher
+import Crypto.Noise.Cipher.ChaChaPoly1305
+import Crypto.Noise.Curve
+import Crypto.Noise.Curve.Curve25519
+import Crypto.Noise.Handshake
+import Crypto.Noise.HandshakePatterns
+import Crypto.Noise.Hash.BLAKE2s
+import Crypto.Noise.Types
+
+import Data.Time.TAI64
+
+w :: PublicKey Curve25519
+  -> Plaintext
+  -> Socket
+  -> SockAddr
+  -> ByteString
+  -> IO ()
+w theirPub (Plaintext myPSK) sock addr msg = do
+  let x      = "\x01\x00\x00" `mappend` msg
+      mac    = hash 16 myPSK (sbToBS' (curvePubToBytes theirPub) `mappend` sbToBS' x)
+  void $ NBS.sendTo sock (x `mappend` mac `mappend` replicate 16 '\0') addr
+
+r :: MVar ByteString -> Socket -> IO ByteString
+r smv sock = do
+  (r, _) <- NBS.recvFrom sock 1024
+  putMVar smv $ (take 2 . drop 1) r
+  return . take 48 . drop 5 $ r
+
+payload :: IO Plaintext
+payload = do
+  tai64n <- getCurrentTAI64N
+  return . Plaintext . bsToSB' $ S.encode tai64n
+
+main :: IO ()
+main = do
+  let ip = "test.wireguard.io"
+  let port = "51820"
+  let mykey = "WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo="
+  let serverkey = "qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM="
+  let psk = "FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE="
+  addrInfo <- head <$> getAddrInfo Nothing (Just ip) (Just port)
+  sock     <- socket (addrFamily addrInfo) Datagram defaultProtocol
+
+  let addr       = addrAddress addrInfo
+      mykey'     = curveBytesToPair  . bsToSB' . either undefined id . B64.decode . pack $ mykey     :: KeyPair Curve25519
+      serverkey' = curveBytesToPub   . bsToSB' . either undefined id . B64.decode . pack $ serverkey :: PublicKey Curve25519
+      psk'       = Plaintext . bsToSB' . either undefined id . B64.decode . pack $ psk
+      hs         = handshakeState $ HandshakeStateParams
+                   noiseIK
+                   "WireGuard v0 zx2c4 Jason@zx2c4.com"
+                   (Just psk')
+                   (Just mykey')
+                   Nothing
+                   (Just serverkey')
+                   Nothing
+                   True :: HandshakeState ChaChaPoly1305 Curve25519 BLAKE2s
+
+  senderindexmv <- newEmptyMVar
+  let hc = HandshakeCallbacks (w serverkey' psk' sock addr) (r senderindexmv sock) (\_ -> return ()) payload
+  (encryption, decryption) <- runHandshake hs hc
+
+  let (keepAlive, encryption') = encryptPayload "" encryption
+  senderindex <- takeMVar senderindexmv
+  void $ NBS.sendTo sock ("\x04" `mappend` senderindex `mappend` replicate 8 '\0' `mappend` keepAlive) addr
diff --git a/contrib/external-tests/rust/.gitignore b/contrib/external-tests/rust/.gitignore
new file mode 100644
index 0000000..1e7caa9
--- /dev/null
+++ b/contrib/external-tests/rust/.gitignore
@@ -0,0 +1,2 @@
+Cargo.lock
+target/
diff --git a/contrib/external-tests/rust/Cargo.toml b/contrib/external-tests/rust/Cargo.toml
new file mode 100644
index 0000000..c064905
--- /dev/null
+++ b/contrib/external-tests/rust/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "wireguard-keepalive"
+version = "0.1.0"
+authors = ["jason@zx2c4.com"]
+[dependencies]
+screech = { git = "https://github.com/trevp/screech" }
+rust-crypto = "*"
+byteorder = "*"
+rustc-serialize = "*"
+time = "*"
diff --git a/contrib/external-tests/rust/src/main.rs b/contrib/external-tests/rust/src/main.rs
new file mode 100644
index 0000000..fa468af
--- /dev/null
+++ b/contrib/external-tests/rust/src/main.rs
@@ -0,0 +1,74 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+extern crate screech;
+extern crate crypto;
+extern crate time;
+extern crate rustc_serialize;
+extern crate byteorder;
+
+use screech::*;
+use byteorder::{ByteOrder, BigEndian, LittleEndian};
+use crypto::curve25519::curve25519_base;
+use crypto::blake2s::Blake2s;
+use rustc_serialize::base64::FromBase64;
+use std::net::*;
+
+fn memcpy(out: &mut [u8], data: &[u8]) {
+	for count in 0..data.len() {
+		out[count] = data[count];
+	}
+}
+
+fn main() {
+	let send_addr = "test.wireguard.io:51820".to_socket_addrs().unwrap().next().unwrap();
+	let listen_addr = "0.0.0.0:0".to_socket_addrs().unwrap().next().unwrap();
+	let socket = UdpSocket::bind(listen_addr).unwrap();
+	let mut empty_payload = [0; 0];
+
+	let mut their_public = [0; 32];
+	memcpy(&mut their_public, &"qRCwZSKInrMAq5sepfCdaCsRJaoLe5jhtzfiw7CjbwM=".from_base64().unwrap());
+	let mut my_private = [0; 32];
+	memcpy(&mut my_private, &"WAmgVYXkbT2bCtdcDwolI88/iVi/aV3/PHcUBTQSYmo=".from_base64().unwrap());
+	let mut my_preshared = [0; 32];
+	memcpy(&mut my_preshared, &"FpCyhws9cxwWoV4xELtfJvjJN+zQVRPISllRWgeopVE=".from_base64().unwrap());
+	let my_public = curve25519_base(&my_private);
+	let mut my_keypair : Dh25519 = Default::default();
+	my_keypair.set(&my_private, &my_public);
+	let mut owner : HandshakeCryptoOwner<RandomOs, Dh25519, CipherChaChaPoly, HashBLAKE2s> = Default::default();
+	owner.set_s(my_keypair);
+	owner.set_rs(&their_public);
+	let mut cipherstate1 : CipherState<CipherChaChaPoly> = Default::default();
+        let mut cipherstate2 : CipherState<CipherChaChaPoly> = Default::default();
+	let mut handshake = HandshakeState::new_from_owner(&mut owner, true, HandshakePattern::IK, "WireGuard v0 zx2c4 Jason@zx2c4.com".as_bytes(), Some(&my_preshared[..]), &mut cipherstate1, &mut cipherstate2);
+
+	let now = time::get_time();
+	let mut tai64n = [0; 12];
+	BigEndian::write_i64(&mut tai64n[0..], now.sec);
+	BigEndian::write_i32(&mut tai64n[8..], now.nsec);
+	let mut initiation_packet = [0; 145];
+	initiation_packet[0] = 1; /* Type: Initiation */
+	LittleEndian::write_u32(&mut initiation_packet[1..], 28); /* Sender index: 28 (arbitrary) */
+	handshake.write_message(&tai64n, &mut initiation_packet[5..]);
+	let mut mac_material = [0; 143];
+	memcpy(&mut mac_material, &their_public);
+	memcpy(&mut mac_material[32..], &initiation_packet[0..113]);
+	let mut mac = [0; 16];
+	Blake2s::blake2s(&mut mac, &mac_material, &my_preshared);
+	memcpy(&mut initiation_packet[113..], &mac);
+	socket.send_to(&initiation_packet, &send_addr).unwrap();
+
+	let mut response_packet = [0; 89];
+	socket.recv_from(&mut response_packet).unwrap();
+	assert!(response_packet[0] == 2 /* Type: Response */);
+	let their_index = LittleEndian::read_u32(&response_packet[1..]);
+	let our_index = LittleEndian::read_u32(&response_packet[5..]);
+	assert!(our_index == 28);
+	let (payload_len, last) = handshake.read_message(&response_packet[9..57], &mut empty_payload).unwrap();
+	assert!(payload_len == 0 && last);
+
+	let mut keepalive_packet = [0; 29];
+	keepalive_packet[0] = 4; /* Type: Data */
+	LittleEndian::write_u32(&mut keepalive_packet[1..], their_index);
+	LittleEndian::write_u64(&mut keepalive_packet[5..], cipherstate1.n);
+	cipherstate1.encrypt(&empty_payload, &mut keepalive_packet[13..]); /* Empty payload means keepalive */
+	socket.send_to(&keepalive_packet, &send_addr).unwrap();
+}
diff --git a/contrib/stress-testing/badpacket.c b/contrib/stress-testing/badpacket.c
new file mode 100644
index 0000000..eee61fc
--- /dev/null
+++ b/contrib/stress-testing/badpacket.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <linux/limits.h>
+
+int main(int argc, char *argv[])
+{
+	static const unsigned char handshake1[143] = { 1, 0 };
+	int fd = socket(AF_INET, SOCK_DGRAM, 0);
+	struct sockaddr_in addr = {
+		.sin_family = AF_INET,
+		.sin_port = htons(atoi(argv[2])),
+		.sin_addr = inet_addr(argv[1])
+	};
+	connect(fd, (struct sockaddr *)&addr, sizeof(addr));
+
+	for (;;)
+		send(fd, handshake1, sizeof(handshake1), 0);
+
+	close(fd);
+
+	return 0;
+}
diff --git a/contrib/stress-testing/peg.c b/contrib/stress-testing/peg.c
new file mode 100644
index 0000000..6b539fa
--- /dev/null
+++ b/contrib/stress-testing/peg.c
@@ -0,0 +1,50 @@
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <linux/limits.h>
+#include <time.h>
+#include <stdio.h>
+#include <string.h>
+
+static unsigned long long interface_tx_bytes(const char *interface)
+{
+	char buf[PATH_MAX];
+	FILE *f;
+	unsigned long long ret;
+	snprintf(buf, PATH_MAX - 1, "/sys/class/net/%s/statistics/tx_bytes", interface);
+	f = fopen(buf, "r");
+	fscanf(f, "%llu", &ret);
+	fclose(f);
+	return ret;
+}
+
+int main(int argc, char *argv[])
+{
+	char buf[1500] = { 0 };
+	unsigned long long before, after, i;
+	struct timespec begin, end;
+	double elapsed;
+	struct ifreq req;
+	int fd = socket(AF_INET, SOCK_DGRAM, 0);
+	struct sockaddr_in addr = {
+		.sin_family = AF_INET,
+		.sin_port = htons(7271),
+		.sin_addr = inet_addr(argv[3])
+	};
+	strcpy(req.ifr_name, argv[1]);
+	ioctl(fd, SIOCGIFMTU, &req);
+
+	connect(fd, (struct sockaddr *)&addr, sizeof(addr));
+
+	before = interface_tx_bytes(argv[2]);
+	clock_gettime(CLOCK_MONOTONIC, &begin);
+	for (i = 0; i < 10000000; ++i)
+		send(fd, buf, req.ifr_mtu - 28, 0);
+	clock_gettime(CLOCK_MONOTONIC, &end);
+	after = interface_tx_bytes(argv[2]);
+	elapsed = end.tv_sec - begin.tv_sec + (end.tv_nsec - begin.tv_nsec) / 1000000000.0;
+
+	printf("%.4f mbps\n", ((after - before) * 8) / elapsed / 1000000.0);
+	return 0;
+}
diff --git a/contrib/stress-testing/self-send.sh b/contrib/stress-testing/self-send.sh
new file mode 100755
index 0000000..eb7947b
--- /dev/null
+++ b/contrib/stress-testing/self-send.sh
@@ -0,0 +1,48 @@
+#!/bin/bash
+set -e
+
+PRIVATE_KEYS=("")
+PUBLIC_KEYS=("")
+
+resetwg() {
+	for i in {1..64}; do
+		ip link delete dev wg${i} 2>/dev/null >/dev/null || true
+	done
+}
+
+for i in {1..64}; do
+	next_key="$(wg genkey)"
+	PRIVATE_KEYS+=("$next_key")
+	PUBLIC_KEYS+=($(wg pubkey <<<"$next_key"))
+done
+
+resetwg
+trap resetwg INT TERM EXIT
+
+for i in {1..64}; do
+	{ echo "[Interface]"
+	  echo "ListenPort = $(( $i + 31222 ))"
+	  echo "PrivateKey = ${PRIVATE_KEYS[$i]}"
+
+	for j in {1..64}; do
+		[[ $i == $j ]] && continue
+		echo "[Peer]"
+		echo "PublicKey = ${PUBLIC_KEYS[$j]}"
+		echo "AllowedIPs = 192.168.8.${j}/32"
+		echo "Endpoint = 127.0.0.1:$(( $j + 31222 ))"
+	  done
+	} > "/tmp/deviceload.conf"
+
+	ip link add dev wg${i} type wireguard
+	wg setconf wg${i} "/tmp/deviceload.conf"
+	ip link set up dev wg${i}
+	rm "/tmp/deviceload.conf"
+done
+
+ip address add dev wg1 192.168.8.1/24
+
+while true; do
+	for i in {2..64}; do
+		echo hello | ncat -u 192.168.8.${i} 1234
+	done
+done
diff --git a/contrib/stress-testing/threewayiperf.sh b/contrib/stress-testing/threewayiperf.sh
new file mode 100755
index 0000000..932d666
--- /dev/null
+++ b/contrib/stress-testing/threewayiperf.sh
@@ -0,0 +1,30 @@
+#!/bin/bash
+set -e
+
+if [[ $(hostname) == "thinkpad" ]]; then
+	make -C "$(dirname "$0")/../../src" remote-run
+	for i in 128 129 130; do
+		scp "$0" root@172.16.48.${i}:
+	done
+	for i in 128 129 130; do
+		konsole --new-tab -e ssh -t root@172.16.48.${i} "./$(basename "$0")"
+	done
+	exit
+fi
+
+# perf top -U --dsos '[wireguard]'
+
+tmux new-session -s bigtest -d
+tmux new-window -n "server 6000" -t bigtest "iperf3 -p 6000 -s"
+tmux new-window -n "server 6001" -t bigtest "iperf3 -p 6001 -s"
+sleep 5
+me=$(ip -o -4 address show dev wg0 | sed 's/.*inet \([^ ]*\)\/.*/\1/' | cut -d . -f 4)
+for i in 1 2 3; do
+	[[ $i == $me ]] && continue
+	[[ $me == "1" ]] && port=6000
+	[[ $me == "3" ]] && port=6001
+	[[ $me == "2" && $i == "1" ]] && port=6000
+	[[ $me == "2" && $i == "3" ]] && port=6001
+	tmux new-window -n "client 192.168.2.${i}" -t bigtest "iperf3 -n 300000G -i 1 -p $port -c 192.168.2.${i}"
+done
+tmux attach -t bigtest
diff --git a/contrib/wgserver.service b/contrib/wgserver.service
new file mode 100644
index 0000000..dfce1e9
--- /dev/null
+++ b/contrib/wgserver.service
@@ -0,0 +1,15 @@
+[Unit]
+Description=WireGuard Server
+
+[Service]
+Type=oneshot
+RemainAfterExit=yes
+ExecStart=/bin/ip link add dev wgserver type wireguard
+ExecStart=/bin/ip address add 192.168.177.1/24 dev wgserver
+ExecStart=/usr/bin/wg setconf wgserver /etc/wireguard-server.conf
+ExecStart=/bin/ip link set up dev wgserver
+ExecStop=/bin/sh -c 'umask 077; /usr/bin/wg showconf wgserver > /etc/wireguard-server.conf.tmp && mv /etc/wireguard-server.conf.tmp /etc/wireguard-server.conf'
+ExecStop=/bin/ip link del dev wgserver
+
+[Install]
+WantedBy=multi-user.target
diff --git a/src/.gitignore b/src/.gitignore
new file mode 100644
index 0000000..359f8b5
--- /dev/null
+++ b/src/.gitignore
@@ -0,0 +1,3 @@
+*.d
+*.o
+wg
diff --git a/src/Makefile b/src/Makefile
new file mode 100644
index 0000000..4eddd25
--- /dev/null
+++ b/src/Makefile
@@ -0,0 +1,26 @@
+PREFIX ?= /usr
+DESTDIR ?=
+BINDIR ?= $(PREFIX)/bin
+LIBDIR ?= $(PREFIX)/lib
+MANDIR ?= $(PREFIX)/share/man
+
+CFLAGS += -std=gnu11
+CFLAGS += -pedantic -Wall -Wextra
+CFLAGS += -MMD
+LDLIBS += -lresolv -lmnl
+
+wg: $(patsubst %.c,%.o,$(wildcard *.c))
+
+clean:
+	rm -f wg *.o *.d
+
+install: wg
+	install -v -d "$(DESTDIR)$(BINDIR)" && install -s -m 0755 -v wg "$(DESTDIR)$(BINDIR)/wg"
+	install -v -d "$(DESTDIR)$(MANDIR)/man8" && install -m 0644 -v wg.8 "$(DESTDIR)$(MANDIR)/man8/wg.8"
+
+check: clean
+	CFLAGS=-g scan-build --view --keep-going $(MAKE) wg
+
+.PHONY: clean install check
+
+-include *.d
diff --git a/src/base64.c b/src/base64.c
new file mode 100644
index 0000000..cf37464
--- /dev/null
+++ b/src/base64.c
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 1996, 1998 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+ * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+ * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * Portions Copyright (c) 1995 by International Business Machines, Inc.
+ *
+ * International Business Machines, Inc. (hereinafter called IBM) grants
+ * permission under its copyrights to use, copy, modify, and distribute this
+ * Software with or without fee, provided that the above copyright notice and
+ * all paragraphs of this notice appear in all copies, and that the name of IBM
+ * not be used in connection with the marketing of any product incorporating
+ * the Software or modifications thereof, without specific, written prior
+ * permission.
+ *
+ * To the extent it has a right to do so, IBM grants an immunity from suit
+ * under its patents, if any, for the use, sale or manufacture of products to
+ * the extent that such products are used for performing Domain Name System
+ * dynamic updates in TCP/IP networks by means of the Software.  No immunity is
+ * granted for any product per se or for any other function of any product.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,
+ * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN
+ * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "base64.h"
+#include <sys/types.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#if defined(NEED_B64_NTOP) || defined(NEED_B64_PTON)
+static const char base64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+static const char pad64 = '=';
+#endif
+
+#ifdef NEED_B64_NTOP
+int b64_ntop(unsigned char const *src, size_t srclength, char *target, size_t targsize)
+{
+	size_t datalength = 0;
+	uint8_t input[3];
+	uint8_t output[4];
+	size_t i;
+
+	while (2 < srclength) {
+		input[0] = *src++;
+		input[1] = *src++;
+		input[2] = *src++;
+		srclength -= 3;
+
+		output[0] = input[0] >> 2;
+		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
+		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
+		output[3] = input[2] & 0x3f;
+		assert(output[0] < 64);
+		assert(output[1] < 64);
+		assert(output[2] < 64);
+		assert(output[3] < 64);
+
+		if (datalength + 4 > targsize)
+			return -1;
+		target[datalength++] = base64[output[0]];
+		target[datalength++] = base64[output[1]];
+		target[datalength++] = base64[output[2]];
+		target[datalength++] = base64[output[3]];
+	}
+	if (0 != srclength) {
+		input[0] = input[1] = input[2] = '\0';
+		for (i = 0; i < srclength; i++)
+			input[i] = *src++;
+		output[0] = input[0] >> 2;
+		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
+		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
+		assert(output[0] < 64);
+		assert(output[1] < 64);
+		assert(output[2] < 64);
+
+		if (datalength + 4 > targsize)
+			return -1;
+		target[datalength++] = base64[output[0]];
+		target[datalength++] = base64[output[1]];
+		if (srclength == 1)
+			target[datalength++] = pad64;
+		else
+			target[datalength++] = base64[output[2]];
+		target[datalength++] = pad64;
+	}
+	if (datalength >= targsize)
+		return (-1);
+	target[datalength] = '\0';
+	return datalength;
+}
+#endif
+
+#ifdef NEED_B64_PTON
+int b64_pton(char const *src, uint8_t *target, size_t targsize)
+{
+	static int b64rmap_initialized = 0;
+	static uint8_t b64rmap[256];
+	static const uint8_t b64rmap_special = 0xf0;
+	static const uint8_t b64rmap_end = 0xfd;
+	static const uint8_t b64rmap_space = 0xfe;
+	static const uint8_t b64rmap_invalid = 0xff;
+	int tarindex, state, ch;
+	uint8_t ofs;
+
+	if (!b64rmap_initialized) {
+		int i;
+		char ch;
+		b64rmap[0] = b64rmap_end;
+		for (i = 1; i < 256; ++i) {
+			ch = (char)i;
+			if (isspace(ch))
+				b64rmap[i] = b64rmap_space;
+			else if (ch == pad64)
+				b64rmap[i] = b64rmap_end;
+			else
+				b64rmap[i] = b64rmap_invalid;
+		}
+		for (i = 0; base64[i] != '\0'; ++i)
+			b64rmap[(uint8_t)base64[i]] = i;
+		b64rmap_initialized = 1;
+	}
+
+	state = 0;
+	tarindex = 0;
+
+	for (;;) {
+		ch = *src++;
+		ofs = b64rmap[ch];
+
+		if (ofs >= b64rmap_special) {
+			if (ofs == b64rmap_space)
+				continue;
+			if (ofs == b64rmap_end)
+				break;
+			return -1;
+		}
+
+		switch (state) {
+		case 0:
+			if ((size_t)tarindex >= targsize)
+				return -1;
+			target[tarindex] = ofs << 2;
+			state = 1;
+			break;
+		case 1:
+			if ((size_t)tarindex + 1 >= targsize)
+				return -1;
+			target[tarindex]   |=  ofs >> 4;
+			target[tarindex+1]  = (ofs & 0x0f) << 4 ;
+			tarindex++;
+			state = 2;
+			break;
+		case 2:
+			if ((size_t)tarindex + 1 >= targsize)
+				return -1;
+			target[tarindex]   |=  ofs >> 2;
+			target[tarindex+1]  = (ofs & 0x03) << 6;
+			tarindex++;
+			state = 3;
+			break;
+		case 3:
+			if ((size_t)tarindex >= targsize)
+				return -1;
+			target[tarindex] |= ofs;
+			tarindex++;
+			state = 0;
+			break;
+		default:
+			abort();
+		}
+	}
+
+	if (ch == pad64) {
+		ch = *src++;
+		switch (state) {
+		case 0:
+		case 1:
+			return -1;
+
+		case 2:
+			for (; ch; ch = *src++) {
+				if (b64rmap[ch] != b64rmap_space)
+					break;
+			}
+			if (ch != pad64)
+				return -1;
+			ch = *src++;
+		case 3:
+			for (; ch; ch = *src++) {
+				if (b64rmap[ch] != b64rmap_space)
+					return -1;
+			}
+			if (target[tarindex] != 0)
+				return -1;
+		}
+	} else {
+		if (state != 0)
+			return -1;
+	}
+
+	return tarindex;
+}
+#endif
diff --git a/src/base64.h b/src/base64.h
new file mode 100644
index 0000000..5cc94e1
--- /dev/null
+++ b/src/base64.h
@@ -0,0 +1,20 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#ifndef BASE64_H
+#define BASE64_H
+
+#include <resolv.h>
+
+#define b64_len(len) ((((len) + 2) / 3) * 4 + 1)
+
+#ifndef b64_ntop
+int b64_ntop(unsigned char const *, size_t, char *, size_t);
+#define NEED_B64_NTOP
+#endif
+
+#ifndef b64_pton
+int b64_pton(char const *, unsigned char *, size_t);
+#define NEED_B64_PTON
+#endif
+
+#endif
diff --git a/src/config.c b/src/config.c
new file mode 100644
index 0000000..0cec30e
--- /dev/null
+++ b/src/config.c
@@ -0,0 +1,518 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+
+#include <arpa/inet.h>
+#include <ctype.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <errno.h>
+
+#include "config.h"
+#include "kernel.h"
+#include "base64.h"
+
+#define COMMENT_CHAR '#'
+
+#define max(a, b) (a > b ? a : b)
+
+static inline struct wgpeer *peer_from_offset(struct wgdevice *dev, size_t offset)
+{
+	return (struct wgpeer *)((uint8_t *)dev + sizeof(struct wgdevice) + offset);
+}
+
+static int use_space(struct inflatable_device *buf, size_t space)
+{
+	size_t expand_to;
+	uint8_t *new_dev;
+
+	if (buf->len - buf->pos < space) {
+		expand_to = max(buf->len * 2, buf->len + space);
+		new_dev = realloc(buf->dev, expand_to + sizeof(struct wgdevice));
+		if (!new_dev)
+			return -errno;
+		memset(&new_dev[buf->len + sizeof(struct wgdevice)], 0, expand_to - buf->len);
+		buf->dev = (struct wgdevice *)new_dev;
+		buf->len = expand_to;
+	}
+	buf->pos += space;
+	return 0;
+}
+
+static const char *get_value(const char *line, const char *key)
+{
+	size_t linelen = strlen(line);
+	size_t keylen = strlen(key);
+
+	if (keylen >= linelen)
+		return NULL;
+
+	if (strncasecmp(line, key, keylen))
+		return NULL;
+
+	return line + keylen;
+}
+
+static inline uint16_t parse_port(const char *value)
+{
+	int ret;
+	uint16_t port = 0;
+	struct addrinfo *resolved;
+	struct addrinfo hints = {
+		.ai_family = AF_UNSPEC,
+		.ai_socktype = SOCK_DGRAM,
+		.ai_protocol = IPPROTO_UDP,
+		.ai_flags = AI_ADDRCONFIG | AI_PASSIVE
+	};
+
+	if (!strlen(value)) {
+		fprintf(stderr, "Unable to parse empty port\n");
+		return 0;
+	}
+
+	ret = getaddrinfo(NULL, value, &hints, &resolved);
+	if (ret != 0) {
+		fprintf(stderr, "%s: `%s`\n", gai_strerror(ret), value);
+		return 0;
+	}
+
+	if (resolved->ai_family == AF_INET && resolved->ai_addrlen == sizeof(struct sockaddr_in))
+		port = ntohs(((struct sockaddr_in *)resolved->ai_addr)->sin_port);
+	else if (resolved->ai_family == AF_INET6 && resolved->ai_addrlen == sizeof(struct sockaddr_in6))
+		port = ntohs(((struct sockaddr_in6 *)resolved->ai_addr)->sin6_port);
+	else
+		fprintf(stderr, "Neither IPv4 nor IPv6 address found: `%s`\n", value);
+
+	freeaddrinfo(resolved);
+	return port;
+}
+
+static inline bool parse_key(uint8_t key[WG_KEY_LEN], const char *value)
+{
+	uint8_t tmp[WG_KEY_LEN + 1];
+	if (strlen(value) != b64_len(WG_KEY_LEN) - 1) {
+		fprintf(stderr, "Key is not the correct length: `%s`\n", value);
+		return false;
+	}
+	if (b64_pton(value, tmp, WG_KEY_LEN + 1) < 0) {
+		fprintf(stderr, "Could not parse base64 key: `%s`\n", value);
+		return false;
+	}
+	memcpy(key, tmp, WG_KEY_LEN);
+	return true;
+}
+
+static inline bool parse_ip(struct wgipmask *ipmask, const char *value)
+{
+	ipmask->family = AF_UNSPEC;
+	if (strchr(value, ':')) {
+		if (inet_pton(AF_INET6, value, &ipmask->ip6) == 1)
+			ipmask->family = AF_INET6;
+	} else {
+		if (inet_pton(AF_INET, value, &ipmask->ip4) == 1)
+			ipmask->family = AF_INET;
+	}
+	if (ipmask->family == AF_UNSPEC) {
+		fprintf(stderr, "Unable to parse IP address: `%s`\n", value);
+		return false;
+	}
+	return true;
+}
+
+static inline bool parse_endpoint(struct sockaddr_storage *endpoint, const char *value)
+{
+	char *mutable = strdup(value);
+	char *begin, *end;
+	int ret;
+	struct addrinfo *resolved;
+	struct addrinfo hints = {
+		.ai_family = AF_UNSPEC,
+		.ai_socktype = SOCK_DGRAM,
+		.ai_protocol = IPPROTO_UDP,
+		.ai_flags = AI_ADDRCONFIG
+	};
+	if (!strlen(value)) {
+		free(mutable);
+		fprintf(stderr, "Unable to parse empty endpoint\n");
+		return false;
+	}
+	if (mutable[0] == '[') {
+		begin = &mutable[1];
+		end = strchr(mutable, ']');
+		if (!end) {
+			free(mutable);
+			fprintf(stderr, "Unable to find matching brace of endpoint: `%s`\n", value);
+			return false;
+		}
+		*end = '\0';
+		++end;
+		if (*end != ':' || !*(end + 1)) {
+			free(mutable);
+			fprintf(stderr, "Unable to find port of endpoint: `%s`\n", value);
+			return false;
+		}
+		++end;
+	} else {
+		begin = mutable;
+		end = strrchr(mutable, ':');
+		if (!end || !*(end + 1)) {
+			free(mutable);
+			fprintf(stderr, "Unable to find port of endpoint: `%s`\n", value);
+			return false;
+		}
+		*end = '\0';
+		++end;
+	}
+	ret = getaddrinfo(begin, end, &hints, &resolved);
+	if (ret != 0) {
+		free(mutable);
+		fprintf(stderr, "%s: `%s`\n", gai_strerror(ret), value);
+		return false;
+	}
+	if ((resolved->ai_family == AF_INET && resolved->ai_addrlen == sizeof(struct sockaddr_in)) ||
+	    (resolved->ai_family == AF_INET6 && resolved->ai_addrlen == sizeof(struct sockaddr_in6)))
+		memcpy(endpoint, resolved->ai_addr, resolved->ai_addrlen);
+	else {
+		freeaddrinfo(resolved);
+		free(mutable);
+		fprintf(stderr, "Neither IPv4 nor IPv6 address found: `%s`\n", value);
+		return false;
+	}
+	freeaddrinfo(resolved);
+	free(mutable);
+	return true;
+}
+
+static inline bool parse_ipmasks(struct inflatable_device *buf, size_t peer_offset, const char *value)
+{
+	struct wgpeer *peer;
+	struct wgipmask *ipmask;
+	char *mask, *mutable = strdup(value), *sep;
+	if (!mutable) {
+		perror("strdup");
+		return false;
+	};
+	peer = peer_from_offset(buf->dev, peer_offset);
+	peer->num_ipmasks = 0;
+	peer->replace_ipmasks = true;
+	if (!strlen(value)) {
+		free(mutable);
+		return true;
+	}
+	sep = mutable;
+	while ((mask = strsep(&sep, ","))) {
+		unsigned long cidr;
+		char *end, *ip = strsep(&mask, "/");
+		if (use_space(buf, sizeof(struct wgipmask)) < 0) {
+			perror("use_space");
+			free(mutable);
+			return false;
+		}
+		peer = peer_from_offset(buf->dev, peer_offset);
+		ipmask = (struct wgipmask *)((uint8_t *)peer + sizeof(struct wgpeer) + (sizeof(struct wgipmask) * peer->num_ipmasks));
+
+		if (!parse_ip(ipmask, ip)) {
+			free(mutable);
+			return false;
+		}
+		if (ipmask->family == AF_INET) {
+			if (mask) {
+				cidr = strtoul(mask, &end, 10);
+				if (*end)
+					mask = NULL;
+				if (cidr > 32)
+					mask = NULL;
+			}
+			if (!mask)
+				cidr = 32;
+		} else if (ipmask->family == AF_INET6) {
+			if (mask) {
+				cidr = strtoul(mask, &end, 10);
+				if (*end)
+					mask = NULL;
+				if (cidr > 128)
+					mask = NULL;
+			}
+			if (!mask)
+				cidr = 128;
+		} else
+			continue;
+		ipmask->cidr = cidr;
+		++peer->num_ipmasks;
+	}
+	free(mutable);
+	return true;
+}
+
+static bool process_line(struct config_ctx *ctx, const char *line)
+{
+	const char *value;
+	bool ret = true;
+
+	if (!strcasecmp(line, "[Interface]")) {
+		ctx->is_peer_section = false;
+		ctx->is_device_section = true;
+		return true;
+	}
+	if (!strcasecmp(line, "[Peer]")) {
+		ctx->peer_offset = ctx->buf.pos;
+		if (use_space(&ctx->buf, sizeof(struct wgpeer)) < 0) {
+			perror("use_space");
+			return false;
+		}
+		++ctx->buf.dev->num_peers;
+		ctx->is_peer_section = true;
+		ctx->is_device_section = false;
+		peer_from_offset(ctx->buf.dev, ctx->peer_offset)->replace_ipmasks = true;
+		return true;
+	}
+
+#define key_match(key) (value = get_value(line, key "="))
+
+	if (ctx->is_device_section) {
+		if (key_match("ListenPort"))
+			ret = !!(ctx->buf.dev->port = parse_port(value));
+		else if (key_match("PrivateKey")) {
+			ret = parse_key(ctx->buf.dev->private_key, value);
+			if (!ret)
+				memset(ctx->buf.dev->private_key, 0, WG_KEY_LEN);
+		} else if (key_match("PresharedKey")) {
+			ret = parse_key(ctx->buf.dev->preshared_key, value);
+			if (!ret)
+				memset(ctx->buf.dev->preshared_key, 0, WG_KEY_LEN);
+		} else
+			goto error;
+	} else if (ctx->is_peer_section) {
+		if (key_match("Endpoint"))
+			ret = parse_endpoint(&peer_from_offset(ctx->buf.dev, ctx->peer_offset)->endpoint, value);
+		else if (key_match("PublicKey"))
+			ret = parse_key(peer_from_offset(ctx->buf.dev, ctx->peer_offset)->public_key, value);
+		else if (key_match("AllowedIPs"))
+			ret = parse_ipmasks(&ctx->buf, ctx->peer_offset, value);
+		else
+			goto error;
+	} else
+		goto error;
+	return ret;
+
+#undef key_match
+
+error:
+	fprintf(stderr, "Line unrecognized: `%s'\n", line);
+	return false;
+}
+
+bool config_read_line(struct config_ctx *ctx, const char *input)
+{
+	size_t len = strlen(input), cleaned_len = 0;
+	char *line = calloc(len + 1, sizeof(char));
+	bool ret = true;
+	if (!line) {
+		perror("calloc");
+		return false;
+	}
+	if (!len)
+		goto out;
+	for (size_t i = 0; i < len; ++i) {
+		if (!isspace(input[i]))
+			line[cleaned_len++] = input[i];
+	}
+	if (!cleaned_len)
+		goto out;
+	if (line[0] == COMMENT_CHAR)
+		goto out;
+	ret = process_line(ctx, line);
+out:
+	free(line);
+	return ret;
+}
+
+bool config_read_init(struct config_ctx *ctx, struct wgdevice **device, bool append)
+{
+	memset(ctx, 0, sizeof(struct config_ctx));
+	ctx->device = device;
+	ctx->buf.dev = calloc(1, sizeof(struct wgdevice));
+	if (!ctx->buf.dev) {
+		perror("calloc");
+		return false;
+	}
+	ctx->buf.dev->replace_peer_list = !append;
+	return true;
+}
+
+static inline bool key_is_valid(uint8_t key[WG_KEY_LEN])
+{
+	static const uint8_t zero[WG_KEY_LEN] = { 0 };
+	return !!memcmp(key, zero, WG_KEY_LEN);
+}
+
+bool config_read_finish(struct config_ctx *ctx)
+{
+	size_t i;
+	struct wgpeer *peer;
+	if (ctx->buf.dev->replace_peer_list && !ctx->buf.dev->num_peers) {
+		fprintf(stderr, "No peers configured\n");
+		goto err;
+	}
+	if (ctx->buf.dev->replace_peer_list && !key_is_valid(ctx->buf.dev->private_key)) {
+		fprintf(stderr, "No private key configured\n");
+		goto err;
+	}
+	for_each_wgpeer(ctx->buf.dev, peer, i) {
+		if (!key_is_valid(peer->public_key)) {
+			fprintf(stderr, "A peer is missing a public key\n");
+			goto err;
+		}
+	}
+	*ctx->device = ctx->buf.dev;
+	return true;
+err:
+	free(ctx->buf.dev);
+	return false;
+}
+
+static int read_line(char **dst, const char *path)
+{
+	FILE *f;
+	size_t n = 0;
+	struct stat stat;
+
+	*dst = NULL;
+
+	f = fopen(path, "r");
+	if (!f) {
+		perror("fopen");
+		return -1;
+	}
+	if (fstat(fileno(f), &stat) < 0) {
+		perror("fstat");
+		fclose(f);
+		return -1;
+	}
+	if (S_ISCHR(stat.st_mode) && stat.st_rdev == makedev(1, 3)) {
+		fclose(f);
+		return 1;
+	}
+	if (getline(dst, &n, f) < 0) {
+		perror("getline");
+		fclose(f);
+		return -1;
+	}
+	fclose(f);
+	n = strlen(*dst);
+	while (--n) {
+		if (isspace((*dst)[n]))
+			(*dst)[n] = '\0';
+	}
+	return 0;
+}
+
+static char *strip_spaces(const char *in)
+{
+	char *out;
+	size_t t, l, i;
+
+	t = strlen(in);
+	out = calloc(t + 1, sizeof(char));
+	if (!out) {
+		perror("calloc");
+		return NULL;
+	}
+	for (i = 0, l = 0; i < t; ++i) {
+		if (!isspace(in[i]))
+			out[l++] = in[i];
+	}
+	return out;
+}
+
+bool config_read_cmd(struct wgdevice **device, char *argv[], int argc)
+{
+	struct inflatable_device buf = { 0 };
+	size_t peer_offset = 0;
+	buf.dev = calloc(sizeof(struct wgdevice), 1);
+	if (!buf.dev) {
+		perror("calloc");
+		return false;
+	}
+	while (argc > 0) {
+		if (!strcmp(argv[0], "listen-port") && argc >= 2 && !buf.dev->num_peers) {
+			buf.dev->port = parse_port(argv[1]);
+			if (!buf.dev->port)
+				goto error;
+			argv += 2;
+			argc -= 2;
+		} else if (!strcmp(argv[0], "private-key") && argc >= 2 && !buf.dev->num_peers) {
+			char *line;
+			int ret = read_line(&line, argv[1]);
+			if (ret == 0) {
+				if (!parse_key(buf.dev->private_key, line)) {
+					free(line);
+					goto error;
+				}
+				free(line);
+			} else if (ret == 1)
+				buf.dev->remove_private_key = true;
+			else
+				goto error;
+			argv += 2;
+			argc -= 2;
+		} else if (!strcmp(argv[0], "preshared-key") && argc >= 2 && !buf.dev->num_peers) {
+			char *line;
+			int ret = read_line(&line, argv[1]);
+			if (ret == 0) {
+				if (!parse_key(buf.dev->preshared_key, line)) {
+					free(line);
+					goto error;
+				}
+				free(line);
+			} else if (ret == 1)
+				buf.dev->remove_preshared_key = true;
+			else
+				goto error;
+			argv += 2;
+			argc -= 2;
+		} else if (!strcmp(argv[0], "peer") && argc >= 2) {
+			peer_offset = buf.pos;
+			if (use_space(&buf, sizeof(struct wgpeer)) < 0) {
+				perror("use_space");
+				goto error;
+			}
+			++buf.dev->num_peers;
+			if (!parse_key(peer_from_offset(buf.dev, peer_offset)->public_key, argv[1]))
+				goto error;
+			argv += 2;
+			argc -= 2;
+		} else if (!strcmp(argv[0], "remove") && argc >= 1 && buf.dev->num_peers) {
+			peer_from_offset(buf.dev, peer_offset)->remove_me = true;
+			argv += 1;
+			argc -= 1;
+		} else if (!strcmp(argv[0], "endpoint") && argc >= 2 && buf.dev->num_peers) {
+			if (!parse_endpoint(&peer_from_offset(buf.dev, peer_offset)->endpoint, argv[1]))
+				goto error;
+			argv += 2;
+			argc -= 2;
+		} else if (!strcmp(argv[0], "allowed-ips") && argc >= 2 && buf.dev->num_peers) {
+			char *line = strip_spaces(argv[1]);
+			if (!line)
+				goto error;
+			if (!parse_ipmasks(&buf, peer_offset, line)) {
+				free(line);
+				goto error;
+			}
+			free(line);
+			argv += 2;
+			argc -= 2;
+		} else {
+			fprintf(stderr, "Invalid argument: %s\n", argv[0]);
+			goto error;
+		}
+	}
+	*device = buf.dev;
+	return true;
+error:
+	free(buf.dev);
+	return false;
+}
diff --git a/src/config.h b/src/config.h
new file mode 100644
index 0000000..268e3f6
--- /dev/null
+++ b/src/config.h
@@ -0,0 +1,34 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#ifndef CONFIG_H
+#define CONFIG_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "../uapi.h"
+
+struct inflatable_device {
+	struct wgdevice *dev;
+	size_t len;
+	size_t pos;
+};
+
+struct config_ctx {
+	struct inflatable_device buf;
+	size_t peer_offset;
+	struct wgdevice **device;
+	bool is_peer_section;
+	bool is_device_section;
+};
+
+bool config_read_cmd(struct wgdevice **dev, char *argv[], int argc);
+bool config_read_init(struct config_ctx *ctx, struct wgdevice **device, bool append);
+bool config_read_line(struct config_ctx *ctx, const char *line);
+bool config_read_finish(struct config_ctx *ctx);
+
+#endif
diff --git a/src/curve25519.c b/src/curve25519.c
new file mode 100644
index 0000000..6c26535
--- /dev/null
+++ b/src/curve25519.c
@@ -0,0 +1,1258 @@
+/* Original author: Adam Langley <agl@imperialviolet.org>
+ *
+ * Copyright 2008 Google Inc. All Rights Reserved.
+ * Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ *   Redistribution and use in source and binary forms of this file, with or
+ *   without modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *       * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *       * Redistributions in binary form must reproduce the above
+ *   copyright notice, this list of conditions and the following disclaimer
+ *   in the documentation and/or other materials provided with the
+ *   distribution.
+ *       * Neither the name of Google Inc nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "curve25519.h"
+
+#include <stdint.h>
+#include <string.h>
+
+#ifndef __always_inline
+#define __always_inline __inline __attribute__((__always_inline__))
+#endif
+
+#ifdef __SIZEOF_INT128__
+typedef uint64_t limb;
+typedef limb felem[5];
+typedef __uint128_t uint128_t;
+
+/* Sum two numbers: output += in */
+static __always_inline void fsum(limb *output, const limb *in)
+{
+	output[0] += in[0];
+	output[1] += in[1];
+	output[2] += in[2];
+	output[3] += in[3];
+	output[4] += in[4];
+}
+
+/* Find the difference of two numbers: output = in - output
+ * (note the order of the arguments!)
+ *
+ * Assumes that out[i] < 2**52
+ * On return, out[i] < 2**55
+ */
+static __always_inline void fdifference_backwards(felem out, const felem in)
+{
+	/* 152 is 19 << 3 */
+	static const limb two54m152 = (((limb)1) << 54) - 152;
+	static const limb two54m8 = (((limb)1) << 54) - 8;
+
+	out[0] = in[0] + two54m152 - out[0];
+	out[1] = in[1] + two54m8 - out[1];
+	out[2] = in[2] + two54m8 - out[2];
+	out[3] = in[3] + two54m8 - out[3];
+	out[4] = in[4] + two54m8 - out[4];
+}
+
+/* Multiply a number by a scalar: output = in * scalar */
+static __always_inline void fscalar_product(felem output, const felem in, const limb scalar)
+{
+	uint128_t a;
+
+	a = ((uint128_t) in[0]) * scalar;
+	output[0] = ((limb)a) & 0x7ffffffffffffUL;
+
+	a = ((uint128_t) in[1]) * scalar + ((limb) (a >> 51));
+	output[1] = ((limb)a) & 0x7ffffffffffffUL;
+
+	a = ((uint128_t) in[2]) * scalar + ((limb) (a >> 51));
+	output[2] = ((limb)a) & 0x7ffffffffffffUL;
+
+	a = ((uint128_t) in[3]) * scalar + ((limb) (a >> 51));
+	output[3] = ((limb)a) & 0x7ffffffffffffUL;
+
+	a = ((uint128_t) in[4]) * scalar + ((limb) (a >> 51));
+	output[4] = ((limb)a) & 0x7ffffffffffffUL;
+
+	output[0] += (a >> 51) * 19;
+}
+
+/* Multiply two numbers: output = in2 * in
+ *
+ * output must be distinct to both inputs. The inputs are reduced coefficient
+ * form, the output is not.
+ *
+ * Assumes that in[i] < 2**55 and likewise for in2.
+ * On return, output[i] < 2**52
+ */
+static __always_inline void fmul(felem output, const felem in2, const felem in)
+{
+	uint128_t t[5];
+	limb r0,r1,r2,r3,r4,s0,s1,s2,s3,s4,c;
+
+	r0 = in[0];
+	r1 = in[1];
+	r2 = in[2];
+	r3 = in[3];
+	r4 = in[4];
+
+	s0 = in2[0];
+	s1 = in2[1];
+	s2 = in2[2];
+	s3 = in2[3];
+	s4 = in2[4];
+
+	t[0]  =  ((uint128_t) r0) * s0;
+	t[1]  =  ((uint128_t) r0) * s1 + ((uint128_t) r1) * s0;
+	t[2]  =  ((uint128_t) r0) * s2 + ((uint128_t) r2) * s0 + ((uint128_t) r1) * s1;
+	t[3]  =  ((uint128_t) r0) * s3 + ((uint128_t) r3) * s0 + ((uint128_t) r1) * s2 + ((uint128_t) r2) * s1;
+	t[4]  =  ((uint128_t) r0) * s4 + ((uint128_t) r4) * s0 + ((uint128_t) r3) * s1 + ((uint128_t) r1) * s3 + ((uint128_t) r2) * s2;
+
+	r4 *= 19;
+	r1 *= 19;
+	r2 *= 19;
+	r3 *= 19;
+
+	t[0] += ((uint128_t) r4) * s1 + ((uint128_t) r1) * s4 + ((uint128_t) r2) * s3 + ((uint128_t) r3) * s2;
+	t[1] += ((uint128_t) r4) * s2 + ((uint128_t) r2) * s4 + ((uint128_t) r3) * s3;
+	t[2] += ((uint128_t) r4) * s3 + ((uint128_t) r3) * s4;
+	t[3] += ((uint128_t) r4) * s4;
+
+			r0 = (limb)t[0] & 0x7ffffffffffffUL; c = (limb)(t[0] >> 51);
+	t[1] += c;      r1 = (limb)t[1] & 0x7ffffffffffffUL; c = (limb)(t[1] >> 51);
+	t[2] += c;      r2 = (limb)t[2] & 0x7ffffffffffffUL; c = (limb)(t[2] >> 51);
+	t[3] += c;      r3 = (limb)t[3] & 0x7ffffffffffffUL; c = (limb)(t[3] >> 51);
+	t[4] += c;      r4 = (limb)t[4] & 0x7ffffffffffffUL; c = (limb)(t[4] >> 51);
+	r0 +=   c * 19; c = r0 >> 51; r0 = r0 & 0x7ffffffffffffUL;
+	r1 +=   c;      c = r1 >> 51; r1 = r1 & 0x7ffffffffffffUL;
+	r2 +=   c;
+
+	output[0] = r0;
+	output[1] = r1;
+	output[2] = r2;
+	output[3] = r3;
+	output[4] = r4;
+}
+
+static __always_inline void fsquare_times(felem output, const felem in, limb count)
+{
+	uint128_t t[5];
+	limb r0,r1,r2,r3,r4,c;
+	limb d0,d1,d2,d4,d419;
+
+	r0 = in[0];
+	r1 = in[1];
+	r2 = in[2];
+	r3 = in[3];
+	r4 = in[4];
+
+	do {
+		d0 = r0 * 2;
+		d1 = r1 * 2;
+		d2 = r2 * 2 * 19;
+		d419 = r4 * 19;
+		d4 = d419 * 2;
+
+		t[0] = ((uint128_t) r0) * r0 + ((uint128_t) d4) * r1 + (((uint128_t) d2) * (r3     ));
+		t[1] = ((uint128_t) d0) * r1 + ((uint128_t) d4) * r2 + (((uint128_t) r3) * (r3 * 19));
+		t[2] = ((uint128_t) d0) * r2 + ((uint128_t) r1) * r1 + (((uint128_t) d4) * (r3     ));
+		t[3] = ((uint128_t) d0) * r3 + ((uint128_t) d1) * r2 + (((uint128_t) r4) * (d419   ));
+		t[4] = ((uint128_t) d0) * r4 + ((uint128_t) d1) * r3 + (((uint128_t) r2) * (r2     ));
+
+				r0 = (limb)t[0] & 0x7ffffffffffffUL; c = (limb)(t[0] >> 51);
+		t[1] += c;      r1 = (limb)t[1] & 0x7ffffffffffffUL; c = (limb)(t[1] >> 51);
+		t[2] += c;      r2 = (limb)t[2] & 0x7ffffffffffffUL; c = (limb)(t[2] >> 51);
+		t[3] += c;      r3 = (limb)t[3] & 0x7ffffffffffffUL; c = (limb)(t[3] >> 51);
+		t[4] += c;      r4 = (limb)t[4] & 0x7ffffffffffffUL; c = (limb)(t[4] >> 51);
+		r0 +=   c * 19; c = r0 >> 51; r0 = r0 & 0x7ffffffffffffUL;
+		r1 +=   c;      c = r1 >> 51; r1 = r1 & 0x7ffffffffffffUL;
+		r2 +=   c;
+	} while(--count);
+
+	output[0] = r0;
+	output[1] = r1;
+	output[2] = r2;
+	output[3] = r3;
+	output[4] = r4;
+}
+
+/* Load a little-endian 64-bit number  */
+static limb load_limb(const uint8_t *in)
+{
+	return
+		((limb)in[0]) |
+		(((limb)in[1]) << 8) |
+		(((limb)in[2]) << 16) |
+		(((limb)in[3]) << 24) |
+		(((limb)in[4]) << 32) |
+		(((limb)in[5]) << 40) |
+		(((limb)in[6]) << 48) |
+		(((limb)in[7]) << 56);
+}
+
+static void store_limb(uint8_t *out, limb in)
+{
+	out[0] = in & 0xff;
+	out[1] = (in >> 8) & 0xff;
+	out[2] = (in >> 16) & 0xff;
+	out[3] = (in >> 24) & 0xff;
+	out[4] = (in >> 32) & 0xff;
+	out[5] = (in >> 40) & 0xff;
+	out[6] = (in >> 48) & 0xff;
+	out[7] = (in >> 56) & 0xff;
+}
+
+/* Take a little-endian, 32-byte number and expand it into polynomial form */
+static void fexpand(limb *output, const uint8_t *in)
+{
+	output[0] = load_limb(in) & 0x7ffffffffffffUL;
+	output[1] = (load_limb(in+6) >> 3) & 0x7ffffffffffffUL;
+	output[2] = (load_limb(in+12) >> 6) & 0x7ffffffffffffUL;
+	output[3] = (load_limb(in+19) >> 1) & 0x7ffffffffffffUL;
+	output[4] = (load_limb(in+24) >> 12) & 0x7ffffffffffffUL;
+}
+
+/* Take a fully reduced polynomial form number and contract it into a
+ * little-endian, 32-byte array
+ */
+static void fcontract(uint8_t *output, const felem input)
+{
+	uint128_t t[5];
+
+	t[0] = input[0];
+	t[1] = input[1];
+	t[2] = input[2];
+	t[3] = input[3];
+	t[4] = input[4];
+
+	t[1] += t[0] >> 51; t[0] &= 0x7ffffffffffffUL;
+	t[2] += t[1] >> 51; t[1] &= 0x7ffffffffffffUL;
+	t[3] += t[2] >> 51; t[2] &= 0x7ffffffffffffUL;
+	t[4] += t[3] >> 51; t[3] &= 0x7ffffffffffffUL;
+	t[0] += 19 * (t[4] >> 51); t[4] &= 0x7ffffffffffffUL;
+
+	t[1] += t[0] >> 51; t[0] &= 0x7ffffffffffffUL;
+	t[2] += t[1] >> 51; t[1] &= 0x7ffffffffffffUL;
+	t[3] += t[2] >> 51; t[2] &= 0x7ffffffffffffUL;
+	t[4] += t[3] >> 51; t[3] &= 0x7ffffffffffffUL;
+	t[0] += 19 * (t[4] >> 51); t[4] &= 0x7ffffffffffffUL;
+
+	/* now t is between 0 and 2^255-1, properly carried. */
+	/* case 1: between 0 and 2^255-20. case 2: between 2^255-19 and 2^255-1. */
+
+	t[0] += 19;
+
+	t[1] += t[0] >> 51; t[0] &= 0x7ffffffffffffUL;
+	t[2] += t[1] >> 51; t[1] &= 0x7ffffffffffffUL;
+	t[3] += t[2] >> 51; t[2] &= 0x7ffffffffffffUL;
+	t[4] += t[3] >> 51; t[3] &= 0x7ffffffffffffUL;
+	t[0] += 19 * (t[4] >> 51); t[4] &= 0x7ffffffffffffUL;
+
+	/* now between 19 and 2^255-1 in both cases, and offset by 19. */
+
+	t[0] += 0x8000000000000UL - 19;
+	t[1] += 0x8000000000000UL - 1;
+	t[2] += 0x8000000000000UL - 1;
+	t[3] += 0x8000000000000UL - 1;
+	t[4] += 0x8000000000000UL - 1;
+
+	/* now between 2^255 and 2^256-20, and offset by 2^255. */
+
+	t[1] += t[0] >> 51; t[0] &= 0x7ffffffffffffUL;
+	t[2] += t[1] >> 51; t[1] &= 0x7ffffffffffffUL;
+	t[3] += t[2] >> 51; t[2] &= 0x7ffffffffffffUL;
+	t[4] += t[3] >> 51; t[3] &= 0x7ffffffffffffUL;
+	t[4] &= 0x7ffffffffffffUL;
+
+	store_limb(output,    t[0] | (t[1] << 51));
+	store_limb(output+8,  (t[1] >> 13) | (t[2] << 38));
+	store_limb(output+16, (t[2] >> 26) | (t[3] << 25));
+	store_limb(output+24, (t[3] >> 39) | (t[4] << 12));
+}
+
+/* Input: Q, Q', Q-Q'
+ * Output: 2Q, Q+Q'
+ *
+ *   x2 z3: long form
+ *   x3 z3: long form
+ *   x z: short form, destroyed
+ *   xprime zprime: short form, destroyed
+ *   qmqp: short form, preserved
+ */
+static void fmonty(limb *x2, limb *z2, /* output 2Q */
+			 limb *x3, limb *z3, /* output Q + Q' */
+			 limb *x, limb *z,   /* input Q */
+			 limb *xprime, limb *zprime, /* input Q' */
+			 const limb *qmqp /* input Q - Q' */)
+{
+	limb origx[5], origxprime[5], zzz[5], xx[5], zz[5], xxprime[5], zzprime[5], zzzprime[5];
+
+	memcpy(origx, x, 5 * sizeof(limb));
+	fsum(x, z);
+	fdifference_backwards(z, origx);  // does x - z
+
+	memcpy(origxprime, xprime, sizeof(limb) * 5);
+	fsum(xprime, zprime);
+	fdifference_backwards(zprime, origxprime);
+	fmul(xxprime, xprime, z);
+	fmul(zzprime, x, zprime);
+	memcpy(origxprime, xxprime, sizeof(limb) * 5);
+	fsum(xxprime, zzprime);
+	fdifference_backwards(zzprime, origxprime);
+	fsquare_times(x3, xxprime, 1);
+	fsquare_times(zzzprime, zzprime, 1);
+	fmul(z3, zzzprime, qmqp);
+
+	fsquare_times(xx, x, 1);
+	fsquare_times(zz, z, 1);
+	fmul(x2, xx, zz);
+	fdifference_backwards(zz, xx);  // does zz = xx - zz
+	fscalar_product(zzz, zz, 121665);
+	fsum(zzz, xx);
+	fmul(z2, zz, zzz);
+}
+
+/* Maybe swap the contents of two limb arrays (@a and @b), each @len elements
+ * long. Perform the swap iff @swap is non-zero.
+ *
+ * This function performs the swap without leaking any side-channel
+ * information.
+ */
+static void swap_conditional(limb a[5], limb b[5], limb iswap)
+{
+	unsigned i;
+	const limb swap = -iswap;
+
+	for (i = 0; i < 5; ++i) {
+		const limb x = swap & (a[i] ^ b[i]);
+		a[i] ^= x;
+		b[i] ^= x;
+	}
+}
+
+/* Calculates nQ where Q is the x-coordinate of a point on the curve
+ *
+ *   resultx/resultz: the x coordinate of the resulting curve point (short form)
+ *   n: a little endian, 32-byte number
+ *   q: a point of the curve (short form)
+ */
+static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
+{
+	limb a[5] = {0}, b[5] = {1}, c[5] = {1}, d[5] = {0};
+	limb *nqpqx = a, *nqpqz = b, *nqx = c, *nqz = d, *t;
+	limb e[5] = {0}, f[5] = {1}, g[5] = {0}, h[5] = {1};
+	limb *nqpqx2 = e, *nqpqz2 = f, *nqx2 = g, *nqz2 = h;
+
+	unsigned i, j;
+
+	memcpy(nqpqx, q, sizeof(limb) * 5);
+
+	for (i = 0; i < 32; ++i) {
+		uint8_t byte = n[31 - i];
+		for (j = 0; j < 8; ++j) {
+			const limb bit = byte >> 7;
+
+			swap_conditional(nqx, nqpqx, bit);
+			swap_conditional(nqz, nqpqz, bit);
+			fmonty(nqx2, nqz2,
+						 nqpqx2, nqpqz2,
+						 nqx, nqz,
+						 nqpqx, nqpqz,
+						 q);
+			swap_conditional(nqx2, nqpqx2, bit);
+			swap_conditional(nqz2, nqpqz2, bit);
+
+			t = nqx;
+			nqx = nqx2;
+			nqx2 = t;
+			t = nqz;
+			nqz = nqz2;
+			nqz2 = t;
+			t = nqpqx;
+			nqpqx = nqpqx2;
+			nqpqx2 = t;
+			t = nqpqz;
+			nqpqz = nqpqz2;
+			nqpqz2 = t;
+
+			byte <<= 1;
+		}
+	}
+
+	memcpy(resultx, nqx, sizeof(limb) * 5);
+	memcpy(resultz, nqz, sizeof(limb) * 5);
+}
+
+static void crecip(felem out, const felem z)
+{
+	felem a,t0,b,c;
+
+	/* 2 */ fsquare_times(a, z, 1); // a = 2
+	/* 8 */ fsquare_times(t0, a, 2);
+	/* 9 */ fmul(b, t0, z); // b = 9
+	/* 11 */ fmul(a, b, a); // a = 11
+	/* 22 */ fsquare_times(t0, a, 1);
+	/* 2^5 - 2^0 = 31 */ fmul(b, t0, b);
+	/* 2^10 - 2^5 */ fsquare_times(t0, b, 5);
+	/* 2^10 - 2^0 */ fmul(b, t0, b);
+	/* 2^20 - 2^10 */ fsquare_times(t0, b, 10);
+	/* 2^20 - 2^0 */ fmul(c, t0, b);
+	/* 2^40 - 2^20 */ fsquare_times(t0, c, 20);
+	/* 2^40 - 2^0 */ fmul(t0, t0, c);
+	/* 2^50 - 2^10 */ fsquare_times(t0, t0, 10);
+	/* 2^50 - 2^0 */ fmul(b, t0, b);
+	/* 2^100 - 2^50 */ fsquare_times(t0, b, 50);
+	/* 2^100 - 2^0 */ fmul(c, t0, b);
+	/* 2^200 - 2^100 */ fsquare_times(t0, c, 100);
+	/* 2^200 - 2^0 */ fmul(t0, t0, c);
+	/* 2^250 - 2^50 */ fsquare_times(t0, t0, 50);
+	/* 2^250 - 2^0 */ fmul(t0, t0, b);
+	/* 2^255 - 2^5 */ fsquare_times(t0, t0, 5);
+	/* 2^255 - 21 */ fmul(out, t0, a);
+}
+
+void curve25519(uint8_t mypublic[CURVE25519_POINT_SIZE], const uint8_t secret[CURVE25519_POINT_SIZE], const uint8_t basepoint[CURVE25519_POINT_SIZE])
+{
+	limb bp[5], x[5], z[5], zmone[5];
+	uint8_t e[32];
+
+	memcpy(e, secret, 32);
+	curve25519_normalize_secret(e);
+
+	fexpand(bp, basepoint);
+	cmult(x, z, e, bp);
+	crecip(zmone, z);
+	fmul(z, x, zmone);
+	fcontract(mypublic, z);
+}
+
+#else
+typedef int64_t limb;
+
+/* Field element representation:
+ *
+ * Field elements are written as an array of signed, 64-bit limbs, least
+ * significant first. The value of the field element is:
+ *   x[0] + 2^26x[1] + x^51x[2] + 2^102x[3] + ...
+ *
+ * i.e. the limbs are 26, 25, 26, 25, ... bits wide. */
+
+/* Sum two numbers: output += in */
+static void fsum(limb *output, const limb *in)
+{
+	unsigned i;
+	for (i = 0; i < 10; i += 2) {
+		output[0 + i] = output[0 + i] + in[0 + i];
+		output[1 + i] = output[1 + i] + in[1 + i];
+	}
+}
+
+/* Find the difference of two numbers: output = in - output
+ * (note the order of the arguments!). */
+static void fdifference(limb *output, const limb *in)
+{
+	unsigned i;
+	for (i = 0; i < 10; ++i) {
+		output[i] = in[i] - output[i];
+	}
+}
+
+/* Multiply a number by a scalar: output = in * scalar */
+static void fscalar_product(limb *output, const limb *in, const limb scalar)
+{
+	unsigned i;
+	for (i = 0; i < 10; ++i) {
+		output[i] = in[i] * scalar;
+	}
+}
+
+/* Multiply two numbers: output = in2 * in
+ *
+ * output must be distinct to both inputs. The inputs are reduced coefficient
+ * form, the output is not.
+ *
+ * output[x] <= 14 * the largest product of the input limbs. */
+static void fproduct(limb *output, const limb *in2, const limb *in)
+{
+	output[0] =       ((limb) ((int32_t) in2[0])) * ((int32_t) in[0]);
+	output[1] =       ((limb) ((int32_t) in2[0])) * ((int32_t) in[1]) +
+					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[0]);
+	output[2] =  2 *  ((limb) ((int32_t) in2[1])) * ((int32_t) in[1]) +
+					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[2]) +
+					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[0]);
+	output[3] =       ((limb) ((int32_t) in2[1])) * ((int32_t) in[2]) +
+					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[1]) +
+					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[0]);
+	output[4] =       ((limb) ((int32_t) in2[2])) * ((int32_t) in[2]) +
+				       2 * (((limb) ((int32_t) in2[1])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[1])) +
+					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[0]);
+	output[5] =       ((limb) ((int32_t) in2[2])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[2]) +
+					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[1]) +
+					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[0]);
+	output[6] =  2 * (((limb) ((int32_t) in2[3])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[1])) +
+					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[2]) +
+					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[0]);
+	output[7] =       ((limb) ((int32_t) in2[3])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[2]) +
+					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[1]) +
+					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[0]);
+	output[8] =       ((limb) ((int32_t) in2[4])) * ((int32_t) in[4]) +
+				       2 * (((limb) ((int32_t) in2[3])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[1])) +
+					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[2]) +
+					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[0]);
+	output[9] =       ((limb) ((int32_t) in2[4])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[2]) +
+					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[1]) +
+					    ((limb) ((int32_t) in2[0])) * ((int32_t) in[9]) +
+					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[0]);
+	output[10] = 2 * (((limb) ((int32_t) in2[5])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in2[1])) * ((int32_t) in[9]) +
+					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[1])) +
+					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[2]);
+	output[11] =      ((limb) ((int32_t) in2[5])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in2[2])) * ((int32_t) in[9]) +
+					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[2]);
+	output[12] =      ((limb) ((int32_t) in2[6])) * ((int32_t) in[6]) +
+				       2 * (((limb) ((int32_t) in2[5])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in2[3])) * ((int32_t) in[9]) +
+					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[3])) +
+					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[4]);
+	output[13] =      ((limb) ((int32_t) in2[6])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in2[7])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in2[4])) * ((int32_t) in[9]) +
+					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[4]);
+	output[14] = 2 * (((limb) ((int32_t) in2[7])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in2[5])) * ((int32_t) in[9]) +
+					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[5])) +
+					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[6]);
+	output[15] =      ((limb) ((int32_t) in2[7])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in2[8])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in2[6])) * ((int32_t) in[9]) +
+					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[6]);
+	output[16] =      ((limb) ((int32_t) in2[8])) * ((int32_t) in[8]) +
+				       2 * (((limb) ((int32_t) in2[7])) * ((int32_t) in[9]) +
+					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[7]));
+	output[17] =      ((limb) ((int32_t) in2[8])) * ((int32_t) in[9]) +
+					    ((limb) ((int32_t) in2[9])) * ((int32_t) in[8]);
+	output[18] = 2 *  ((limb) ((int32_t) in2[9])) * ((int32_t) in[9]);
+}
+
+/* Reduce a long form to a short form by taking the input mod 2^255 - 19.
+ *
+ * On entry: |output[i]| < 14*2^54
+ * On exit: |output[0..8]| < 280*2^54 */
+static void freduce_degree(limb *output)
+{
+	/* Each of these shifts and adds ends up multiplying the value by 19.
+	 *
+	 * For output[0..8], the absolute entry value is < 14*2^54 and we add, at
+	 * most, 19*14*2^54 thus, on exit, |output[0..8]| < 280*2^54. */
+	output[8] += output[18] << 4;
+	output[8] += output[18] << 1;
+	output[8] += output[18];
+	output[7] += output[17] << 4;
+	output[7] += output[17] << 1;
+	output[7] += output[17];
+	output[6] += output[16] << 4;
+	output[6] += output[16] << 1;
+	output[6] += output[16];
+	output[5] += output[15] << 4;
+	output[5] += output[15] << 1;
+	output[5] += output[15];
+	output[4] += output[14] << 4;
+	output[4] += output[14] << 1;
+	output[4] += output[14];
+	output[3] += output[13] << 4;
+	output[3] += output[13] << 1;
+	output[3] += output[13];
+	output[2] += output[12] << 4;
+	output[2] += output[12] << 1;
+	output[2] += output[12];
+	output[1] += output[11] << 4;
+	output[1] += output[11] << 1;
+	output[1] += output[11];
+	output[0] += output[10] << 4;
+	output[0] += output[10] << 1;
+	output[0] += output[10];
+}
+
+#if (-1 & 3) != 3
+#error "This code only works on a two's complement system"
+#endif
+
+/* return v / 2^26, using only shifts and adds.
+ *
+ * On entry: v can take any value. */
+static inline limb div_by_2_26(const limb v)
+{
+	/* High word of v; no shift needed. */
+	const uint32_t highword = (uint32_t) (((uint64_t) v) >> 32);
+	/* Set to all 1s if v was negative; else set to 0s. */
+	const int32_t sign = ((int32_t) highword) >> 31;
+	/* Set to 0x3ffffff if v was negative; else set to 0. */
+	const int32_t roundoff = ((uint32_t) sign) >> 6;
+	/* Should return v / (1<<26) */
+	return (v + roundoff) >> 26;
+}
+
+/* return v / (2^25), using only shifts and adds.
+ *
+ * On entry: v can take any value. */
+static inline limb div_by_2_25(const limb v)
+{
+	/* High word of v; no shift needed*/
+	const uint32_t highword = (uint32_t) (((uint64_t) v) >> 32);
+	/* Set to all 1s if v was negative; else set to 0s. */
+	const int32_t sign = ((int32_t) highword) >> 31;
+	/* Set to 0x1ffffff if v was negative; else set to 0. */
+	const int32_t roundoff = ((uint32_t) sign) >> 7;
+	/* Should return v / (1<<25) */
+	return (v + roundoff) >> 25;
+}
+
+/* Reduce all coefficients of the short form input so that |x| < 2^26.
+ *
+ * On entry: |output[i]| < 280*2^54 */
+static void freduce_coefficients(limb *output)
+{
+	unsigned i;
+
+	output[10] = 0;
+
+	for (i = 0; i < 10; i += 2) {
+		limb over = div_by_2_26(output[i]);
+		/* The entry condition (that |output[i]| < 280*2^54) means that over is, at
+		 * most, 280*2^28 in the first iteration of this loop. This is added to the
+		 * next limb and we can approximate the resulting bound of that limb by
+		 * 281*2^54. */
+		output[i] -= over << 26;
+		output[i+1] += over;
+
+		/* For the first iteration, |output[i+1]| < 281*2^54, thus |over| <
+		 * 281*2^29. When this is added to the next limb, the resulting bound can
+		 * be approximated as 281*2^54.
+		 *
+		 * For subsequent iterations of the loop, 281*2^54 remains a conservative
+		 * bound and no overflow occurs. */
+		over = div_by_2_25(output[i+1]);
+		output[i+1] -= over << 25;
+		output[i+2] += over;
+	}
+	/* Now |output[10]| < 281*2^29 and all other coefficients are reduced. */
+	output[0] += output[10] << 4;
+	output[0] += output[10] << 1;
+	output[0] += output[10];
+
+	output[10] = 0;
+
+	/* Now output[1..9] are reduced, and |output[0]| < 2^26 + 19*281*2^29
+	 * So |over| will be no more than 2^16. */
+	{
+		limb over = div_by_2_26(output[0]);
+		output[0] -= over << 26;
+		output[1] += over;
+	}
+
+	/* Now output[0,2..9] are reduced, and |output[1]| < 2^25 + 2^16 < 2^26. The
+	 * bound on |output[1]| is sufficient to meet our needs. */
+}
+
+/* A helpful wrapper around fproduct: output = in * in2.
+ *
+ * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27.
+ *
+ * output must be distinct to both inputs. The output is reduced degree
+ * (indeed, one need only provide storage for 10 limbs) and |output[i]| < 2^26. */
+static void fmul(limb *output, const limb *in, const limb *in2)
+{
+	limb t[19];
+	fproduct(t, in, in2);
+	/* |t[i]| < 14*2^54 */
+	freduce_degree(t);
+	freduce_coefficients(t);
+	/* |t[i]| < 2^26 */
+	memcpy(output, t, sizeof(limb) * 10);
+}
+
+/* Square a number: output = in**2
+ *
+ * output must be distinct from the input. The inputs are reduced coefficient
+ * form, the output is not.
+ *
+ * output[x] <= 14 * the largest product of the input limbs. */
+static void fsquare_inner(limb *output, const limb *in)
+{
+	output[0] =       ((limb) ((int32_t) in[0])) * ((int32_t) in[0]);
+	output[1] =  2 *  ((limb) ((int32_t) in[0])) * ((int32_t) in[1]);
+	output[2] =  2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[1]) +
+					    ((limb) ((int32_t) in[0])) * ((int32_t) in[2]));
+	output[3] =  2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[2]) +
+					    ((limb) ((int32_t) in[0])) * ((int32_t) in[3]));
+	output[4] =       ((limb) ((int32_t) in[2])) * ((int32_t) in[2]) +
+				       4 *  ((limb) ((int32_t) in[1])) * ((int32_t) in[3]) +
+				       2 *  ((limb) ((int32_t) in[0])) * ((int32_t) in[4]);
+	output[5] =  2 * (((limb) ((int32_t) in[2])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in[1])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in[0])) * ((int32_t) in[5]));
+	output[6] =  2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[3]) +
+					    ((limb) ((int32_t) in[2])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in[0])) * ((int32_t) in[6]) +
+				       2 *  ((limb) ((int32_t) in[1])) * ((int32_t) in[5]));
+	output[7] =  2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[4]) +
+					    ((limb) ((int32_t) in[2])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in[1])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in[0])) * ((int32_t) in[7]));
+	output[8] =       ((limb) ((int32_t) in[4])) * ((int32_t) in[4]) +
+				       2 * (((limb) ((int32_t) in[2])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in[0])) * ((int32_t) in[8]) +
+				       2 * (((limb) ((int32_t) in[1])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in[3])) * ((int32_t) in[5])));
+	output[9] =  2 * (((limb) ((int32_t) in[4])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in[3])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in[2])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in[1])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in[0])) * ((int32_t) in[9]));
+	output[10] = 2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[5]) +
+					    ((limb) ((int32_t) in[4])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in[2])) * ((int32_t) in[8]) +
+				       2 * (((limb) ((int32_t) in[3])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in[1])) * ((int32_t) in[9])));
+	output[11] = 2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[6]) +
+					    ((limb) ((int32_t) in[4])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in[3])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in[2])) * ((int32_t) in[9]));
+	output[12] =      ((limb) ((int32_t) in[6])) * ((int32_t) in[6]) +
+				       2 * (((limb) ((int32_t) in[4])) * ((int32_t) in[8]) +
+				       2 * (((limb) ((int32_t) in[5])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in[3])) * ((int32_t) in[9])));
+	output[13] = 2 * (((limb) ((int32_t) in[6])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in[5])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in[4])) * ((int32_t) in[9]));
+	output[14] = 2 * (((limb) ((int32_t) in[7])) * ((int32_t) in[7]) +
+					    ((limb) ((int32_t) in[6])) * ((int32_t) in[8]) +
+				       2 *  ((limb) ((int32_t) in[5])) * ((int32_t) in[9]));
+	output[15] = 2 * (((limb) ((int32_t) in[7])) * ((int32_t) in[8]) +
+					    ((limb) ((int32_t) in[6])) * ((int32_t) in[9]));
+	output[16] =      ((limb) ((int32_t) in[8])) * ((int32_t) in[8]) +
+				       4 *  ((limb) ((int32_t) in[7])) * ((int32_t) in[9]);
+	output[17] = 2 *  ((limb) ((int32_t) in[8])) * ((int32_t) in[9]);
+	output[18] = 2 *  ((limb) ((int32_t) in[9])) * ((int32_t) in[9]);
+}
+
+/* fsquare sets output = in^2.
+ *
+ * On entry: The |in| argument is in reduced coefficients form and |in[i]| <
+ * 2^27.
+ *
+ * On exit: The |output| argument is in reduced coefficients form (indeed, one
+ * need only provide storage for 10 limbs) and |out[i]| < 2^26. */
+static void fsquare(limb *output, const limb *in)
+{
+	limb t[19];
+	fsquare_inner(t, in);
+	/* |t[i]| < 14*2^54 because the largest product of two limbs will be <
+	 * 2^(27+27) and fsquare_inner adds together, at most, 14 of those
+	 * products. */
+	freduce_degree(t);
+	freduce_coefficients(t);
+	/* |t[i]| < 2^26 */
+	memcpy(output, t, sizeof(limb) * 10);
+}
+
+/* Take a little-endian, 32-byte number and expand it into polynomial form */
+static void fexpand(limb *output, const uint8_t *input)
+{
+#define F(n,start,shift,mask) \
+	output[n] = ((((limb) input[start + 0]) | \
+		      ((limb) input[start + 1]) << 8 | \
+		      ((limb) input[start + 2]) << 16 | \
+		      ((limb) input[start + 3]) << 24) >> shift) & mask;
+	F(0, 0, 0, 0x3ffffff);
+	F(1, 3, 2, 0x1ffffff);
+	F(2, 6, 3, 0x3ffffff);
+	F(3, 9, 5, 0x1ffffff);
+	F(4, 12, 6, 0x3ffffff);
+	F(5, 16, 0, 0x1ffffff);
+	F(6, 19, 1, 0x3ffffff);
+	F(7, 22, 3, 0x1ffffff);
+	F(8, 25, 4, 0x3ffffff);
+	F(9, 28, 6, 0x1ffffff);
+#undef F
+}
+
+#if (-32 >> 1) != -16
+#error "This code only works when >> does sign-extension on negative numbers"
+#endif
+
+/* int32_t_eq returns 0xffffffff iff a == b and zero otherwise. */
+static int32_t int32_t_eq(int32_t a, int32_t b)
+{
+	a = ~(a ^ b);
+	a &= a << 16;
+	a &= a << 8;
+	a &= a << 4;
+	a &= a << 2;
+	a &= a << 1;
+	return a >> 31;
+}
+
+/* int32_t_gte returns 0xffffffff if a >= b and zero otherwise, where a and b are
+ * both non-negative. */
+static int32_t int32_t_gte(int32_t a, int32_t b)
+{
+	a -= b;
+	/* a >= 0 iff a >= b. */
+	return ~(a >> 31);
+}
+
+/* Take a fully reduced polynomial form number and contract it into a
+ * little-endian, 32-byte array.
+ *
+ * On entry: |input_limbs[i]| < 2^26 */
+static void fcontract(uint8_t *output, limb *input_limbs)
+{
+	int i;
+	int j;
+	int32_t input[10];
+	int32_t mask;
+
+	/* |input_limbs[i]| < 2^26, so it's valid to convert to an int32_t. */
+	for (i = 0; i < 10; i++) {
+		input[i] = input_limbs[i];
+	}
+
+	for (j = 0; j < 2; ++j) {
+		for (i = 0; i < 9; ++i) {
+			if ((i & 1) == 1) {
+				/* This calculation is a time-invariant way to make input[i]
+				 * non-negative by borrowing from the next-larger limb. */
+				const int32_t mask = input[i] >> 31;
+				const int32_t carry = -((input[i] & mask) >> 25);
+				input[i] = input[i] + (carry << 25);
+				input[i+1] = input[i+1] - carry;
+			} else {
+				const int32_t mask = input[i] >> 31;
+				const int32_t carry = -((input[i] & mask) >> 26);
+				input[i] = input[i] + (carry << 26);
+				input[i+1] = input[i+1] - carry;
+			}
+		}
+
+		/* There's no greater limb for input[9] to borrow from, but we can multiply
+		 * by 19 and borrow from input[0], which is valid mod 2^255-19. */
+		{
+			const int32_t mask = input[9] >> 31;
+			const int32_t carry = -((input[9] & mask) >> 25);
+			input[9] = input[9] + (carry << 25);
+			input[0] = input[0] - (carry * 19);
+		}
+
+		/* After the first iteration, input[1..9] are non-negative and fit within
+		 * 25 or 26 bits, depending on position. However, input[0] may be
+		 * negative. */
+	}
+
+	/* The first borrow-propagation pass above ended with every limb
+		 except (possibly) input[0] non-negative.
+		 If input[0] was negative after the first pass, then it was because of a
+		 carry from input[9]. On entry, input[9] < 2^26 so the carry was, at most,
+		 one, since (2**26-1) >> 25 = 1. Thus input[0] >= -19.
+		 In the second pass, each limb is decreased by at most one. Thus the second
+		 borrow-propagation pass could only have wrapped around to decrease
+		 input[0] again if the first pass left input[0] negative *and* input[1]
+		 through input[9] were all zero.  In that case, input[1] is now 2^25 - 1,
+		 and this last borrow-propagation step will leave input[1] non-negative. */
+	{
+		const int32_t mask = input[0] >> 31;
+		const int32_t carry = -((input[0] & mask) >> 26);
+		input[0] = input[0] + (carry << 26);
+		input[1] = input[1] - carry;
+	}
+
+	/* All input[i] are now non-negative. However, there might be values between
+	 * 2^25 and 2^26 in a limb which is, nominally, 25 bits wide. */
+	for (j = 0; j < 2; j++) {
+		for (i = 0; i < 9; i++) {
+			if ((i & 1) == 1) {
+				const int32_t carry = input[i] >> 25;
+				input[i] &= 0x1ffffff;
+				input[i+1] += carry;
+			} else {
+				const int32_t carry = input[i] >> 26;
+				input[i] &= 0x3ffffff;
+				input[i+1] += carry;
+			}
+		}
+
+		{
+			const int32_t carry = input[9] >> 25;
+			input[9] &= 0x1ffffff;
+			input[0] += 19*carry;
+		}
+	}
+
+	/* If the first carry-chain pass, just above, ended up with a carry from
+	 * input[9], and that caused input[0] to be out-of-bounds, then input[0] was
+	 * < 2^26 + 2*19, because the carry was, at most, two.
+	 *
+	 * If the second pass carried from input[9] again then input[0] is < 2*19 and
+	 * the input[9] -> input[0] carry didn't push input[0] out of bounds. */
+
+	/* It still remains the case that input might be between 2^255-19 and 2^255.
+	 * In this case, input[1..9] must take their maximum value and input[0] must
+	 * be >= (2^255-19) & 0x3ffffff, which is 0x3ffffed. */
+	mask = int32_t_gte(input[0], 0x3ffffed);
+	for (i = 1; i < 10; i++) {
+		if ((i & 1) == 1) {
+			mask &= int32_t_eq(input[i], 0x1ffffff);
+		} else {
+			mask &= int32_t_eq(input[i], 0x3ffffff);
+		}
+	}
+
+	/* mask is either 0xffffffff (if input >= 2^255-19) and zero otherwise. Thus
+	 * this conditionally subtracts 2^255-19. */
+	input[0] -= mask & 0x3ffffed;
+
+	for (i = 1; i < 10; i++) {
+		if ((i & 1) == 1) {
+			input[i] -= mask & 0x1ffffff;
+		} else {
+			input[i] -= mask & 0x3ffffff;
+		}
+	}
+
+	input[1] <<= 2;
+	input[2] <<= 3;
+	input[3] <<= 5;
+	input[4] <<= 6;
+	input[6] <<= 1;
+	input[7] <<= 3;
+	input[8] <<= 4;
+	input[9] <<= 6;
+#define F(i, s) \
+	output[s+0] |=  input[i] & 0xff; \
+	output[s+1]  = (input[i] >> 8) & 0xff; \
+	output[s+2]  = (input[i] >> 16) & 0xff; \
+	output[s+3]  = (input[i] >> 24) & 0xff;
+	output[0] = 0;
+	output[16] = 0;
+	F(0,0);
+	F(1,3);
+	F(2,6);
+	F(3,9);
+	F(4,12);
+	F(5,16);
+	F(6,19);
+	F(7,22);
+	F(8,25);
+	F(9,28);
+#undef F
+}
+
+/* Input: Q, Q', Q-Q'
+ * Output: 2Q, Q+Q'
+ *
+ *   x2 z3: long form
+ *   x3 z3: long form
+ *   x z: short form, destroyed
+ *   xprime zprime: short form, destroyed
+ *   qmqp: short form, preserved
+ *
+ * On entry and exit, the absolute value of the limbs of all inputs and outputs
+ * are < 2^26. */
+static void fmonty(limb *x2, limb *z2,  /* output 2Q */
+		   limb *x3, limb *z3,  /* output Q + Q' */
+		   limb *x, limb *z,    /* input Q */
+		   limb *xprime, limb *zprime,  /* input Q' */
+		   const limb *qmqp /* input Q - Q' */)
+{
+	limb origx[10], origxprime[10], zzz[19], xx[19], zz[19], xxprime[19],
+				zzprime[19], zzzprime[19], xxxprime[19];
+
+	memcpy(origx, x, 10 * sizeof(limb));
+	fsum(x, z);
+	/* |x[i]| < 2^27 */
+	fdifference(z, origx);  /* does x - z */
+	/* |z[i]| < 2^27 */
+
+	memcpy(origxprime, xprime, sizeof(limb) * 10);
+	fsum(xprime, zprime);
+	/* |xprime[i]| < 2^27 */
+	fdifference(zprime, origxprime);
+	/* |zprime[i]| < 2^27 */
+	fproduct(xxprime, xprime, z);
+	/* |xxprime[i]| < 14*2^54: the largest product of two limbs will be <
+	 * 2^(27+27) and fproduct adds together, at most, 14 of those products.
+	 * (Approximating that to 2^58 doesn't work out.) */
+	fproduct(zzprime, x, zprime);
+	/* |zzprime[i]| < 14*2^54 */
+	freduce_degree(xxprime);
+	freduce_coefficients(xxprime);
+	/* |xxprime[i]| < 2^26 */
+	freduce_degree(zzprime);
+	freduce_coefficients(zzprime);
+	/* |zzprime[i]| < 2^26 */
+	memcpy(origxprime, xxprime, sizeof(limb) * 10);
+	fsum(xxprime, zzprime);
+	/* |xxprime[i]| < 2^27 */
+	fdifference(zzprime, origxprime);
+	/* |zzprime[i]| < 2^27 */
+	fsquare(xxxprime, xxprime);
+	/* |xxxprime[i]| < 2^26 */
+	fsquare(zzzprime, zzprime);
+	/* |zzzprime[i]| < 2^26 */
+	fproduct(zzprime, zzzprime, qmqp);
+	/* |zzprime[i]| < 14*2^52 */
+	freduce_degree(zzprime);
+	freduce_coefficients(zzprime);
+	/* |zzprime[i]| < 2^26 */
+	memcpy(x3, xxxprime, sizeof(limb) * 10);
+	memcpy(z3, zzprime, sizeof(limb) * 10);
+
+	fsquare(xx, x);
+	/* |xx[i]| < 2^26 */
+	fsquare(zz, z);
+	/* |zz[i]| < 2^26 */
+	fproduct(x2, xx, zz);
+	/* |x2[i]| < 14*2^52 */
+	freduce_degree(x2);
+	freduce_coefficients(x2);
+	/* |x2[i]| < 2^26 */
+	fdifference(zz, xx);  // does zz = xx - zz
+	/* |zz[i]| < 2^27 */
+	memset(zzz + 10, 0, sizeof(limb) * 9);
+	fscalar_product(zzz, zz, 121665);
+	/* |zzz[i]| < 2^(27+17) */
+	/* No need to call freduce_degree here:
+		 fscalar_product doesn't increase the degree of its input. */
+	freduce_coefficients(zzz);
+	/* |zzz[i]| < 2^26 */
+	fsum(zzz, xx);
+	/* |zzz[i]| < 2^27 */
+	fproduct(z2, zz, zzz);
+	/* |z2[i]| < 14*2^(26+27) */
+	freduce_degree(z2);
+	freduce_coefficients(z2);
+	/* |z2|i| < 2^26 */
+}
+
+/* Conditionally swap two reduced-form limb arrays if 'iswap' is 1, but leave
+ * them unchanged if 'iswap' is 0.  Runs in data-invariant time to avoid
+ * side-channel attacks.
+ *
+ * NOTE that this function requires that 'iswap' be 1 or 0; other values give
+ * wrong results.  Also, the two limb arrays must be in reduced-coefficient,
+ * reduced-degree form: the values in a[10..19] or b[10..19] aren't swapped,
+ * and all all values in a[0..9],b[0..9] must have magnitude less than
+ * INT32_MAX. */
+static void swap_conditional(limb a[19], limb b[19], limb iswap)
+{
+	unsigned i;
+	const int32_t swap = (int32_t) -iswap;
+
+	for (i = 0; i < 10; ++i) {
+		const int32_t x = swap & ( ((int32_t)a[i]) ^ ((int32_t)b[i]) );
+		a[i] = ((int32_t)a[i]) ^ x;
+		b[i] = ((int32_t)b[i]) ^ x;
+	}
+}
+
+/* Calculates nQ where Q is the x-coordinate of a point on the curve
+ *
+ *   resultx/resultz: the x coordinate of the resulting curve point (short form)
+ *   n: a little endian, 32-byte number
+ *   q: a point of the curve (short form) */
+static void cmult(limb *resultx, limb *resultz, const uint8_t *n, const limb *q)
+{
+	limb a[19] = {0}, b[19] = {1}, c[19] = {1}, d[19] = {0};
+	limb *nqpqx = a, *nqpqz = b, *nqx = c, *nqz = d, *t;
+	limb e[19] = {0}, f[19] = {1}, g[19] = {0}, h[19] = {1};
+	limb *nqpqx2 = e, *nqpqz2 = f, *nqx2 = g, *nqz2 = h;
+
+	unsigned i, j;
+
+	memcpy(nqpqx, q, sizeof(limb) * 10);
+
+	for (i = 0; i < 32; ++i) {
+		uint8_t byte = n[31 - i];
+		for (j = 0; j < 8; ++j) {
+			const limb bit = byte >> 7;
+
+			swap_conditional(nqx, nqpqx, bit);
+			swap_conditional(nqz, nqpqz, bit);
+			fmonty(nqx2, nqz2,
+			       nqpqx2, nqpqz2,
+			       nqx, nqz,
+			       nqpqx, nqpqz,
+			       q);
+			swap_conditional(nqx2, nqpqx2, bit);
+			swap_conditional(nqz2, nqpqz2, bit);
+
+			t = nqx;
+			nqx = nqx2;
+			nqx2 = t;
+			t = nqz;
+			nqz = nqz2;
+			nqz2 = t;
+			t = nqpqx;
+			nqpqx = nqpqx2;
+			nqpqx2 = t;
+			t = nqpqz;
+			nqpqz = nqpqz2;
+			nqpqz2 = t;
+
+			byte <<= 1;
+		}
+	}
+
+	memcpy(resultx, nqx, sizeof(limb) * 10);
+	memcpy(resultz, nqz, sizeof(limb) * 10);
+}
+
+static void crecip(limb *out, const limb *z)
+{
+	limb z2[10];
+	limb z9[10];
+	limb z11[10];
+	limb z2_5_0[10];
+	limb z2_10_0[10];
+	limb z2_20_0[10];
+	limb z2_50_0[10];
+	limb z2_100_0[10];
+	limb t0[10];
+	limb t1[10];
+	int i;
+
+	/* 2 */ fsquare(z2,z);
+	/* 4 */ fsquare(t1,z2);
+	/* 8 */ fsquare(t0,t1);
+	/* 9 */ fmul(z9,t0,z);
+	/* 11 */ fmul(z11,z9,z2);
+	/* 22 */ fsquare(t0,z11);
+	/* 2^5 - 2^0 = 31 */ fmul(z2_5_0,t0,z9);
+
+	/* 2^6 - 2^1 */ fsquare(t0,z2_5_0);
+	/* 2^7 - 2^2 */ fsquare(t1,t0);
+	/* 2^8 - 2^3 */ fsquare(t0,t1);
+	/* 2^9 - 2^4 */ fsquare(t1,t0);
+	/* 2^10 - 2^5 */ fsquare(t0,t1);
+	/* 2^10 - 2^0 */ fmul(z2_10_0,t0,z2_5_0);
+
+	/* 2^11 - 2^1 */ fsquare(t0,z2_10_0);
+	/* 2^12 - 2^2 */ fsquare(t1,t0);
+	/* 2^20 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t0,t1); fsquare(t1,t0); }
+	/* 2^20 - 2^0 */ fmul(z2_20_0,t1,z2_10_0);
+
+	/* 2^21 - 2^1 */ fsquare(t0,z2_20_0);
+	/* 2^22 - 2^2 */ fsquare(t1,t0);
+	/* 2^40 - 2^20 */ for (i = 2; i < 20; i += 2) { fsquare(t0,t1); fsquare(t1,t0); }
+	/* 2^40 - 2^0 */ fmul(t0,t1,z2_20_0);
+
+	/* 2^41 - 2^1 */ fsquare(t1,t0);
+	/* 2^42 - 2^2 */ fsquare(t0,t1);
+	/* 2^50 - 2^10 */ for (i = 2; i < 10; i += 2) { fsquare(t1,t0); fsquare(t0,t1); }
+	/* 2^50 - 2^0 */ fmul(z2_50_0,t0,z2_10_0);
+
+	/* 2^51 - 2^1 */ fsquare(t0,z2_50_0);
+	/* 2^52 - 2^2 */ fsquare(t1,t0);
+	/* 2^100 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0,t1); fsquare(t1,t0); }
+	/* 2^100 - 2^0 */ fmul(z2_100_0,t1,z2_50_0);
+
+	/* 2^101 - 2^1 */ fsquare(t1,z2_100_0);
+	/* 2^102 - 2^2 */ fsquare(t0,t1);
+	/* 2^200 - 2^100 */ for (i = 2; i < 100; i += 2) { fsquare(t1,t0); fsquare(t0,t1); }
+	/* 2^200 - 2^0 */ fmul(t1,t0,z2_100_0);
+
+	/* 2^201 - 2^1 */ fsquare(t0,t1);
+	/* 2^202 - 2^2 */ fsquare(t1,t0);
+	/* 2^250 - 2^50 */ for (i = 2; i < 50; i += 2) { fsquare(t0,t1); fsquare(t1,t0); }
+	/* 2^250 - 2^0 */ fmul(t0,t1,z2_50_0);
+
+	/* 2^251 - 2^1 */ fsquare(t1,t0);
+	/* 2^252 - 2^2 */ fsquare(t0,t1);
+	/* 2^253 - 2^3 */ fsquare(t1,t0);
+	/* 2^254 - 2^4 */ fsquare(t0,t1);
+	/* 2^255 - 2^5 */ fsquare(t1,t0);
+	/* 2^255 - 21 */ fmul(out,t1,z11);
+}
+
+void curve25519(uint8_t mypublic[CURVE25519_POINT_SIZE], const uint8_t secret[CURVE25519_POINT_SIZE], const uint8_t basepoint[CURVE25519_POINT_SIZE])
+{
+	limb bp[10], x[10], z[11], zmone[10];
+	uint8_t e[32];
+
+	memcpy(e, secret, 32);
+	curve25519_normalize_secret(e);
+
+	fexpand(bp, basepoint);
+	cmult(x, z, e, bp);
+	crecip(zmone, z);
+	fmul(z, x, zmone);
+	fcontract(mypublic, z);
+}
+#endif
+
+void curve25519_generate_public(uint8_t *pub, const uint8_t *secret)
+{
+	static const uint8_t basepoint[CURVE25519_POINT_SIZE] = { 9 };
+	curve25519(pub, secret, basepoint);
+}
diff --git a/src/curve25519.h b/src/curve25519.h
new file mode 100644
index 0000000..3c1404a
--- /dev/null
+++ b/src/curve25519.h
@@ -0,0 +1,22 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#ifndef CURVE25519_H
+#define CURVE25519_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+enum curve25519_lengths {
+	CURVE25519_POINT_SIZE = 32,
+};
+
+void curve25519(uint8_t *mypublic, const uint8_t *secret, const uint8_t *basepoint);
+void curve25519_generate_public(uint8_t *pub, const uint8_t *secret);
+static inline void curve25519_normalize_secret(uint8_t secret[CURVE25519_POINT_SIZE])
+{
+	secret[0] &= 248;
+	secret[31] &= 127;
+	secret[31] |= 64;
+}
+
+#endif
diff --git a/src/genkey.c b/src/genkey.c
new file mode 100644
index 0000000..1602ae1
--- /dev/null
+++ b/src/genkey.c
@@ -0,0 +1,59 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "curve25519.h"
+#include "base64.h"
+
+#ifdef __NR_getrandom
+static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
+{
+	return syscall(__NR_getrandom, out, len, 0);
+}
+#else
+#include <fcntl.h>
+static inline ssize_t get_random_bytes(uint8_t *out, size_t len)
+{
+	ssize_t ret;
+	int fd = open("/dev/urandom", O_RDONLY);
+	if (fd < 0)
+		return fd;
+	ret = read(fd, out, len);
+	close(fd);
+	return ret;
+}
+#endif
+
+int genkey_main(int argc, char *argv[])
+{
+	unsigned char private_key[CURVE25519_POINT_SIZE];
+	char private_key_base64[b64_len(CURVE25519_POINT_SIZE)];
+	struct stat stat;
+
+	if (!fstat(STDOUT_FILENO, &stat) && S_ISREG(stat.st_mode) && stat.st_mode & S_IRWXO)
+		fputs("Warning: writing to world accessible file.\nConsider setting the umask to 077 and trying again.\n", stderr);
+
+	if (get_random_bytes(private_key, CURVE25519_POINT_SIZE) != CURVE25519_POINT_SIZE) {
+		perror("getrandom");
+		return 1;
+	}
+	if (argc && !strcmp(argv[0], "genkey"))
+		curve25519_normalize_secret(private_key);
+
+	if (b64_ntop(private_key, sizeof(private_key), private_key_base64, sizeof(private_key_base64)) < 0) {
+		errno = EINVAL;
+		perror("b64");
+		return 1;
+	}
+
+	puts(private_key_base64);
+	return 0;
+
+}
diff --git a/src/kernel.c b/src/kernel.c
new file mode 100644
index 0000000..0448308
--- /dev/null
+++ b/src/kernel.c
@@ -0,0 +1,242 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#include <errno.h>
+#include <libmnl/libmnl.h>
+#include <linux/if_link.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <time.h>
+
+#include "kernel.h"
+#include "../uapi.h"
+
+struct inflatable_buffer {
+	char *buffer;
+	char *next;
+	bool good;
+	size_t len;
+	size_t pos;
+};
+
+#define max(a, b) (a > b ? a : b)
+
+static int add_next_to_inflatable_buffer(struct inflatable_buffer *buffer)
+{
+	size_t len, expand_to;
+	char *new_buffer;
+
+	if (!buffer->good || !buffer->next) {
+		free(buffer->next);
+		return 0;
+	}
+
+	len = strlen(buffer->next) + 1;
+
+	if (len == 1)
+		return 0;
+
+	if (buffer->len - buffer->pos <= len) {
+		expand_to = max(buffer->len * 2, buffer->len + len + 1);
+		new_buffer = realloc(buffer->buffer, expand_to);
+		if (!new_buffer) {
+			free(buffer->next);
+			return -errno;
+		}
+		memset(&new_buffer[buffer->len], 0, expand_to - buffer->len);
+		buffer->buffer = new_buffer;
+		buffer->len = expand_to;
+	}
+	memcpy(&buffer->buffer[buffer->pos], buffer->next, len);
+	free(buffer->next);
+	buffer->pos += len;
+	return 0;
+}
+
+static int parse_linkinfo(const struct nlattr *attr, void *data)
+{
+	struct inflatable_buffer *buffer = data;
+	if (mnl_attr_get_type(attr) == IFLA_INFO_KIND && !strcmp("wireguard", mnl_attr_get_str(attr)))
+		buffer->good = true;
+	return MNL_CB_OK;
+}
+
+static int parse_infomsg(const struct nlattr *attr, void *data)
+{
+	struct inflatable_buffer *buffer = data;
+	if (mnl_attr_get_type(attr) == IFLA_LINKINFO)
+		return mnl_attr_parse_nested(attr, parse_linkinfo, data);
+	else if (mnl_attr_get_type(attr) == IFLA_IFNAME)
+		buffer->next = strdup(mnl_attr_get_str(attr));
+	return MNL_CB_OK;
+}
+
+static int read_devices_cb(const struct nlmsghdr *nlh, void *data)
+{
+	struct inflatable_buffer *buffer = data;
+	buffer->good = false;
+	buffer->next = NULL;
+	int ret = mnl_attr_parse(nlh, sizeof(struct ifinfomsg), parse_infomsg, data);
+	if (ret != MNL_CB_OK)
+		return ret;
+	ret = add_next_to_inflatable_buffer(buffer);
+	if (ret < 0)
+		return ret;
+	if (nlh->nlmsg_type != NLMSG_DONE)
+		return MNL_CB_OK + 1;
+	return MNL_CB_OK;
+}
+
+/* first\0second\0third\0forth\0last\0\0 */
+char *kernel_get_wireguard_interfaces(void)
+{
+	struct mnl_socket *nl = NULL;
+	char *rtnl_buffer = NULL;
+	size_t message_len;
+	unsigned int portid, seq;
+	ssize_t len;
+	int ret = 0;
+	struct inflatable_buffer buffer = { 0 };
+	struct nlmsghdr *nlh;
+	struct ifinfomsg *ifm;
+
+	buffer.len = 4096;
+	buffer.buffer = calloc(buffer.len, 1);
+	if (!buffer.buffer) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	rtnl_buffer = calloc(4096, 1);
+	if (!rtnl_buffer) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	nl = mnl_socket_open(NETLINK_ROUTE);
+	if (!nl) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+	seq = time(NULL);
+	portid = mnl_socket_get_portid(nl);
+	nlh = mnl_nlmsg_put_header(rtnl_buffer);
+	nlh->nlmsg_type = RTM_GETLINK;
+	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP;
+	nlh->nlmsg_seq = seq;
+	ifm = mnl_nlmsg_put_extra_header(nlh, sizeof(*ifm));
+	ifm->ifi_family = AF_UNSPEC;
+	message_len = nlh->nlmsg_len;
+
+	if (mnl_socket_sendto(nl, rtnl_buffer, message_len) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+
+another:
+	if ((len = mnl_socket_recvfrom(nl, rtnl_buffer, 4096)) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+	if ((len = mnl_cb_run(rtnl_buffer, len, seq, portid, read_devices_cb, &buffer)) < 0) {
+		ret = -errno;
+		goto cleanup;
+	}
+	if (len == MNL_CB_OK + 1)
+		goto another;
+
+cleanup:
+	free(rtnl_buffer);
+	if (nl)
+		mnl_socket_close(nl);
+	errno = -ret;
+	if (errno) {
+		perror("Error when trying to get a list of Wireguard interfaces");
+		free(buffer.buffer);
+		return NULL;
+	}
+	return buffer.buffer;
+}
+
+bool kernel_has_wireguard_interface(const char *interface)
+{
+	char *interfaces, *this_interface;
+	this_interface = interfaces = kernel_get_wireguard_interfaces();
+	if (!interfaces)
+		return false;
+	for (size_t len = 0; (len = strlen(this_interface)); this_interface += len + 1) {
+		if (!strcmp(interface, this_interface)) {
+			free(interfaces);
+			return true;
+		}
+	}
+	free(interfaces);
+	return false;
+}
+
+static int do_ioctl(int req, struct ifreq *ifreq)
+{
+	static int fd = -1;
+	if (fd < 0) {
+		fd = socket(AF_INET, SOCK_DGRAM, 0);
+		if (fd < 0)
+			return fd;
+	}
+	return ioctl(fd, req, ifreq);
+}
+
+int kernel_set_device(struct wgdevice *dev)
+{
+	struct ifreq ifreq = { .ifr_data = (char *)dev };
+	memcpy(&ifreq.ifr_name, dev->interface, IFNAMSIZ);
+	ifreq.ifr_name[IFNAMSIZ - 1] = 0;
+	return do_ioctl(WG_SET_DEVICE, &ifreq);
+}
+
+int kernel_get_device(struct wgdevice **dev, const char *interface)
+{
+	int ret;
+	struct ifreq ifreq = { 0 };
+	memcpy(&ifreq.ifr_name, interface, IFNAMSIZ);
+	ifreq.ifr_name[IFNAMSIZ - 1] = 0;
+	*dev = NULL;
+	do {
+		free(*dev);
+		ret = do_ioctl(WG_GET_DEVICE, &ifreq);
+		if (ret < 0)
+			goto out;
+		*dev = calloc(ret + sizeof(struct wgdevice), 1);
+		if (!*dev) {
+			perror("calloc");
+			ret = -ENOMEM;
+			goto out;
+		}
+		(*dev)->peers_size = ret;
+		ifreq.ifr_data = (char *)*dev;
+		memcpy(&ifreq.ifr_name, interface, IFNAMSIZ);
+		ifreq.ifr_name[IFNAMSIZ - 1] = 0;
+		ret = do_ioctl(WG_GET_DEVICE, &ifreq);
+	} while (ret == -EMSGSIZE);
+	if (ret < 0) {
+		free(*dev);
+		*dev = NULL;
+	}
+out:
+	errno = -ret;
+	return ret;
+}
diff --git a/src/kernel.h b/src/kernel.h
new file mode 100644
index 0000000..0525ce1
--- /dev/null
+++ b/src/kernel.h
@@ -0,0 +1,24 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#ifndef KERNEL_H
+#define KERNEL_H
+
+#include <stdbool.h>
+
+struct wgdevice;
+
+int kernel_set_device(struct wgdevice *dev);
+int kernel_get_device(struct wgdevice **dev, const char *interface);
+char *kernel_get_wireguard_interfaces(void);
+bool kernel_has_wireguard_interface(const char *interface);
+
+
+#define for_each_wgpeer(__dev, __peer, __i) for ((__i) = 0, (__peer) = (typeof(__peer))((uint8_t *)(__dev) + sizeof(struct wgdevice)); \
+						 (__i) < (__dev)->num_peers; \
+						 ++(__i), (__peer) = (typeof(__peer))((uint8_t *)(__peer) + sizeof(struct wgpeer) + (sizeof(struct wgipmask) * (__peer)->num_ipmasks)))
+
+#define for_each_wgipmask(__peer, __ipmask, __i) for ((__i) = 0, (__ipmask) = (typeof(__ipmask))((uint8_t *)(__peer) + sizeof(struct wgpeer)); \
+						 (__i) < (__peer)->num_ipmasks; \
+						 ++(__i), (__ipmask) = (typeof(__ipmask))((uint8_t *)(__ipmask) + sizeof(struct wgipmask)))
+
+#endif
diff --git a/src/pubkey.c b/src/pubkey.c
new file mode 100644
index 0000000..d9a97d9
--- /dev/null
+++ b/src/pubkey.c
@@ -0,0 +1,33 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#include <errno.h>
+#include <resolv.h>
+#include <stdio.h>
+
+#include "curve25519.h"
+#include "base64.h"
+
+int pubkey_main(__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
+{
+	unsigned char private_key[CURVE25519_POINT_SIZE + 1] = { 0 }, public_key[CURVE25519_POINT_SIZE] = { 0 };
+	char private_key_base64[b64_len(CURVE25519_POINT_SIZE)] = { 0 }, public_key_base64[b64_len(CURVE25519_POINT_SIZE)] = { 0 };
+
+	if (fread(private_key_base64, 1, sizeof(private_key_base64) - 1, stdin) != sizeof(private_key_base64) - 1) {
+		errno = EINVAL;
+		perror("fread(private key)");
+		return 1;
+	}
+	if (b64_pton(private_key_base64, private_key, sizeof(private_key)) < 0) {
+		errno = EINVAL;
+		perror("b64");
+		return 1;
+	}
+	curve25519_generate_public(public_key, private_key);
+	if (b64_ntop(public_key, sizeof(public_key), public_key_base64, sizeof(public_key_base64)) < 0) {
+		errno = EINVAL;
+		perror("b64");
+		return 1;
+	}
+	puts(public_key_base64);
+	return 0;
+}
diff --git a/src/set.c b/src/set.c
new file mode 100644
index 0000000..f85162d
--- /dev/null
+++ b/src/set.c
@@ -0,0 +1,35 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "subcommands.h"
+#include "config.h"
+#include "kernel.h"
+
+int set_main(int argc, char *argv[])
+{
+	struct wgdevice *device = NULL;
+	int ret = 1;
+
+	if (argc < 3) {
+		fprintf(stderr, "Usage: %s %s <interface> [listen-port <port>] [private-key <file path>] [peer <base64 public key> [remove] [endpoint <ip>:<port>] [allowed-ips <ip1>/<cidr1>[,<ip2>/<cidr2>]...] ]...\n", PROG_NAME, argv[0]);
+		return 1;
+	}
+
+	if (!config_read_cmd(&device, argv + 2, argc - 2))
+		goto cleanup;
+	strncpy(device->interface, argv[1], IFNAMSIZ -  1);
+	device->interface[IFNAMSIZ - 1] = 0;
+
+	if (kernel_set_device(device) != 0) {
+		perror("Unable to set device");
+		goto cleanup;
+	}
+
+	ret = 0;
+
+cleanup:
+	free(device);
+	return ret;
+}
diff --git a/src/setconf.c b/src/setconf.c
new file mode 100644
index 0000000..81faa64
--- /dev/null
+++ b/src/setconf.c
@@ -0,0 +1,61 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "config.h"
+#include "kernel.h"
+#include "subcommands.h"
+
+int setconf_main(int argc, char *argv[])
+{
+	struct wgdevice *device = NULL;
+	struct config_ctx ctx;
+	FILE *config_input = NULL;
+	char *config_buffer = NULL;
+	size_t config_buffer_len = 0;
+	int ret = 1;
+
+	if (argc != 3) {
+		fprintf(stderr, "Usage: %s %s <interface> <configuration filename>\n", PROG_NAME, argv[0]);
+		return 1;
+	}
+
+	config_input = fopen(argv[2], "r");
+	if (!config_input) {
+		perror("fopen");
+		return 1;
+	}
+	if (!config_read_init(&ctx, &device, !strcmp(argv[0], "addconf"))) {
+		fclose(config_input);
+		return 1;
+	}
+	while (getline(&config_buffer, &config_buffer_len, config_input) >= 0) {
+		if (!config_read_line(&ctx, config_buffer)) {
+			fprintf(stderr, "Configuration parsing error\n");
+			goto cleanup;
+		}
+	}
+	if (!config_read_finish(&ctx) || !device) {
+		fprintf(stderr, "Invalid configuration\n");
+		goto cleanup;
+	}
+	strncpy(device->interface, argv[1], IFNAMSIZ - 1);
+	device->interface[IFNAMSIZ - 1] = 0;
+
+	if (kernel_set_device(device) != 0) {
+		perror("Unable to set device");
+		goto cleanup;
+	}
+
+	ret = 0;
+
+cleanup:
+	if (config_input)
+		fclose(config_input);
+	free(config_buffer);
+	free(device);
+	return ret;
+}
diff --git a/src/show.c b/src/show.c
new file mode 100644
index 0000000..1662751
--- /dev/null
+++ b/src/show.c
@@ -0,0 +1,366 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#include <arpa/inet.h>
+#include <inttypes.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <resolv.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <netdb.h>
+
+#include "kernel.h"
+#include "subcommands.h"
+#include "terminal.h"
+#include "base64.h"
+#include "../uapi.h"
+
+static int peer_cmp(const void *first, const void *second)
+{
+	time_t diff;
+	const struct wgpeer *a = *(const void **)first, *b = *(const void **)second;
+	if (!a->last_handshake_time.tv_sec && !a->last_handshake_time.tv_usec && (b->last_handshake_time.tv_sec || b->last_handshake_time.tv_usec))
+		return 1;
+	if (!b->last_handshake_time.tv_sec && !b->last_handshake_time.tv_usec && (a->last_handshake_time.tv_sec || a->last_handshake_time.tv_usec))
+		return -1;
+	diff = a->last_handshake_time.tv_sec - b->last_handshake_time.tv_sec;
+	if (!diff)
+		diff = a->last_handshake_time.tv_usec - b->last_handshake_time.tv_usec;
+	if (diff < 0)
+		return 1;
+	if (diff > 0)
+		return -1;
+	return 0;
+}
+
+static void sort_peers(struct wgdevice *device)
+{
+	uint8_t *new_device, *pos;
+	struct wgpeer **peers;
+	struct wgpeer *peer;
+	size_t i, len;
+
+	peers = calloc(device->num_peers, sizeof(struct wgpeer *));
+	if (!peers)
+		return;
+
+	len = sizeof(struct wgdevice);
+	for_each_wgpeer(device, peer, i)
+		len += sizeof(struct wgpeer) + (peer->num_ipmasks * sizeof(struct wgipmask));
+	pos = new_device = malloc(len);
+	if (!new_device) {
+		free(peers);
+		return;
+	}
+
+	memcpy(pos, device, sizeof(struct wgdevice));
+	pos += sizeof(struct wgdevice);
+
+	for_each_wgpeer(device, peer, i)
+		peers[i] = peer;
+
+	qsort(peers, device->num_peers, sizeof(struct wgpeer *), peer_cmp);
+	for (i = 0; i < device->num_peers; ++i) {
+		len = sizeof(struct wgpeer) + (peers[i]->num_ipmasks * sizeof(struct wgipmask));
+		memcpy(pos, peers[i], len);
+		pos += len;
+	}
+	free(peers);
+
+	memcpy(device, new_device, pos - new_device);
+	free(new_device);
+}
+
+static const uint8_t zero[WG_KEY_LEN] = { 0 };
+
+static char *key(const unsigned char key[WG_KEY_LEN])
+{
+	static char b64[b64_len(WG_KEY_LEN)];
+	if (!memcmp(key, zero, WG_KEY_LEN))
+		return "(none)";
+	memset(b64, 0, b64_len(WG_KEY_LEN));
+	b64_ntop(key, WG_KEY_LEN, b64, b64_len(WG_KEY_LEN));
+	return b64;
+}
+
+static char *ip(const struct wgipmask *ip)
+{
+	static char buf[INET6_ADDRSTRLEN + 1];
+	memset(buf, 0, INET6_ADDRSTRLEN + 1);
+	if (ip->family == AF_INET)
+		inet_ntop(AF_INET, &ip->ip4, buf, INET6_ADDRSTRLEN);
+	else if (ip->family == AF_INET6)
+		inet_ntop(AF_INET6, &ip->ip6, buf, INET6_ADDRSTRLEN);
+	return buf;
+}
+
+static char *endpoint(const struct sockaddr_storage *addr)
+{
+	char host[4096 + 1];
+	char service[512 + 1];
+	static char buf[sizeof(host) + sizeof(service) + 4];
+	int ret;
+	socklen_t addr_len = 0;
+
+	memset(buf, 0, sizeof(buf));
+	if (addr->ss_family == AF_INET)
+		addr_len = sizeof(struct sockaddr_in);
+	else if (addr->ss_family == AF_INET6)
+		addr_len = sizeof(struct sockaddr_in6);
+
+	ret = getnameinfo((struct sockaddr *)addr, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST);
+	if (ret)
+		strncpy(buf, gai_strerror(ret), sizeof(buf) - 1);
+	else
+		snprintf(buf, sizeof(buf) - 1, (addr->ss_family == AF_INET6 && strchr(host, ':')) ? "[%s]:%s" : "%s:%s", host, service);
+	return buf;
+}
+
+static char *ago(const struct timeval *t)
+{
+	static char buf[1024];
+	unsigned long long left, years, days, hours, minutes, seconds;
+	size_t offset = 0;
+
+	left = time(NULL) - t->tv_sec;
+	years = left / (365 * 24 * 60 * 60);
+	left = left % (365 * 24 * 60 * 60);
+	days = left / (24 * 60 * 60);
+	left = left % (24 * 60 * 60);
+	hours = left / (60 * 60);
+	left = left % (60 * 60);
+	minutes = left / 60;
+	seconds = left % 60;
+
+	if (years)
+		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN "year%s" TERMINAL_RESET, offset ? ", " : "", years, years == 1 ? "" : "s");
+	if (days)
+		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN  "day%s" TERMINAL_RESET, offset ? ", " : "", days, days == 1 ? "" : "s");
+	if (hours)
+		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN  "hour%s" TERMINAL_RESET, offset ? ", " : "", hours, hours == 1 ? "" : "s");
+	if (minutes)
+		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN "minute%s" TERMINAL_RESET, offset ? ", " : "", minutes, minutes == 1 ? "" : "s");
+	if (seconds)
+		offset += snprintf(buf + offset, sizeof(buf) - offset, "%s%llu " TERMINAL_FG_CYAN  "second%s" TERMINAL_RESET, offset ? ", " : "", seconds, seconds == 1 ? "" : "s");
+	if (offset)
+		snprintf(buf + offset, sizeof(buf) - offset, " ago");
+	else
+		snprintf(buf, sizeof(buf), "Now");
+
+	return buf;
+}
+
+static char *bytes(uint64_t b)
+{
+	static char buf[1024];
+
+	if (b < 1024ULL)
+		snprintf(buf, sizeof(buf), "%u " TERMINAL_FG_CYAN "B" TERMINAL_RESET, (unsigned)b);
+	else if (b < 1024ULL * 1024ULL)
+		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "KiB" TERMINAL_RESET, (double)b / 1024);
+	else if (b < 1024ULL * 1024ULL * 1024ULL)
+		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "MiB" TERMINAL_RESET, (double)b / (1024 * 1024));
+	else if (b < 1024ULL * 1024ULL * 1024ULL * 1024ULL)
+		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "GiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024));
+	else
+		snprintf(buf, sizeof(buf), "%.2f " TERMINAL_FG_CYAN "TiB" TERMINAL_RESET, (double)b / (1024 * 1024 * 1024) / 1024);
+
+	return buf;
+}
+
+static const char *COMMAND_NAME = NULL;
+static void show_usage(void)
+{
+	fprintf(stderr, "Usage: %s %s { <interface> | all | interfaces } [public-key | private-key | preshared-key | listen-port | peers | endpoints | allowed-ips | latest-handshake | bandwidth]\n", PROG_NAME, COMMAND_NAME);
+}
+
+static void pretty_print(struct wgdevice *device)
+{
+	size_t i, j;
+	struct wgpeer *peer;
+	struct wgipmask *ipmask;
+
+	terminal_printf(TERMINAL_RESET);
+	terminal_printf(TERMINAL_FG_GREEN TERMINAL_BOLD "interface" TERMINAL_RESET ": " TERMINAL_FG_GREEN "%s" TERMINAL_RESET "\n", device->interface);
+	if (memcmp(device->public_key, zero, WG_KEY_LEN))
+		terminal_printf("  " TERMINAL_BOLD "public key" TERMINAL_RESET ": %s\n", key(device->public_key));
+	if (memcmp(device->private_key, zero, WG_KEY_LEN))
+		terminal_printf("  " TERMINAL_BOLD "private key" TERMINAL_RESET ": %s\n", key(device->private_key));
+	if (memcmp(device->preshared_key, zero, WG_KEY_LEN))
+		terminal_printf("  " TERMINAL_BOLD "pre-shared key" TERMINAL_RESET ": %s\n", key(device->preshared_key));
+	if (device->port)
+		terminal_printf("  " TERMINAL_BOLD "listening port" TERMINAL_RESET ": %u\n", device->port);
+	if (device->num_peers) {
+		sort_peers(device);
+		terminal_printf("\n");
+	}
+	for_each_wgpeer(device, peer, i) {
+		terminal_printf(TERMINAL_FG_YELLOW TERMINAL_BOLD "peer" TERMINAL_RESET ": " TERMINAL_FG_YELLOW "%s" TERMINAL_RESET "\n", key(peer->public_key));
+		if (peer->endpoint.ss_family == AF_INET || peer->endpoint.ss_family == AF_INET6)
+			terminal_printf("  " TERMINAL_BOLD "endpoint" TERMINAL_RESET ": %s\n", endpoint(&peer->endpoint));
+		terminal_printf("  " TERMINAL_BOLD "allowed ips" TERMINAL_RESET ": ");
+		if (peer->num_ipmasks) {
+			for_each_wgipmask(peer, ipmask, j)
+				terminal_printf("%s" TERMINAL_FG_CYAN "/" TERMINAL_RESET "%u%s", ip(ipmask), ipmask->cidr, j == (size_t)peer->num_ipmasks - 1 ? "\n" : ", ");
+		} else
+			terminal_printf("(none)\n");
+		if (peer->last_handshake_time.tv_sec)
+			terminal_printf("  " TERMINAL_BOLD "latest handshake" TERMINAL_RESET ": %s\n", ago(&peer->last_handshake_time));
+		if (peer->rx_bytes || peer->tx_bytes) {
+			terminal_printf("  " TERMINAL_BOLD "bandwidth" TERMINAL_RESET ": ");
+			terminal_printf("%s received, ", bytes(peer->rx_bytes));
+			terminal_printf("%s sent\n", bytes(peer->tx_bytes));
+		}
+		if (i + 1 < device->num_peers)
+			terminal_printf("\n");
+	}
+}
+
+static bool ugly_print(struct wgdevice *device, const char *param, bool with_interface)
+{
+	size_t i, j;
+	struct wgpeer *peer;
+	struct wgipmask *ipmask;
+	if (!strcmp(param, "public-key")) {
+		if (with_interface)
+			printf("%s\t", device->interface);
+		printf("%s\n", key(device->public_key));
+	} else if (!strcmp(param, "private-key")) {
+		if (with_interface)
+			printf("%s\t", device->interface);
+		printf("%s\n", key(device->private_key));
+	} else if (!strcmp(param, "preshared-key")) {
+		if (with_interface)
+			printf("%s\t", device->interface);
+		printf("%s\n", key(device->preshared_key));
+	} else if (!strcmp(param, "listen-port")) {
+		if (with_interface)
+			printf("%s\t", device->interface);
+		printf("%u\n", device->port);
+	} else if (!strcmp(param, "endpoints")) {
+		if (with_interface)
+			printf("%s\t", device->interface);
+		for_each_wgpeer(device, peer, i) {
+			printf("%s\t", key(peer->public_key));
+			if (peer->endpoint.ss_family == AF_INET || peer->endpoint.ss_family == AF_INET6)
+				printf("%s\n", endpoint(&peer->endpoint));
+			else
+				printf("(none)\n");
+		}
+	} else if (!strcmp(param, "allowed-ips")) {
+		for_each_wgpeer(device, peer, i) {
+			if (with_interface)
+				printf("%s\t", device->interface);
+			printf("%s\t", key(peer->public_key));
+			if (peer->num_ipmasks) {
+				for_each_wgipmask(peer, ipmask, j)
+					printf("%s/%u%s", ip(ipmask), ipmask->cidr, j == (size_t)peer->num_ipmasks - 1 ? "\n" : ", ");
+			} else
+				printf("(none)\n");
+		}
+	} else if (!strcmp(param, "latest-handshakes")) {
+		for_each_wgpeer(device, peer, i) {
+			if (with_interface)
+				printf("%s\t", device->interface);
+			printf("%s\t%llu\n", key(peer->public_key), (unsigned long long)peer->last_handshake_time.tv_sec);
+		}
+	} else if (!strcmp(param, "bandwidth")) {
+		for_each_wgpeer(device, peer, i) {
+			if (with_interface)
+				printf("%s\t", device->interface);
+			printf("%s\t%" PRIu64 "\t%" PRIu64 "\n", key(peer->public_key), (uint64_t)peer->rx_bytes, (uint64_t)peer->tx_bytes);
+		}
+	} else if (!strcmp(param, "peers")) {
+		for_each_wgpeer(device, peer, i) {
+			if (with_interface)
+				printf("%s\t", device->interface);
+			printf("%s\n", key(peer->public_key));
+		}
+	} else {
+		fprintf(stderr, "Invalid parameter: `%s`\n", param);
+		show_usage();
+		return false;
+	}
+	return true;
+}
+
+int show_main(int argc, char *argv[])
+{
+	int ret = 0;
+	COMMAND_NAME = argv[0];
+
+	if (argc > 3) {
+		show_usage();
+		return 1;
+	}
+
+	if (argc == 1 || !strcmp(argv[1], "all")) {
+		char *interfaces = kernel_get_wireguard_interfaces(), *interface;
+		if (!interfaces) {
+			perror("Unable to get devices");
+			return 1;
+		}
+		interface = interfaces;
+		for (size_t len = 0; (len = strlen(interface)); interface += len + 1) {
+			struct wgdevice *device = NULL;
+			if (kernel_get_device(&device, interface) < 0) {
+				perror("Unable to get device");
+				continue;
+			}
+			if (argc == 3) {
+				if (!ugly_print(device, argv[2], true)) {
+					ret = 1;
+					free(device);
+					break;
+				}
+			} else {
+				pretty_print(device);
+				if (strlen(interface + len + 1))
+					printf("\n");
+			}
+			free(device);
+		}
+		free(interfaces);
+	} else if (!strcmp(argv[1], "interfaces")) {
+		char *interfaces, *interface;
+		if (argc > 2) {
+			show_usage();
+			return 1;
+		}
+		interfaces = kernel_get_wireguard_interfaces();
+		if (!interfaces) {
+			perror("Unable to get devices");
+			return 1;
+		}
+		interface = interfaces;
+		for (size_t len = 0; (len = strlen(interface)); interface += len + 1)
+			printf("%s%c", interface, strlen(interface + len + 1) ? ' ' : '\n');
+		free(interfaces);
+	} else if (argc == 2 && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "help")))
+		show_usage();
+	else {
+		struct wgdevice *device = NULL;
+		if (!kernel_has_wireguard_interface(argv[1])) {
+			fprintf(stderr, "`%s` is not a valid WireGuard interface\n", argv[1]);
+			show_usage();
+			return 1;
+		}
+		if (kernel_get_device(&device, argv[1]) < 0) {
+			perror("Unable to get device");
+			show_usage();
+			return 1;
+		}
+		if (argc == 3) {
+			if (!ugly_print(device, argv[2], false))
+				ret = 1;
+		} else
+			pretty_print(device);
+		free(device);
+	}
+	return ret;
+}
diff --git a/src/showconf.c b/src/showconf.c
new file mode 100644
index 0000000..faf2482
--- /dev/null
+++ b/src/showconf.c
@@ -0,0 +1,102 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <resolv.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <netdb.h>
+
+#include "subcommands.h"
+#include "base64.h"
+#include "kernel.h"
+#include "../uapi.h"
+
+int showconf_main(int argc, char *argv[])
+{
+	static const uint8_t zero[WG_KEY_LEN] = { 0 };
+	char b64[b64_len(WG_KEY_LEN)] = { 0 };
+	char ip[INET6_ADDRSTRLEN];
+	struct wgdevice *device = NULL;
+	struct wgpeer *peer;
+	struct wgipmask *ipmask;
+	size_t i, j;
+	int ret = 1;
+
+	if (argc != 2) {
+		fprintf(stderr, "Usage: %s %s <interface>\n", PROG_NAME, argv[0]);
+		return 1;
+	}
+
+	if (!kernel_has_wireguard_interface(argv[1])) {
+		fprintf(stderr, "`%s` is not a valid WireGuard interface\n", argv[1]);
+		fprintf(stderr, "Usage: %s %s <interface>\n", PROG_NAME, argv[0]);
+		return 1;
+	}
+
+	if (kernel_get_device(&device, argv[1])) {
+		perror("Unable to get device");
+		goto cleanup;
+	}
+
+	printf("[Interface]\n");
+	if (device->port)
+		printf("ListenPort = %d\n", device->port);
+	if (memcmp(device->private_key, zero, WG_KEY_LEN)) {
+		b64_ntop(device->private_key, WG_KEY_LEN, b64, b64_len(WG_KEY_LEN));
+		printf("PrivateKey = %s\n", b64);
+	}
+	if (memcmp(device->preshared_key, zero, WG_KEY_LEN)) {
+		b64_ntop(device->preshared_key, WG_KEY_LEN, b64, b64_len(WG_KEY_LEN));
+		printf("PresharedKey = %s\n", b64);
+	}
+	printf("\n");
+	for_each_wgpeer(device, peer, i) {
+		b64_ntop(peer->public_key, WG_KEY_LEN, b64, b64_len(WG_KEY_LEN));
+		printf("[Peer]\nPublicKey = %s\n", b64);
+		if (peer->num_ipmasks)
+			printf("AllowedIPs = ");
+		for_each_wgipmask(peer, ipmask, j) {
+			if (ipmask->family == AF_INET) {
+				if (!inet_ntop(AF_INET, &ipmask->ip4, ip, INET6_ADDRSTRLEN))
+					continue;
+			} else if (ipmask->family == AF_INET6) {
+				if (!inet_ntop(AF_INET6, &ipmask->ip6, ip, INET6_ADDRSTRLEN))
+					continue;
+			} else
+				continue;
+			printf("%s/%d", ip, ipmask->cidr);
+			if (j + 1 < (size_t)peer->num_ipmasks)
+				printf(", ");
+		}
+		if (peer->num_ipmasks)
+			printf("\n");
+
+		if (peer->endpoint.ss_family == AF_INET || peer->endpoint.ss_family == AF_INET6) {
+			char host[4096 + 1];
+			char service[512 + 1];
+			static char buf[sizeof(host) + sizeof(service) + 4];
+			socklen_t addr_len = 0;
+			memset(buf, 0, sizeof(buf));
+			if (peer->endpoint.ss_family == AF_INET)
+				addr_len = sizeof(struct sockaddr_in);
+			else if (peer->endpoint.ss_family == AF_INET6)
+				addr_len = sizeof(struct sockaddr_in6);
+			if (!getnameinfo((struct sockaddr *)&peer->endpoint, addr_len, host, sizeof(host), service, sizeof(service), NI_DGRAM | NI_NUMERICSERV | NI_NUMERICHOST)) {
+				snprintf(buf, sizeof(buf) - 1, (peer->endpoint.ss_family == AF_INET6 && strchr(host, ':')) ? "[%s]:%s" : "%s:%s", host, service);
+				printf("Endpoint = %s\n", buf);
+			}
+		}
+
+		if (i + 1 < device->num_peers)
+			printf("\n");
+	}
+	ret = 0;
+
+cleanup:
+	free(device);
+	return ret;
+}
diff --git a/src/subcommands.h b/src/subcommands.h
new file mode 100644
index 0000000..8351f8f
--- /dev/null
+++ b/src/subcommands.h
@@ -0,0 +1,14 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#ifndef SUBCOMMANDS_H
+#define SUBCOMMANDS_H
+
+extern const char *PROG_NAME;
+int show_main(int argc, char *argv[]);
+int showconf_main(int argc, char *argv[]);
+int set_main(int argc, char *argv[]);
+int setconf_main(int argc, char *argv[]);
+int genkey_main(int argc, char *argv[]);
+int pubkey_main(int argc, char *argv[]);
+
+#endif
diff --git a/src/terminal.c b/src/terminal.c
new file mode 100644
index 0000000..74d04c2
--- /dev/null
+++ b/src/terminal.c
@@ -0,0 +1,79 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#define _GNU_SOURCE
+#include <ctype.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <unistd.h>
+
+static bool color_mode(FILE *file)
+{
+	static int mode = -1;
+	char *var;
+	if (mode != -1)
+		return mode;
+	var = getenv("WG_COLOR_MODE");
+	if (var && !strcmp(var, "always"))
+		mode = true;
+	else if (var && !strcmp(var, "never"))
+		mode = false;
+	else
+		return isatty(fileno(file));
+	return mode;
+}
+
+static void filter_ansi(FILE *file, const char *fmt, va_list args)
+{
+	char *str = NULL;
+	size_t len, i, j;
+
+	if (color_mode(file)) {
+		vfprintf(file, fmt, args);
+		return;
+	}
+
+	len = vasprintf(&str, fmt, args);
+
+	if (len >= 2) {
+		for (i = 0; i < len - 2; ++i) {
+			if (str[i] == '\x1b' && str[i + 1] == '[') {
+				str[i] = str[i + 1] = '\0';
+				for (j = i + 2; j < len; ++j) {
+					if (isalpha(str[j]))
+						break;
+					str[j] = '\0';
+				}
+				str[j] = '\0';
+			}
+		}
+	}
+	for (i = 0; i < len; i = j) {
+		fputs(&str[i], file);
+		for (j = i + strlen(&str[i]); j < len; ++j) {
+			if (str[j] != '\0')
+				break;
+		}
+	}
+
+	free(str);
+}
+
+void terminal_printf(const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	filter_ansi(stdout, fmt, args);
+	va_end(args);
+}
+
+void terminal_fprintf(FILE *file, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	filter_ansi(file, fmt, args);
+	va_end(args);
+}
diff --git a/src/terminal.h b/src/terminal.h
new file mode 100644
index 0000000..825c057
--- /dev/null
+++ b/src/terminal.h
@@ -0,0 +1,49 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#ifndef TERMINAL_H
+#define TERMINAL_H
+
+#define TERMINAL_FG_BLACK	"\x1b[30m"
+#define TERMINAL_FG_RED		"\x1b[31m"
+#define TERMINAL_FG_GREEN	"\x1b[32m"
+#define TERMINAL_FG_YELLOW	"\x1b[33m"
+#define TERMINAL_FG_BLUE	"\x1b[34m"
+#define TERMINAL_FG_MAGENTA	"\x1b[35m"
+#define TERMINAL_FG_CYAN	"\x1b[36m"
+#define TERMINAL_FG_WHITE	"\x1b[37m"
+#define TERMINAL_FG_DEFAULT	"\x1b[39m"
+
+#define TERMINAL_BG_BLACK	"\x1b[40m"
+#define TERMINAL_BG_RED		"\x1b[41m"
+#define TERMINAL_BG_GREEN	"\x1b[42m"
+#define TERMINAL_BG_YELLOW	"\x1b[43m"
+#define TERMINAL_BG_BLUE	"\x1b[44m"
+#define TERMINAL_BG_MAGENTA	"\x1b[45m"
+#define TERMINAL_BG_CYAN	"\x1b[46m"
+#define TERMINAL_BG_WHITE	"\x1b[47m"
+#define TERMINAL_BG_DEFAULT	"\x1b[49m"
+
+#define TERMINAL_BOLD		"\x1b[1m"
+#define TERMINAL_NO_BOLD	"\x1b[22m"
+#define TERMINAL_UNDERLINE	"\x1b[4m"
+#define TERMINAL_NO_UNDERLINE	"\x1b[24m"
+
+#define TERMINAL_RESET		"\x1b[0m"
+
+#define TERMINAL_SAVE_CURSOR	"\x1b[s"
+#define TERMINAL_RESTORE_CURSOR	"\x1b[u"
+#define TERMINAL_UP_CURSOR(l)	"\x1b[" #l "A"
+#define TERMINAL_DOWN_CURSOR(l)	"\x1b[" #l "B"
+#define TERMINAL_RIGHT_CURSOR(c) "\x1b[" #c "C"
+#define TERMINAL_LEFT_CURSOR(c)	"\x1b[" #c "D"
+#define TERMINAL_CLEAR_DOWN	"\x1b[0J"
+#define TERMINAL_CLEAR_UP	"\x1b[1J"
+#define TERMINAL_CLEAR_RIGHT	"\x1b[0K"
+#define TERMINAL_CLEAR_LEFT	"\x1b[1K"
+#define TERMINAL_CLEAR_LINE	"\x1b[2K"
+#define TERMINAL_CLEAR_ALL	"\x1b[2J"
+
+void terminal_printf(const char *fmt, ...) __attribute__((format(printf, 1, 2)));
+void terminal_fprintf(FILE *file, const char *fmt, ...) __attribute__((format(printf, 2, 3)));
+
+#endif
diff --git a/src/wg.8 b/src/wg.8
new file mode 100644
index 0000000..4ee5027
--- /dev/null
+++ b/src/wg.8
@@ -0,0 +1,194 @@
+.TH WG 8 "2015 August 13" ZX2C4 "WireGuard"
+
+.SH NAME
+wg - set and retrieve configuration of WireGuard interfaces
+
+.SH SYNOPSIS
+.B wg
+[ 
+.I COMMAND
+] [ 
+.I OPTIONS
+]... [ 
+.I ARGS
+]...
+
+.SH DESCRIPTION
+
+.B wg 
+is the configuration utility for getting and setting the configuration of
+WireGuard tunnel interfaces. The interfaces themselves can be added and removed
+using
+.BR ip-link (8)
+and their IP addresses and routing tables can be set using
+.BR ip-address (8)
+and
+.BR ip-route (8).
+The
+.B wg
+utility provides a series of sub-commands for changing WireGuard-specific
+aspects of WireGuard interfaces.
+
+If no COMMAND is specified, COMMAND defaults to
+.BR show .
+Sub-commands that take an INTERFACE must be passed a WireGuard interface.
+
+.SH COMMANDS
+
+.TP
+\fBshow\fP { \fI<interface>\fP | \fIall\fP | \fIinterfaces\fP } [\fIpublic-key\fP | \fIprivate-key\fP | \fIpreshared-key\fP | \fIlisten-port\fP | \fIpeers\fP | \fIendpoints\fP | \fIallowed-ips\fP | \fIlatest-handshake\fP | \fIbandwidth\fP]
+Shows current WireGuard configuration of specified \fI<interface>\fP.
+If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
+If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,
+one per line, and quit. If no options are given after the interface
+specification, then prints a list of all attributes in a visually pleasing way
+meant for the terminal. Otherwise, prints specified information grouped by
+newlines and tabs, meant to be used in scripts.
+.TP
+\fBshowconf\fP \fI<interface>\fP
+Shows the current configuration of \fI<interface>\fP in the format described
+by \fICONFIGURATION FILE FORMAT\fP below.
+.TP
+\fBset\fP \fI<interface>\fP [\fIlisten-port\fP \fI<port>\fP] [\fIprivate-key\fP \fI<file-path>\fP] [\fIpreshared-key\fP \fI<file-path>\fP] [\fIpeer\fP \fI<base64-public-key>\fP [\fIremove\fP] [\fIendpoint\fP \fI<ip>:<port>\fP] [\fIallowed-ips\fP \fI<ip1>/<cidr1>\fP[,\fI<ip2>/<cidr2>\fP]...] ]...
+Sets configuration values for the specified \fI<interface>\fP. Multiple
+\fIpeer\fPs may be specified, and if the \fIremove\fP argument is given
+for a peer, that peer is removed, not configured. If \fIlisten-port\fP
+is not specified, the port will be automatically generated when the
+interface comes up. Both \fIprivate-key\fP and \fIpreshared-key\fP must
+be a files, for security reasons, but if you're using
+.BR bash (1),
+you may safely pass in a string by specifying as \fIprivate-key\fP or
+\fIpreshared-key\fP the expression: <(echo PRIVATEKEYSTRING). If
+\fI/dev/null\fP is specified as the filename for either \fIprivate-key\fP or
+\fIpreshared-key\fP, the key is removed from the device. The use of
+\fIpreshared-key\fP is optional, and may be omitted; it adds an additional
+layer of symmetric-key cryptography to be mixed into the already existing
+public-key cryptography, for post-quantum resistance. If \fIallowed-ips\fP
+is specified, but the value is the empty string, all allowed ips are removed
+from the peer.
+.TP
+\fBsetconf\fP \fI<interface>\fP \fI<configuration-filename>\fP
+Sets the current configuration of \fI<interface>\fP to the contents of
+\fI<configuration-filename>\fP, which must be in the format described
+by \fICONFIGURATION FILE FORMAT\fP below.
+.TP
+\fBaddconf\fP \fI<interface>\fP \fI<configuration-filename>\fP
+Appends the contents of \fI<configuration-filename>\fP, which must
+be in the format described by \fICONFIGURATION FILE FORMAT\fP below,
+to the current configuration of \fI<interface>\fP.
+.TP
+\fBgenkey\fP
+Generates a random \fIprivate\fP key in base64 and prints it to
+standard output.
+.TP
+\fBgenpsk\fP
+Generates a random \fIpreshared\fP key in base64 and prints it to
+standard output.
+.TP
+\fBpubkey\fP
+Calculates a \fIpublic\fP key and prints it in base64 to standard
+output from a corresponding \fIprivate\fP key (generated with
+\fIgenkey\fP) given in base64 on standard input.
+
+A private key and a corresponding public key may be generated at once by calling:
+.br
+    $ umask 077
+.br
+    $ wg genkey | tee private.key | wg pubkey > public.key
+.TP
+\fBhelp\fP
+Show usage message.
+
+.SH CONFIGURATION FILE FORMAT
+The configuration file format is based on \fIINI\fP. There are two top level sections
+-- \fIInterface\fP and \fIPeer\fP. Multiple \fIPeer\fP sections may be specified, but
+only one \fIInterface\fP section may be specified.
+
+.P
+The \fIInterface\fP section contains two fields:
+.IP \(bu
+PrivateKey \(em a base64 private key generated by \fIwg genkey\fP. Required.
+.IP \(bu
+PresharedKey \(em a base64 preshared key generated by \fIwg genpsk\fP. Optional,
+and may be omitted. This option adds an additional layer of symmetric-key
+cryptography to be mixed into the already existing public-key cryptography,
+for post-quantum resistance.
+.IP \(bu
+ListenPort \(em a 16-bit port for listening. Optional; if not specified,
+automatically generated based on interface name.
+.P
+The \fIPeer\fP sections contain three fields each:
+.IP \(bu
+PublicKey \(em a base64 public key calculated by \fIwg pubkey\fP from a
+private key, and usually transmitted out of band to the author of the
+configuration file. Required.
+.IP \(bu
+AllowedIPs \(em a comma-separated list of IP (v4 or v6) addresses with
+CIDR masks. The catch-all \fI0.0.0.0/0\fP may be specified for matching
+all IPv4 addresses, and \fI::/0\fP may be specified for matching all
+IPv6 addresses. Required.
+.IP \(bu
+Endpoint \(em an endpoint IP or hostname, followed by a comma, and then a
+port number. Optional.
+
+.SH CONFIGURATION FILE FORMAT EXAMPLE
+This example may be used as a model for writing configuration files.
+Note that not all keys are required.
+
+    [Interface]
+.br
+    PrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=
+.br
+    ListenPort = 41414
+.br
+    
+.br
+    [Peer]
+.br
+    PublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=
+.br
+    Endpoint = 192.95.5.67:1234
+.br
+    AllowedIPs = 10.192.122.3/32, 10.192.124.1/24
+.br
+    
+.br
+    [Peer]
+.br
+    PublicKey = TrMvSoP4jYQlY6RIzBgbssQqY3vxI2Pi+y71lOWWXX0=
+.br
+    Endpoint = [2607:5300:60:6b0::c05f:543]:2468
+.br
+    AllowedIPs = 10.192.122.4/32, 192.168.0.0/16
+.br
+    
+.br
+    [Peer]
+.br
+    PublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA=
+.br
+    Endpoint = test.wireguard.io:18981
+.br
+    AllowedIPs = 10.10.10.230/32
+
+.SH ENVIRONMENT VARIABLES
+.TP
+.I WG_COLOR_MODE
+If set to \fIalways\fP, always print ANSI colorized output. If set to \fInever\fP, never print ANSI colorized output. If set to \fIauto\fP, something invalid, or unset, then print ANSI colorized output only when writing to a TTY.
+
+.SH SEE ALSO
+.BR ip (8),
+.BR ip-link (8),
+.BR ip-address (8),
+.BR ip-route (8).
+
+.SH AUTHOR
+.B wg
+was written by
+.MT Jason@zx2c4.com
+Jason A. Donenfeld
+.ME .
+For updates and more information, a project page is available on the
+.UR http://\:www.wireguard.io/
+World Wide Web
+.UE .
diff --git a/src/wg.c b/src/wg.c
new file mode 100644
index 0000000..d4d2965
--- /dev/null
+++ b/src/wg.c
@@ -0,0 +1,66 @@
+/* Copyright 2015-2016 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved. */
+
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "subcommands.h"
+
+const char *PROG_NAME;
+
+static const struct {
+	const char *subcommand;
+	int (*function)(int, char**);
+	const char *description;
+} subcommands[] = {
+	{ "show", show_main, "Shows the current configuration and device information" },
+	{ "showconf", showconf_main, "Shows the current configuration of a given WireGuard interface, for use with `setconf`" },
+	{ "set", set_main, "Change the current configuration, add peers, remove peers, or change peers" },
+	{ "setconf", setconf_main, "Applies a configuration file to a WireGuard interface" },
+	{ "addconf", setconf_main, "Appends a configuration file to a WireGuard interface" },
+	{ "genkey", genkey_main, "Generates a new private key and writes it to stdout" },
+	{ "genpsk", genkey_main, "Generates a new pre-shared key and writes it to stdout" },
+	{ "pubkey", pubkey_main, "Reads a private key from stdin and writes a public key to stdout" }
+};
+
+static void show_usage(void)
+{
+	fprintf(stderr, "Usage: %s <cmd> [<args>]\n\n", PROG_NAME);
+	fprintf(stderr, "Available subcommands:\n");
+	for (size_t i = 0; i < sizeof(subcommands) / sizeof(subcommands[0]); ++i)
+		fprintf(stderr, "  %s: %s\n", subcommands[i].subcommand, subcommands[i].description);
+}
+
+int main(int argc, char *argv[])
+{
+	char *tmp = NULL;
+	PROG_NAME = argv[0];
+
+	if (argc == 2 && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "help"))) {
+		show_usage();
+		return 1;
+	}
+
+	if (argc == 1) {
+		char *new_argv[] = { "show", NULL };
+		return show_main(1, new_argv);
+	}
+
+findsubcommand:
+	for (size_t i = 0; i < sizeof(subcommands) / sizeof(subcommands[0]); ++i) {
+		if (!strcmp(argv[1], subcommands[i].subcommand))
+			return subcommands[i].function(argc - 1, argv + 1);
+	}
+
+	/* Crude way of supporting "wg wg0 show..." */
+	if (!tmp && argc >= 3) {
+		tmp = argv[1];
+		argv[1] = argv[2];
+		argv[2] = tmp;
+		goto findsubcommand;
+	}
+
+	fprintf(stderr, "Invalid subcommand: `%s`\n", argv[1]);
+	show_usage();
+	return 1;
+}
